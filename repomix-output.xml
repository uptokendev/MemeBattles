This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/indexer.yml
.gitignore
contracts/interfaces/IPancakeRouter02.sol
contracts/ITreasuryVault.sol
contracts/LaunchCampaign.sol
contracts/LaunchFactory.sol
contracts/LaunchFactory.spec.ts
contracts/LpTimelock.sol
contracts/mocks/MockERC20.sol
contracts/mocks/MockFeeOnTransferERC20.sol
contracts/mocks/MockRouter.sol
contracts/mocks/RevertingReceiver.sol
contracts/test/FactoryCaller.sol
contracts/token/LaunchToken.sol
contracts/TreasuryRouter.sol
contracts/TreasuryVault.sol
contracts/UPVoteTreasury.sol
data.txt
db/migrations/001_init.sql
db/migrations/002_social.sql
db/migrations/003_indexer.sql
db/migrations/004_social_fixes.sql
db/migrations/20260127_000001_votes.sql
db/migrations/20260129_000001_league.sql
db/SUPABASE_SCHEMA_FIX.sql
deployments/bscTestnet.json
docs/activity-feed.md
frontend.zip
frontend/.env.example
frontend/.gitignore
frontend/api/ably/token.js
frontend/api/auth/nonce.js
frontend/api/campaigns.js
frontend/api/campaigns/upsert.js
frontend/api/certs/aiven-ca.pem
frontend/api/comments.js
frontend/api/diagnostics.js
frontend/api/featured.js
frontend/api/LEAGUE_EPOCHS_AND_CLAIMS.sql
frontend/api/league.js
frontend/api/profile.js
frontend/api/rewards.js
frontend/api/status.js
frontend/api/SUPABASE_SCHEMA_FIX.sql
frontend/api/upload.js
frontend/api/vote_counts.js
frontend/api/votes.js
frontend/components.json
frontend/eslint.config.js
frontend/global.css
frontend/index.html
frontend/package.json
frontend/pages/components/WalletMenu.jsx
frontend/postcss.config.js
frontend/public/assets/biggesthit.png
frontend/public/assets/crowdfavorite.png
frontend/public/assets/fastestfinish.png
frontend/public/assets/logo.png
frontend/public/assets/MemeBattleLeague.png
frontend/public/assets/perfectrun.png
frontend/public/assets/profile_placeholder.png
frontend/public/assets/ticker.png
frontend/public/assets/topearner.png
frontend/public/assets/memebattles.png
frontend/public/assets/UpVote_image.png
frontend/public/favicon.ico
frontend/public/fonts/Pixeboy.ttf
frontend/public/fonts/PixelGame-Extrude.otf
frontend/public/fonts/PixelGame-Regular.otf
frontend/public/placeholder.svg
frontend/public/robots.txt
frontend/README.md
frontend/server/db.js
frontend/server/http.js
frontend/src/abi/LaunchCampaign.json
frontend/src/abi/LaunchFactory.json
frontend/src/abi/LaunchToken.json
frontend/src/App.css
frontend/src/App.tsx
frontend/src/assets/logo-text.png
frontend/src/assets/logo.png
frontend/src/assets/menu-icons/carousel.png
frontend/src/assets/menu-icons/up-arrow.png
frontend/src/assets/menu-icons/user.png
frontend/src/assets/social/book.png
frontend/src/assets/social/discord.png
frontend/src/assets/social/telegram.png
frontend/src/assets/social/twitter.png
frontend/src/components/ConnectWalletButton.tsx
frontend/src/components/FilterBar.tsx
frontend/src/components/GridBackground.tsx
frontend/src/components/home/CampaignCard.tsx
frontend/src/components/home/CampaignGrid.tsx
frontend/src/components/home/DiscoveryControls.tsx
frontend/src/components/home/FeaturedCampaigns.tsx
frontend/src/components/home/HeaderBand.tsx
frontend/src/components/home/LeagueCampaigns.tsx
frontend/src/components/home/LeagueOverlayCard.tsx
frontend/src/components/LoadingScreen.tsx
frontend/src/components/profile/EditProfileDialog.tsx
frontend/src/components/Sidebar.tsx
frontend/src/components/token/AthBar.tsx
frontend/src/components/token/CurvePriceChart.tsx
frontend/src/components/token/TokenCandlestickChart.tsx
frontend/src/components/token/TokenComments.tsx
frontend/src/components/token/TradingViewChart.tsx
frontend/src/components/token/UpvoteDialog.tsx
frontend/src/components/TopBar.tsx
frontend/src/components/TrendingSection.tsx
frontend/src/components/ui/accordion.tsx
frontend/src/components/ui/alert-dialog.tsx
frontend/src/components/ui/alert.tsx
frontend/src/components/ui/animated-nav.tsx
frontend/src/components/ui/aspect-ratio.tsx
frontend/src/components/ui/avatar.tsx
frontend/src/components/ui/badge.tsx
frontend/src/components/ui/border-beam.tsx
frontend/src/components/ui/breadcrumb.tsx
frontend/src/components/ui/button.tsx
frontend/src/components/ui/calendar.tsx
frontend/src/components/ui/card.tsx
frontend/src/components/ui/carousel.tsx
frontend/src/components/ui/chart.tsx
frontend/src/components/ui/checkbox.tsx
frontend/src/components/ui/collapsible.tsx
frontend/src/components/ui/command.tsx
frontend/src/components/ui/context-menu.tsx
frontend/src/components/ui/dialog.tsx
frontend/src/components/ui/drawer.tsx
frontend/src/components/ui/dropdown-menu.tsx
frontend/src/components/ui/effects/letter-glitch.tsx
frontend/src/components/ui/form.tsx
frontend/src/components/ui/glass-button.tsx
frontend/src/components/ui/glowing-button.tsx
frontend/src/components/ui/glowing-effect.tsx
frontend/src/components/ui/horizontal-scroll-carousel.tsx
frontend/src/components/ui/hover-card.tsx
frontend/src/components/ui/input-otp.tsx
frontend/src/components/ui/input.tsx
frontend/src/components/ui/label.tsx
frontend/src/components/ui/loaders/custom-loader.tsx
frontend/src/components/ui/menubar.tsx
frontend/src/components/ui/navigation-menu.tsx
frontend/src/components/ui/pagination.tsx
frontend/src/components/ui/popover.tsx
frontend/src/components/ui/processing-card-refactored.tsx
frontend/src/components/ui/processing-card.tsx
frontend/src/components/ui/progress.tsx
frontend/src/components/ui/progress/ascii-progress-bar.tsx
frontend/src/components/ui/radio-group.tsx
frontend/src/components/ui/resizable.tsx
frontend/src/components/ui/scroll-area.tsx
frontend/src/components/ui/scrolling-holographic-card-feed.tsx
frontend/src/components/ui/search-bar.tsx
frontend/src/components/ui/select.tsx
frontend/src/components/ui/separator.tsx
frontend/src/components/ui/sheet.tsx
frontend/src/components/ui/sidebar.tsx
frontend/src/components/ui/skeleton.tsx
frontend/src/components/ui/slider.tsx
frontend/src/components/ui/social-media.tsx
frontend/src/components/ui/sonner.tsx
frontend/src/components/ui/space-background.tsx
frontend/src/components/ui/switch.tsx
frontend/src/components/ui/table.tsx
frontend/src/components/ui/tabs.tsx
frontend/src/components/ui/textarea.tsx
frontend/src/components/ui/toast.tsx
frontend/src/components/ui/toaster.tsx
frontend/src/components/ui/toggle-group.tsx
frontend/src/components/ui/toggle.tsx
frontend/src/components/ui/tooltip.tsx
frontend/src/components/ui/use-toast.ts
frontend/src/constants/filters.ts
frontend/src/constants/navigation.ts
frontend/src/constants/processingStages.ts
frontend/src/constants/validation.ts
frontend/src/hooks/use-mobile.tsx
frontend/src/hooks/use-toast.ts
frontend/src/hooks/useAblyLeagueChannel.ts
frontend/src/hooks/useAblyTokenChannel.ts
frontend/src/hooks/useBnbUsdPrice.ts
frontend/src/hooks/useCurveTrades.ts
frontend/src/hooks/useDexPairTrades.ts
frontend/src/hooks/useDexScreenerChart.ts
frontend/src/hooks/useLeagueRealtime.ts
frontend/src/hooks/useTokenForm.ts
frontend/src/hooks/useTokenProcessing.ts
frontend/src/hooks/useTokenRealtime.ts
frontend/src/hooks/useTokenSearch.ts
frontend/src/hooks/useTokenStatsRealtime.ts
frontend/src/hooks/useWallet.ts
frontend/src/index.css
frontend/src/lib/chainConfig.ts
frontend/src/lib/chart/buildCandles.ts
frontend/src/lib/chart/CurveTradesChart.tsx
frontend/src/lib/followApi.ts
frontend/src/lib/launchpadClient.ts
frontend/src/lib/media.ts
frontend/src/lib/profileApi.ts
frontend/src/lib/readProvider.ts
frontend/src/lib/rewardsApi.ts
frontend/src/lib/searchClient.ts
frontend/src/lib/tradeMapper.ts
frontend/src/lib/utils.ts
frontend/src/main.tsx
frontend/src/pages/Create.tsx
frontend/src/pages/HowItWorks.tsx
frontend/src/pages/League.tsx
frontend/src/pages/NotFound.tsx
frontend/src/pages/Playbook.tsx
frontend/src/pages/Profile.tsx
frontend/src/pages/Showcase.tsx
frontend/src/pages/Status.tsx
frontend/src/pages/TokenDetails.tsx
frontend/src/pages/UpDashboard.tsx
frontend/src/pages/UpNow.tsx
frontend/src/types/profile.ts
frontend/src/types/search.ts
frontend/src/types/token.ts
frontend/src/vite-env.d.ts
frontend/tailwind.config.ts
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vercel.json
frontend/vite.config.ts
hardhat.config.ts
hardhat.deploy.config.ts
package.json
README.md
realtime-indexer/.dockerignore
realtime-indexer/Dockerfile
realtime-indexer/nixpacks.toml
realtime-indexer/package.json
realtime-indexer/src/abis.ts
realtime-indexer/src/ably.ts
realtime-indexer/src/db.ts
realtime-indexer/src/env.ts
realtime-indexer/src/indexer.ts
realtime-indexer/src/jobs/dailyRepair.ts
realtime-indexer/src/leagueFeed.ts
realtime-indexer/src/server.ts
realtime-indexer/src/telemetry.ts
realtime-indexer/src/timeframes.ts
realtime-indexer/SUPABASE_SCHEMA_FIX.sql
realtime-indexer/tsconfig.json
run-tests.mjs
scripts/deploy-testnet.ts
scripts/deploy.ts
scripts/deployAll.ts
scripts/deployFactory.ts
scripts/deployLeagueTreasury.ts
scripts/deployUPVoteTreasury.ts
scripts/exportAbis.ts
scripts/sync-abis.mjs
test/backup/LaunchCampaign.spec.ts
test/backup/LaunchFactory.spec.ts
test/backup/LaunchToken.spec.ts
test/backup/LpTimelock.spec.ts
test/backup/UPVoteTreasury.test.ts
test/bondingCurveSale.test.js
test/bondingCurveSale.test.js.disabled
test/factory.test.js
test/factory.test.js.disabled
test/fixtures/core.ts
test/helpers/balances.ts
test/helpers/math.ts
test/LaunchCampaign.spec.ts
test/LaunchFactory.spec.ts
test/Launchpad.ts
test/LaunchToken.spec.ts
test/LpTimelock.spec.ts
test/lpTimelock.test.js
test/lpTimelock.test.js.disabled
test/tokenTemplate.test.js
test/tokenTemplate.test.js.disabled
test/TreasuryRouter.spec.ts
test/UPVoteTreasury.test.ts
tsconfig.json
typechain-types/@openzeppelin/contracts/access/index.ts
typechain-types/@openzeppelin/contracts/access/Ownable.ts
typechain-types/@openzeppelin/contracts/index.ts
typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors.ts
typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors.ts
typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors.ts
typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/index.ts
typechain-types/@openzeppelin/contracts/interfaces/IERC1363.ts
typechain-types/@openzeppelin/contracts/interfaces/index.ts
typechain-types/@openzeppelin/contracts/proxy/Clones.ts
typechain-types/@openzeppelin/contracts/proxy/index.ts
typechain-types/@openzeppelin/contracts/token/ERC20/ERC20.ts
typechain-types/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.ts
typechain-types/@openzeppelin/contracts/token/ERC20/extensions/index.ts
typechain-types/@openzeppelin/contracts/token/ERC20/IERC20.ts
typechain-types/@openzeppelin/contracts/token/ERC20/index.ts
typechain-types/@openzeppelin/contracts/token/ERC20/utils/index.ts
typechain-types/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.ts
typechain-types/@openzeppelin/contracts/token/index.ts
typechain-types/@openzeppelin/contracts/utils/Create2.ts
typechain-types/@openzeppelin/contracts/utils/Errors.ts
typechain-types/@openzeppelin/contracts/utils/index.ts
typechain-types/@openzeppelin/contracts/utils/introspection/IERC165.ts
typechain-types/@openzeppelin/contracts/utils/introspection/index.ts
typechain-types/@openzeppelin/contracts/utils/math/index.ts
typechain-types/@openzeppelin/contracts/utils/math/SafeCast.ts
typechain-types/@openzeppelin/contracts/utils/ReentrancyGuard.ts
typechain-types/@openzeppelin/index.ts
typechain-types/common.ts
typechain-types/contracts/index.ts
typechain-types/contracts/interfaces/index.ts
typechain-types/contracts/interfaces/IPancakeRouter02.ts
typechain-types/contracts/ITreasuryVault.ts
typechain-types/contracts/LaunchCampaign.ts
typechain-types/contracts/LaunchFactory.ts
typechain-types/contracts/LpTimelock.ts
typechain-types/contracts/mocks/index.ts
typechain-types/contracts/mocks/MockERC20.ts
typechain-types/contracts/mocks/MockFeeOnTransferERC20.ts
typechain-types/contracts/mocks/MockRouter.ts
typechain-types/contracts/mocks/RevertingReceiver.ts
typechain-types/contracts/test/FactoryCaller.ts
typechain-types/contracts/test/index.ts
typechain-types/contracts/token/index.ts
typechain-types/contracts/token/LaunchToken.ts
typechain-types/contracts/TreasuryRouter.ts
typechain-types/contracts/TreasuryVault.ts
typechain-types/contracts/UPVoteTreasury.sol/IERC20.ts
typechain-types/contracts/UPVoteTreasury.sol/index.ts
typechain-types/contracts/UPVoteTreasury.sol/Ownable.ts
typechain-types/contracts/UPVoteTreasury.sol/UPVoteTreasury.ts
typechain-types/factories/@openzeppelin/contracts/access/index.ts
typechain-types/factories/@openzeppelin/contracts/access/Ownable__factory.ts
typechain-types/factories/@openzeppelin/contracts/index.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors__factory.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors__factory.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors__factory.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/index.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/IERC1363__factory.ts
typechain-types/factories/@openzeppelin/contracts/interfaces/index.ts
typechain-types/factories/@openzeppelin/contracts/proxy/Clones__factory.ts
typechain-types/factories/@openzeppelin/contracts/proxy/index.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/ERC20__factory.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata__factory.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/extensions/index.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/IERC20__factory.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/index.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/utils/index.ts
typechain-types/factories/@openzeppelin/contracts/token/ERC20/utils/SafeERC20__factory.ts
typechain-types/factories/@openzeppelin/contracts/token/index.ts
typechain-types/factories/@openzeppelin/contracts/utils/Create2__factory.ts
typechain-types/factories/@openzeppelin/contracts/utils/Errors__factory.ts
typechain-types/factories/@openzeppelin/contracts/utils/index.ts
typechain-types/factories/@openzeppelin/contracts/utils/introspection/IERC165__factory.ts
typechain-types/factories/@openzeppelin/contracts/utils/introspection/index.ts
typechain-types/factories/@openzeppelin/contracts/utils/math/index.ts
typechain-types/factories/@openzeppelin/contracts/utils/math/SafeCast__factory.ts
typechain-types/factories/@openzeppelin/contracts/utils/ReentrancyGuard__factory.ts
typechain-types/factories/@openzeppelin/index.ts
typechain-types/factories/contracts/index.ts
typechain-types/factories/contracts/interfaces/index.ts
typechain-types/factories/contracts/interfaces/IPancakeRouter02__factory.ts
typechain-types/factories/contracts/ITreasuryVault__factory.ts
typechain-types/factories/contracts/LaunchCampaign__factory.ts
typechain-types/factories/contracts/LaunchFactory__factory.ts
typechain-types/factories/contracts/LpTimelock__factory.ts
typechain-types/factories/contracts/mocks/index.ts
typechain-types/factories/contracts/mocks/MockERC20__factory.ts
typechain-types/factories/contracts/mocks/MockFeeOnTransferERC20__factory.ts
typechain-types/factories/contracts/mocks/MockRouter__factory.ts
typechain-types/factories/contracts/mocks/RevertingReceiver__factory.ts
typechain-types/factories/contracts/test/FactoryCaller__factory.ts
typechain-types/factories/contracts/test/index.ts
typechain-types/factories/contracts/token/index.ts
typechain-types/factories/contracts/token/LaunchToken__factory.ts
typechain-types/factories/contracts/TreasuryRouter__factory.ts
typechain-types/factories/contracts/TreasuryVault__factory.ts
typechain-types/factories/contracts/UPVoteTreasury.sol/IERC20__factory.ts
typechain-types/factories/contracts/UPVoteTreasury.sol/index.ts
typechain-types/factories/contracts/UPVoteTreasury.sol/Ownable__factory.ts
typechain-types/factories/contracts/UPVoteTreasury.sol/UPVoteTreasury__factory.ts
typechain-types/factories/index.ts
typechain-types/hardhat.d.ts
typechain-types/index.ts
types/ethers-contracts/BondingCurveSale.sol/BondingCurveSale.ts
types/ethers-contracts/BondingCurveSale.sol/index.ts
types/ethers-contracts/common.ts
types/ethers-contracts/factories/BondingCurveSale.sol/BondingCurveSale__factory.ts
types/ethers-contracts/factories/BondingCurveSale.sol/index.ts
types/ethers-contracts/factories/Factory.sol/Factory__factory.ts
types/ethers-contracts/factories/Factory.sol/index.ts
types/ethers-contracts/factories/index.ts
types/ethers-contracts/factories/interfaces/index.ts
types/ethers-contracts/factories/interfaces/IPancakeRouter02.sol/index.ts
types/ethers-contracts/factories/interfaces/IPancakeRouter02.sol/IPancakeRouter02__factory.ts
types/ethers-contracts/factories/LpTimelock.sol/index.ts
types/ethers-contracts/factories/LpTimelock.sol/LpTimelock__factory.ts
types/ethers-contracts/factories/TokenTemplate.sol/index.ts
types/ethers-contracts/factories/TokenTemplate.sol/TokenTemplate__factory.ts
types/ethers-contracts/Factory.sol/Factory.ts
types/ethers-contracts/Factory.sol/index.ts
types/ethers-contracts/hardhat.d.ts
types/ethers-contracts/index.ts
types/ethers-contracts/interfaces/index.ts
types/ethers-contracts/interfaces/IPancakeRouter02.sol/index.ts
types/ethers-contracts/interfaces/IPancakeRouter02.sol/IPancakeRouter02.ts
types/ethers-contracts/LpTimelock.sol/index.ts
types/ethers-contracts/LpTimelock.sol/LpTimelock.ts
types/ethers-contracts/TokenTemplate.sol/index.ts
types/ethers-contracts/TokenTemplate.sol/TokenTemplate.ts
vitest.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/indexer.yml">
name: Indexer

on:
  schedule:
    - cron: "2-59/5 * * * *"  # every 5 minutes, UTC
  workflow_dispatch: {}

concurrency:
  group: indexer
  cancel-in-progress: false

jobs:
  run-indexer:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install
        run: npm ci

      - name: Run indexer
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          BSC_RPC_URL: ${{ secrets.BSC_RPC_URL }}
          FACTORY_ADDRESS: ${{ secrets.FACTORY_ADDRESS }}
          CHAIN_ID: ${{ secrets.CHAIN_ID }}
          CONFIRMATIONS: ${{ secrets.CONFIRMATIONS }}
          START_BLOCK: ${{ secrets.START_BLOCK }}
        run: npm run indexer
</file>

<file path=".gitignore">
node_modules
cache
artifacts
coverage
coverage.json
dist
.env
</file>

<file path="contracts/interfaces/IPancakeRouter02.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

interface IPancakeRouter02 {
    function factory() external view returns (address);

    function WETH() external view returns (address);

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    )
        external
        payable
        returns (
            uint256 amountToken,
            uint256 amountETH,
            uint256 liquidity
        );
}
</file>

<file path="contracts/ITreasuryVault.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ITreasuryVault {
    receive() external payable;
}
</file>

<file path="contracts/LaunchCampaign.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {LaunchToken} from "./token/LaunchToken.sol";
import {IPancakeRouter02} from "./interfaces/IPancakeRouter02.sol";

/// @notice Pump.fun inspired bonding curve launch campaign that targets PancakeSwap for final liquidity.
contract LaunchCampaign is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    struct InitParams {
        string name;
        string symbol;
        string logoURI;
        string xAccount;
        string website;
        string extraLink;
        uint256 totalSupply;
        uint256 curveBps;
        uint256 liquidityTokenBps;
        uint256 basePrice;
        uint256 priceSlope;
        uint256 graduationTarget;
        uint256 liquidityBps;
        uint256 protocolFeeBps;
        uint256 leagueFeeBps;
        address leagueReceiver;
        address router;
        address lpReceiver;
        address feeRecipient;
        address creator;
        address factory;
    }

    uint256 private constant WAD = 1e18;
    uint256 private constant MAX_BPS = 10_000;

    LaunchToken public token;
    IERC20 private tokenInterface;
    IPancakeRouter02 public router;
    address public factory;
    address public feeRecipient;
    address public leagueReceiver;
    uint256 public leagueFeeBps;
    address public lpReceiver;

    string public logoURI;
    string public xAccount;
    string public website;
    string public extraLink;

    uint256 public basePrice;
    uint256 public priceSlope;
    uint256 public graduationTarget;
    uint256 public liquidityBps;
    uint256 public protocolFeeBps;

    uint256 public totalSupply;
    uint256 public curveSupply;
    uint256 public liquiditySupply;
    uint256 public creatorReserve;

    uint256 public sold;
    bool public launched;
    uint256 public finalizedAt;

    modifier onlyFactory() {
        require(msg.sender == factory, "ONLY_FACTORY");
        _;
    }

// ---- Phase 2 cheap counters (no backend / no log scanning) ----
uint256 public totalBuyVolumeWei;
uint256 public totalSellVolumeWei;
uint256 public buyersCount;
mapping(address => bool) public hasBought;
mapping(address => uint256) public pendingNative;

    event TokensPurchased(address indexed buyer, uint256 amountOut, uint256 cost);
    event TokensSold(address indexed seller, uint256 amountIn, uint256 payout);
    event NativeEscrowed(address indexed beneficiary, uint256 amount);
    event NativeClaimed(address indexed beneficiary, uint256 amount);
    event CampaignFinalized(
        address indexed caller,
        uint256 liquidityTokens,
        uint256 liquidityBnb,
        uint256 protocolFee,
        uint256 creatorPayout
    );

    bool private _initialized;

/// @dev The implementation contract is deployed once and locked in its constructor.
///      Clones start uninitialized and must call initialize() exactly once.
constructor() Ownable(address(1)) {
    _initialized = true;
}

function initialize(InitParams memory params) external {
    require(!_initialized, "initialized");
    _initialized = true;

    require(params.totalSupply > 0, "invalid supply");
    require(params.curveBps > 0 && params.curveBps < MAX_BPS, "curve bps");
    require(
        params.curveBps + params.liquidityTokenBps <= MAX_BPS,
        "portion overflow"
    );
    require(params.basePrice > 0, "price zero");
    require(params.priceSlope > 0, "slope zero");
    require(params.router != address(0), "router zero");
    require(params.creator != address(0), "creator zero");
    require(params.liquidityBps <= MAX_BPS, "liquidity bps");
    require(params.protocolFeeBps <= MAX_BPS, "protocol bps");
    require(params.leagueFeeBps <= params.protocolFeeBps, "league>protocol");
    require(params.leagueReceiver != address(0), "league receiver zero");
    require(bytes(params.logoURI).length > 0, "logo uri");

    // set owner to creator
    _transferOwnership(params.creator);

    logoURI = params.logoURI;
    xAccount = params.xAccount;
    website = params.website;
    extraLink = params.extraLink;
    basePrice = params.basePrice;
    priceSlope = params.priceSlope;
    graduationTarget = params.graduationTarget;
    liquidityBps = params.liquidityBps;
    protocolFeeBps = params.protocolFeeBps;
    factory = params.factory;
    feeRecipient = params.feeRecipient;
    leagueReceiver = params.leagueReceiver;
    leagueFeeBps = params.leagueFeeBps;
    lpReceiver = params.lpReceiver == address(0)
        ? params.creator
        : params.lpReceiver;
    router = IPancakeRouter02(params.router);

    totalSupply = params.totalSupply;
    curveSupply = (params.totalSupply * params.curveBps) / MAX_BPS;
    liquiditySupply =
        (params.totalSupply * params.liquidityTokenBps) /
        MAX_BPS;
    creatorReserve = params.totalSupply - curveSupply - liquiditySupply;
    require(liquiditySupply > 0, "liquidity zero");
    require(creatorReserve >= 0, "creator portion");

    token = new LaunchToken(
        params.name,
        params.symbol,
        params.totalSupply,
        address(this)
    );
    tokenInterface = IERC20(address(token));
    token.mint(address(this), params.totalSupply);
}

receive() external payable {}

    function _fee(uint256 amountWei) internal view returns (uint256) {
        if (protocolFeeBps == 0) return 0;
        return (amountWei * protocolFeeBps) / MAX_BPS;
    }

    function _feeSplit(uint256 amountWei)
        internal
        view
        returns (uint256 totalFeeWei, uint256 protocolNetFeeWei, uint256 leagueFeeWei)
    {
        totalFeeWei = _fee(amountWei);
        if (totalFeeWei == 0) return (0, 0, 0);

        // league fee is a fixed bps slice of the same base amount used to compute the total fee.
        // This keeps user-visible fees unchanged while funding the League from inside the existing fee.
        leagueFeeWei = (amountWei * leagueFeeBps) / MAX_BPS;

        if (leagueReceiver == address(0) || leagueFeeWei == 0) {
            // Fallback: if league receiver isn't set, everything goes to protocol feeRecipient.
            return (totalFeeWei, totalFeeWei, 0);
        }

        // Guard: never exceed the total fee (e.g., if protocolFeeBps is configured too low)
        if (leagueFeeWei > totalFeeWei) leagueFeeWei = totalFeeWei;

        protocolNetFeeWei = totalFeeWei - leagueFeeWei;
    }

    function _quoteBuyNoFee(uint256 amountOut) internal view returns (uint256) {
        return _area(sold + amountOut) - _area(sold);
    }

    function _quoteSellNoFee(uint256 amountIn) internal view returns (uint256) {
        return _area(sold) - _area(sold - amountIn);
    }

    function quoteBuyExactTokens(uint256 amountOut) public view returns (uint256) {
        require(amountOut > 0, "zero amount");
        require(sold + amountOut <= curveSupply, "sold out");
        uint256 cost = _quoteBuyNoFee(amountOut);
        return cost + _fee(cost);
    }

    /// @notice Quote the maximum tokens obtainable for an exact total BNB input (including protocol fee).
    /// @dev Uses a monotonic binary search over amountOut to avoid fragile quadratic math.
    /// Returns (tokensOut, totalCostWei, feeWei) where totalCostWei <= totalInWei.
    function quoteBuyExactBnb(uint256 totalInWei)
        public
        view
        returns (uint256 tokensOut, uint256 totalCostWei, uint256 feeWei)
    {
        if (totalInWei == 0) return (0, 0, 0);
        if (launched) return (0, 0, 0);

        uint256 remaining = curveSupply - sold;
        if (remaining == 0) return (0, 0, 0);

        uint256 lo = 0;
        uint256 hi = remaining;

        // Find max x such that cost(x) <= totalInWei
        while (lo < hi) {
            uint256 mid = (lo + hi + 1) / 2;
            uint256 costNoFee = _quoteBuyNoFee(mid);
            uint256 fee = _fee(costNoFee);
            uint256 total = costNoFee + fee;

            if (total <= totalInWei) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }

        if (lo == 0) return (0, 0, 0);
        uint256 costNoFeeFinal = _quoteBuyNoFee(lo);
        feeWei = _fee(costNoFeeFinal);
        totalCostWei = costNoFeeFinal + feeWei;
        return (lo, totalCostWei, feeWei);
    }

    function quoteSellExactTokens(uint256 amountIn) public view returns (uint256) {
        require(amountIn > 0, "zero amount");
        require(amountIn <= sold, "exceeds sold");
        uint256 payout = _quoteSellNoFee(amountIn);
        uint256 fee = _fee(payout);
        return payout - fee;
    }

    function currentPrice() external view returns (uint256) {
        return basePrice + Math.mulDiv(priceSlope, sold, WAD);
    }

    function buyExactTokens(uint256 amountOut, uint256 maxCost)
        external
        payable
        nonReentrant
        returns (uint256 cost)
    {
        require(!launched, "campaign launched");
        require(amountOut > 0, "zero amount");
        require(sold + amountOut <= curveSupply, "sold out");
        uint256 costNoFee = _quoteBuyNoFee(amountOut);
        uint256 fee = _fee(costNoFee);
        uint256 total = costNoFee + fee;
        require(total <= maxCost, "slippage");
        require(msg.value >= total, "insufficient value");

// Phase 2 counters (volume excludes protocol fee)
totalBuyVolumeWei += costNoFee;
if (!hasBought[msg.sender]) {
    hasBought[msg.sender] = true;
    buyersCount += 1;
}

        sold += amountOut;
        tokenInterface.safeTransfer(msg.sender, amountOut);

        if (fee > 0) {
            (, uint256 protocolNet, uint256 leagueFee) = _feeSplit(costNoFee);
            // fee == protocolNet + leagueFee
            if (protocolNet > 0 && feeRecipient != address(0)) _sendNativeFee(payable(feeRecipient), protocolNet);
            if (leagueFee > 0) _sendNativeFee(payable(leagueReceiver), leagueFee);
        }

        if (msg.value > total) {
            _sendNative(msg.sender, msg.value - total);
        }

        emit TokensPurchased(msg.sender, amountOut, total);
        return total;
    }

    /// @notice Buy as many tokens as possible for the exact msg.value provided (incl. protocol fee).
    /// @param minTokensOut Minimum acceptable tokens (slippage protection).
    function buyExactBnb(uint256 minTokensOut)
        external
        payable
        nonReentrant
        returns (uint256 tokensOut, uint256 totalSpent)
    {
        require(!launched, "campaign launched");
        (tokensOut, totalSpent, ) = quoteBuyExactBnb(msg.value);
        require(tokensOut > 0, "zero amount");
        require(tokensOut >= minTokensOut, "slippage");
        require(sold + tokensOut <= curveSupply, "sold out");

        uint256 costNoFee = _quoteBuyNoFee(tokensOut);
        uint256 fee = _fee(costNoFee);
        uint256 total = costNoFee + fee;
        require(total == totalSpent, "quote mismatch");

        // Phase 2 counters (volume excludes protocol fee)
        totalBuyVolumeWei += costNoFee;
        if (!hasBought[msg.sender]) {
            hasBought[msg.sender] = true;
            buyersCount += 1;
        }

        sold += tokensOut;
        tokenInterface.safeTransfer(msg.sender, tokensOut);

        if (fee > 0) {
            (, uint256 protocolNet, uint256 leagueFee) = _feeSplit(costNoFee);
            // fee == protocolNet + leagueFee
            if (protocolNet > 0 && feeRecipient != address(0)) _sendNativeFee(payable(feeRecipient), protocolNet);
            if (leagueFee > 0) _sendNativeFee(payable(leagueReceiver), leagueFee);
        }

        if (msg.value > total) {
            _sendNative(msg.sender, msg.value - total);
        }

        emit TokensPurchased(msg.sender, tokensOut, total);
        return (tokensOut, total);
    }

    /// @dev Factory-only helper to do an optional initial buy in the same tx as campaign creation.
    /// Emits the same event shape but attributes the trade to `recipient`.
    function buyExactTokensFor(address recipient, uint256 amountOut, uint256 maxCost)
        external
        payable
        onlyFactory
        nonReentrant
        returns (uint256 total)
    {
        require(recipient != address(0), "zero recipient");
        require(!launched, "campaign launched");
        require(amountOut > 0, "zero amount");
        require(sold + amountOut <= curveSupply, "sold out");

        uint256 costNoFee = _quoteBuyNoFee(amountOut);
        uint256 fee = _fee(costNoFee);
        total = costNoFee + fee;
        require(total <= maxCost, "slippage");
        require(msg.value >= total, "insufficient value");

        // Phase 2 counters (volume excludes protocol fee)
        totalBuyVolumeWei += costNoFee;
        if (!hasBought[recipient]) {
            hasBought[recipient] = true;
            buyersCount += 1;
        }

        sold += amountOut;
        tokenInterface.safeTransfer(recipient, amountOut);

        if (fee > 0) {
            (, uint256 protocolNet, uint256 leagueFee) = _feeSplit(costNoFee);
            // fee == protocolNet + leagueFee
            if (protocolNet > 0 && feeRecipient != address(0)) _sendNativeFee(payable(feeRecipient), protocolNet);
            if (leagueFee > 0) _sendNativeFee(payable(leagueReceiver), leagueFee);
        }

        if (msg.value > total) {
            _sendNative(msg.sender, msg.value - total);
        }

        emit TokensPurchased(recipient, amountOut, total);
        return total;
    }

    /// @dev Factory-only helper to do an optional initial buy with exact BNB in the same tx as campaign creation.
    /// Attributes the trade to `recipient`.
    function buyExactBnbFor(address recipient, uint256 minTokensOut)
        external
        payable
        onlyFactory
        nonReentrant
        returns (uint256 tokensOut, uint256 totalSpent)
    {
        require(recipient != address(0), "zero recipient");
        require(!launched, "campaign launched");

        (tokensOut, totalSpent, ) = quoteBuyExactBnb(msg.value);
        require(tokensOut > 0, "zero amount");
        require(tokensOut >= minTokensOut, "slippage");
        require(sold + tokensOut <= curveSupply, "sold out");

        uint256 costNoFee = _quoteBuyNoFee(tokensOut);
        uint256 fee = _fee(costNoFee);
        uint256 total = costNoFee + fee;
        require(total == totalSpent, "quote mismatch");

        // Phase 2 counters (volume excludes protocol fee)
        totalBuyVolumeWei += costNoFee;
        if (!hasBought[recipient]) {
            hasBought[recipient] = true;
            buyersCount += 1;
        }

        sold += tokensOut;
        tokenInterface.safeTransfer(recipient, tokensOut);

        if (fee > 0) {
            (, uint256 protocolNet, uint256 leagueFee) = _feeSplit(costNoFee);
            // fee == protocolNet + leagueFee
            if (protocolNet > 0 && feeRecipient != address(0)) _sendNativeFee(payable(feeRecipient), protocolNet);
            if (leagueFee > 0) _sendNativeFee(payable(leagueReceiver), leagueFee);
        }

        if (msg.value > total) {
            _sendNative(msg.sender, msg.value - total);
        }

        emit TokensPurchased(recipient, tokensOut, total);
        return (tokensOut, total);
    }

    function sellExactTokens(uint256 amountIn, uint256 minPayout)
        external
        nonReentrant
        returns (uint256 payout)
    {
        require(!launched, "campaign launched");
        require(amountIn > 0, "zero amount");
        require(amountIn <= sold, "exceeds sold");
        uint256 gross = _quoteSellNoFee(amountIn);
        uint256 fee = _fee(gross);
        payout = gross - fee; // net to seller
        require(payout >= minPayout, "slippage");

        sold -= amountIn;
        tokenInterface.safeTransferFrom(msg.sender, address(this), amountIn);

        if (fee > 0) {
            (, uint256 protocolNet, uint256 leagueFee) = _feeSplit(gross);
            // fee == protocolNet + leagueFee
            if (protocolNet > 0 && feeRecipient != address(0)) _sendNativeFee(payable(feeRecipient), protocolNet);
            if (leagueFee > 0) _sendNativeFee(payable(leagueReceiver), leagueFee);
        }
        _sendNative(msg.sender, payout);

        // Phase 2 counters (volume excludes protocol fee)
        totalSellVolumeWei += gross;

        emit TokensSold(msg.sender, amountIn, payout);
        return payout;
    }

    function claimPendingNative() external nonReentrant returns (uint256 amount) {
    amount = pendingNative[msg.sender];
    require(amount > 0, "no pending");
    pendingNative[msg.sender] = 0;
    (bool ok, ) = payable(msg.sender).call{value: amount}("");
    require(ok, "claim failed");
    emit NativeClaimed(msg.sender, amount);
}

function finalize(uint256 minTokens, uint256 minBnb)
        external
        onlyOwner
        nonReentrant
        returns (uint256 usedTokens, uint256 usedBnb)
    {
        require(!launched, "finalized");
        require(
            sold == curveSupply || address(this).balance >= graduationTarget,
            "threshold"
        );
        launched = true;
        finalizedAt = block.timestamp;

        // Take protocol fee from the total raised BNB BEFORE creating liquidity.
        // This ensures the fee is taken from the full raise (and therefore affects both
        // LP funding and creator payout proportionally).
        uint256 balanceBefore = address(this).balance;
        uint256 protocolFee = (balanceBefore * protocolFeeBps) / MAX_BPS;
        if (protocolFee > 0 && feeRecipient != address(0)) {
            _sendNativeFee(payable(feeRecipient), protocolFee);
        }

        // Bonding-curve fees apply only pre-launch. Once liquidity is seeded on the DEX,
        // this campaign no longer executes trades and the protocol fee should be considered off.
        // (Also protects against any future code-paths that might read protocolFeeBps post-launch.)
        // protocolFeeBps = 0;

        uint256 remainingAfterFee = address(this).balance;
        uint256 liquidityValue = (remainingAfterFee * liquidityBps) / MAX_BPS;
        uint256 tokensForLp = liquiditySupply;

        if (tokensForLp > 0 && liquidityValue > 0) {
            tokenInterface.forceApprove(address(router), tokensForLp);
            (usedTokens, usedBnb, ) = router.addLiquidityETH{value: liquidityValue}(
                address(token),
                tokensForLp,
                minTokens,
                minBnb,
                lpReceiver,
                block.timestamp + 30 minutes
            );
            tokenInterface.forceApprove(address(router), 0);
            if (tokensForLp > usedTokens) {
                tokenInterface.safeTransfer(owner(), tokensForLp - usedTokens);
            }
        }

        uint256 unsold = curveSupply - sold;
        if (unsold > 0) {
            token.burn(address(this), unsold);
        }

        if (creatorReserve > 0) {
            tokenInterface.safeTransfer(owner(), creatorReserve);
        }

        // Whatever BNB remains after LP provision (and any LP budget refund) goes to the creator.
        uint256 creatorPayout = address(this).balance;
        if (creatorPayout > 0) {
            _sendNative(owner(), creatorPayout);
        }

        // Enable unrestricted token transfers after liquidity is added and funds are distributed
        token.enableTrading();

        emit CampaignFinalized(
            msg.sender,
            usedTokens,
            usedBnb,
            protocolFee,
            creatorPayout
        );
    }

    /// @dev Integral of the bonding curve from 0..x gives cumulative cost in wei.
    function _area(uint256 x) internal view returns (uint256) {
        uint256 linear = Math.mulDiv(x, basePrice, WAD);
        uint256 square;
        unchecked {
            square = x * x;
        }
        uint256 slopeTerm = Math.mulDiv(priceSlope, square, 2 * WAD * WAD);
        return linear + slopeTerm;
    }

    function _sendNativeFee(address payable to, uint256 value) private {
    if (value == 0) return;
    (bool ok, ) = to.call{value: value}("");
    if (!ok) {
        pendingNative[to] += value;
        emit NativeEscrowed(to, value);
    }
}

function _sendNative(address to, uint256 value) private {
        (bool success, ) = to.call{value: value}("");
        require(success, "transfer failed");
    }
}
</file>

<file path="contracts/LaunchFactory.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

import {LaunchCampaign} from "./LaunchCampaign.sol";
import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";

contract LaunchFactory is Ownable {
    // Custom errors to reduce deployed bytecode size (BSC testnet enforces the 24KB limit).
    error RouterZero();
    error NameEmpty();
    error SymbolEmpty();
    error LogoEmpty();
    error InitBuyValue();
    error InitBuyTooLarge();
    error RefundFail();
    error RecipientZero();
    error FeeTooHigh();
    error FeeTooLowForLeague();
    error ParamTooHigh();
    error OutOfBounds();
    error Offset();
    error SupplyZero();
    error InvalidCurveBps();
    error PriceZero();
    error SlopeZero();
    error TargetZero();
    error LiquidityBps();
    struct LaunchConfig {
        uint256 totalSupply;
        uint256 curveBps;
        uint256 liquidityTokenBps;
        uint256 basePrice;
        uint256 priceSlope;
        uint256 graduationTarget;
        uint256 liquidityBps;
    }

    struct CampaignInfo {
        address campaign;
        address token;
        address creator;
        string name;
        string symbol;
        string logoURI;
        string xAccount;
        string website;
        string extraLink;
        uint64 createdAt;
    }

    struct CampaignRequest {
        string name;
        string symbol;
        string logoURI;
        string xAccount;
        string website;
        string extraLink;
        uint256 basePrice;
        uint256 priceSlope;
        uint256 graduationTarget;
        address lpReceiver;
        uint256 initialBuyBnbWei; // optional: buy tokens for the creator using exact BNB in the create tx
    }

    uint256 private constant MAX_BPS = 10_000;
    uint256 private constant MAX_CREATOR_INIT_BUY = 1 ether;

    LaunchConfig public config;
    address public feeRecipient;
    uint256 public protocolFeeBps;
    uint256 public constant LEAGUE_FEE_BPS = 25;
    uint256 public constant MAX_BASE_PRICE = 1_000 ether;
    uint256 public constant MAX_PRICE_SLOPE = 1e36;
    uint256 public constant MAX_GRADUATION_TARGET = 1_000_000 ether;
    address public immutable leagueReceiver;
    address public router;
    address public campaignImplementation;

    CampaignInfo[] private _campaigns;

    event CampaignCreated(
        uint256 indexed id,
        address indexed campaign,
        address indexed token,
        address creator,
        string name,
        string symbol
    );
    event ConfigUpdated(LaunchConfig newConfig);
    event FeeRecipientUpdated(address indexed newRecipient);
    event RouterUpdated(address indexed newRouter);
    event ProtocolFeeUpdated(uint256 newFeeBps);

    constructor(address router_, address leagueReceiver_) Ownable(msg.sender) {
        if (router_ == address(0)) revert RouterZero();
        if (leagueReceiver_ == address(0)) revert RecipientZero();
        router = router_;
        leagueReceiver = leagueReceiver_;
        config = LaunchConfig({
            totalSupply: 1_000_000_000 ether,
            curveBps: 8800,
            liquidityTokenBps: 1000,
            basePrice: 5e13, // 0.00005 BNB
            priceSlope: 1e9, // grows 1 gwei per token sold (scaled to 1e18)
            graduationTarget: 50 ether,
            // 80% of raised BNB (after protocol fee) goes to LP, 20% to the creator.
            liquidityBps: 8000
        });
        feeRecipient = msg.sender;
        // 2% fee on bonding-curve buys/sells, and 2% taken again at finalize before LP.
        protocolFeeBps = 200;
        // Deploy the campaign implementation once; campaigns are cheap EIP-1167 clones.
        campaignImplementation = address(new LaunchCampaign());
    }

    receive() external payable {}

    /// @notice Quotes the BNB value required to perform the optional initial buy during createCampaign.
    /// @dev Assumes sold == 0 for the newly created campaign.
    function quoteInitialBuyTotal(
        uint256 initialBuyTokens,
        uint256 basePriceOverride,
        uint256 priceSlopeOverride
    ) external view returns (uint256) {
        if (initialBuyTokens == 0) return 0;
        uint256 base = basePriceOverride > 0 ? basePriceOverride : config.basePrice;
        uint256 slope = priceSlopeOverride > 0 ? priceSlopeOverride : config.priceSlope;

        // Matches LaunchCampaign._area() for sold == 0
        uint256 term1 = (base * initialBuyTokens) / 1e18;
        uint256 term2 = (slope * initialBuyTokens * initialBuyTokens) / (2 * 1e18 * 1e18);
        uint256 costNoFee = term1 + term2;
        uint256 fee = (costNoFee * protocolFeeBps) / 10000;
        return costNoFee + fee;
    }

    function createCampaign(CampaignRequest calldata req)
        external
        payable
        returns (address campaignAddr, address tokenAddr)
    {
        if (bytes(req.name).length == 0) revert NameEmpty();
        if (bytes(req.symbol).length == 0) revert SymbolEmpty();
        if (bytes(req.logoURI).length == 0) revert LogoEmpty();

if (req.basePrice != 0 && req.basePrice > MAX_BASE_PRICE) revert ParamTooHigh();
if (req.priceSlope != 0 && req.priceSlope > MAX_PRICE_SLOPE) revert ParamTooHigh();
if (req.graduationTarget != 0 && req.graduationTarget > MAX_GRADUATION_TARGET) revert ParamTooHigh();


        LaunchCampaign.InitParams memory params = LaunchCampaign.InitParams({
            name: req.name,
            symbol: req.symbol,
            logoURI: req.logoURI,
            xAccount: req.xAccount,
            website: req.website,
            extraLink: req.extraLink,
            totalSupply: config.totalSupply,
            curveBps: config.curveBps,
            liquidityTokenBps: config.liquidityTokenBps,
            basePrice: req.basePrice == 0 ? config.basePrice : req.basePrice,
            priceSlope: req.priceSlope == 0 ? config.priceSlope : req.priceSlope,
            graduationTarget: req.graduationTarget == 0
                ? config.graduationTarget
                : req.graduationTarget,
            liquidityBps: config.liquidityBps,
            protocolFeeBps: protocolFeeBps,
            leagueFeeBps: LEAGUE_FEE_BPS,
            leagueReceiver: leagueReceiver,
            router: router,
            lpReceiver: req.lpReceiver == address(0)
                ? msg.sender
                : req.lpReceiver,
            feeRecipient: feeRecipient,
            creator: msg.sender,
            factory: address(this)
        });

        address clone = Clones.clone(campaignImplementation);
        LaunchCampaign(payable(clone)).initialize(params);
        campaignAddr = clone;
        tokenAddr = address(LaunchCampaign(payable(clone)).token());

        _campaigns.push(
            CampaignInfo({
                campaign: campaignAddr,
                token: tokenAddr,
                creator: msg.sender,
                name: req.name,
                symbol: req.symbol,
                logoURI: req.logoURI,
                xAccount: req.xAccount,
                website: req.website,
                extraLink: req.extraLink,
                createdAt: uint64(block.timestamp)
            })
        );

        // Optional initial buy for the creator, executed within the same transaction.
        // Creator specifies exact BNB to spend (req.initialBuyBnbWei). Any extra msg.value is refunded.
        uint256 spent = 0;
        if (req.initialBuyBnbWei > 0) {
    if (req.initialBuyBnbWei > MAX_CREATOR_INIT_BUY) revert InitBuyTooLarge();
    if (msg.value < req.initialBuyBnbWei) revert InitBuyValue();

    (, uint256 totalSpent) = LaunchCampaign(payable(campaignAddr)).buyExactBnbFor{value: req.initialBuyBnbWei}(
        msg.sender,
        0
    );
    spent = totalSpent;
}
        if (msg.value > spent) {
            (bool ok, ) = msg.sender.call{value: msg.value - spent}("");
            if (!ok) revert RefundFail();
        }

        emit CampaignCreated(
            _campaigns.length - 1,
            campaignAddr,
            tokenAddr,
            msg.sender,
            req.name,
            req.symbol
        );
    }

    function setConfig(LaunchConfig calldata newConfig) external onlyOwner {
        _validateConfig(newConfig);
        config = newConfig;
        emit ConfigUpdated(newConfig);
    }

    function setRouter(address newRouter) external onlyOwner {
        if (newRouter == address(0)) revert RouterZero();
        router = newRouter;
        emit RouterUpdated(newRouter);
    }

    function setFeeRecipient(address newRecipient) external onlyOwner {
        if (newRecipient == address(0)) revert RecipientZero();
        feeRecipient = newRecipient;
        emit FeeRecipientUpdated(newRecipient);
    }

    function setProtocolFee(uint256 newProtocolFeeBps) external onlyOwner {
        if (newProtocolFeeBps > 1000) revert FeeTooHigh();
        if (newProtocolFeeBps < LEAGUE_FEE_BPS) revert FeeTooLowForLeague();
        protocolFeeBps = newProtocolFeeBps;
        emit ProtocolFeeUpdated(newProtocolFeeBps);
    }

    function campaignsCount() external view returns (uint256) {
        return _campaigns.length;
    }

    function getCampaign(uint256 id) external view returns (CampaignInfo memory) {
        if (id >= _campaigns.length) revert OutOfBounds();
        return _campaigns[id];
    }

    function getCampaignPage(uint256 offset, uint256 limit)
        external
        view
        returns (CampaignInfo[] memory page)
    {
        if (!(_campaigns.length == 0 || offset < _campaigns.length)) revert Offset();
        if (_campaigns.length == 0 || limit == 0) {
            return new CampaignInfo[](0);
        }
        uint256 end = offset + limit;
        if (end > _campaigns.length) {
            end = _campaigns.length;
        }
        uint256 size = end > offset ? end - offset : 0;
        page = new CampaignInfo[](size);
        for (uint256 i = 0; i < size; i++) {
            page[i] = _campaigns[offset + i];
        }
    }

    function _validateConfig(LaunchConfig memory newConfig) internal pure {
        if (newConfig.totalSupply == 0) revert SupplyZero();
        if (!(newConfig.curveBps > 0 && newConfig.curveBps + newConfig.liquidityTokenBps <= MAX_BPS)) revert InvalidCurveBps();
        if (newConfig.basePrice == 0) revert PriceZero();
        if (newConfig.basePrice > MAX_BASE_PRICE) revert ParamTooHigh();
        if (newConfig.priceSlope == 0) revert SlopeZero();
        if (newConfig.priceSlope > MAX_PRICE_SLOPE) revert ParamTooHigh();
        if (newConfig.graduationTarget == 0) revert TargetZero();
        if (newConfig.graduationTarget > MAX_GRADUATION_TARGET) revert ParamTooHigh();
        if (newConfig.liquidityBps > MAX_BPS) revert LiquidityBps();
    }
}
</file>

<file path="contracts/LaunchFactory.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import { deployCoreFixture } from "./fixtures/core";
import { quoteBuyExactTokens } from "./helpers/math";

describe("LaunchFactory", function () {
  it("constructor requires router != 0 and sets defaults", async () => {
    const Factory = await ethers.getContractFactory("LaunchFactory");
    const [deployer] = await ethers.getSigners();
    await expect(Factory.deploy(ethers.ZeroAddress, await deployer.getAddress())).to.be.revertedWithCustomError(
      Factory,
      "RouterZero"
    );

    const Router = await ethers.getContractFactory("MockRouter");
    const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);
    await expect(Factory.deploy(await router.getAddress(), ethers.ZeroAddress)).to.be.revertedWithCustomError(Factory, "RecipientZero");

    const factory = await Factory.deploy(await router.getAddress(), await deployer.getAddress());

    expect(await factory.router()).to.eq(await router.getAddress());
    expect((await factory.config()).totalSupply).to.be.gt(0n);
    expect(await factory.protocolFeeBps()).to.eq(200n);
  });

  it("quoteInitialBuyTotal: 0 tokens -> 0; override params respected", async () => {
    const { factory } = await deployCoreFixture();
    expect(await factory.quoteInitialBuyTotal(0n, 0n, 0n)).to.eq(0n);

    const base = 777n;
    const slope = 999n;
    const amount = ethers.parseEther("10");
    const quoted = await factory.quoteInitialBuyTotal(amount, base, slope);

    const { total } = quoteBuyExactTokens(0n, amount, base, slope, await factory.protocolFeeBps());
    expect(quoted).to.eq(total);
  });

  it("createCampaign: validates inputs, emits, persists CampaignInfo; refunds excess msg.value", async () => {
    const { factory, creator } = await deployCoreFixture();

    const bad = {
      name: "",
      symbol: "X",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: 0n,
    };

    await expect(factory.connect(creator).createCampaign(bad as any)).to.be.revertedWithCustomError(
      factory,
      "NameEmpty"
    );
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "" } as any)
    ).to.be.revertedWithCustomError(factory, "SymbolEmpty");
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "S", logoURI: "" } as any)
    ).to.be.revertedWithCustomError(factory, "LogoEmpty");

    const req = { ...bad, name: "MyToken", symbol: "MYT", logoURI: "ipfs://logo" };
    const tx = await factory.connect(creator).createCampaign(req as any, { value: ethers.parseEther("1") });

    await expect(tx).to.emit(factory, "CampaignCreated");

    expect(await factory.campaignsCount()).to.eq(1n);
    const info = await factory.getCampaign(0n);
    expect(info.creator).to.eq(await creator.getAddress());
    expect(info.name).to.eq("MyToken");
    expect(info.symbol).to.eq("MYT");
    expect(info.logoURI).to.eq("ipfs://logo");

    // getCampaignPage
    const page = await factory.getCampaignPage(0n, 10n);
    expect(page.length).to.eq(1);
    expect(page[0].campaign).to.eq(info.campaign);

    // bounds
    await expect(factory.getCampaign(1n)).to.be.revertedWithCustomError(factory, "OutOfBounds");
    await expect(factory.getCampaignPage(2n, 1n)).to.be.revertedWithCustomError(factory, "Offset");
  });

  it("createCampaign optional initialBuy: requires enough value; performs buy; refunds extra", async () => {
    const { factory, creator, feeRecipient } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei - 1n })
    ).to.be.revertedWithCustomError(factory, "InitBuyValue");

    const feeBefore = await ethers.provider.getBalance(await feeRecipient.getAddress());
    const tx = await factory
      .connect(creator)
      .createCampaign(req as any, { value: req.initialBuyBnbWei + ethers.parseEther("0.5") });
    const receipt = await tx.wait();

    const info = await factory.getCampaign(0n);
    const campaign = await ethers.getContractAt("LaunchCampaign", info.campaign);
    const token = await ethers.getContractAt("LaunchToken", await campaign.token());

    // Exact-BNB buy: token amount is determined by the curve, so just assert nonzero.
    expect(await campaign.sold()).to.be.gt(0n);
    expect(await token.balanceOf(await creator.getAddress())).to.be.gt(0n);

    // Fee recipient should have received the bonding-curve fee from the initial buy (not affected by creator gas)
    const feeAfter = await ethers.provider.getBalance(await feeRecipient.getAddress());
    expect(feeAfter).to.be.gt(feeBefore);

    // Campaign retains the no-fee portion of the buy (nonzero)
    expect(await ethers.provider.getBalance(info.campaign)).to.be.gt(0n);

    expect(receipt).to.not.eq(null);
  });

  it("createCampaign optional initialBuy: reverts when creator initial buy exceeds 1 BNB cap", async () => {
    const { factory, creator } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1.01"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei })
    ).to.be.revertedWithCustomError(factory, "InitBuyTooLarge");
  });

  it("owner-only setters with validation + events", async () => {
    const { factory, owner, alice } = await deployCoreFixture();

    await expect(factory.connect(alice).setRouter(await alice.getAddress())).to.be.revertedWithCustomError(
      factory,
      "OwnableUnauthorizedAccount"
    );

    await expect(factory.connect(owner).setRouter(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RouterZero"
    );
    await expect(factory.connect(owner).setFeeRecipient(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RecipientZero"
    );
    await expect(factory.connect(owner).setProtocolFee(1001n)).to.be.revertedWithCustomError(
      factory,
      "FeeTooHigh"
    );

    await expect(factory.connect(owner).setProtocolFee(24n)).to.be.revertedWithCustomError(
      factory,
      "FeeTooLowForLeague"
    );

    await expect(factory.connect(owner).setProtocolFee(123n)).to.emit(factory, "ProtocolFeeUpdated").withArgs(123n);
    expect(await factory.protocolFeeBps()).to.eq(123n);

    const newRouter = await (await ethers.getContractFactory("MockRouter")).deploy(
      ethers.ZeroAddress,
      ethers.ZeroAddress
    );
    await expect(factory.connect(owner).setRouter(await newRouter.getAddress()))
      .to.emit(factory, "RouterUpdated")
      .withArgs(await newRouter.getAddress());

    await expect(factory.connect(owner).setFeeRecipient(await alice.getAddress()))
      .to.emit(factory, "FeeRecipientUpdated")
      .withArgs(await alice.getAddress());

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 0n,
        curveBps: 5000n,
        liquidityTokenBps: 4000n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "SupplyZero");

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 1n,
        curveBps: 0n,
        liquidityTokenBps: 0n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "InvalidCurveBps");
  });

  it("createCampaign: rejects override params above bounds", async () => {
    const { factory, creator, owner } = await deployCoreFixture();

    const baseTooHigh = ethers.parseEther("1001");
    const targetTooHigh = ethers.parseEther("1000001");
    const slopeTooHigh = 10n ** 36n + 1n;

    const reqBase = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: baseTooHigh,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: 0n,
    };

    await expect(factory.connect(creator).createCampaign(reqBase as any)).to.be.revertedWithCustomError(factory, "ParamTooHigh");

    await expect(factory.connect(creator).createCampaign({ ...reqBase, basePrice: 0n, priceSlope: slopeTooHigh } as any))
      .to.be.revertedWithCustomError(factory, "ParamTooHigh");

    await expect(factory.connect(creator).createCampaign({ ...reqBase, basePrice: 0n, priceSlope: 0n, graduationTarget: targetTooHigh } as any))
      .to.be.revertedWithCustomError(factory, "ParamTooHigh");
  });

});
</file>

<file path="contracts/LpTimelock.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @dev Minimal timelock for LP tokens.
 * Holds an ERC20 and allows the beneficiary to claim after releaseTime.
 */
contract LpTimelock {
    IERC20 public immutable token;
    address public immutable beneficiary;
    uint256 public immutable releaseTime;

    constructor(IERC20 token_, address beneficiary_, uint256 releaseTime_) {
        require(address(token_) != address(0), "token=0");
        require(beneficiary_ != address(0), "beneficiary=0");
        require(releaseTime_ > block.timestamp, "releaseTime");
        token = token_;
        beneficiary = beneficiary_;
        releaseTime = releaseTime_;
    }

    function release() external {
        require(block.timestamp >= releaseTime, "not released");
        uint256 amount = token.balanceOf(address(this));
        require(amount > 0, "no tokens");
        require(token.transfer(beneficiary, amount), "transfer failed");
    }
}
</file>

<file path="contracts/mocks/MockERC20.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name_, string memory symbol_, uint256 supply, address to) ERC20(name_, symbol_) {
        _mint(to, supply);
    }
}
</file>

<file path="contracts/mocks/MockFeeOnTransferERC20.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * Simple fee-on-transfer token for testing.
 * Charges feeBps (e.g., 1000 = 10%) and "burns" it by sending to address(0).
 */
contract MockFeeOnTransferERC20 {
    string public name = "FeeToken";
    string public symbol = "FEE";
    uint8 public decimals = 18;

    uint256 public totalSupply;
    uint256 public feeBps; // e.g., 1000 = 10%

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 _feeBps) {
        require(_feeBps <= 2000, "fee too high");
        feeBps = _feeBps;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        _transfer(msg.sender, to, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 a = allowance[from][msg.sender];
        require(a >= amount, "ALLOWANCE");
        allowance[from][msg.sender] = a - amount;
        _transfer(from, to, amount);
        return true;
    }

    function _transfer(address from, address to, uint256 amount) internal {
        require(balanceOf[from] >= amount, "BAL");

        uint256 fee = (amount * feeBps) / 10_000;
        uint256 net = amount - fee;

        balanceOf[from] -= amount;
        balanceOf[to] += net;

        // burn fee
        if (fee > 0) {
            balanceOf[address(0)] += fee;
            emit Transfer(from, address(0), fee);
        }

        emit Transfer(from, to, net);
    }
}
</file>

<file path="contracts/mocks/MockRouter.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {IPancakeRouter02} from "../interfaces/IPancakeRouter02.sol";

contract MockRouter is IPancakeRouter02 {
    address private immutable _factory;
    address private immutable _wrapped;

    event LiquidityAdded(
        address indexed token,
        uint256 amountToken,
        uint256 amountETH,
        address indexed to
    );

    constructor(address factory_, address wrapped_) {
        _factory = factory_;
        _wrapped = wrapped_;
    }

    function factory() external view override returns (address) {
        return _factory;
    }

    function WETH() external view override returns (address) {
        return _wrapped;
    }

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256,
        uint256,
        address to,
        uint256
    )
        external
        payable
        override
        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)
    {
        IERC20(token).transferFrom(msg.sender, address(this), amountTokenDesired);
        amountToken = amountTokenDesired;
        amountETH = msg.value;
        liquidity = amountTokenDesired + msg.value;
        emit LiquidityAdded(token, amountToken, amountETH, to);
    }
}
</file>

<file path="contracts/mocks/RevertingReceiver.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/// @notice Helper that always reverts on receiving native value.
/// Used to prove fee receiver / vault cannot DOS core flows.
contract RevertingReceiver {
    receive() external payable {
        revert("NO_RECEIVE");
    }

    fallback() external payable {
        revert("NO_FALLBACK");
    }
}
</file>

<file path="contracts/test/FactoryCaller.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {LaunchCampaign} from "../LaunchCampaign.sol";

/// @dev Test-only helper that can call LaunchCampaign.buyExactTokensFor as the factory.
contract FactoryCaller {
    /// @dev Allow the campaign to refund excess msg.value back to this contract.
    receive() external payable {}

    function buyFor(address campaign, address recipient, uint256 amountOut, uint256 maxCost)
        external
        payable
        returns (uint256 total)
    {
        total = LaunchCampaign(payable(campaign)).buyExactTokensFor{value: msg.value}(recipient, amountOut, maxCost);
    }
}
</file>

<file path="contracts/token/LaunchToken.sol">
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract LaunchToken is ERC20, Ownable {
    uint256 public immutable cap;

    // Trading / transfer control
    bool public tradingEnabled;

    error TradingNotEnabled();

    constructor(
        string memory name_,
        string memory symbol_,
        uint256 cap_,
        address owner_
    ) ERC20(name_, symbol_) Ownable(owner_) {
        require(cap_ > 0, "cap is zero");
        require(owner_ != address(0), "owner is zero");
        cap = cap_;
    }

    function mint(address to, uint256 amount) external onlyOwner {
        require(to != address(0), "to zero");
        require(totalSupply() + amount <= cap, "cap exceeded");
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }

    /// @notice Called by the campaign (token owner) when liquidity is added and trading should start.
    function enableTrading() external onlyOwner {
        tradingEnabled = true;
    }

    /// @dev OZ v5 hook that centralizes all balance changes.
    function _update(address from, address to, uint256 value) internal override {
        if (!tradingEnabled) {
            // Before trading is enabled, only allow:
            // - mints (from == address(0))
            // - transfers where the campaign (owner) is the source
            // - transfers initiated by the campaign (owner), e.g. sellExactTokens
            //
            // This blocks:
            // - user -> user transfers
            // - user -> router addLiquidity attempts
            if (from != address(0) && from != owner() && msg.sender != owner()) {
                revert TradingNotEnabled();
            }
        }

        super._update(from, to, value);
    }
}
</file>

<file path="contracts/TreasuryRouter.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TreasuryRouter {
    address public immutable admin;
    uint64  public immutable upgradeDelay;

    address public activeVault;

    address public pendingVault;
    uint64  public pendingSince;

    bool public forwardingPaused;

    event Forwarded(address indexed vault, uint256 amount);
    event ForwardFailed(address indexed vault, uint256 amount);
    event ForwardingPaused(bool paused);

    event VaultProposed(address indexed newVault, uint64 executeAfter);
    event VaultActivated(address indexed oldVault, address indexed newVault);

    modifier onlyAdmin() {
        require(msg.sender == admin, "not admin");
        _;
    }

    constructor(address _admin, address _initialVault, uint64 _upgradeDelaySeconds) {
        require(_admin != address(0), "admin=0");
        require(_initialVault != address(0), "vault=0");
        require(_upgradeDelaySeconds >= 1 hours, "delay too small");
        admin = _admin;
        activeVault = _initialVault;
        upgradeDelay = _upgradeDelaySeconds;
    }

    receive() external payable {
        _forward(msg.value);
    }

    function forward() external {
        _forward(address(this).balance);
    }

    function _forward(uint256 amount) internal {
        if (forwardingPaused) return;
        if (amount == 0) return;

        address vault = activeVault;
        (bool ok, ) = payable(vault).call{value: amount}("");
        if (!ok) {
            emit ForwardFailed(vault, amount);
            return;
        }
        emit Forwarded(vault, amount);
    }

    function proposeVault(address newVault) external onlyAdmin {
        require(newVault != address(0), "vault=0");
        uint256 size;
        assembly { size := extcodesize(newVault) }
        require(size > 0, "not contract");

        pendingVault = newVault;
        pendingSince = uint64(block.timestamp);
        emit VaultProposed(newVault, uint64(block.timestamp) + upgradeDelay);
    }

    function acceptVault() external onlyAdmin {
        address newVault = pendingVault;
        require(newVault != address(0), "no pending");
        require(pendingSince != 0, "no pending");
        require(block.timestamp >= pendingSince + upgradeDelay, "delay");

        address old = activeVault;
        activeVault = newVault;

        pendingVault = address(0);
        pendingSince = 0;

        emit VaultActivated(old, newVault);
    }

    function setForwardingPaused(bool paused) external onlyAdmin {
        forwardingPaused = paused;
        emit ForwardingPaused(paused);
    }
}
</file>

<file path="contracts/TreasuryVault.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract TreasuryVault {
    address public immutable multisig;

    event Withdraw(address indexed to, uint256 amount);

    constructor(address _multisig) {
        require(_multisig != address(0), "multisig=0");
        multisig = _multisig;
    }

    receive() external payable {}

    function withdraw(address payable to, uint256 amount) external {
        require(msg.sender == multisig, "not multisig");
        require(to != address(0), "to=0");
        require(amount <= address(this).balance, "insufficient");
        (bool ok, ) = to.call{value: amount}("");
        require(ok, "transfer failed");
        emit Withdraw(to, amount);
    }
}
</file>

<file path="contracts/UPVoteTreasury.sol">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * MemeBattles UP Vote Treasury (v1 - Forwarding)
 *
 * - Users pay a small fee (BNB or supported ERC20) to cast an upvote for a campaign/token.
 * - Payments are forwarded immediately to feeReceiver (do not sit in this contract).
 * - Emits VoteCast events; off-chain indexer tallies and ranks.
 * - Enforces min amounts per asset on-chain.
 * - Supports fee-on-transfer tokens by measuring actual received amount.
 */

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

library SafeERC20 {
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        bool ok = token.transfer(to, value);
        require(ok, "SAFE_ERC20_TRANSFER_FAILED");
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        bool ok = token.transferFrom(from, to, value);
        require(ok, "SAFE_ERC20_TRANSFERFROM_FAILED");
    }
}

abstract contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(msg.sender == owner, "NOT_OWNER");
        _;
    }

    constructor(address initialOwner) {
        require(initialOwner != address(0), "OWNER_ZERO");
        owner = initialOwner;
        emit OwnershipTransferred(address(0), initialOwner);
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "OWNER_ZERO");
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract UPVoteTreasury is Ownable {
    using SafeERC20 for IERC20;

    // Use address(0) to represent native BNB.
    address public constant NATIVE = address(0);

    struct AssetConfig {
        bool enabled;
        uint256 minAmount; // minimum payment to count as a vote
    }

    mapping(address => AssetConfig) public assetConfig;

    // Campaign allowlist (optional)
    bool public campaignAllowlistEnabled;
    mapping(address => bool) public campaignAllowed;

    address public feeReceiver;

    event AssetConfigured(address indexed asset, bool enabled, uint256 minAmount);
    event CampaignAllowlistToggled(bool enabled);
    event CampaignAllowed(address indexed campaign, bool allowed);
    event FeeReceiverUpdated(address indexed previousReceiver, address indexed newReceiver);

    event VoteCast(
        address indexed campaign,
        address indexed voter,
        address indexed asset,   // address(0) for BNB, else ERC20
        uint256 amountPaid,      // actual received amount (for ERC20, measured)
        bytes32 meta
    );

    // Rescue events (in case tokens/BNB are accidentally sent to this contract)
    event Rescue(address indexed asset, address indexed to, uint256 amount);

    constructor(address initialOwner, address initialFeeReceiver) Ownable(initialOwner) {
        require(initialFeeReceiver != address(0), "FEE_RECEIVER_ZERO");
        feeReceiver = initialFeeReceiver;

        assetConfig[NATIVE] = AssetConfig({ enabled: true, minAmount: 0 });
        emit AssetConfigured(NATIVE, true, 0);
        emit FeeReceiverUpdated(address(0), initialFeeReceiver);
    }

    // -----------------------------
    // Admin configuration
    // -----------------------------

    function setAsset(address asset, bool enabled, uint256 minAmount) external onlyOwner {
        assetConfig[asset] = AssetConfig({ enabled: enabled, minAmount: minAmount });
        emit AssetConfigured(asset, enabled, minAmount);
    }

    function setFeeReceiver(address newFeeReceiver) external onlyOwner {
        require(newFeeReceiver != address(0), "FEE_RECEIVER_ZERO");
        emit FeeReceiverUpdated(feeReceiver, newFeeReceiver);
        feeReceiver = newFeeReceiver;
    }

    function setCampaignAllowlistEnabled(bool enabled) external onlyOwner {
        campaignAllowlistEnabled = enabled;
        emit CampaignAllowlistToggled(enabled);
    }

    function setCampaignAllowed(address campaign, bool allowed) external onlyOwner {
        campaignAllowed[campaign] = allowed;
        emit CampaignAllowed(campaign, allowed);
    }

    // -----------------------------
    // Voting
    // -----------------------------

    function voteWithBNB(address campaign, bytes32 meta) external payable {
        _requireCampaignAllowed(campaign);

        AssetConfig memory cfg = assetConfig[NATIVE];
        require(cfg.enabled, "ASSET_DISABLED");
        require(msg.value >= cfg.minAmount, "AMOUNT_TOO_LOW");

        emit VoteCast(campaign, msg.sender, NATIVE, msg.value, meta);

        (bool ok, ) = payable(feeReceiver).call{ value: msg.value }("");
        require(ok, "FEE_FORWARD_BNB_FAILED");
    }

    /**
     * voteWithToken supports fee-on-transfer tokens:
     * - pulls tokens in
     * - measures actual received
     * - enforces minAmount against received
     * - forwards received to feeReceiver
     */
    function voteWithToken(address campaign, address token, uint256 amount, bytes32 meta) external {
        _requireCampaignAllowed(campaign);

        require(token != address(0), "TOKEN_ZERO");
        AssetConfig memory cfg = assetConfig[token];
        require(cfg.enabled, "ASSET_DISABLED");
        require(amount > 0, "AMOUNT_ZERO");

        IERC20 erc20 = IERC20(token);
        uint256 beforeBal = erc20.balanceOf(address(this));
        erc20.safeTransferFrom(msg.sender, address(this), amount);
        uint256 afterBal = erc20.balanceOf(address(this));

        uint256 received = afterBal - beforeBal;
        require(received >= cfg.minAmount, "AMOUNT_TOO_LOW");

        emit VoteCast(campaign, msg.sender, token, received, meta);

        // Forward only what was actually received
        erc20.safeTransfer(feeReceiver, received);
    }

    // -----------------------------
    // Rescue (should normally stay unused)
    // -----------------------------

    function rescueBNB(address payable to, uint256 amount) external onlyOwner {
        require(to != address(0), "TO_ZERO");
        require(amount <= address(this).balance, "INSUFFICIENT_BNB");
        (bool ok, ) = to.call{ value: amount }("");
        require(ok, "BNB_RESCUE_FAILED");
        emit Rescue(NATIVE, to, amount);
    }

    function rescueToken(address token, address to, uint256 amount) external onlyOwner {
        require(token != address(0), "TOKEN_ZERO");
        require(to != address(0), "TO_ZERO");
        IERC20(token).safeTransfer(to, amount);
        emit Rescue(token, to, amount);
    }

    // -----------------------------
    // Internal
    // -----------------------------

    function _requireCampaignAllowed(address campaign) internal view {
        require(campaign != address(0), "CAMPAIGN_ZERO");
        if (campaignAllowlistEnabled) {
            require(campaignAllowed[campaign], "CAMPAIGN_NOT_ALLOWED");
        }
    }

    receive() external payable {
        // Accept direct BNB transfers (not counted as votes unless voteWithBNB is called)
    }
}
</file>

<file path="data.txt">
Network: bsctestnet
Deployer: 0x13AD79765e14927dF2c554d9662Bbe539e89C8e8
Deploying LaunchFactory with router 0xD99D1c33F9fC3444f8101754aBC46c52416550D1...
LaunchFactory deployed at 0x00295F00672a49513972F582A4054356de6886cB
Setting fee recipient to 0x13ad79765e14927df2c554d9662bbe539e89c8e8...
Setting protocol fee to 250 bps...
Deployment complete. Export these addresses for the frontend:
FACTORY_ADDRESS=0x6F85592b02488DB874ad83FaA667c6197b6581C5
</file>

<file path="db/migrations/001_init.sql">
-- db/migrations/001_init.sql

BEGIN;

-- 1) Stores normalized on-chain events we can render as Activity items
CREATE TABLE IF NOT EXISTS activity_events (
  id                BIGSERIAL PRIMARY KEY,

  chain_id          INTEGER NOT NULL,
  event_type        TEXT NOT NULL, -- e.g. CREATE_CAMPAIGN, BUY, SELL, FINALIZE

  tx_hash           TEXT NOT NULL,
  log_index         INTEGER NOT NULL,
  block_number      BIGINT NOT NULL,
  block_time        TIMESTAMPTZ NOT NULL,

  actor_address     TEXT NOT NULL, -- buyer/seller/creator/finalizer
  campaign_address  TEXT,          -- bonding campaign (LaunchCampaign)
  token_address     TEXT,          -- token address (if known/emitted)

  -- amounts in raw wei for lossless accounting
  amount_in_wei     NUMERIC(78, 0),
  amount_out_wei    NUMERIC(78, 0),
  cost_wei          NUMERIC(78, 0),
  payout_wei        NUMERIC(78, 0),

  meta              JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT activity_events_uniq_log UNIQUE (chain_id, tx_hash, log_index)
);

-- Indexes for common feed queries
CREATE INDEX IF NOT EXISTS idx_activity_events_actor_time
  ON activity_events (chain_id, actor_address, block_number DESC, log_index DESC);

CREATE INDEX IF NOT EXISTS idx_activity_events_campaign_time
  ON activity_events (chain_id, campaign_address, block_number DESC, log_index DESC);

CREATE INDEX IF NOT EXISTS idx_activity_events_token_time
  ON activity_events (chain_id, token_address, block_number DESC, log_index DESC);

CREATE INDEX IF NOT EXISTS idx_activity_events_block_time
  ON activity_events (chain_id, block_number DESC, log_index DESC);


-- 2) Relationship graph: which campaigns/tokens matter to a wallet (created/bought)
CREATE TABLE IF NOT EXISTS user_coin_edges (
  chain_id          INTEGER NOT NULL,
  user_address      TEXT NOT NULL,
  campaign_address  TEXT NOT NULL,
  token_address     TEXT,
  reason            TEXT NOT NULL, -- CREATED | BOUGHT_BONDING

  first_seen_block  BIGINT,
  first_seen_time   TIMESTAMPTZ,
  last_seen_block   BIGINT,
  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, user_address, campaign_address, reason)
);

CREATE INDEX IF NOT EXISTS idx_user_coin_edges_user
  ON user_coin_edges (chain_id, user_address);

CREATE INDEX IF NOT EXISTS idx_user_coin_edges_campaign
  ON user_coin_edges (chain_id, campaign_address);


-- 3) Indexer checkpoints: where the cron job left off
CREATE TABLE IF NOT EXISTS indexer_checkpoints (
  chain_id              INTEGER NOT NULL,
  checkpoint_key        TEXT NOT NULL,   -- e.g. FACTORY:<addr> or CAMPAIGN:<addr>
  contract_address      TEXT NOT NULL,
  last_processed_block  BIGINT NOT NULL DEFAULT 0,
  updated_at            TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, checkpoint_key)
);

COMMIT;
</file>

<file path="db/migrations/002_social.sql">
BEGIN;

-- =========================================================
-- 1) User profiles (wallet address -> display name + avatar)
-- =========================================================
CREATE TABLE IF NOT EXISTS user_profiles (
  chain_id      INTEGER NOT NULL,
  address       TEXT NOT NULL,               -- wallet address (store lowercase)
  display_name  TEXT,                        -- optional
  avatar_url    TEXT,                        -- optional (URL)
  bio           TEXT,                        -- optional

  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, address),
  CONSTRAINT user_profiles_address_lowercase CHECK (address = lower(address))
);

-- Optional: enforce unique display names per chain (case-insensitive) when provided
CREATE UNIQUE INDEX IF NOT EXISTS ux_user_profiles_display_name_ci
  ON user_profiles (chain_id, lower(display_name))
  WHERE display_name IS NOT NULL AND length(trim(display_name)) > 0;

CREATE INDEX IF NOT EXISTS idx_user_profiles_chain
  ON user_profiles (chain_id);


-- =========================================================
-- 2) Campaign registry (campaign -> creator), needed for:
--    "comments on my campaigns show in my profile replies"
-- =========================================================
CREATE TABLE IF NOT EXISTS campaigns (
  chain_id         INTEGER NOT NULL,
  campaign_address TEXT NOT NULL,            -- LaunchCampaign address (lowercase)
  token_address    TEXT,                     -- token address (optional/known later)
  creator_address  TEXT NOT NULL,            -- wallet that created it (lowercase)

  name             TEXT,
  symbol           TEXT,
  meta             JSONB NOT NULL DEFAULT '{}'::jsonb,

  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, campaign_address),
  CONSTRAINT campaigns_campaign_lowercase CHECK (campaign_address = lower(campaign_address)),
  CONSTRAINT campaigns_creator_lowercase  CHECK (creator_address = lower(creator_address)),
  CONSTRAINT campaigns_token_lowercase    CHECK (token_address IS NULL OR token_address = lower(token_address))
);

CREATE INDEX IF NOT EXISTS idx_campaigns_creator
  ON campaigns (chain_id, creator_address);

CREATE INDEX IF NOT EXISTS idx_campaigns_token
  ON campaigns (chain_id, token_address);


-- =========================================================
-- 3) Auth nonces (for SIWE-like "sign this nonce" auth)
--    One active nonce per (chain_id, address).
-- =========================================================
CREATE TABLE IF NOT EXISTS auth_nonces (
  chain_id     INTEGER NOT NULL,
  address      TEXT NOT NULL,                -- lowercase
  nonce        TEXT NOT NULL,
  expires_at   TIMESTAMPTZ NOT NULL,

  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, address),
  CONSTRAINT auth_nonces_address_lowercase CHECK (address = lower(address))
);

CREATE INDEX IF NOT EXISTS idx_auth_nonces_expires
  ON auth_nonces (expires_at);


-- =========================================================
-- 4) Token comments (per campaign; optional token address)
-- =========================================================
CREATE TABLE IF NOT EXISTS token_comments (
  id              BIGSERIAL PRIMARY KEY,

  chain_id         INTEGER NOT NULL,
  campaign_address TEXT NOT NULL,            -- lowercase
  token_address    TEXT,                     -- lowercase (optional)

  author_address   TEXT NOT NULL,            -- lowercase
  body             TEXT NOT NULL,

  parent_id        BIGINT,                   -- for replies (optional)
  status           SMALLINT NOT NULL DEFAULT 0,  -- 0=active, 1=hidden, 2=deleted

  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT token_comments_campaign_lowercase CHECK (campaign_address = lower(campaign_address)),
  CONSTRAINT token_comments_author_lowercase   CHECK (author_address = lower(author_address)),
  CONSTRAINT token_comments_token_lowercase    CHECK (token_address IS NULL OR token_address = lower(token_address)),
  CONSTRAINT token_comments_status_valid       CHECK (status IN (0,1,2)),
  CONSTRAINT token_comments_parent_fk          FOREIGN KEY (parent_id)
    REFERENCES token_comments(id) ON DELETE CASCADE
);

-- Feed-style queries: newest comments per campaign
CREATE INDEX IF NOT EXISTS idx_token_comments_campaign_time
  ON token_comments (chain_id, campaign_address, created_at DESC);

-- Profile/recent activity: newest comments by author
CREATE INDEX IF NOT EXISTS idx_token_comments_author_time
  ON token_comments (chain_id, author_address, created_at DESC);

-- Optional query: filter by token if you render comments post-graduation by token
CREATE INDEX IF NOT EXISTS idx_token_comments_token_time
  ON token_comments (chain_id, token_address, created_at DESC)
  WHERE token_address IS NOT NULL;

COMMIT;
</file>

<file path="db/migrations/003_indexer.sql">
-- db/migrations/003_indexer.sql
--
-- Supabase-only DB standardization:
-- Adds the indexer/trading tables used by realtime-indexer (Railway) and
-- aligns the existing campaigns table with the indexers expectations.

BEGIN;

-- =========================================================
-- 1) campaigns: extend the existing social registry with indexer fields
-- =========================================================

ALTER TABLE IF EXISTS public.campaigns
  ADD COLUMN IF NOT EXISTS created_block BIGINT NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS is_active BOOLEAN NOT NULL DEFAULT true;

CREATE INDEX IF NOT EXISTS idx_campaigns_active
  ON public.campaigns (chain_id, is_active);

-- =========================================================
-- 2) indexer_state: simple cursor -> last indexed block
--    Used by realtime-indexer/src/indexer.ts
-- =========================================================

CREATE TABLE IF NOT EXISTS public.indexer_state (
  chain_id           INTEGER NOT NULL,
  cursor             TEXT NOT NULL,
  last_indexed_block BIGINT NOT NULL DEFAULT 0,
  updated_at         TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, cursor)
);

-- =========================================================
-- 3) curve_trades: normalized buy/sell events (bonding curve)
-- =========================================================

CREATE TABLE IF NOT EXISTS public.curve_trades (
  chain_id          INTEGER NOT NULL,
  campaign_address  TEXT NOT NULL,          -- lowercase

  tx_hash           TEXT NOT NULL,          -- lowercase
  log_index         INTEGER NOT NULL,
  block_number      BIGINT NOT NULL,
  block_time        TIMESTAMPTZ NOT NULL,

  side              TEXT NOT NULL,          -- 'buy' | 'sell'
  wallet            TEXT NOT NULL,          -- lowercase

  token_amount_raw  NUMERIC(78, 0) NOT NULL,
  bnb_amount_raw    NUMERIC(78, 0) NOT NULL,

  -- Convenience floats for UI (source of truth remains *_raw)
  token_amount      DOUBLE PRECISION,
  bnb_amount        DOUBLE PRECISION,
  price_bnb         DOUBLE PRECISION,

  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT curve_trades_uniq_log PRIMARY KEY (chain_id, tx_hash, log_index),
  CONSTRAINT curve_trades_campaign_lowercase CHECK (campaign_address = lower(campaign_address)),
  CONSTRAINT curve_trades_txhash_lowercase   CHECK (tx_hash = lower(tx_hash)),
  CONSTRAINT curve_trades_wallet_lowercase   CHECK (wallet = lower(wallet)),
  CONSTRAINT curve_trades_side_chk           CHECK (side IN ('buy', 'sell'))
);

CREATE INDEX IF NOT EXISTS idx_curve_trades_campaign_time
  ON public.curve_trades (chain_id, campaign_address, block_number DESC, log_index DESC);

CREATE INDEX IF NOT EXISTS idx_curve_trades_wallet_time
  ON public.curve_trades (chain_id, wallet, block_number DESC, log_index DESC);

CREATE INDEX IF NOT EXISTS idx_curve_trades_block_time
  ON public.curve_trades (chain_id, block_time DESC);

-- =========================================================
-- 4) token_candles: OHLCV buckets for charts
-- =========================================================

CREATE TABLE IF NOT EXISTS public.token_candles (
  chain_id          INTEGER NOT NULL,
  campaign_address  TEXT NOT NULL,          -- lowercase
  timeframe         TEXT NOT NULL,          -- e.g. '5s', '1m', '5m'
  bucket_start      TIMESTAMPTZ NOT NULL,

  o                DOUBLE PRECISION NOT NULL,
  h                DOUBLE PRECISION NOT NULL,
  l                DOUBLE PRECISION NOT NULL,
  c                DOUBLE PRECISION NOT NULL,

  volume_bnb       DOUBLE PRECISION NOT NULL DEFAULT 0,
  trades_count     INTEGER NOT NULL DEFAULT 0,

  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, campaign_address, timeframe, bucket_start),
  CONSTRAINT token_candles_campaign_lowercase CHECK (campaign_address = lower(campaign_address))
);

CREATE INDEX IF NOT EXISTS idx_token_candles_campaign_tf_time
  ON public.token_candles (chain_id, campaign_address, timeframe, bucket_start DESC);

-- =========================================================
-- 5) token_stats: cached summary used by /api/token/:campaign/summary
-- =========================================================

CREATE TABLE IF NOT EXISTS public.token_stats (
  chain_id          INTEGER NOT NULL,
  campaign_address  TEXT NOT NULL,          -- lowercase

  last_price_bnb    DOUBLE PRECISION,
  sold_tokens       DOUBLE PRECISION NOT NULL DEFAULT 0,
  marketcap_bnb     DOUBLE PRECISION,
  vol_24h_bnb       DOUBLE PRECISION NOT NULL DEFAULT 0,

  updated_at        TIMESTAMPTZ NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, campaign_address),
  CONSTRAINT token_stats_campaign_lowercase CHECK (campaign_address = lower(campaign_address))
);

CREATE INDEX IF NOT EXISTS idx_token_stats_updated
  ON public.token_stats (chain_id, updated_at DESC);

COMMIT;
</file>

<file path="db/migrations/004_social_fixes.sql">
-- db/migrations/004_social_fixes.sql
-- Small compatibility fixes for the Vercel API functions.

BEGIN;

-- The Vercel API endpoints (auth nonce + profile upsert) mark nonces as used.
ALTER TABLE IF EXISTS public.auth_nonces
  ADD COLUMN IF NOT EXISTS used_at TIMESTAMPTZ;

COMMIT;
</file>

<file path="db/migrations/20260127_000001_votes.sql">
-- =========================================
-- MemeBattles Votes: ledger + aggregates
-- =========================================

begin;

-- 1) Votes ledger (append-only)
create table if not exists public.votes (
  id bigserial primary key,

  chain_id integer not null,
  campaign_address text not null,      -- store lowercase hex "0x..."
  voter_address text not null,         -- lowercase hex
  asset_address text not null,         -- "0x000..000" for native BNB, else ERC20 address
  amount_raw numeric not null,         -- uint256 can exceed bigint; numeric is safest

  tx_hash text not null,               -- lowercase "0x..."
  log_index integer not null,          -- logIndex from receipt
  block_number bigint not null,
  block_timestamp timestamptz not null,

  meta text null,                      -- optional (store bytes32 as hex string)
  status text not null default 'confirmed',  -- confirmed | reorged | invalid

  created_at timestamptz not null default now()
);

-- Idempotency: same on-chain event should never insert twice
create unique index if not exists votes_uq_event
  on public.votes(chain_id, tx_hash, log_index);

-- Query performance indexes
create index if not exists votes_idx_campaign_time
  on public.votes(campaign_address, block_timestamp desc);

create index if not exists votes_idx_voter_time
  on public.votes(voter_address, block_timestamp desc);

create index if not exists votes_idx_status
  on public.votes(status);

create index if not exists votes_idx_chain_block
  on public.votes(chain_id, block_number);

-- 2) Aggregates table for Featured list (fast sort/filter)
create table if not exists public.vote_aggregates (
  chain_id integer not null,
  campaign_address text not null,

  votes_1h integer not null default 0,
  votes_24h integer not null default 0,
  votes_7d integer not null default 0,
  votes_all_time integer not null default 0,

  -- A single score you can sort on for "Trending"
  -- Keep as numeric so you can do fractional decay weights
  trending_score numeric not null default 0,

  last_vote_at timestamptz null,
  updated_at timestamptz not null default now(),

  primary key (chain_id, campaign_address)
);

create index if not exists vote_aggregates_idx_trending
  on public.vote_aggregates(chain_id, trending_score desc);

create index if not exists vote_aggregates_idx_24h
  on public.vote_aggregates(chain_id, votes_24h desc);

create index if not exists vote_aggregates_idx_all
  on public.vote_aggregates(chain_id, votes_all_time desc);

-- 3) Helper view: confirmed votes only (simple for API)
create or replace view public.votes_confirmed as
select *
from public.votes
where status = 'confirmed';

commit;
</file>

<file path="db/migrations/20260129_000001_league.sql">
-- =========================================
-- MemeBattles UP Only League: lifecycle columns + indexes
-- =========================================

begin;

-- Extend campaigns table with objective lifecycle fields used by the League.
-- These are filled by the realtime-indexer:
--  - created_at_chain: from factory CampaignCreated block timestamp or factory.getCampaign().createdAt
--  - graduated_at_chain + graduated_block: from CampaignFinalized event
--  - fee_recipient_address: from LaunchCampaign.feeRecipient()

alter table public.campaigns
  add column if not exists created_at_chain timestamptz null;

alter table public.campaigns
  add column if not exists graduated_at_chain timestamptz null;

alter table public.campaigns
  add column if not exists graduated_block bigint null;

alter table public.campaigns
  add column if not exists fee_recipient_address text null;

-- Indexes for leaderboard queries
create index if not exists campaigns_idx_chain_graduated_time
  on public.campaigns(chain_id, graduated_at_chain desc);

create index if not exists campaigns_idx_chain_created_time
  on public.campaigns(chain_id, created_at_chain desc);

create index if not exists campaigns_idx_chain_fee_recipient
  on public.campaigns(chain_id, fee_recipient_address);

-- Helpful expression index for Largest Buy queries
create index if not exists curve_trades_idx_chain_side_bnb
  on public.curve_trades(chain_id, side, (bnb_amount_raw::numeric) desc);

commit;
</file>

<file path="db/SUPABASE_SCHEMA_FIX.sql">
-- MemeBattles Supabase schema fix (League + profiles/comments)
-- Safe to run multiple times.

-- ---------------------------
-- campaigns
-- ---------------------------
ALTER TABLE public.campaigns
  ADD COLUMN IF NOT EXISTS logo_uri text,
  ADD COLUMN IF NOT EXISTS created_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS graduated_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS graduated_block bigint,
  ADD COLUMN IF NOT EXISTS fee_recipient_address text;

CREATE INDEX IF NOT EXISTS campaigns_chain_created_block_idx
  ON public.campaigns(chain_id, created_block);

CREATE INDEX IF NOT EXISTS campaigns_chain_graduated_at_idx
  ON public.campaigns(chain_id, graduated_at_chain DESC);

-- ---------------------------
-- curve_trades: ensure log_index exists for stable UI keys
-- ---------------------------
ALTER TABLE public.curve_trades
  ADD COLUMN IF NOT EXISTS log_index integer;

CREATE INDEX IF NOT EXISTS curve_trades_chain_campaign_side_time_idx
  ON public.curve_trades(chain_id, campaign_address, side, block_time DESC);

-- ---------------------------
-- user_profiles
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.user_profiles (
  chain_id integer NOT NULL,
  address text NOT NULL,
  display_name text,
  avatar_url text,
  bio text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

-- Ensure expected columns exist (if table was created earlier with a different shape)
ALTER TABLE public.user_profiles
  ADD COLUMN IF NOT EXISTS display_name text,
  ADD COLUMN IF NOT EXISTS avatar_url text,
  ADD COLUMN IF NOT EXISTS bio text,
  ADD COLUMN IF NOT EXISTS created_at timestamptz,
  ADD COLUMN IF NOT EXISTS updated_at timestamptz;

-- ---------------------------
-- auth_nonces (used for profile/comment signatures)
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.auth_nonces (
  chain_id integer NOT NULL,
  address text NOT NULL,
  nonce text NOT NULL,
  expires_at timestamptz NOT NULL,
  used_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

ALTER TABLE public.auth_nonces
  ADD COLUMN IF NOT EXISTS nonce text,
  ADD COLUMN IF NOT EXISTS expires_at timestamptz,
  ADD COLUMN IF NOT EXISTS used_at timestamptz,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

-- ---------------------------
-- token_comments
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.token_comments (
  id bigserial PRIMARY KEY,
  chain_id integer NOT NULL,
  campaign_address text NOT NULL,
  token_address text,
  author_address text NOT NULL,
  body text NOT NULL,
  parent_id bigint,
  status integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.token_comments
  ADD COLUMN IF NOT EXISTS token_address text,
  ADD COLUMN IF NOT EXISTS parent_id bigint,
  ADD COLUMN IF NOT EXISTS status integer,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

CREATE INDEX IF NOT EXISTS token_comments_chain_campaign_id_idx
  ON public.token_comments(chain_id, campaign_address, id DESC);

-- Note: if you use RLS on these tables, ensure your server-side DB user (DATABASE_URL)
-- has permissions, or disable RLS for these tables (since Vercel/Railway access via Postgres).
</file>

<file path="deployments/bscTestnet.json">
{
  "network": "bscTestnet",
  "chainId": 97,
  "deployer": "0x13AD79765e14927dF2c554d9662Bbe539e89C8e8",
  "router": "0xD99D1c33F9fC3444f8101754aBC46c52416550D1",
  "treasurySafe": "0x13ad79765e14927df2c554d9662bbe539e89c8e8",
  "upgradeDelaySeconds": 172800,
  "protocolFeeBps": "200",
  "contracts": {
    "TreasuryVault": "0xc9d3e1174983314490B32a7929ac82421E4e5707",
    "TreasuryRouter": "0xf10909CA840b0C2212a0b15821b0a92Ba47ef769",
    "LaunchFactory": "0xCCCa3f0daf3D3D6D063287a0FbFd90607Ca8B7F6",
    "UPVoteTreasury": "0x58386c97B7AaE0738d50730cC59de8191eD1c816"
  }
}
</file>

<file path="frontend/.env.example">
# MemeBattles Frontend Environment (Vite)

# Chain configuration
# Reads follow the wallet chain automatically (if allowed); otherwise we fall back to default.
VITE_ALLOWED_CHAIN_IDS=56,97
VITE_DEFAULT_CHAIN_ID=97

# Public RPCs used for read-only calls (logs, balances, etc)
VITE_PUBLIC_RPC_97=https://data-seed-prebsc-1-s1.binance.org:8545/
VITE_PUBLIC_RPC_56=https://bsc-dataseed.binance.org/

# VITE_FACTORY_ADDRESS_97=0x...
# VITE_FACTORY_ADDRESS_56=0x...

# Optional: per-chain UP Vote treasury (enables "UP Vote" button)
# VITE_VOTE_TREASURY_ADDRESS_97=0x...
# VITE_VOTE_TREASURY_ADDRESS_56=0x...

# -----------------------------
# Server-only (Vercel Functions)
# -----------------------------

# Private status token used by /api/status
STATUS_TOKEN=

# Telemetry service endpoint (Railway)
TELEMETRY_STATUS_URL=
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/api/ably/token.js">
import Ably from "ably";
import { badMethod, getQuery, isAddress, json } from "../../server/http.js";

function p(v) {
  return String(v ?? "").trim();
}

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  // Never cache token requests
  res.setHeader("cache-control", "no-store");

  try {
    const ABLY_API_KEY = p(process.env.ABLY_API_KEY);
    if (!ABLY_API_KEY) return json(res, 500, { error: "Server misconfigured: ABLY_API_KEY missing" });

    const q = getQuery(req);
    const chainId = Number(q.chainId ?? 97);
    const campaign = p(q.campaign).toLowerCase();

    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (!isAddress(campaign)) return json(res, 400, { error: "Invalid campaign address" });

    const channel = `token:${chainId}:${campaign}`;

    // Browser only needs to SUBSCRIBE.
    // Publishing is done by your Railway indexer (server-side).
    const capability = {
      [channel]: ["subscribe"],
    };

    const rest = new Ably.Rest({ key: ABLY_API_KEY });

    const tokenRequest = await new Promise((resolve, reject) => {
      rest.auth.createTokenRequest(
        {
          capability: JSON.stringify(capability),
          // optional: reduce abuse window
          ttl: 60 * 60 * 1000, // 1 hour
        },
        (err, tr) => {
          if (err) return reject(err);
          resolve(tr);
        }
      );
    });

    return json(res, 200, tokenRequest);
  } catch (e) {
    console.error("[api/ably/token]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/api/auth/nonce.js">
import crypto from "crypto";
import { pool } from "../../server/db.js";
import { badMethod, getQuery, isAddress, json } from "../../server/http.js";

function makeNonce() {
  return crypto.randomBytes(16).toString("hex");
}

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId);
    const address = String(q.address ?? "").toLowerCase();
    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (!isAddress(address)) return json(res, 400, { error: "Invalid address" });
    if (!pool) return json(res, 500, { error: "Server misconfigured: DATABASE_URL missing" });

    const nonce = makeNonce();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000);

    await pool.query(
      `INSERT INTO auth_nonces (chain_id, address, nonce, expires_at)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (chain_id, address)
       DO UPDATE SET nonce = EXCLUDED.nonce, expires_at = EXCLUDED.expires_at, used_at = NULL`,
      [chainId, address, nonce, expiresAt]
    );

    return json(res, 200, { nonce, expiresAt: expiresAt.toISOString() });
  } catch (e) {
  console.error("[api/auth/nonce]", e);
  return json(res, 200, {
  vercelEnv: process.env.VERCEL_ENV || null,
  dbHost: (() => { try { return new URL(process.env.DATABASE_URL).hostname; } catch { return null; } })(),
  caB64Len: (process.env.PG_CA_CERT_B64 || "").length
});
}
}
</file>

<file path="frontend/api/campaigns/upsert.js">
import { pool } from "../../server/db.js";
import { badMethod, isAddress, json, readJson } from "../../server/http.js";

export default async function handler(req, res) {
  if (req.method !== "POST") return badMethod(res);

  try {
    const b = await readJson(req);
    const chainId = Number(b.chainId);
    const campaignAddress = String(b.campaignAddress ?? "").toLowerCase();
    const tokenAddress = String(b.tokenAddress ?? "").toLowerCase();
    const creatorAddress = String(b.creatorAddress ?? "").toLowerCase();
    const name = String(b.name ?? "").slice(0, 64);
    const symbol = String(b.symbol ?? "").slice(0, 16);

    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (!isAddress(campaignAddress)) return json(res, 400, { error: "Invalid campaignAddress" });
    if (!isAddress(tokenAddress)) return json(res, 400, { error: "Invalid tokenAddress" });
    if (!isAddress(creatorAddress)) return json(res, 400, { error: "Invalid creatorAddress" });

    await pool.query(
      `INSERT INTO campaigns (chain_id, campaign_address, token_address, creator_address, name, symbol)
       VALUES ($1, $2, $3, $4, $5, $6)
       ON CONFLICT (chain_id, campaign_address)
       DO UPDATE SET
         token_address = EXCLUDED.token_address,
         creator_address = EXCLUDED.creator_address,
         name = EXCLUDED.name,
         symbol = EXCLUDED.symbol,
         updated_at = NOW()`,
      [chainId, campaignAddress, tokenAddress, creatorAddress, name, symbol]
    );

    return json(res, 200, { ok: true });
  } catch (e) {
    console.error("[api/campaigns/upsert]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/api/certs/aiven-ca.pem">
-----BEGIN CERTIFICATE-----
MIIEUDCCArigAwIBAgIUTTFLGEI8KCv09z+X0A0YUMLmdjEwDQYJKoZIhvcNAQEM
BQAwQDE+MDwGA1UEAww1ZTEzYWZiMTAtOTk4YS00MGFlLWJkNDItODA4NjkwZDE4
MGI3IEdFTiAxIFByb2plY3QgQ0EwHhcNMjUxMjE4MjM1MjUyWhcNMzUxMjE2MjM1
MjUyWjBAMT4wPAYDVQQDDDVlMTNhZmIxMC05OThhLTQwYWUtYmQ0Mi04MDg2OTBk
MTgwYjcgR0VOIDEgUHJvamVjdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCC
AYoCggGBAN8Vwop7F83S8saK+Nf3GNby++/nmCmjELGbJFh3FqMBr1G0C/gKnvki
2Atpicjijj9zxI9F56fVkTBhyVJe7wdHtMqHLROSk/b/8e1b6wwVRdqvEWmppHaJ
UpsLRW5Dc2/uFh5BkzT9UixVVQlso9bce755V+PEv9qsDCAcwzZz6KlkMlhIN8Na
iX4a0W4trgNjkW8BfVDrxqi/8bgRcxu3ZpOnVSTRTSkS5dVlkAY8YlddI/2pt0KO
4RDF7OCPZNM6x5gvPa4c4ioWh8LdD7Tv+5oyn4Sp/CIBZpR+6kbvWSGGRaHyHi65
ApKhFMQlGUyU4CAw2Z392dq+hABn1T7xoyIl28cGaFwfsMVGtOSkouH+48tPC26I
w1D2dUeUEUngM0eqbU0tPBUQdSlUYaBhqDJaUKTm2DUzK2OFxQ/+NXS5g7Qe5QaV
eVR92K43i/XSaVc6hCPXLzs0S76t2bR08SZzPbnmOncV7Cf/QUAB7JTOH8w6qR4h
EXHnXScPkQIDAQABo0IwQDAdBgNVHQ4EFgQUTzuD9iwoxqnrqmzPtSNLSqa98HUw
EgYDVR0TAQH/BAgwBgEB/wIBADALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEMBQAD
ggGBADVLwUAV1b9ihGq0KAZwp1hXJ4PQTu/SbZnADKeEs/S8nRasN7cikoB5EebP
RoRiIrhagL2WqYgly6ExfPt1CrGLe9mwPWzhqfE5Lpe2BBHkIiILeAHq5j8syFrd
fvRuzVUesayqYEx7Dhbezf8SGeDSga7ag47PqANwAFFrkMTrI3exwOTu7NBnQYud
o2D0ecMihGK8LmKqW4EWMSfl3gO30KxnNd37AtVC2LpiJXYhlO2Tm+Spv8vNwQ64
mysnHUbFiY9oIBaDFsYKyLEW2WzTlbHM3a/HzWd+wajUyJR1nvEZbODPXCFHu+cC
lNuRS3381WZH7bf3KIMPi9wE3A6avPtCrxxS2JCfGZZkOp5Pnz/Exp0HMb+GNhez
fdD/TA3z68bkYMm6j/c7YJ0RXRRHf+7G3J0q2yj5VMHG1z9egiGRsKWEw3/pajCk
vDqU48NtyEF8S5GgVDe45Uw/2YpzoUJbMnubbr4kCfmbZozOX3ev1k3RPtLdGVe+
5glW6A==
-----END CERTIFICATE-----
</file>

<file path="frontend/api/comments.js">
import { ethers } from "ethers";
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json, readJson } from "../server/http.js";

function buildCommentMessage({ chainId, address, campaignAddress, nonce, body }) {
  const bodyPreview = String(body ?? "").replace(/\s+/g, " ").trim().slice(0, 180);
  return [
    "MemeBattles Comment",
    "Action: COMMENT_CREATE",
    `ChainId: ${chainId}`,
    `Address: ${String(address).toLowerCase()}`,
    `Campaign: ${String(campaignAddress).toLowerCase()}`,
    `Nonce: ${nonce}`,
    "",
    bodyPreview,
  ].join("\n");
}

async function consumeNonce(chainId, address, nonce) {
  const { rows } = await pool.query(
    `SELECT nonce, expires_at, used_at
     FROM auth_nonces
     WHERE chain_id = $1 AND address = $2
     LIMIT 1`,
    [chainId, address]
  );
  const row = rows[0];
  if (!row) throw new Error("Nonce not found");
  if (row.used_at) throw new Error("Nonce already used");
  const exp = row.expires_at ? new Date(row.expires_at).getTime() : 0;
  if (!exp || Date.now() > exp) throw new Error("Nonce expired");
  if (String(row.nonce) !== String(nonce)) throw new Error("Nonce mismatch");

  await pool.query(
    `UPDATE auth_nonces
     SET used_at = NOW()
     WHERE chain_id = $1 AND address = $2`,
    [chainId, address]
  );
}

export default async function handler(req, res) {
  if (req.method === "GET") {
    try {
      const q = getQuery(req);
      const chainId = Number(q.chainId);
      const campaignAddress = String(q.campaignAddress ?? "").toLowerCase();
      const limitRaw = Number(q.limit ?? 50);
      const beforeIdRaw = q.beforeId != null ? Number(q.beforeId) : null;

      if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
      if (!isAddress(campaignAddress)) return json(res, 400, { error: "Invalid campaignAddress" });
      const limit = Math.min(100, Math.max(1, Number.isFinite(limitRaw) ? limitRaw : 50));
      const beforeId = beforeIdRaw != null && Number.isFinite(beforeIdRaw) ? beforeIdRaw : null;

      const { rows } = await pool.query(
        `SELECT
           c.id,
           c.body,
           c.author_address AS "authorAddress",
           c.parent_id AS "parentId",
           c.created_at AS "createdAt",
           p.display_name AS "authorDisplayName",
           p.avatar_url AS "authorAvatarUrl"
         FROM token_comments c
         LEFT JOIN user_profiles p
           ON p.chain_id = c.chain_id AND p.address = c.author_address
         WHERE c.chain_id = $1
           AND c.campaign_address = $2
           AND c.status = 0
           AND ($3::bigint IS NULL OR c.id < $3)
         ORDER BY c.id DESC
         LIMIT $4`,
        [chainId, campaignAddress, beforeId, limit]
      );

      return json(res, 200, { items: rows });
    } catch (e) {
      const code = e?.code;
      console.error("[api/comments GET]", e);
      if (code === "42P01" || code === "42703") {
        return json(res, 200, { items: [], warning: "DB schema missing comments/profile tables/columns" });
      }
      return json(res, 500, { error: "Server error" });
    }
  }

  if (req.method === "POST") {
    try {
      const b = await readJson(req);
      const chainId = Number(b.chainId);
      const campaignAddress = String(b.campaignAddress ?? "").toLowerCase();
      const tokenAddress = b.tokenAddress ? String(b.tokenAddress).toLowerCase() : null;
      const address = String(b.address ?? "").toLowerCase();
      const body = String(b.body ?? "");
      const nonce = String(b.nonce ?? "");
      const signature = String(b.signature ?? "");
      const parentId = b.parentId != null ? Number(b.parentId) : null;

      if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
      if (!isAddress(campaignAddress)) return json(res, 400, { error: "Invalid campaignAddress" });
      if (!isAddress(address)) return json(res, 400, { error: "Invalid address" });
      if (tokenAddress && !isAddress(tokenAddress)) return json(res, 400, { error: "Invalid tokenAddress" });

      const trimmed = body.trim();
      if (!trimmed) return json(res, 400, { error: "Comment is empty" });
      if (trimmed.length > 500) return json(res, 400, { error: "Comment too long" });
      if (!nonce) return json(res, 400, { error: "Nonce missing" });
      if (!signature) return json(res, 400, { error: "Signature missing" });

      await consumeNonce(chainId, address, nonce);

      const msg = buildCommentMessage({ chainId, address, campaignAddress, nonce, body: trimmed });
      const recovered = ethers.verifyMessage(msg, signature).toLowerCase();
      if (recovered !== address) return json(res, 401, { error: "Invalid signature" });

      const { rows } = await pool.query(
        `INSERT INTO token_comments (
           chain_id, campaign_address, token_address, author_address, body, parent_id, status
         ) VALUES ($1, $2, $3, $4, $5, $6, 0)
         RETURNING id`,
        [chainId, campaignAddress, tokenAddress, address, trimmed, parentId]
      );

      return json(res, 200, { id: rows[0]?.id ?? null });
    } catch (e) {
      const msg = String(e?.message ?? "");
      const isAuth = /nonce|signature/i.test(msg);
      console.error("[api/comments POST]", e);
      return json(res, isAuth ? 401 : 500, { error: isAuth ? msg : "Server error" });
    }
  }

  return badMethod(res);
}
</file>

<file path="frontend/api/diagnostics.js">
import pg from "pg";

const { Pool } = pg;

function redact(value, keepStart = 6, keepEnd = 4) {
  const s = String(value ?? "");
  if (!s) return "";
  if (s.length <= keepStart + keepEnd) return "*".repeat(s.length);
  return `${s.slice(0, keepStart)}${s.slice(-keepEnd)}`;
}

function safeError(e) {
  return {
    name: e?.name || "Error",
    message: String(e?.message || e),
    code: e?.code,
    detail: e?.detail,
    where: e?.where,
    hint: e?.hint,
  };
}

function b64urlToUtf8(input) {
  const s = String(input || "").replace(/-/g, "+").replace(/_/g, "/");
  const pad = s.length % 4 ? "=".repeat(4 - (s.length % 4)) : "";
  return Buffer.from(s + pad, "base64").toString("utf8");
}

function decodeJwtUnsafe(token) {
  try {
    const parts = String(token || "").split(".");
    if (parts.length < 2) return { looksJwt: false };
    const payload = JSON.parse(b64urlToUtf8(parts[1]));
    const issHost = payload?.iss ? (() => { try { return new URL(payload.iss).host; } catch { return null; } })() : null;
    return {
      looksJwt: true,
      role: payload?.role || payload?.user_role || null,
      iss: payload?.iss || null,
      issHost,
      exp: payload?.exp || null,
      iat: payload?.iat || null,
    };
  } catch {
    return { looksJwt: false };
  }
}

function loadOptionalCaPem() {
  // Optional escape hatch: allow providing a custom CA PEM via env.
  // Supabase uses a public CA-signed certificate; you typically do NOT need this.
  const b64 = process.env.PG_CA_CERT_B64;
  if (b64) {
    const pem = Buffer.from(b64, "base64").toString("utf8");
    if (pem.includes("BEGIN CERTIFICATE")) return pem;
    throw new Error("PG_CA_CERT_B64 does not decode to a PEM certificate");
  }

  const pem = process.env.PG_CA_CERT;
  if (pem) return pem.includes("\\n") ? pem.replace(/\\n/g, "\n") : pem;

  return null;
}

function parseDbUrl(url) {
  const u = new URL(url);
  return {
    host: u.hostname,
    port: u.port ? Number(u.port) : 5432,
    user: u.username,
    password: u.password,
    database: (u.pathname || "").replace(/^\//, "") || "postgres",
  };
}

function normalizeHttpUrl(input) {
  const s = String(input || "").trim();
  if (!s) return "";
  if (/^https?:\/\//i.test(s)) return s;
  return "https://" + s;
}

async function checkTelemetry() {
  const url = String(process.env.TELEMETRY_STATUS_URL || "").trim();
  if (!url) return { ok: false, skipped: true, error: { message: "Missing TELEMETRY_STATUS_URL" } };

  try {
    const r = await fetchJson(url);
    if (!r.ok) {
      return { ok: false, latencyMs: r.latencyMs, httpStatus: r.status, url, error: { message: "Telemetry status non-200", detail: r.json || r.text } };
    }

    const svc = r.json?.services?.["realtime-indexer"] || null;
    if (!svc) {
      return { ok: false, latencyMs: r.latencyMs, httpStatus: r.status, url, error: { message: "No realtime-indexer in telemetry services yet" } };
    }

    return {
      ok: true,
      latencyMs: r.latencyMs,
      httpStatus: r.status,
      url,
      indexer: {
        ok: !!svc.ok,
        rps_1m: svc.rps_1m,
        errors_1m: svc.errors_1m,
        head_block: svc.head_block,
        last_indexed_block: svc.last_indexed_block,
        lag_blocks: svc.lag_blocks,
        last_indexer_run_ms_ago: svc.last_indexer_run_ms_ago,
        mem_mb: svc.mem_mb,
      },
    };
  } catch (e) {
    return { ok: false, error: safeError(e) };
  }
}

async function checkRpcHeadBlock() {
  const raw = String(process.env.BSC_RPC_HTTP_97 || "").trim();
  if (!raw) return { ok: false, skipped: true, error: { message: "Missing BSC_RPC_HTTP_97" } };

  const first = raw.split(",").map((s) => s.trim()).filter(Boolean)[0];
  if (!first) return { ok: false, skipped: true, error: { message: "No valid RPC URL found in BSC_RPC_HTTP_97" } };

  const body = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
  const t0 = Date.now();
  try {
    const resp = await fetch(first, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body),
      cache: "no-store",
    });
    const latencyMs = Date.now() - t0;
    if (!resp.ok) return { ok: false, latencyMs, httpStatus: resp.status, url: first };

    const j = await resp.json();
    const hex = j?.result;
    if (typeof hex !== "string" || !hex.startsWith("0x")) return { ok: false, latencyMs, httpStatus: resp.status, url: first };

    const head = parseInt(hex, 16);
    return { ok: true, latencyMs, httpStatus: resp.status, url: first, head_block: head };
  } catch (e) {
    return { ok: false, latencyMs: Date.now() - t0, url: first, error: safeError(e) };
  }
}

async function checkAblyRestAuth() {
  const key = String(process.env.ABLY_API_KEY || "");
  if (!key) return { ok: false, skipped: true, error: { message: "Missing ABLY_API_KEY" } };

  const [name, secret] = key.split(":");
  if (!name || !secret) return { ok: false, error: { message: "ABLY_API_KEY is not in keyName:keySecret format" } };

  const auth = Buffer.from(`${name}:${secret}`).toString("base64");
  const url = "https://rest.ably.io/time"; // safe endpoint
  const t0 = Date.now();
  try {
    const r = await fetch(url, {
      method: "GET",
      headers: { Authorization: `Basic ${auth}` },
      cache: "no-store",
    });
    const latencyMs = Date.now() - t0;
    const text = await r.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}

    // 200 means creds ok; 401 means bad key
    return {
      ok: r.ok,
      latencyMs,
      httpStatus: r.status,
      note: r.ok ? "REST auth OK" : "REST auth failed (check ABLY_API_KEY)",
      body: json || text.slice(0, 200),
    };
  } catch (e) {
    return { ok: false, latencyMs: Date.now() - t0, error: safeError(e) };
  }
}

async function pgCheck() {
  const DATABASE_URL = process.env.DATABASE_URL || "";
  if (!DATABASE_URL) {
    return { ok: false, error: { message: "DATABASE_URL is missing on this deployment" } };
  }

  let host = "";
  try {
    host = parseDbUrl(DATABASE_URL).host;
  } catch (e) {
    return { ok: false, error: { message: "DATABASE_URL is not a valid URL", detail: safeError(e) } };
  }

  let ca = null;
  try {
    ca = loadOptionalCaPem();
  } catch (e) {
    return { ok: false, error: { message: "Failed to load CA cert", detail: safeError(e) } };
  }

  const sslDisabled = String(process.env.PG_DISABLE_SSL || "").trim() === "1";
  const allowSelfSigned = String(process.env.PG_SSL_ALLOW_SELF_SIGNED || "").trim() === "1";
  const ssl = sslDisabled
    ? false
    : ca
      ? { ca, rejectUnauthorized: true, servername: host }
      : allowSelfSigned
        ? { rejectUnauthorized: false, servername: host }
        : { rejectUnauthorized: true, servername: host };

  const pool = new Pool({
    connectionString: DATABASE_URL,
    ssl,
    max: 1,
    idleTimeoutMillis: 10_000,
    connectionTimeoutMillis: 10_000,
  });

  try {
    const t0 = Date.now();
    await pool.query("select 1 as ok");
    const latencyMs = Date.now() - t0;

    // minimal schema checks (these are what your profile/comments features rely on)
    const checks = {};
    const reg1 = await pool.query(`select to_regclass('public.user_profiles') as reg`);
    checks.user_profiles = Boolean(reg1.rows?.[0]?.reg);

    const reg2 = await pool.query(`select to_regclass('public.token_comments') as reg`);
    checks.token_comments = Boolean(reg2.rows?.[0]?.reg);

    const reg3 = await pool.query(`select to_regclass('public.auth_nonces') as reg`);
    checks.auth_nonces = Boolean(reg3.rows?.[0]?.reg);

    if (checks.auth_nonces) {
      const cols = await pool.query(
        `select column_name
         from information_schema.columns
         where table_schema='public' and table_name='auth_nonces'`
      );
      const names = new Set((cols.rows || []).map((r) => String(r.column_name)));
      checks.auth_nonces_used_at = names.has("used_at");
      checks.auth_nonces_expires_at = names.has("expires_at");
      checks.auth_nonces_nonce = names.has("nonce");
    }

    return { ok: true, latencyMs, ssl: { hasCa: Boolean(ca), rejectUnauthorized: true }, checks };
  } catch (e) {
    return { ok: false, error: safeError(e), ssl: { hasCa: Boolean(ca) } };
  } finally {
    try { await pool.end(); } catch {}
  }
}

async function fetchJson(url, opts = {}) {
  const t0 = Date.now();
  const r = await fetch(url, { ...opts, cache: "no-store" });
  const text = await r.text();
  let json = null;
  try { json = JSON.parse(text); } catch {}
  return {
    ok: r.ok,
    status: r.status,
    latencyMs: Date.now() - t0,
    json,
    text: json ? null : text.slice(0, 300),
  };
}

async function checkRailway() {
  const baseRaw = process.env.RAILWAY_INDEXER_URL || "";
  if (!baseRaw) {
    return { ok: false, error: { message: "Missing RAILWAY_INDEXER_URL" } };
  }

  // Accept either:
  // - https://service.up.railway.app
  // - service.up.railway.app
  // - https://service.up.railway.app/health
  const base = normalizeHttpUrl(baseRaw).replace(/\/+$/, "");
  const url = base.endsWith("/health") ? base : base + "/health";

  try {
    const r = await fetchJson(url);
    const appOk = Boolean(r.json?.ok);
    return {
      ok: r.ok && appOk,
      latencyMs: r.latencyMs,
      url,
      httpStatus: r.status,
      body: r.json || r.text,
      note: baseRaw.startsWith("http") ? "" : "Tip: include https:// in RAILWAY_INDEXER_URL",
    };
  } catch (e) {
    return { ok: false, error: safeError(e), url };
  }
}

async function checkSupabasePublic() {
  // We only validate presence + basic URL sanity here (no secrets required).
  const url = process.env.SUPABASE_URL || "";
  if (!url) return { ok: false, error: { message: "Missing SUPABASE_URL" } };

  // Lightweight reachability: hit Supabase storage public endpoint root (should return 400/404 but reachable)
  const pingUrl = url.replace(/\/+$/, "") + "/rest/v1/";
  try {
    const t0 = Date.now();
    const r = await fetch(pingUrl, { method: "GET", cache: "no-store" });
    const latencyMs = Date.now() - t0;

    // Any response (even 401) confirms reachability from Vercel runtime
    return {
      ok: true,
      latencyMs,
      urlHost: (() => { try { return new URL(url).host; } catch { return "invalid"; } })(),
      pingUrl,
      httpStatus: r.status,
      note: "Reachability only (no service role key used).",
    };
  } catch (e) {
    return { ok: false, error: safeError(e), pingUrl };
  }
}

async function checkSupabaseServiceRole() {
  const baseUrl = process.env.SUPABASE_URL || "";
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY || "";
  const bucket = process.env.SUPABASE_BUCKET || "MemeBattles";

  const supaHost = (() => { try { return new URL(baseUrl).host; } catch { return null; } })();
  const jwt = decodeJwtUnsafe(key);
  const issuerMismatch = Boolean(jwt.looksJwt && jwt.issHost && supaHost && jwt.issHost !== supaHost);

  const jwtInfo = {
    looksJwt: jwt.looksJwt,
    role: jwt.role,
    issHost: jwt.issHost,
    supabaseHost: supaHost,
    issuerMismatch,
  };
  const headers = jwtInfo.looksJwt
  ? { Authorization: `Bearer ${key}`, apikey: key }   // legacy JWT keys
  : { apikey: key }; 

  if (!baseUrl || !key) {
    return {
      ok: false,
      skipped: true,
      error: { message: "Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY (required for /api/upload)" },
      bucket,
      jwt: jwtInfo,
    };
  }

  const url = baseUrl.replace(/\/+$/, "") + "/storage/v1/bucket";

  try {
    const t0 = Date.now();
    const r = await fetch(url, {
  method: "GET",
  headers,
  cache: "no-store",
});
    const latencyMs = Date.now() - t0;

    const text = await r.text();
    let json = null;
    try { json = JSON.parse(text); } catch {}

    if (!r.ok) {
      return {
        ok: false,
        latencyMs,
        httpStatus: r.status,
        error: {
          message: "Supabase Storage API request failed",
          detail: json || text.slice(0, 400),
        },
        bucket,
        url,
        jwt: jwtInfo,              // <-- add here (failure path)
      };
    }

    const buckets = Array.isArray(json) ? json : [];
    const bucketExists = buckets.some((b) => b?.name === bucket);

    return {
      ok: true,
      latencyMs,
      httpStatus: r.status,
      url,
      bucket: { name: bucket, exists: bucketExists, total: buckets.length },
      jwt: jwtInfo,                // <-- add here (success path)
    };
  } catch (e) {
    return {
      ok: false,
      error: safeError(e),
      bucket,
      url,
      jwt: jwtInfo,                // <-- optional but recommended
    };
  }
}


async function checkAblyServerKey() {
  // Ably server key must NOT be exposed to browser; check server-side env only
  const key = process.env.ABLY_API_KEY || "";
  if (!key) return { ok: false, error: { message: "Missing ABLY_API_KEY (server-side)" } };

  // Validate format without revealing it: should contain ":" (keyName:keySecret)
  const looksValid = key.includes(":") && key.length >= 20;
  return {
    ok: looksValid,
    looksValid,
    preview: redact(key, 10, 6),
    note: looksValid
      ? "Server key present and format looks valid."
      : "ABLY_API_KEY present but format does not look like keyName:keySecret.",
  };
}

export default async function handler(req, res) {
  try {
    const want = String(process.env.DIAGNOSTICS_TOKEN || "");
    const got = String(req.query?.token || "");

    // Hide endpoint if not authorized
    if (!want || got !== want) {
      return res.status(404).json({ error: "Not found" });
    }


    // Optional UI: /api/diagnostics-ui?token=... is rewritten here as /api/diagnostics?ui=1&token=...
    // We keep it inside this single function to save function slots on Vercel Hobby.
    const ui = String(req.query?.ui || "");
    if (ui === "1") {
      const token = got; // token comes from querystring

      const html = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MemeBattles Diagnostics</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1733;
      --panel2:#0c132b;
      --text:#e8ecff;
      --muted:#a9b3da;
      --line:rgba(255,255,255,.08);
      --ok:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --info:#60a5fa;
      --chip:#121c3e;
      --shadow: 0 20px 70px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    body{ margin:0; background: radial-gradient(1200px 700px at 20% 0%, rgba(96,165,250,.12), transparent 60%),
                           radial-gradient(900px 600px at 90% 10%, rgba(34,197,94,.10), transparent 55%),
                           var(--bg);
          color:var(--text); font-family:var(--sans); }
    td { word-break: break-word; }
.v, .mono { white-space: normal; }
    .wrap{
  max-width: min(1900px, calc(100vw - 32px));
  margin: 24px auto;
  padding: 0 16px;
}
    header{ display:flex; gap:16px; align-items:flex-start; justify-content:space-between; margin-bottom:18px; }
    h1{ margin:0; font-size:22px; letter-spacing:.2px; }
    .sub{ margin-top:6px; color:var(--muted); font-size:13px; }
    .actions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    button{ border:1px solid var(--line); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
            color:var(--text); padding:10px 12px; border-radius:12px; cursor:pointer; box-shadow:0 10px 30px rgba(0,0,0,.25);
            font-size:13px; }
    button:hover{ border-color:rgba(255,255,255,.18); }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border:1px solid var(--line);
           background:rgba(255,255,255,.03); border-radius:999px; font-size:12px; color:var(--muted); }
    .dot{ width:8px; height:8px; border-radius:999px; background:var(--muted); }
    .dot.ok{ background:var(--ok); }
    .dot.warn{ background:var(--warn); }
    .dot.bad{ background:var(--bad); }
    .dot.info{ background:var(--info); }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }

    .card{ background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
           border:1px solid var(--line); border-radius:18px; box-shadow:var(--shadow); overflow:hidden; }
    .card h2{ margin:0; padding:14px 14px 0 14px; font-size:14px; color:var(--muted); font-weight:600; letter-spacing:.3px; text-transform:uppercase; }
    .card .body{ padding:14px; }

    table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;

  /* NEW: keep columns stable and prevent the Status column from collapsing */
  table-layout: fixed;
}

th, td{
  padding:10px 10px;
  border-bottom:1px solid var(--line);
  vertical-align:top;

  /* NEW: allow long text/URLs/JSON to wrap instead of exploding the layout */
  word-break: break-word;
}

th{
  color:var(--muted);
  font-weight:600;
  text-align:left;
  background:rgba(0,0,0,.12);
}

tr:last-child td{ border-bottom:none; }

/* NEW: fixed 3-column widths for all 3-column tables */
th:nth-child(1), td:nth-child(1){ width:28%; }
th:nth-child(2), td:nth-child(2){ width:16%; }
th:nth-child(3), td:nth-child(3){ width:56%; }

/* Keep your existing semantics */
.k{ color:var(--muted); }          /* removed width:44% */
.v{ font-family:var(--mono); }
    .k{ color:var(--muted); width:44%; }
    .v{ font-family:var(--mono); }
    .badge{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-size:12px; font-weight:600;
            border:1px solid var(--line); background:rgba(255,255,255,.03); }
    .badge.ok{ color:var(--ok); border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.08); }
    .badge.bad{ color:var(--bad); border-color:rgba(239,68,68,.35); background:rgba(239,68,68,.08); }
    .badge.warn{ color:var(--warn); border-color:rgba(245,158,11,.35); background:rgba(245,158,11,.08); }
    .badge.info{ color:var(--info); border-color:rgba(96,165,250,.35); background:rgba(96,165,250,.08); }

    .muted{ color:var(--muted); }
    .mono{ font-family:var(--mono); }
    pre{
  margin:0;
  padding:12px;
  border-radius:14px;
  border:1px solid var(--line);
  background:rgba(0,0,0,.20);
  color:var(--text);
  overflow:auto;
  font-size:12px;
  line-height:1.5;
  max-height: 520px;
}
    .footer{ margin-top:14px; color:var(--muted); font-size:12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; margin-top:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>MemeBattles Diagnostics</h1>
        <div class="sub">Readable health view for Supabase Postgres (single DB) and integrations. Token is required via <span class="mono">?token=</span>.</div>
        <div class="row">
          <span id="overall" class="pill"><span class="dot info"></span><span>Loading</span></span>
          <span class="pill"><span class="dot info"></span><span class="mono" id="ts"></span></span>
          <span class="pill"><span class="dot info"></span><span class="mono" id="nodeEnv"></span></span>
        </div>
      </div>
      <div class="actions">
        <button id="refreshBtn">Refresh</button>
        <button id="copyBtn">Copy JSON</button>
      </div>
    </header>

    <div class="grid">
    <div class="card" style="grid-column: 1 / -1;">
  <h2>Readiness</h2>
  <div class="body">
    <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px;">
      <span id="corePill" class="pill"><span class="dot info"></span><span>Core: </span></span>
      <span id="goLivePill" class="pill"><span class="dot info"></span><span>Go-live: </span></span>
    </div>

    <div class="grid" style="grid-template-columns: 1fr 1fr;">
      <div class="card" style="box-shadow:none;">
        <h2 style="padding-top:0;">Core gates</h2>
        <div class="body" style="padding:0;">
          <table>
            <thead><tr><th>Gate</th><th>Status</th></tr></thead>
            <tbody id="coreGateRows"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="box-shadow:none;">
        <h2 style="padding-top:0;">Go-live gates</h2>
        <div class="body" style="padding:0;">
          <table>
            <thead><tr><th>Gate</th><th>Status</th></tr></thead>
            <tbody id="goLiveGateRows"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="card" style="grid-column: 1 / -1;">
  <h2>Monitoring / Scale signals</h2>
  <div class="body">
    <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px;">
      <span id="mRpc" class="pill"><span class="dot info"></span><span>RPC: </span></span>
      <span id="mDb" class="pill"><span class="dot info"></span><span>DB: </span></span>
      <span id="mRail" class="pill"><span class="dot info"></span><span>Indexer: </span></span>
      <span id="mLag" class="pill"><span class="dot info"></span><span>Lag: </span></span>
      <span id="mAbly" class="pill"><span class="dot info"></span><span>Ably: </span></span>
    </div>

    <table>
      <thead><tr><th>Signal</th><th>Status</th><th>Action</th></tr></thead>
      <tbody id="monitorRows"></tbody>
    </table>
  </div>
</div>

<div class="card">
  <h2>Vercel Runtime</h2>
  <div class="body">
    <table>
      <thead><tr><th>Item</th><th>Status</th><th>Details</th></tr></thead>
      <tbody id="vercelRows"></tbody>
    </table>
  </div>
</div>

<div class="card">
  <h2>Supabase Postgres (DATABASE_URL)</h2>
  <div class="body">
    <table>
      <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
      <tbody id="dbRows"></tbody>
    </table>
  </div>
</div>

<div class="card">
  <h2>Supabase (Token Data)</h2>
  <div class="body">
    <table>
      <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
      <tbody id="supabaseRows"></tbody>
    </table>
  </div>
</div>

<div class="card">
  <h2>Railway (Indexer)</h2>
  <div class="body">
    <table>
      <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
      <tbody id="railwayRows"></tbody>
    </table>
  </div>
</div>

<div class="card">
  <h2>Ably (Realtime)</h2>
  <div class="body">
    <table>
      <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
      <tbody id="ablyRows"></tbody>
    </table>
  </div>
</div>

      <div class="card">
        <h2>Recommendations</h2>
        <div class="body">
          <div id="recs" class="muted">Loading</div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <h2>Environment summary</h2>
        <div class="body">
          <table>
            <thead><tr><th>Key</th><th>Present</th><th>Extra</th></tr></thead>
            <tbody id="envRows"></tbody>
          </table>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <h2>Raw JSON</h2>
        <div class="body">
          <pre id="raw">Loading</pre>
          <div class="footer">This page intentionally never displays secrets. If you add more checks, keep them redacted.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const TOKEN = ${JSON.stringify(token)};
    let lastJson = null;


    function setPill(id, level, text) {
      const el = document.getElementById(id);
      if (!el) return;
      el.innerHTML = '<span class="dot ' + level + '"></span><span>' + text + '</span>';
    }

    function levelFromLatency(ms, warnMs, badMs) {
      if (!isFinite(ms)) return "info";
      if (ms >= badMs) return "bad";
      if (ms >= warnMs) return "warn";
      return "ok";
    }

    function setMonitoring(j) {
      const rowsEl = document.getElementById("monitorRows");
      if (!rowsEl) return;

      const tel = j?.checks?.telemetry;
      const rpc = j?.checks?.rpc;
      const db = j?.checks?.supabase_postgres;
      const rail = j?.checks?.railway;
      const ablyRest = j?.checks?.ably_rest;

      // Pills
      setPill(
        "mRpc",
        rpc?.ok ? levelFromLatency(rpc.latencyMs, 800, 2000) : (rpc?.skipped ? "warn" : "bad"),
        rpc?.ok ? ("RPC: " + rpc.latencyMs + "ms") : (rpc?.skipped ? "RPC: not configured" : "RPC: FAIL")
      );

      setPill(
        "mDb",
        db?.ok ? levelFromLatency(db.latencyMs, 800, 2000) : "bad",
        db?.ok ? ("DB: " + db.latencyMs + "ms") : "DB: FAIL"
      );

      setPill(
        "mRail",
        rail?.ok ? levelFromLatency(rail.latencyMs, 1200, 3000) : "bad",
        rail?.ok ? ("Indexer: " + rail.latencyMs + "ms") : "Indexer: FAIL"
      );

      const lag = tel?.ok ? Number(tel.indexer?.lag_blocks ?? NaN) : NaN;
      const lagLevel = !isFinite(lag)
        ? (tel?.ok ? "info" : (tel?.skipped ? "warn" : "bad"))
        : lag > 1000 ? "bad" : lag > 200 ? "warn" : "ok";

      setPill(
        "mLag",
        lagLevel,
        isFinite(lag) ? ("Lag: " + lag + " blocks") : (tel?.ok ? "Lag: " : "Lag: n/a")
      );

      setPill(
        "mAbly",
        ablyRest?.ok ? levelFromLatency(ablyRest.latencyMs, 800, 2000) : (ablyRest?.skipped ? "warn" : "bad"),
        ablyRest?.ok ? ("Ably: " + ablyRest.latencyMs + "ms") : (ablyRest?.skipped ? "Ably: not checked" : "Ably: FAIL")
      );

      // Rows + actions
      const rows = [];

      rows.push([
        "RPC latency / head block",
        rpc?.ok
          ? badge(levelFromLatency(rpc.latencyMs, 800, 2000), "OK")
          : badge(rpc?.skipped ? "warn" : "bad", rpc?.skipped ? "Skipped" : "FAIL"),
        rpc?.ok
          ? ("If latency stays high or timeouts: add better RPC(s) / rotate providers; consider rate limits. Head: <span class='mono'>" + (rpc.head_block ?? "") + "</span>")
          : "Set <span class='mono'>BSC_RPC_HTTP_97</span> on Vercel to validate RPC independently of the indexer.",
      ]);

      rows.push([
        "Supabase Postgres latency",
        db?.ok ? badge(levelFromLatency(db.latencyMs, 800, 2000), "OK") : badge("bad", "FAIL"),
        db?.ok
          ? "If this trends upward: move to higher Supabase compute tier, reduce query load, add indexes."
          : "DB failing: check DATABASE_URL / SSL / pooler availability.",
      ]);

      rows.push([
        "Indexer health (Railway /health)",
        rail?.ok ? badge(levelFromLatency(rail.latencyMs, 1200, 3000), "OK") : badge("bad", "FAIL"),
        rail?.ok
          ? "If /health latency rises and lag rises: scale Railway CPU/RAM for indexer."
          : "Indexer unhealthy: inspect Railway logs immediately.",
      ]);

      rows.push([
        "Indexer lag (telemetry)",
        tel?.ok
          ? badge(lagLevel, lagLevel === "ok" ? "OK" : lagLevel === "warn" ? "Rising" : "High")
          : badge(tel?.skipped ? "warn" : "bad", tel?.skipped ? "Skipped" : "FAIL"),
        tel?.ok
          ? ("If lag steadily increases: CPU bound or RPC throttled. Scale indexer and/or improve RPC. Errors/1m: <span class='mono'>" + (tel.indexer?.errors_1m ?? "") + "</span>, mem: <span class='mono'>" + (tel.indexer?.mem_mb ?? "") + "</span>MB")
          : "Set TELEMETRY_STATUS_URL on Vercel to surface indexer lag/errors/memory.",
      ]);

      rows.push([
        "Ably REST auth",
        ablyRest?.ok
          ? badge(levelFromLatency(ablyRest.latencyMs, 800, 2000), "OK")
          : badge(ablyRest?.skipped ? "warn" : "bad", ablyRest?.skipped ? "Skipped" : "FAIL"),
        ablyRest?.ok
          ? "If FAIL: ABLY_API_KEY invalid or blocked. Fix before launch; realtime will break."
          : "Add/validate ABLY_API_KEY server-side.",
      ]);

      rowsEl.innerHTML = rows
        .map(([k, st, d]) => "<tr><td class='k'>" + k + "</td><td>" + st + "</td><td class='muted'>" + d + "</td></tr>")
        .join("");
    }


    function setReadiness(j) {
  const status = j?.status || {};
  const coreReady = !!status.coreReady;
  const goLiveReady = !!status.goLiveReady;

  const corePill = document.getElementById("corePill");
  const goLivePill = document.getElementById("goLivePill");


  if (corePill) corePill.innerHTML = coreReady
    ? '<span class="dot ok"></span><span>Core: READY</span>'
    : '<span class="dot bad"></span><span>Core: NOT READY</span>';

  if (goLivePill) goLivePill.innerHTML = goLiveReady
    ? '<span class="dot ok"></span><span>Go-live: READY</span>'
    : '<span class="dot warn"></span><span>Go-live: NOT READY</span>';

  const coreRows = document.getElementById("coreGateRows");
  const goRows = document.getElementById("goLiveGateRows");

  const core = status.gates?.core || [];
  const go = status.gates?.goLive || [];

  if (coreRows) coreRows.innerHTML = core.map(g =>
    '<tr><td class="k">' + g.name + '</td><td>' + (g.ok ? badge("ok","PASS") : badge("bad","FAIL")) + '</td></tr>'
  ).join("");

  if (goRows) goRows.innerHTML = go.map(g =>
    '<tr><td class="k">' + g.name + '</td><td>' + (g.ok ? badge("ok","PASS") : badge("warn","FAIL")) + '</td></tr>'
  ).join("");
}

    function badge(status, label) {
      const cls = status === "ok" ? "ok" : status === "bad" ? "bad" : status === "warn" ? "warn" : "info";
      return '<span class="badge ' + cls + '"><span class="dot ' + cls + '"></span>' + label + '</span>';
    }

    function fmtBool(b){ return b ? badge("ok","Yes") : badge("bad","No"); }

    function setOverall(ok) {
      const el = document.getElementById("overall");
      if (!el) return;
      el.innerHTML = ok
        ? '<span class="dot ok"></span><span>Overall: OK</span>'
        : '<span class="dot bad"></span><span>Overall: Issues detected</span>';
    }

    function setVercelRows(j) {
  const tbody = document.getElementById("vercelRows");
  const env = j?.env_presence || {};
  const host = j?.redacted?.DATABASE_URL_host || "";

  const rows = [
    ["NODE_ENV", badge("info", j?.runtime?.nodeEnv || ""), "<span class='mono'>runtime</span>"],
    ["DATABASE_URL", env.DATABASE_URL ? badge("ok", "Present") : badge("bad", "Missing"), "host: <span class='mono'>" + host + "</span>"],
    ["RAILWAY_INDEXER_URL", env.RAILWAY_INDEXER_URL ? badge("ok","Present") : badge("warn","Missing"),
      env.RAILWAY_INDEXER_URL ? "used for /health checks" : "optional until you wire it"
    ],
  ];

  tbody.innerHTML = rows.map(([k,s,d]) =>
    "<tr><td class='k'>" + k + "</td><td>" + s + "</td><td class='muted'>" + d + "</td></tr>"
  ).join("");
}

function setDbRows(j) {
  const tbody = document.getElementById("dbRows");
  const a = j?.checks?.supabase_postgres;
  const env = j?.env_presence || {};
  const host = j?.redacted?.DATABASE_URL_host || "";

  const rows = [];

  // --- Section: Configuration ---
  rows.push([
    "<span class='mono'>Configuration</span>",
    badge("info", "Section"),
    "Validates DB env presence and TLS settings used for the Supabase Postgres connection."
  ]);

  rows.push([
    "DATABASE_URL",
    env.DATABASE_URL ? badge("ok", "Present") : badge("bad", "Missing"),
    env.DATABASE_URL ? ("host: <span class='mono'>" + host + "</span>") : "Add DATABASE_URL on Vercel (Production)."
  ]);

  const sslDisabled = String(env.PG_DISABLE_SSL || "") === "1";
  rows.push([
    "TLS",
    sslDisabled ? badge("warn", "Disabled") : badge("ok", "Enabled"),
    sslDisabled
      ? "TLS is disabled via <span class='mono'>PG_DISABLE_SSL=1</span>. Use this only for local Postgres."
      : "TLS is enabled. Supabase uses a public CA-signed certificate; a custom CA is optional."
  ]);

  // spacer
  rows.push(["", "", ""]);

  // --- Section: Connectivity ---
  rows.push([
    "<span class='mono'>Connectivity</span>",
    badge("info", "Section"),
    "Attempts <span class='mono'>select 1</span> with current SSL settings."
  ]);

  if (!a) {
    rows.push(["DB check", badge("bad", "No data"), "No diagnostics data for Postgres connectivity."]);
  } else if (!a.ok) {
    const code = a.error?.code ? ("<span class='mono'>" + a.error.code + "</span> ") : "";
    const msg = a.error?.message || "Unknown error";
    rows.push(["DB check", badge("bad", "FAIL"), code + msg]);

    // If you ever add these fields later, they will appear automatically
    if (a.ssl?.hasCa !== undefined) {
      rows.push(["SSL", badge("info", "Info"), "hasCa: <span class='mono'>" + String(!!a.ssl.hasCa) + "</span>"]);
    }
  } else {
    rows.push([
      "DB check",
      badge("ok", "OK"),
      "Latency: <span class='mono'>" + (a.latencyMs ?? "") + "ms</span>"
    ]);

    rows.push([
      "SSL verification",
      a.ssl?.rejectUnauthorized ? badge("ok", "Verified") : badge("warn", "Unverified"),
      "hasCa: <span class='mono'>" + String(!!a.ssl?.hasCa) + "</span>"
    ]);
  }

  // spacer
  rows.push(["", "", ""]);

  // --- Section: Schema ---
  rows.push([
    "<span class='mono'>Schema</span>",
    badge("info", "Section"),
    "Checks required tables/columns for profiles, comments, and nonces."
  ]);

  const c = a?.checks || {};

  // If no schema data (because connectivity failed or older diagnostics), show guidance
  if (!a?.ok) {
    rows.push([
      "Schema checks",
      badge("warn", "Skipped"),
      "Schema checks run only when DB connectivity is OK."
    ]);
  } else {
    rows.push(["Table: user_profiles", c.user_profiles ? badge("ok", "Present") : badge("bad", "Missing"), "Profiles (displayName/avatar/bio)."]);
    rows.push(["Table: token_comments", c.token_comments ? badge("ok", "Present") : badge("bad", "Missing"), "Comments feed on token pages."]);
    rows.push(["Table: auth_nonces", c.auth_nonces ? badge("ok", "Present") : badge("bad", "Missing"), "Wallet signature nonces."]);

    // Columns (only meaningful if auth_nonces exists)
    if (c.auth_nonces) {
      rows.push(["Column: auth_nonces.nonce", c.auth_nonces_nonce ? badge("ok", "Present") : badge("warn", "Missing"), "Nonce value."]);
      rows.push(["Column: auth_nonces.expires_at", c.auth_nonces_expires_at ? badge("ok", "Present") : badge("warn", "Missing"), "Expiration timestamp."]);
      rows.push(["Column: auth_nonces.used_at", c.auth_nonces_used_at ? badge("ok", "Present") : badge("warn", "Missing"), "Replay protection (used marker)."]);
    } else {
      rows.push(["auth_nonces columns", badge("warn", "Skipped"), "auth_nonces table missing."]);
    }
  }

  tbody.innerHTML = rows
    .map(([k, st, d]) => "<tr><td class='k'>" + k + "</td><td>" + st + "</td><td class='muted'>" + d + "</td></tr>")
    .join("");
}


function setSupabaseRows(j) {
  const tbody = document.getElementById("supabaseRows");
  const s = j?.checks?.supabase;                 // reachability-only
  const sr = j?.checks?.supabase_service_role;   // service-role storage check

  const rows = [];

  // --- Section: Reachability (public) ---
  rows.push([
    "<span class='mono'>Reachability (public)</span>",
    badge("info", "Section"),
    "Checks if Supabase is reachable from Vercel runtime (no secrets)."
  ]);

  if (!s) {
    rows.push(["Reachability", badge("bad", "No data"), "No response from diagnostics."]);
  } else if (!s.ok) {
    rows.push(["Reachability", badge("bad", "FAIL"), (s.error?.message || "Unknown error")]);
  } else {
    rows.push([
      "Reachability",
      badge("ok", "OK"),
      "Latency: <span class='mono'>" + (s.latencyMs ?? "") + "ms</span>, HTTP: <span class='mono'>" + (s.httpStatus ?? "") + "</span>"
    ]);
    rows.push(["Host", badge("info", s.urlHost || ""), "<span class='mono'>" + (s.pingUrl || "") + "</span>"]);
    rows.push(["Note", badge("info", "Info"), s.note || ""]);
  }

  // spacer row
  rows.push(["", "", ""]);

  // --- Section: Service Role / Storage (server-side) ---
  rows.push([
    "<span class='mono'>Service role / Storage</span>",
    badge("info", "Section"),
    "Validates SUPABASE_SERVICE_ROLE_KEY and checks bucket access (used by /api/upload)."
  ]);

  if (!sr) {
    rows.push(["Service role", badge("warn", "Not checked"), "supabase_service_role check not present in /api/diagnostics yet."]);
  } else if (!sr.ok) {
    const msg =
      sr.error?.message ||
      sr.error?.detail?.message ||
      sr.note ||
      "Missing or invalid SUPABASE_SERVICE_ROLE_KEY.";

    // If diagnostics marks it skipped, show WARN instead of FAIL
    const level = sr.skipped ? "warn" : "bad";
    rows.push(["Service role", badge(level, sr.skipped ? "Missing" : "FAIL"), msg]);

    if (sr.bucket) {
      rows.push(["Bucket", badge("info", "Info"), "Expected bucket: <span class='mono'>" + sr.bucket + "</span>"]);
    }
  } else {
    rows.push([
      "Service role",
      badge("ok", "OK"),
      "Latency: <span class='mono'>" + (sr.latencyMs ?? "") + "ms</span>"
    ]);

    if (sr.bucket) {
      rows.push([
        "Bucket",
        sr.bucket.exists ? badge("ok", "Exists") : badge("warn", "Missing"),
        "Name: <span class='mono'>" + sr.bucket.name + "</span>, buckets: <span class='mono'>" + (sr.bucket.total ?? "") + "</span>"
      ]);
    }
  }

  tbody.innerHTML = rows
    .map(([k, st, d]) => "<tr><td class='k'>" + k + "</td><td>" + st + "</td><td class='muted'>" + d + "</td></tr>")
    .join("");
}

function setRailwayRows(j) {
  const tbody = document.getElementById("railwayRows");
  const r = j?.checks?.railway;
  const env = j?.env_presence || {};

  const rows = [];

  // --- Section: Configuration ---
  rows.push([
    "<span class='mono'>Configuration</span>",
    badge("info", "Section"),
    "Checks Vercel env + URL normalization for the Railway indexer."
  ]);

  rows.push([
    "RAILWAY_INDEXER_URL",
    env.RAILWAY_INDEXER_URL ? badge("ok", "Present") : badge("warn", "Missing"),
    env.RAILWAY_INDEXER_URL
      ? "Configured. Diagnostics will call <span class='mono'>/health</span>."
      : "Add <span class='mono'>RAILWAY_INDEXER_URL</span> in Vercel (prefer full <span class='mono'>https://</span>)."
  ]);

  // spacer
  rows.push(["", "", ""]);

  // --- Section: Health (/health) ---
  rows.push([
    "<span class='mono'>Health check</span>",
    badge("info", "Section"),
    "Calls <span class='mono'>GET /health</span> on the Railway service and validates response body."
  ]);

  if (!r) {
    rows.push(["/health", badge("warn", "Not checked"), "No diagnostics data for Railway."]);
  } else if (!r.ok) {
    const bodyStr =
      typeof r.body === "string"
        ? r.body
        : r.body
        ? JSON.stringify(r.body)
        : "";

    const errStr =
      r.error?.message
        ? r.error.message
        : bodyStr
        ? bodyStr
        : "Unreachable or unhealthy.";

    rows.push([
      "/health",
      badge("bad", "FAIL"),
      "HTTP: <span class='mono'>" + (r.httpStatus ?? "") + "</span> " +
      (errStr ? ("<span class='mono'>" + errStr + "</span>") : "")
    ]);

    if (r.url) {
      rows.push(["URL", badge("info", "Info"), "<span class='mono'>" + r.url + "</span>"]);
    }
    if (r.note) {
      rows.push(["Note", badge("info", "Info"), r.note]);
    }
  } else {
    rows.push([
      "/health",
      badge("ok", "OK"),
      "Latency: <span class='mono'>" + (r.latencyMs ?? "") + "ms</span>, HTTP: <span class='mono'>" + (r.httpStatus ?? "") + "</span>"
    ]);

    rows.push(["URL", badge("info", "Info"), "<span class='mono'>" + (r.url || "") + "</span>"]);

    // Show the Railway payload (your /health returns {ok:false,error:"..."} etc.)
    if (r.body) {
      rows.push([
        "Body",
        badge("info", "Info"),
        "<span class='mono'>" + (typeof r.body === "string" ? r.body : JSON.stringify(r.body)) + "</span>"
      ]);
    }

    if (r.note) {
      rows.push(["Note", badge("info", "Info"), r.note]);
    }
  }

  tbody.innerHTML = rows
    .map(([k, st, d]) => "<tr><td class='k'>" + k + "</td><td>" + st + "</td><td class='muted'>" + d + "</td></tr>")
    .join("");
}


function setAblyRows(j) {
  const tbody = document.getElementById("ablyRows");
  const a = j?.checks?.ably; // server-side check
  const env = j?.env_presence || {};
  const preview = j?.redacted?.ABLY_API_KEY_preview || a?.preview || "";

  const rows = [];

  // --- Section: Server-side (Vercel) ---
  rows.push([
    "<span class='mono'>Server-side key</span>",
    badge("info", "Section"),
    "ABLY_API_KEY is required server-side. Never expose this key to the browser."
  ]);

  if (!a) {
    rows.push(["ABLY_API_KEY", badge("warn", "Not checked"), "No diagnostics data for Ably server key."]);
  } else if (!a.ok) {
    rows.push([
      "ABLY_API_KEY",
      badge("bad", "Missing/Invalid"),
      a.error?.message || a.note || "Server key missing or invalid."
    ]);
  } else {
    rows.push([
      "ABLY_API_KEY",
      badge("ok", "OK"),
      "Preview: <span class='mono'>" + (preview || "") + "</span>"
    ]);
    rows.push(["Note", badge("info", "Info"), a.note || ""]);
  }

  // spacer
  rows.push(["", "", ""]);

  // --- Section: Client-side (Browser) ---
  rows.push([
    "<span class='mono'>Client-side config</span>",
    badge("info", "Section"),
    "Browser should ideally use <span class='mono'>authUrl</span> (token auth), not a raw key. Wrong key causes <span class='mono'>invalid key parameter</span>."
  ]);

  rows.push([
    "VITE_ABLY_CLIENT_KEY",
    env.VITE_ABLY_CLIENT_KEY_on_server ? badge("warn", "Present") : badge("info", "Unknown"),
    env.VITE_ABLY_CLIENT_KEY_on_server
      ? "Client key appears to be set at build time. Ensure it is a valid Ably key, or remove it and rely on <span class='mono'>authUrl</span> only."
      : "Not visible server-side (can still be set client-side at build time)."
  ]);

  rows.push([
    "Recommendation",
    badge("info", "Info"),
    "For production: use <span class='mono'>authUrl: /api/ably/auth</span> and remove <span class='mono'>key</span> from the browser client constructor. This prevents key-format errors and avoids exposing secrets."
  ]);

  tbody.innerHTML = rows
    .map(([k, st, d]) => "<tr><td class='k'>" + k + "</td><td>" + st + "</td><td class='muted'>" + d + "</td></tr>")
    .join("");
}


    function setEnvRows(j) {
      const tbody = document.getElementById("envRows");
      const e = j?.env_presence || {};
      const rows = [
        ["DATABASE_URL", !!e.DATABASE_URL, j?.redacted?.DATABASE_URL_host ? ("host: " + j.redacted.DATABASE_URL_host) : ""],
        ["PG_CA_CERT_B64", !!e.PG_CA_CERT_B64, ""],
        ["PG_CA_CERT", !!e.PG_CA_CERT, ""],
        ["PG_DISABLE_SSL", String(e.PG_DISABLE_SSL || "") === "1", "set to 1 only for local Postgres"],
        ["SUPABASE_URL", !!e.SUPABASE_URL, ""],
        ["SUPABASE_SERVICE_ROLE_KEY", !!e.SUPABASE_SERVICE_ROLE_KEY, ""],
        ["ABLY_API_KEY", !!e.ABLY_API_KEY, ""],
        ["VITE_ABLY_CLIENT_KEY (server presence)", !!e.VITE_ABLY_CLIENT_KEY_on_server, "build-time var (client)"],
      ];

      tbody.innerHTML = rows.map(([k,p,extra]) => (
        '<tr>'
        + '<td class="k">' + k + '</td>'
        + '<td>' + (p ? badge("ok","Present") : badge("bad","Missing")) + '</td>'
        + '<td class="muted">' + (extra || "") + '</td>'
        + '</tr>'
      )).join("");
    }

    function setRecommendations(j) {
      const el = document.getElementById("recs");
      const recs = Array.isArray(j?.recommendations) ? j.recommendations : [];
      if (recs.length === 0) {
        el.innerHTML = badge("ok","No recommendations");
        return;
      }
      el.innerHTML = '<ol style="margin:0; padding-left:18px;">'
        + recs.map(r => '<li style="margin:8px 0;">' + r + '</li>').join("")
        + '</ol>';
    }

    function setHeaderMeta(j) {
      document.getElementById("ts").textContent = new Date().toISOString();
      document.getElementById("nodeEnv").textContent = "NODE_ENV=" + (j?.runtime?.nodeEnv || "");
    }

    async function load() {
    
      setOverall(false);
      const rawEl = document.getElementById("raw");
      rawEl.textContent = "Loading";

      const r = await fetch('/api/diagnostics?token=' + encodeURIComponent(TOKEN), { cache: 'no-store' });
      const j = await r.json();
      lastJson = j;

      setHeaderMeta(j);
      setReadiness(j);
      setMonitoring(j);
      setVercelRows(j);
setDbRows(j);
setSupabaseRows(j);
setRailwayRows(j);
setAblyRows(j);
setEnvRows(j); // keep the global env table too (optional)
      setRecommendations(j);

      rawEl.textContent = JSON.stringify(j, null, 2);
    }

    document.getElementById("refreshBtn").addEventListener("click", load);
    document.getElementById("copyBtn").addEventListener("click", async () => {
      try {
        const text = lastJson ? JSON.stringify(lastJson, null, 2) : "";
        await navigator.clipboard.writeText(text);
      } catch {}
    });

    load();
  </script>
</body>
</html>`;

    res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.setHeader("cache-control", "no-store");
      return res.status(200).send(html);
    }

    const out = {
      ok: false,
      runtime: {
        nodeEnv: process.env.NODE_ENV || "",
      },
      env_presence: {
        TELEMETRY_STATUS_URL: Boolean(process.env.TELEMETRY_STATUS_URL),
        BSC_RPC_HTTP_97: Boolean(process.env.BSC_RPC_HTTP_97),
        DATABASE_URL: Boolean(process.env.DATABASE_URL),
        PG_CA_CERT_B64: Boolean(process.env.PG_CA_CERT_B64),
        PG_CA_CERT: Boolean(process.env.PG_CA_CERT),
        PG_DISABLE_SSL: Boolean(process.env.PG_DISABLE_SSL),
        SUPABASE_URL: Boolean(process.env.SUPABASE_URL),
        SUPABASE_SERVICE_ROLE_KEY: Boolean(process.env.SUPABASE_SERVICE_ROLE_KEY),
        // Ably: server side should have ABLY_API_KEY (do not expose it)
        ABLY_API_KEY: Boolean(process.env.ABLY_API_KEY),
        // Client side uses VITE_ABLY_CLIENT_KEY at build time; may be absent here
        VITE_ABLY_CLIENT_KEY_on_server: Boolean(process.env.VITE_ABLY_CLIENT_KEY),
        RAILWAY_INDEXER_URL: Boolean(process.env.RAILWAY_INDEXER_URL),
      },
      redacted: {
        // helpful to verify you're pointing to the expected Postgres without leaking secrets
        DATABASE_URL_host: process.env.DATABASE_URL ? (() => {
          try { return parseDbUrl(process.env.DATABASE_URL).host; } catch { return "invalid"; }
        })() : "",
        ABLY_API_KEY_preview: process.env.ABLY_API_KEY ? redact(process.env.ABLY_API_KEY, 10, 6) : "",
      },
      checks: {},
      recommendations: [],
    };

    out.checks.telemetry = await checkTelemetry();
out.checks.rpc = await checkRpcHeadBlock();
out.checks.ably_rest = await checkAblyRestAuth();

    // DATABASE_URL should point at Supabase Postgres (single source of truth)
    out.checks.supabase_postgres = await pgCheck();

    // Railway (indexer health)
out.checks.railway = await checkRailway();

// Supabase (reachability only; token data lives here)
out.checks.supabase = await checkSupabasePublic();

out.checks.supabase_service_role = await checkSupabaseServiceRole();

const sr = out.checks.supabase_service_role;
if (sr && sr.jwt?.issuerMismatch) {
  out.recommendations.push(
    "SUPABASE_SERVICE_ROLE_KEY issuer does not match SUPABASE_URL host. You likely pasted a key from a different Supabase project. Copy the service_role key from the SAME project as SUPABASE_URL."
  );
}
if (sr && sr.jwt?.looksJwt && sr.jwt?.role && String(sr.jwt.role).toLowerCase() !== "service_role") {
  out.recommendations.push(
    "SUPABASE_SERVICE_ROLE_KEY JWT role is not service_role. Ensure you copied the service_role key (not anon) from Supabase Settings  API."
  );
}

if (!out.checks.supabase_service_role?.ok) {
  out.recommendations.push(
    "Supabase service role key is missing/invalid. This will break /api/upload. Set SUPABASE_SERVICE_ROLE_KEY on Vercel."
  );
}

// Ably (server key presence/format only)
out.checks.ably = await checkAblyServerKey();

if (!out.checks.railway?.ok) {
  out.recommendations.push(
    "Railway /health is failing or unreachable. Set RAILWAY_INDEXER_URL on Vercel and confirm the indexer can connect to Supabase Postgres."
  );
}

if (!out.checks.supabase?.ok) {
  out.recommendations.push(
    "Supabase reachability failed. Verify SUPABASE_URL on Vercel."
  );
}

if (!out.checks.ably?.ok) {
  out.recommendations.push(
    "Ably server key is missing/invalid on Vercel. Set ABLY_API_KEY (keyName:keySecret). Client-side should not use the server key."
  );
}
    if (!out.checks.supabase_postgres.ok) {
      out.recommendations.push(
        "Postgres DB check failed. Look at checks.supabase_postgres.error for the exact TLS/auth/host issue."
      );
      if (!out.env_presence.DATABASE_URL) {
        out.recommendations.push(
          "DATABASE_URL is missing on Vercel Production env. Add it and redeploy."
        );
      }
    } else {
      const c = out.checks.supabase_postgres.checks || {};
      if (!c.user_profiles) out.recommendations.push("Missing table user_profiles. Apply db/migrations/002_social.sql.");
      if (!c.token_comments) out.recommendations.push("Missing table token_comments. Apply db/migrations/002_social.sql.");
      if (c.auth_nonces && !c.auth_nonces_used_at) {
        out.recommendations.push(
          "auth_nonces.used_at column is missing but your API expects it. Add the column or update the queries/migration."
        );
      }
    }

    const gates = {
      core: [
        { name: "Supabase Postgres (DATABASE_URL)", ok: Boolean(out.checks.supabase_postgres?.ok) },
        { name: "Supabase reachability (REST)", ok: Boolean(out.checks.supabase?.ok) },
      ],
      goLive: [
        { name: "Supabase Postgres (DATABASE_URL)", ok: Boolean(out.checks.supabase_postgres?.ok) },
        { name: "Railway indexer /health", ok: Boolean(out.checks.railway?.ok) },
        { name: "Supabase reachability", ok: Boolean(out.checks.supabase?.ok) },
        { name: "Supabase service role (uploads)", ok: Boolean(out.checks.supabase_service_role?.ok) },
        { name: "Ably server key", ok: Boolean(out.checks.ably?.ok) },
      ],
    };

    out.status = {
      coreReady: gates.core.every((g) => g.ok),
      goLiveReady: gates.goLive.every((g) => g.ok),
      gates,
    };

    out.ok = out.status.coreReady;

    return res.status(200).json(out);
  } catch (e) {
    console.error("[api/diagnostics] crashed", e);
    return res.status(500).json({ error: "Server error", detail: safeError(e) });
  }
}
</file>

<file path="frontend/api/featured.js">
import { pool } from "../server/db.js";
import { badMethod, getQuery, json } from "../server/http.js";

const SORT_MAP = {
  trending: "trending_score",
  "24h": "votes_24h",
  "7d": "votes_7d",
  all: "votes_all_time",
};

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId ?? 97);
    const sortKeyRaw = String(q.sort ?? "trending").toLowerCase();
    const sortCol = SORT_MAP[sortKeyRaw] ?? SORT_MAP.trending;
    const limit = Math.max(1, Math.min(50, Number(q.limit ?? 10)));

    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });

    // IMPORTANT: Featured list is a *paid* placement via UPvote.
    // We only surface campaigns that still exist in our campaigns table and are still in bonding
    // (not graduated), to prevent old-factory / old-campaign addresses from showing up.
    const { rows } = await pool.query(
      `SELECT
         va.chain_id AS "chainId",
         va.campaign_address AS "campaignAddress",
         c.token_address AS "tokenAddress",
         c.creator_address AS "creatorAddress",
         c.name AS "name",
         c.symbol AS "symbol",
         c.logo_uri AS "logoUri",
         c.created_at_chain AS "createdAtChain",
         c.graduated_at_chain AS "graduatedAtChain",
         ts.marketcap_bnb AS "marketcapBnb",
         va.votes_1h AS "votes1h",
         va.votes_24h AS "votes24h",
         va.votes_7d AS "votes7d",
         va.votes_all_time AS "votesAllTime",
         va.trending_score AS "trendingScore",
         va.last_vote_at AS "lastVoteAt"
       FROM vote_aggregates va
       INNER JOIN campaigns c
         ON c.chain_id = va.chain_id
        AND c.campaign_address = va.campaign_address
       LEFT JOIN token_stats ts
         ON ts.chain_id = c.chain_id
        AND ts.campaign_address = c.campaign_address
       WHERE va.chain_id = $1
         AND (c.graduated_at_chain IS NULL)
       ORDER BY ${sortCol} DESC NULLS LAST
       LIMIT $2`,
      [chainId, limit]
    );

    return json(res, 200, { items: rows });
  } catch (e) {
    console.error("[api/featured]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/api/profile.js">
import { ethers } from "ethers";
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json, readJson } from "../server/http.js";

function buildProfileMessage({ chainId, address, nonce, displayName, avatarUrl }) {
  const name = String(displayName ?? "").trim().slice(0, 32);
  const avatar = String(avatarUrl ?? "").trim().slice(0, 200);
  return [
    "MemeBattles Profile",
    "Action: PROFILE_UPSERT",
    `ChainId: ${chainId}`,
    `Address: ${String(address).toLowerCase()}`,
    `Nonce: ${nonce}`,
    "",
    `DisplayName: ${name}`,
    `AvatarUrl: ${avatar}`,
  ].join("\n");
}

async function consumeNonce(chainId, address, nonce) {
  const { rows } = await pool.query(
    `SELECT nonce, expires_at, used_at
     FROM auth_nonces
     WHERE chain_id = $1 AND address = $2
     LIMIT 1`,
    [chainId, address]
  );
  const row = rows[0];
  if (!row) throw new Error("Nonce not found");
  if (row.used_at) throw new Error("Nonce already used");
  const exp = row.expires_at ? new Date(row.expires_at).getTime() : 0;
  if (!exp || Date.now() > exp) throw new Error("Nonce expired");
  if (String(row.nonce) !== String(nonce)) throw new Error("Nonce mismatch");

  await pool.query(
    `UPDATE auth_nonces SET used_at = NOW() WHERE chain_id = $1 AND address = $2`,
    [chainId, address]
  );
}

export default async function handler(req, res) {
  if (req.method === "GET") {
    try {
      const q = getQuery(req);
      const chainId = Number(q.chainId);
      const address = String(q.address ?? "").toLowerCase();
      if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
      if (!isAddress(address)) return json(res, 400, { error: "Invalid address" });

      const { rows } = await pool.query(
        `SELECT address, chain_id AS "chainId", display_name AS "displayName", avatar_url AS "avatarUrl", bio
         FROM user_profiles
         WHERE chain_id = $1 AND address = $2
         LIMIT 1`,
        [chainId, address]
      );

      return json(res, 200, { profile: rows[0] ?? null });
    } catch (e) {
      // Common deployment footguns: missing table/columns after a new migration.
      // Don't break the whole frontend; return an empty profile and log the real error.
      const code = e?.code;
      console.error("[api/profile GET]", e);
      if (code === "42P01" || code === "42703") {
        return json(res, 200, { profile: null, warning: "DB schema missing profile tables/columns" });
      }
      return json(res, 500, { error: "Server error" });
    }
  }

  if (req.method === "POST") {
    try {
      const b = await readJson(req);
      const chainId = Number(b.chainId);
      const address = String(b.address ?? "").toLowerCase();
      const displayName = String(b.displayName ?? "").trim().slice(0, 32);
      const avatarUrl = String(b.avatarUrl ?? "").trim().slice(0, 200) || null;
      const bio = String(b.bio ?? "").trim().slice(0, 280) || null;
      const nonce = String(b.nonce ?? "");
      const signature = String(b.signature ?? "");

      if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
      if (!isAddress(address)) return json(res, 400, { error: "Invalid address" });
      if (!nonce) return json(res, 400, { error: "Nonce missing" });
      if (!signature) return json(res, 400, { error: "Signature missing" });
      if (!pool) return json(res, 500, { error: "Server misconfigured: DATABASE_URL missing" });

      await consumeNonce(chainId, address, nonce);
      const msg = buildProfileMessage({ chainId, address, nonce, displayName, avatarUrl: avatarUrl ?? "" });
      const recovered = ethers.verifyMessage(msg, signature).toLowerCase();
      if (recovered !== address) return json(res, 401, { error: "Invalid signature" });

      await pool.query(
        `INSERT INTO user_profiles (chain_id, address, display_name, avatar_url, bio)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (chain_id, address)
         DO UPDATE SET display_name = EXCLUDED.display_name, avatar_url = EXCLUDED.avatar_url, bio = EXCLUDED.bio, updated_at = NOW()`,
        [chainId, address, displayName || null, avatarUrl, bio]
      );

      return json(res, 200, { ok: true });
    } catch (e) {
      const msg = String(e?.message ?? "");
      const isAuth = /nonce|signature/i.test(msg);
      console.error("[api/profile POST]", e);
      return json(res, isAuth ? 401 : 500, { error: isAuth ? msg : "Server error" });
    }
  }

  return badMethod(res);
}
</file>

<file path="frontend/api/status.js">
import { json, badMethod } from "../server/http.js";

function getBearerToken(req) {
  const h = String(req.headers?.authorization || "");
  const m = h.match(/^Bearer\s+(.+)$/i);
  return m ? m[1].trim() : "";
}

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  const expected = String(process.env.STATUS_TOKEN || "").trim();
  if (!expected) {
    return json(res, 500, { error: "STATUS_TOKEN is not configured" });
  }

  const token = getBearerToken(req) || String(req.query?.token || "").trim();
  if (!token || token !== expected) {
    return json(res, 401, { error: "Unauthorized" });
  }

  const url = String(process.env.TELEMETRY_STATUS_URL || "").trim();
  if (!url) {
    return json(res, 500, { error: "TELEMETRY_STATUS_URL is not configured" });
  }

  try {
    const r = await fetch(url, {
      headers: {
        "accept": "application/json",
      },
    });

    const txt = await r.text();
    if (!r.ok) {
      return json(res, 502, { error: "Telemetry upstream error", status: r.status, body: txt.slice(0, 500) });
    }

    // Private endpoint: don't cache in browsers.
    res.setHeader("cache-control", "no-store");
    res.statusCode = 200;
    res.setHeader("content-type", "application/json; charset=utf-8");
    res.end(txt);
  } catch (e) {
    return json(res, 502, { error: "Telemetry fetch failed", message: String(e?.message || e) });
  }
}
</file>

<file path="frontend/api/SUPABASE_SCHEMA_FIX.sql">
-- MemeBattles Supabase schema fix (League + profiles/comments)
-- Safe to run multiple times.

-- ---------------------------
-- campaigns
-- ---------------------------
ALTER TABLE public.campaigns
  ADD COLUMN IF NOT EXISTS logo_uri text,
  ADD COLUMN IF NOT EXISTS created_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS graduated_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS graduated_block bigint,
  ADD COLUMN IF NOT EXISTS fee_recipient_address text;

CREATE INDEX IF NOT EXISTS campaigns_chain_created_block_idx
  ON public.campaigns(chain_id, created_block);

CREATE INDEX IF NOT EXISTS campaigns_chain_graduated_at_idx
  ON public.campaigns(chain_id, graduated_at_chain DESC);

-- ---------------------------
-- curve_trades: ensure log_index exists for stable UI keys
-- ---------------------------
ALTER TABLE public.curve_trades
  ADD COLUMN IF NOT EXISTS log_index integer;

CREATE INDEX IF NOT EXISTS curve_trades_chain_campaign_side_time_idx
  ON public.curve_trades(chain_id, campaign_address, side, block_time DESC);

-- ---------------------------
-- user_profiles
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.user_profiles (
  chain_id integer NOT NULL,
  address text NOT NULL,
  display_name text,
  avatar_url text,
  bio text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

-- Ensure expected columns exist (if table was created earlier with a different shape)
ALTER TABLE public.user_profiles
  ADD COLUMN IF NOT EXISTS display_name text,
  ADD COLUMN IF NOT EXISTS avatar_url text,
  ADD COLUMN IF NOT EXISTS bio text,
  ADD COLUMN IF NOT EXISTS created_at timestamptz,
  ADD COLUMN IF NOT EXISTS updated_at timestamptz;

-- ---------------------------
-- auth_nonces (used for profile/comment signatures)
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.auth_nonces (
  chain_id integer NOT NULL,
  address text NOT NULL,
  nonce text NOT NULL,
  expires_at timestamptz NOT NULL,
  used_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

ALTER TABLE public.auth_nonces
  ADD COLUMN IF NOT EXISTS nonce text,
  ADD COLUMN IF NOT EXISTS expires_at timestamptz,
  ADD COLUMN IF NOT EXISTS used_at timestamptz,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

-- ---------------------------
-- token_comments
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.token_comments (
  id bigserial PRIMARY KEY,
  chain_id integer NOT NULL,
  campaign_address text NOT NULL,
  token_address text,
  author_address text NOT NULL,
  body text NOT NULL,
  parent_id bigint,
  status integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.token_comments
  ADD COLUMN IF NOT EXISTS token_address text,
  ADD COLUMN IF NOT EXISTS parent_id bigint,
  ADD COLUMN IF NOT EXISTS status integer,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

CREATE INDEX IF NOT EXISTS token_comments_chain_campaign_id_idx
  ON public.token_comments(chain_id, campaign_address, id DESC);

-- Note: if you use RLS on these tables, ensure your server-side DB user (DATABASE_URL)
-- has permissions, or disable RLS for these tables (since Vercel/Railway access via Postgres).
</file>

<file path="frontend/api/upload.js">
import { createClient } from "@supabase/supabase-js";
import formidable from "formidable";
import fs from "fs";
import crypto from "crypto";

// Keep as-is; harmless unless interpreted Next-style
export const config = {
  api: { bodyParser: false },
};

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

function bad(res, code, msg) {
  return res.status(code).json({ error: msg });
}

function pickExt(mimetype) {
  switch (mimetype) {
    case "image/png":
      return "png";
    case "image/jpeg":
    case "image/jpg":
      return "jpg";
    case "image/webp":
      return "webp";
    default:
      return null;
  }
}

export default async function handler(req, res) {
  if (req.method !== "POST") return bad(res, 405, "Method not allowed");

  const q = req.query || {};
  const kind = String(q.kind || "avatar"); // "avatar" | "logo"
  const chainId = String(q.chainId || "97");
  const address = String(q.address || "").toLowerCase();

  const maxBytes = kind === "avatar" ? 500 * 1024 : 2 * 1024 * 1024; // keep under Vercel body limits
  const form = formidable({
    multiples: false,
    maxFileSize: maxBytes,
    // optionally: uploadDir: "/tmp"  (formidable defaults to OS temp)
  });

  form.parse(req, async (err, fields, files) => {
    try {
      if (err) return bad(res, 400, `Upload parse failed: ${err.message}`);

      const fRaw = files.file;
      const f = Array.isArray(fRaw) ? fRaw[0] : fRaw;
      if (!f) return bad(res, 400, "Missing file (field name: file)");

      const filepath = f.filepath || f.path;
      const mimetype = String(f.mimetype || "");
      if (!/^image\/(png|jpeg|jpg|webp)$/.test(mimetype)) {
        return bad(res, 400, "Unsupported image type. Use png/jpg/webp.");
      }

      const ext = pickExt(mimetype);
      if (!ext) return bad(res, 400, "Unsupported image type.");

      const bucket = process.env.SUPABASE_BUCKET || "MemeBattles";

      // Defensive UUID generation across runtimes
      const uuid =
        (crypto && typeof crypto.randomUUID === "function" && crypto.randomUUID()) ||
        `${Date.now()}-${Math.random().toString(16).slice(2)}`;

      const name =
        kind === "avatar" && address
          ? `avatars/${chainId}/${address}.${ext}`
          : `logos/${chainId}/${uuid}.${ext}`;

      const buf = fs.readFileSync(filepath);

      const { error: upErr } = await supabase.storage.from(bucket).upload(name, buf, {
        contentType: mimetype,
        upsert: true,
        cacheControl: "3600",
      });

      // best-effort cleanup of temp file
      try {
        fs.unlinkSync(filepath);
      } catch {}

      if (upErr) return bad(res, 500, `Supabase upload failed: ${upErr.message}`);

      const { data } = supabase.storage.from(bucket).getPublicUrl(name);
      if (!data?.publicUrl) return bad(res, 500, "Failed to produce public URL");

      return res.status(200).json({ url: data.publicUrl });
    } catch (e) {
      console.error("[api/upload]", e);
      return bad(res, 500, "Server error");
    }
  });
}
</file>

<file path="frontend/api/vote_counts.js">
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json } from "../server/http.js";

/**
 * Batch vote counts for a set of campaigns.
 *
 * GET /api/vote_counts?chainId=97&campaigns=0x...,0x...
 *
 * Returns:
 * {
 *   chainId: 97,
 *   counts: {
 *     "0xabc...": { votes1h, votes24h, votes7d, votesAllTime, trendingScore, lastVoteAt }
 *   }
 * }
 */
export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId ?? 97);
    const raw = String(q.campaigns ?? "").trim();

    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (!raw) return json(res, 200, { chainId, counts: {} });

    const addrs = raw
      .split(",")
      .map((s) => s.trim().toLowerCase())
      .filter(Boolean);

    // Safety caps to keep URL/query sane.
    const unique = Array.from(new Set(addrs)).slice(0, 60);

    const valid = unique.filter((a) => isAddress(a));
    if (!valid.length) return json(res, 200, { chainId, counts: {} });

    const { rows } = await pool.query(
      `SELECT
         campaign_address AS "campaignAddress",
         votes_1h AS "votes1h",
         votes_24h AS "votes24h",
         votes_7d AS "votes7d",
         votes_all_time AS "votesAllTime",
         trending_score AS "trendingScore",
         last_vote_at AS "lastVoteAt"
       FROM vote_aggregates
       WHERE chain_id = $1
         AND campaign_address = ANY($2::text[])`,
      [chainId, valid]
    );

    const counts = {};
    for (const r of rows ?? []) {
      counts[String(r.campaignAddress).toLowerCase()] = {
        votes1h: r.votes1h ?? 0,
        votes24h: r.votes24h ?? 0,
        votes7d: r.votes7d ?? 0,
        votesAllTime: r.votesAllTime ?? 0,
        trendingScore: r.trendingScore ?? null,
        lastVoteAt: r.lastVoteAt ?? null,
      };
    }

    return json(res, 200, { chainId, counts });
  } catch (e) {
    console.error("[api/vote_counts]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/api/votes.js">
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json } from "../server/http.js";

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId ?? 97);
    const campaignAddress = q.campaignAddress ? String(q.campaignAddress).toLowerCase() : "";
    const voter = q.voter ? String(q.voter).toLowerCase() : "";
    const limit = Math.max(1, Math.min(100, Number(q.limit ?? 50)));

    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (campaignAddress && !isAddress(campaignAddress)) return json(res, 400, { error: "Invalid campaignAddress" });
    if (voter && !isAddress(voter)) return json(res, 400, { error: "Invalid voter" });

    const where = ["chain_id = $1", "status = 'confirmed'"];
    const params = [chainId];
    let idx = 2;

    if (campaignAddress) {
      where.push(`campaign_address = $${idx++}`);
      params.push(campaignAddress);
    }
    if (voter) {
      where.push(`voter_address = $${idx++}`);
      params.push(voter);
    }

    params.push(limit);

    const { rows } = await pool.query(
      `SELECT
         chain_id AS "chainId",
         campaign_address AS "campaignAddress",
         voter_address AS "voterAddress",
         asset_address AS "assetAddress",
         amount_raw AS "amountRaw",
         tx_hash AS "txHash",
         log_index AS "logIndex",
         block_number AS "blockNumber",
         block_timestamp AS "blockTimestamp",
         meta,
         status
       FROM votes
       WHERE ${where.join(" AND ")}
       ORDER BY block_timestamp DESC
       LIMIT $${idx}`,
      params
    );

    return json(res, 200, { items: rows });
  } catch (e) {
    console.error("[api/votes]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="frontend/eslint.config.js">
import js from "@eslint/js";
import globals from "globals";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import tseslint from "typescript-eslint";

export default tseslint.config(
  { ignores: ["dist"] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ["**/*.{ts,tsx}"],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
      "@typescript-eslint/no-unused-vars": "off",
    },
  },
);
</file>

<file path="frontend/global.css">
.nav {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 2rem;
  border-bottom: 1px solid #2a2340;
}

.nav-left,
.nav-right {
  display: flex;
  align-items: center;
}

.nav-links {
  display: flex;
  gap: 1.5rem;
  align-items: center;
}

.brand {
  font-size: 1.25rem;
  font-weight: 600;
  cursor: pointer;
}
</file>

<file path="frontend/package.json">
{
  "name": "vite_react_shadcn_ts",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:dev": "vite build --mode development",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toast": "^1.2.14",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@supabase/supabase-js": "^2.49.1",
    "@tanstack/react-query": "^5.83.0",
    "ably": "^2.17.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.6.0",
    "ethers": "^6.15.0",
    "formidable": "^3.5.1",
    "framer-motion": "^12.23.24",
    "input-otp": "^1.4.2",
    "lightweight-charts": "^5.1.0",
    "lucide-react": "^0.462.0",
    "motion": "^12.23.24",
    "next-themes": "^0.3.0",
    "pg": "^8.16.3",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.61.1",
    "react-resizable-panels": "^2.1.9",
    "react-router-dom": "^6.30.1",
    "recharts": "^2.15.4",
    "sonner": "^1.7.4",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.9",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/js": "^9.32.0",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22.16.5",
    "@types/pg": "^8.16.0",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@vitejs/plugin-react-swc": "^3.11.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^9.32.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^15.15.0",
    "lovable-tagger": "^1.1.11",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.8.3",
    "typescript-eslint": "^8.38.0",
    "vite": "^5.4.19"
  }
}
</file>

<file path="frontend/pages/components/WalletMenu.jsx">
// components/WalletMenu.jsx
import React from 'react';
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { InjectedConnector } from 'wagmi/connectors/injected';

export default function WalletMenu() {
  const { address, isConnected } = useAccount();
  const { connect, connectors, isLoading, pendingConnector } = useConnect({
    connector: new InjectedConnector(),
  });
  const { disconnect } = useDisconnect();

  const displayAddress = address
    ? `${address.slice(0, 6)}...${address.slice(-4)}`
    : '';

  // NOT CONNECTED
  if (!isConnected) {
    return (
      <button
        onClick={() => connect({ connector: connectors[0] })}
        disabled={isLoading}
        className="px-4 py-2 text-sm font-medium rounded-full border border-emerald-400 hover:bg-emerald-500 hover:text-black transition"
      >
        {isLoading && pendingConnector
          ? 'Connecting...'
          : 'Connect Wallet'}
      </button>
    );
  }

  // CONNECTED
  return (
    <div className="relative group">
      <button className="px-4 py-2 text-sm font-medium rounded-full border border-emerald-400 bg-neutral-900 hover:bg-neutral-800 transition">
        {displayAddress}
      </button>

      {/* hover dropdown */}
      <div className="absolute right-0 mt-2 hidden group-hover:block">
        <div className="w-40 rounded-lg border border-neutral-700 bg-neutral-900 shadow-lg py-1">
          <button
            onClick={() => disconnect()}
            className="w-full text-left px-4 py-2 text-sm hover:bg-neutral-800"
          >
            Disconnect
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="frontend/public/placeholder.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/robots.txt">
User-agent: Googlebot
Allow: /

User-agent: Bingbot
Allow: /

User-agent: Twitterbot
Allow: /

User-agent: facebookexternalhit
Allow: /

User-agent: *
Allow: /
</file>

<file path="frontend/README.md">
# Welcome to your Lovable project

## Project info

**URL**: https://lovable.dev/projects/cf28b9bc-eb75-49fd-b9b7-033893ae4394

## Project Structure

This project follows a well-organized architecture for maintainability and scalability:

### Directory Structure

```
src/
 assets/              # Static assets (images, icons, fonts)
 components/          # Reusable UI components
    ui/             # shadcn-ui and custom UI components
        effects/    # Visual effects (glitch, animations)
        loaders/    # Loading indicators
        progress/   # Progress bar components
 constants/          # Application constants and configuration
    navigation.ts   # Navigation configuration
    processingStages.ts  # Token processing stages
    validation.ts   # Form validation rules
 hooks/              # Custom React hooks
    useTokenForm.ts       # Token form state management
    useTokenProcessing.ts # Token processing state
 pages/              # Page components (routes)
 types/              # TypeScript type definitions
    token.ts        # Token-related types
    profile.ts      # Profile-related types
 lib/                # Utility functions

```

### Key Design Patterns

- **Component Organization**: Large components are broken down into smaller, focused sub-components
- **Custom Hooks**: Business logic is extracted into reusable custom hooks
- **Type Safety**: All data structures have proper TypeScript interfaces
- **Constants**: Magic numbers and configuration are centralized in constants files
- **Code Documentation**: All files include JSDoc comments explaining their purpose

## How can I edit this code?

There are several ways of editing your application.

**Use Lovable**

Simply visit the [Lovable Project](https://lovable.dev/projects/cf28b9bc-eb75-49fd-b9b7-033893ae4394) and start prompting.

Changes made via Lovable will be committed automatically to this repo.

**Use your preferred IDE**

If you want to work locally using your own IDE, you can clone this repo and push changes. Pushed changes will also be reflected in Lovable.

The only requirement is having Node.js & npm installed - [install with nvm](https://github.com/nvm-sh/nvm#installing-and-updating)

Follow these steps:

```sh
# Step 1: Clone the repository using the project's Git URL.
git clone <YOUR_GIT_URL>

# Step 2: Navigate to the project directory.
cd <YOUR_PROJECT_NAME>

# Step 3: Install the necessary dependencies.
npm i

# Step 4: Start the development server with auto-reloading and an instant preview.
npm run dev
```

**Edit a file directly in GitHub**

- Navigate to the desired file(s).
- Click the "Edit" button (pencil icon) at the top right of the file view.
- Make your changes and commit the changes.

**Use GitHub Codespaces**

- Navigate to the main page of your repository.
- Click on the "Code" button (green button) near the top right.
- Select the "Codespaces" tab.
- Click on "New codespace" to launch a new Codespace environment.
- Edit files directly within the Codespace and commit and push your changes once you're done.

## What technologies are used for this project?

This project is built with:

- Vite
- TypeScript
- React
- shadcn-ui
- Tailwind CSS

## How can I deploy this project?

Simply open [Lovable](https://lovable.dev/projects/cf28b9bc-eb75-49fd-b9b7-033893ae4394) and click on Share -> Publish.

## Can I connect a custom domain to my Lovable project?

Yes, you can!

To connect a domain, navigate to Project > Settings > Domains and click Connect Domain.

Read more here: [Setting up a custom domain](https://docs.lovable.dev/features/custom-domain#custom-domain)
</file>

<file path="frontend/server/db.js">
import pg from "pg";

const { Pool } = pg;

const DATABASE_URL = process.env.DATABASE_URL;

/**
 * Standardize on Supabase Postgres.
 *
 * Supabase uses a public CA-signed certificate, so you typically do NOT need
 * to provide a custom CA. Keep TLS enabled by default.
 *
 * If you are connecting to a local Postgres for development, you can disable
 * TLS by setting PG_DISABLE_SSL=1.
 */
function loadOptionalCaPem() {
  const b64 = process.env.PG_CA_CERT_B64;
  if (b64) {
    const pem = Buffer.from(b64, "base64").toString("utf8");
    if (pem.includes("BEGIN CERTIFICATE")) return pem;
    throw new Error("PG_CA_CERT_B64 does not decode to a PEM certificate");
  }

  const pem = process.env.PG_CA_CERT;
  if (pem) return pem.includes("\\n") ? pem.replace(/\\n/g, "\n") : pem;

  return null;
}

function parseDbUrl(url) {
  const u = new URL(url);
  return {
    host: u.hostname,
    port: u.port ? Number(u.port) : 5432,
    user: decodeURIComponent(u.username || ""),
    password: decodeURIComponent(u.password || ""),
    database: (u.pathname || "").replace(/^\//, "") || "postgres",
  };
}

// Reuse pool across invocations
let _pool = globalThis.__MemeBattles_pool;

if (!_pool) {
  if (!DATABASE_URL) throw new Error("DATABASE_URL missing");

  const { host, port, user, password, database } = parseDbUrl(DATABASE_URL);
  const ca = loadOptionalCaPem();
  const sslDisabled = String(process.env.PG_DISABLE_SSL || "").trim() === "1";
  // Some serverless/container environments ship with a minimal CA bundle.
  // If you hit SELF_SIGNED_CERT_IN_CHAIN when connecting to Supabase pooler,
  // set PG_SSL_ALLOW_SELF_SIGNED=1 to keep TLS on but skip certificate verification.
  const allowSelfSigned = String(process.env.PG_SSL_ALLOW_SELF_SIGNED || "").trim() === "1";

  console.log("[api/_db] PG host:", host, "port:", port, "db:", database);
  console.log(
    "[api/_db] CA loaded:",
    Boolean(ca),
    "CA bytes:",
    ca ? ca.length : 0,
    "allowSelfSigned:",
    allowSelfSigned
  );

  _pool = new Pool({
    host,
    port,
    user,
    password,
    database,

    ssl: sslDisabled
      ? false
      : ca
        ? { ca, rejectUnauthorized: true, servername: host }
        : allowSelfSigned
          ? { rejectUnauthorized: false, servername: host }
          : { rejectUnauthorized: true, servername: host },

    max: 2,
    idleTimeoutMillis: 30_000,
    connectionTimeoutMillis: 10_000,
  });

  globalThis.__MemeBattles_pool = _pool;

  _pool.on("error", (err) => console.error("[api/_db] Pool error", err));
}

export const pool = _pool;
</file>

<file path="frontend/server/http.js">
export function json(res, status, data) {
  res.statusCode = status;
  res.setHeader("content-type", "application/json; charset=utf-8");
  res.end(JSON.stringify(data));
}

export function badMethod(res) {
  json(res, 405, { error: "Method not allowed" });
}

export async function readJson(req) {
  if (req.body != null) return req.body;

  const chunks = [];
  for await (const c of req) chunks.push(c);
  const raw = Buffer.concat(chunks).toString("utf8");
  if (!raw) return {};
  try {
    return JSON.parse(raw);
  } catch {
    return {};
  }
}

export function getQuery(req) {
  const u = new URL(req.url, "http://localhost");
  const out = {};
  for (const [k, v] of u.searchParams.entries()) out[k] = v;
  return out;
}

export function isAddress(v) {
  return /^0x[a-fA-F0-9]{40}$/.test(String(v ?? ""));
}
</file>

<file path="frontend/src/abi/LaunchCampaign.json">
{
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURI",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "xAccount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "website",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "extraLink",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "curveBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityTokenBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "basePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "priceSlope",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "graduationTarget",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "protocolFeeBps",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "router",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "lpReceiver",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "feeRecipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "factory",
              "type": "address"
            }
          ],
          "internalType": "struct LaunchCampaign.InitParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityTokens",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityBnb",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "protocolFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "creatorPayout",
          "type": "uint256"
        }
      ],
      "name": "CampaignFinalized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "cost",
          "type": "uint256"
        }
      ],
      "name": "TokensPurchased",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "seller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "payout",
          "type": "uint256"
        }
      ],
      "name": "TokensSold",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "basePrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxCost",
          "type": "uint256"
        }
      ],
      "name": "buyExactTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "cost",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "buyersCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "creatorReserve",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "curveSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "extraLink",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "minTokens",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minBnb",
          "type": "uint256"
        }
      ],
      "name": "finalize",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "usedTokens",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "usedBnb",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "finalizedAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "graduationTarget",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasBought",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "launched",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquidityBps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "liquiditySupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "logoURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lpReceiver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "priceSlope",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolFeeBps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "quoteBuyExactTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "name": "quoteSellExactTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "router",
      "outputs": [
        {
          "internalType": "contract IPancakeRouter02",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minPayout",
          "type": "uint256"
        }
      ],
      "name": "sellExactTokens",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "payout",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token",
      "outputs": [
        {
          "internalType": "contract LaunchToken",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalBuyVolumeWei",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSellVolumeWei",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "website",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "xAccount",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ]
}
</file>

<file path="frontend/src/abi/LaunchFactory.json">
{
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "FeeTooHigh",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitBuyValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCurveBps",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LiquidityBps",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LogoEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NameEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Offset",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OutOfBounds",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PriceZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RecipientZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RefundFail",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RouterZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SlopeZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SupplyZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SymbolEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TargetZero",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "campaign",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "symbol",
          "type": "string"
        }
      ],
      "name": "CampaignCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "curveBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityTokenBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "basePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "priceSlope",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "graduationTarget",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityBps",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct LaunchFactory.LaunchConfig",
          "name": "newConfig",
          "type": "tuple"
        }
      ],
      "name": "ConfigUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newRecipient",
          "type": "address"
        }
      ],
      "name": "FeeRecipientUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newFeeBps",
          "type": "uint256"
        }
      ],
      "name": "ProtocolFeeUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newRouter",
          "type": "address"
        }
      ],
      "name": "RouterUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "campaignsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "config",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "curveBps",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "liquidityTokenBps",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "basePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "priceSlope",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "graduationTarget",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "liquidityBps",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURI",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "xAccount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "website",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "extraLink",
              "type": "string"
            },
            {
              "internalType": "uint256",
              "name": "basePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "priceSlope",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "graduationTarget",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "lpReceiver",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "initialBuyBnbWei",
              "type": "uint256"
            }
          ],
          "internalType": "struct LaunchFactory.CampaignRequest",
          "name": "req",
          "type": "tuple"
        }
      ],
      "name": "createCampaign",
      "outputs": [
        {
          "internalType": "address",
          "name": "campaignAddr",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenAddr",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "id",
          "type": "uint256"
        }
      ],
      "name": "getCampaign",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "campaign",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURI",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "xAccount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "website",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "extraLink",
              "type": "string"
            },
            {
              "internalType": "uint64",
              "name": "createdAt",
              "type": "uint64"
            }
          ],
          "internalType": "struct LaunchFactory.CampaignInfo",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "offset",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limit",
          "type": "uint256"
        }
      ],
      "name": "getCampaignPage",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "campaign",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURI",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "xAccount",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "website",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "extraLink",
              "type": "string"
            },
            {
              "internalType": "uint64",
              "name": "createdAt",
              "type": "uint64"
            }
          ],
          "internalType": "struct LaunchFactory.CampaignInfo[]",
          "name": "page",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolFeeBps",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "initialBuyTokens",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "basePriceOverride",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "priceSlopeOverride",
          "type": "uint256"
        }
      ],
      "name": "quoteInitialBuyTotal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "router",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "curveBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityTokenBps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "basePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "priceSlope",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "graduationTarget",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidityBps",
              "type": "uint256"
            }
          ],
          "internalType": "struct LaunchFactory.LaunchConfig",
          "name": "newConfig",
          "type": "tuple"
        }
      ],
      "name": "setConfig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newRecipient",
          "type": "address"
        }
      ],
      "name": "setFeeRecipient",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newProtocolFeeBps",
          "type": "uint256"
        }
      ],
      "name": "setProtocolFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newRouter",
          "type": "address"
        }
      ],
      "name": "setRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
}
</file>

<file path="frontend/src/abi/LaunchToken.json">
{
  "abi": [
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name_",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "symbol_",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "cap_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "allowance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        }
      ],
      "name": "ERC20InsufficientAllowance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "needed",
          "type": "uint256"
        }
      ],
      "name": "ERC20InsufficientBalance",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "approver",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "receiver",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidSender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "ERC20InvalidSpender",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TradingNotEnabled",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "burn",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "enableTrading",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tradingEnabled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]
}
</file>

<file path="frontend/src/components/ConnectWalletButton.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { useWallet, WalletType } from "@/hooks/useWallet";
import { Loader2, ChevronDown, Check } from "lucide-react";

export const ConnectWalletButton = () => {
  const { connect, disconnect, isConnected, account, connecting } = useWallet();
  const [isOpen, setIsOpen] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false); // <- NEW

  const shortAddress =
    account && account.length > 10
      ? `${account.slice(0, 6)}...${account.slice(-4)}`
      : account;

  const handleConnect = async (type: WalletType) => {
    try {
      await connect(type);
      setIsOpen(false);
    } catch (e: any) {
      console.error(e);
      alert(e?.message || "Failed to connect wallet");
    }
  };

  if (isConnected) {
    return (
      <div
        className="relative"
        onMouseEnter={() => setShowDropdown(true)}
        onMouseLeave={() => setShowDropdown(false)}
      >
        <Button
          variant="outline"
          className="font-mono text-xs md:text-sm rounded-full px-3 md:px-4 py-1 h-auto flex items-center gap-2"
        >
          <span className="w-2 h-2 rounded-full bg-emerald-500" />
          {shortAddress}
        </Button>

        {showDropdown && (
          <div className="absolute right-0 mt-1 w-32 rounded-md border border-border bg-background shadow-lg z-50">
            <button
              className="w-full text-left text-xs px-3 py-2 hover:bg-muted"
              onClick={() => {
                disconnect();
                setShowDropdown(false);
              }}
            >
              Disconnect
            </button>
          </div>
        )}
      </div>
    );
  }

  return (
    <>
      <Button
        onClick={() => setIsOpen(true)}
        disabled={connecting}
        className="font-retro text-xs md:text-sm rounded-full px-3 md:px-4 py-1 h-auto flex items-center gap-1"
      >
        {connecting ? (
          <>
            <Loader2 className="h-3 w-3 animate-spin" />
            Connecting...
          </>
        ) : (
          <>
            Connect Wallet
            <ChevronDown className="h-3 w-3" />
          </>
        )}
      </Button>

      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <div className="bg-background border border-border rounded-2xl shadow-xl w-[90%] max-w-sm p-4 md:p-6 space-y-4">
            <div className="flex items-center justify-between mb-2">
              <h2 className="text-sm md:text-base font-retro">
                Connect a wallet
              </h2>
              <button
                onClick={() => setIsOpen(false)}
                className="text-xs text-muted-foreground hover:text-foreground"
              >
                Close
              </button>
            </div>

            <p className="text-xs text-muted-foreground mb-2">
              Select a BSC-compatible EVM wallet. You can switch between
              testnet and mainnet from your wallet settings.
            </p>

            <div className="space-y-2">
              {/* MetaMask / Rabby / browser wallet */}
              <button
                onClick={() => handleConnect("metamask")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">MetaMask</p>
                  <p className="text-[11px] text-muted-foreground">
                    Browser wallet (Rabby etc.) on BSC
                  </p>
                </div>
                <div className="flex items-center gap-2 text-[11px] text-muted-foreground">
                  <span>EVM</span>
                  <Check className="h-3 w-3 opacity-60" />
                </div>
              </button>

              {/* Binance Wallet */}
              <button
                onClick={() => handleConnect("binance")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">Binance Wallet</p>
                  <p className="text-[11px] text-muted-foreground">
                    Official Binance extension for BSC
                  </p>
                </div>
                <div className="flex items-center gap-2 text-[11px] text-muted-foreground">
                  <span>BSC</span>
                  <Check className="h-3 w-3 opacity-60" />
                </div>
              </button>

              {/* Generic injected fallback */}
              <button
                onClick={() => handleConnect("injected")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">Other EVM wallet</p>
                  <p className="text-[11px] text-muted-foreground">
                    Any injected BSC-compatible wallet
                  </p>
                </div>
              </button>

              {/* If later you add WalletConnect, you can add a fourth option here */}
              {/* <button ...>WalletConnect (mobile)</button> */}
            </div>

            <p className="text-[10px] text-muted-foreground mt-2">
              Make sure your selected wallet is configured for Binance Smart
              Chain (BSC mainnet or testnet, depending on your setup).
            </p>
          </div>
        </div>
      )}
    </>
  );
};
</file>

<file path="frontend/src/components/FilterBar.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { FILTERS, type FilterKey } from "@/constants/filters";

export const FilterBar = () => {
  const [activeFilter, setActiveFilter] = useState<FilterKey>("All");

  return (
    <div className="flex gap-3 mb-6 justify-center">
      {FILTERS.map((filter) => (
        <Button
          key={filter}
          variant={activeFilter === filter ? "default" : "outline"}
          onClick={() => setActiveFilter(filter)}
          className={`font-retro text-xs ${
            activeFilter === filter
              ? "bg-accent/20 text-accent border-accent/50"
              : "border-accent/30 text-accent/70 hover:text-accent hover:border-accent/50"
          }`}
        >
          {filter}
        </Button>
      ))}
    </div>
  );
};
</file>

<file path="frontend/src/components/GridBackground.tsx">
/**
 * Grid Background Component
 * Creates an interactive grid background that lights up squares on mouse hover
 * The grid automatically adjusts to window size and has random initial lit squares
 */

import { useState, useEffect, useRef } from "react";

export const GridBackground = () => {
  const [litSquares, setLitSquares] = useState<Set<string>>(new Set());
  const [gridDimensions, setGridDimensions] = useState({ cols: 20, rows: 20 });
  const squareSize = typeof window !== 'undefined' && window.innerWidth < 768 ? 40 : 80; // Smaller squares on mobile
  const gridRef = useRef<HTMLDivElement>(null);
  const lastKeyRef = useRef<string>("");


  useEffect(() => {
    const updateGridSize = () => {
      const availableWidth = window.innerWidth;
      const availableHeight = window.innerHeight;
      
      const cols = Math.ceil(availableWidth / squareSize) + 2;
      const rows = Math.ceil(availableHeight / squareSize) + 2;
      
      setGridDimensions({ cols, rows });
    };

    updateGridSize();
    window.addEventListener("resize", updateGridSize);
    return () => window.removeEventListener("resize", updateGridSize);
  }, [squareSize]);

  useEffect(() => {
    const initialLit = new Set<string>();
    const isMobile = typeof window !== 'undefined' && window.innerWidth < 768;
    const numInitialLit = Math.floor((gridDimensions.cols * gridDimensions.rows) / (isMobile ? 12 : 8)); // Fewer lit squares on mobile
    
    for (let i = 0; i < numInitialLit; i++) {
      const x = Math.floor(Math.random() * gridDimensions.cols);
      const y = Math.floor(Math.random() * gridDimensions.rows);
      initialLit.add(`${x}-${y}`);
    }
    
    setLitSquares(initialLit);
  }, [gridDimensions]);

  useEffect(() => {
    const handleMove = (e: MouseEvent) => {
      const el = gridRef.current;
      if (!el) return;
      const rect = el.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const gridX = Math.floor(x / squareSize);
      const gridY = Math.floor(y / squareSize);
      const key = `${gridX}-${gridY}`;

      if (
        gridX >= 0 &&
        gridX < gridDimensions.cols &&
        gridY >= 0 &&
        gridY < gridDimensions.rows &&
        key !== lastKeyRef.current
      ) {
        lastKeyRef.current = key;
        setLitSquares((prev) => {
          const newSet = new Set(prev);
          if (newSet.has(key)) {
            newSet.delete(key);
          } else {
            newSet.add(key);
          }
          return newSet;
        });
      }
    };

    window.addEventListener("mousemove", handleMove, { passive: true });
    return () => {
      window.removeEventListener("mousemove", handleMove);
    };
  }, [gridDimensions, squareSize]);

  const gridStyle = {
    gridTemplateColumns: `repeat(${gridDimensions.cols}, ${squareSize}px)`,
    gridTemplateRows: `repeat(${gridDimensions.rows}, ${squareSize}px)`,
  };

  return (
    <>
      {/* Visual layer - behind all content */}
      <div className="fixed left-0 top-0 right-0 bottom-0 overflow-hidden pointer-events-none z-0">
        <div 
          ref={gridRef}
          className="absolute inset-0 grid"
          style={gridStyle}
        >
          {Array.from({ length: gridDimensions.cols * gridDimensions.rows }).map((_, index) => {
            const x = index % gridDimensions.cols;
            const y = Math.floor(index / gridDimensions.cols);
            const key = `${x}-${y}`;
            const isLit = litSquares.has(key);

            return (
              <div
                key={key}
                className="border border-border/30 transition-all duration-300"
                style={{
                  backgroundColor: isLit ? 'hsl(220 12% 75% / 0.2)' : 'transparent',
                  boxShadow: isLit ? '0 0 20px hsl(220 12% 75% / 0.35)' : 'none',
                }}
              />
            );
          })}
        </div>
      </div>
    </>
  );
};
</file>

<file path="frontend/src/components/home/LeagueCampaigns.tsx">
import { useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import { ethers } from "ethers";
import { GlowingEffect } from "@/components/ui/glowing-effect";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

type Period = "weekly" | "monthly" | "all_time";

type LeagueBase = {
  campaign_address: string;
  name?: string | null;
  symbol?: string | null;
  logo_uri?: string | null;
};

type GraduationRow = LeagueBase & {
  duration_seconds: number;
  unique_buyers: number;
  sells_count: number;
};

type LargestBuyRow = LeagueBase & {
  buyer_address: string;
  bnb_amount_raw: string;
  tx_hash: string;
  log_index: number;
};

type LeagueResponse<T> = {
  chainId: number;
  category: string;
  period: Period;
  items: T[];
};

const isAddress = (s?: string) => /^0x[a-fA-F0-9]{40}$/.test(String(s ?? "").trim());
const shortAddr = (a: string) => (a && a.length > 12 ? a.slice(0, 6) + "..." + a.slice(-4) : a);

function formatDuration(seconds?: number | null) {
  const s = Math.max(0, Number(seconds ?? 0));
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = Math.floor(s % 60);
  if (h > 0) return `${h}h ${m}m`;
  if (m > 0) return `${m}m ${sec}s`;
  return `${sec}s`;
}

function formatBnbFromRaw(raw?: string | null) {
  try {
    const v = BigInt(String(raw ?? "0"));
    const n = Number(ethers.formatUnits(v, 18));
    if (!Number.isFinite(n)) return "0";
    if (n >= 100) return n.toFixed(2);
    if (n >= 1) return n.toFixed(4);
    return n.toFixed(6);
  } catch {
    return "0";
  }
}

function TokenLine({ row }: { row: LeagueBase }) {
  const title = (row.name ? String(row.name) : "") || "Unknown";
  const sym = (row.symbol ? String(row.symbol) : "") || "";
  const initial = sym ? sym.slice(0, 1).toUpperCase() : "T";

  return (
    <div className="flex items-center gap-2 min-w-0">
      <Avatar className="h-7 w-7">
        <AvatarImage src={row.logo_uri || undefined} />
        <AvatarFallback>{initial}</AvatarFallback>
      </Avatar>
      <div className="min-w-0">
        <div className="text-sm font-semibold truncate">
          {title} {sym ? <span className="text-muted-foreground">({sym})</span> : null}
        </div>
        <div className="text-[11px] text-muted-foreground truncate">{row.campaign_address}</div>
      </div>
    </div>
  );
}

export function LeagueCampaigns({ chainId = 97, limit = 3 }: { chainId?: number; limit?: number }) {
  const navigate = useNavigate();

  const [loading, setLoading] = useState(true);
  const [straightUp, setStraightUp] = useState<GraduationRow[]>([]);
  const [fastest, setFastest] = useState<GraduationRow[]>([]);
  const [largestBuys, setLargestBuys] = useState<LargestBuyRow[]>([]);

  const qs = useMemo(
    () => `chainId=${encodeURIComponent(String(chainId))}&period=weekly&limit=${encodeURIComponent(String(limit))}`,
    [chainId, limit]
  );

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setLoading(true);
        const [a, b, c] = await Promise.all([
          fetch(`/api/league?${qs}&category=straight_up`).then((r) => r.json()),
          fetch(`/api/league?${qs}&category=fastest_graduation`).then((r) => r.json()),
          fetch(`/api/league?${qs}&category=largest_buy`).then((r) => r.json()),
        ]);

        if (cancelled) return;
        setStraightUp((a as LeagueResponse<GraduationRow>)?.items ?? []);
        setFastest((b as LeagueResponse<GraduationRow>)?.items ?? []);
        setLargestBuys((c as LeagueResponse<LargestBuyRow>)?.items ?? []);
      } catch (e) {
        console.error("[LeagueCampaigns] failed to load /api/league", e);
        if (!cancelled) {
          setStraightUp([]);
          setFastest([]);
          setLargestBuys([]);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [qs]);

  if (loading) {
    return (
      <div className="mt-4 md:mt-6">
        <div className="mb-2 flex items-center justify-between">
          <h2 className="text-sm md:text-base font-semibold tracking-wide">UP Only League</h2>
          <span className="text-xs text-muted-foreground">This week</span>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 md:gap-4">
          {Array.from({ length: 3 }).map((_, i) => (
            <div key={i} className="h-44 rounded-[1.25rem] border border-border/40 bg-card" />
          ))}
        </div>
      </div>
    );
  }

  // If no data at all, don't render the section.
  if (!straightUp.length && !fastest.length && !largestBuys.length) return null;

  const panelClass =
    "relative rounded-[1.25rem] border border-border/40 bg-card/70 p-4 text-left overflow-hidden hover:bg-card transition-colors";

  return (
    <div className="mt-4 md:mt-6">
      <div className="mb-2 flex items-center justify-between">
        <h2 className="text-sm md:text-base font-semibold tracking-wide">UP Only League</h2>
        <button
          type="button"
          onClick={() => navigate("/league")}
          className="text-xs text-muted-foreground hover:text-foreground transition-colors"
        >
          View all
        </button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-3 md:gap-4">
        {/* Straight UP */}
        <div className={panelClass}>
          <GlowingEffect blur={18} spread={36} glow={true} disabled={false} movementDuration={1.6} className="pointer-events-none" />
          <div className="flex items-center justify-between">
            <div className="text-sm font-semibold">Straight UP</div>
            <div className="text-[11px] text-muted-foreground">No sells</div>
          </div>

          <div className="mt-3 space-y-3">
            {straightUp.slice(0, limit).map((r, idx) => (
              <button
                key={r.campaign_address}
                type="button"
                onClick={() => navigate(`/token/${r.campaign_address}`)}
                className="w-full text-left flex items-start justify-between gap-3"
              >
                <div className="min-w-0 flex-1">
                  <TokenLine row={r} />
                </div>
                <div className="text-right">
                  <div className="text-sm font-semibold" style={{ color: "#affe00" }}>
                    {idx + 1}
                  </div>
                  <div className="text-[11px] text-muted-foreground">{formatDuration(r.duration_seconds)}</div>
                </div>
              </button>
            ))}
            {!straightUp.length ? <div className="text-xs text-muted-foreground">No qualifiers yet.</div> : null}
          </div>
        </div>

        {/* Fastest */}
        <div className={panelClass}>
          <GlowingEffect blur={18} spread={36} glow={true} disabled={false} movementDuration={1.6} className="pointer-events-none" />
          <div className="flex items-center justify-between">
            <div className="text-sm font-semibold">Fastest Graduation</div>
            <div className="text-[11px] text-muted-foreground"> 25 buyers</div>
          </div>

          <div className="mt-3 space-y-3">
            {fastest.slice(0, limit).map((r, idx) => (
              <button
                key={r.campaign_address}
                type="button"
                onClick={() => navigate(`/token/${r.campaign_address}`)}
                className="w-full text-left flex items-start justify-between gap-3"
              >
                <div className="min-w-0 flex-1">
                  <TokenLine row={r} />
                </div>
                <div className="text-right">
                  <div className="text-sm font-semibold" style={{ color: "#affe00" }}>
                    {idx + 1}
                  </div>
                  <div className="text-[11px] text-muted-foreground">{formatDuration(r.duration_seconds)}</div>
                </div>
              </button>
            ))}
            {!fastest.length ? <div className="text-xs text-muted-foreground">No graduates yet.</div> : null}
          </div>
        </div>

        {/* Largest buys */}
        <div className={panelClass}>
          <GlowingEffect blur={18} spread={36} glow={true} disabled={false} movementDuration={1.6} className="pointer-events-none" />
          <div className="flex items-center justify-between">
            <div className="text-sm font-semibold">Largest Buy</div>
            <div className="text-[11px] text-muted-foreground">Bonding</div>
          </div>

          <div className="mt-3 space-y-3">
            {largestBuys.slice(0, limit).map((r, idx) => (
              <button
                key={r.tx_hash + ":" + String(r.log_index)}
                type="button"
                onClick={() => navigate(`/token/${r.campaign_address}`)}
                className="w-full text-left flex items-start justify-between gap-3"
              >
                <div className="min-w-0 flex-1">
                  <TokenLine row={r} />
                  <div className="text-[11px] text-muted-foreground mt-1">
                    Buyer: {isAddress(r.buyer_address) ? shortAddr(r.buyer_address) : "-"}
                  </div>
                </div>
                <div className="text-right">
                  <div className="text-sm font-semibold" style={{ color: "#affe00" }}>
                    {idx + 1}
                  </div>
                  <div className="text-[11px] text-muted-foreground">{formatBnbFromRaw(r.bnb_amount_raw)} BNB</div>
                </div>
              </button>
            ))}
            {!largestBuys.length ? <div className="text-xs text-muted-foreground">No buys yet.</div> : null}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/home/LeagueOverlayCard.tsx">
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { useNavigate } from "react-router-dom";

type LeagueOverlayCardProps = {
  className?: string;
};

export function LeagueOverlayCard({ className }: LeagueOverlayCardProps) {
  const navigate = useNavigate();

  return (
    <div
      className={cn(
        "pointer-events-auto w-[260px] md:w-[300px] rounded-2xl overflow-hidden border border-border/50 bg-card/70 shadow-2xl",
        "backdrop-blur-md",
        className
      )}
    >
      <div className="relative">
        <img
          src="/assets/MemeBattleLeague.png"
          alt="Meme Battles League"
          className="w-full h-[160px] object-cover"
          draggable={false}
        />
        <div className="absolute inset-0 bg-gradient-to-t from-background/80 via-transparent to-transparent" />
      </div>

      <div className="p-4">
        <div className="space-y-1">
          <div className="text-sm font-semibold tracking-tight">Battle starts with a coin.</div>
          <div className="text-xs text-muted-foreground">Launch a campaign to enter leagues.</div>
        </div>

        <div className="mt-4 grid gap-2">
          <Button
            className="w-full bg-accent hover:bg-accent/90 text-accent-foreground font-retro"
            onClick={() => navigate("/create")}
          >
            Start a Battle
          </Button>
          <Button
            variant="outline"
            className="w-full font-retro"
            onClick={() => navigate("/battle-leagues")}
          >
            Go to Leagues
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/profile/EditProfileDialog.tsx">
import { useEffect, useMemo, useState } from "react";
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";

export type EditProfileValues = {
  username: string;
  bio: string;
};

type Props = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  initialUsername?: string | null;
  initialBio?: string | null;
  saving?: boolean;
  onSave: (values: EditProfileValues) => Promise<void> | void;
};

function normalizeUsername(raw: string): string {
  return raw.trim();
}

function validateUsername(username: string): string | null {
  // Optional: empty clears the username.
  if (!username) return null;
  if (username.length < 3) return "Username must be at least 3 characters.";
  if (username.length > 20) return "Username must be at most 20 characters.";
  if (!/^[a-zA-Z0-9_]+$/.test(username)) return "Only letters, numbers, and underscores are allowed.";
  return null;
}

export function EditProfileDialog({
  open,
  onOpenChange,
  initialUsername,
  initialBio,
  saving,
  onSave,
}: Props) {
  const [username, setUsername] = useState(initialUsername ?? "");
  const [bio, setBio] = useState(initialBio ?? "");
  const [touched, setTouched] = useState(false);

  useEffect(() => {
    if (!open) return;
    setUsername(initialUsername ?? "");
    setBio(initialBio ?? "");
    setTouched(false);
  }, [open, initialUsername, initialBio]);

  const usernameError = useMemo(() => {
    if (!touched) return null;
    return validateUsername(normalizeUsername(username));
  }, [username, touched]);

  const canSave = useMemo(() => {
    return !saving && !validateUsername(normalizeUsername(username));
  }, [saving, username]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle className="font-retro">Edit profile</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div className="space-y-2">
            <Label className="font-retro" htmlFor="username">
              Username (optional)
            </Label>
            <Input
              id="username"
              value={username}
              onChange={(e) => {
                setUsername(e.target.value);
                setTouched(true);
              }}
              placeholder="e.g. patrick_k"
              autoCapitalize="none"
              autoCorrect="off"
              spellCheck={false}
              className="font-retro"
              disabled={!!saving}
            />
            <div className="text-xs font-retro text-muted-foreground">
              Leave blank to remove. If set: 320 chars, letters/numbers/underscore.
            </div>
            {usernameError && <div className="text-xs font-retro text-destructive">{usernameError}</div>}
          </div>

          <div className="space-y-2">
            <Label className="font-retro" htmlFor="bio">
              Bio
            </Label>
            <Textarea
              id="bio"
              value={bio}
              onChange={(e) => setBio(e.target.value)}
              placeholder="Add a short bio"
              className="font-retro min-h-[96px]"
              maxLength={160}
              disabled={!!saving}
            />
            <div className="text-xs font-retro text-muted-foreground">{bio.length}/160</div>
          </div>
        </div>

        <DialogFooter className="gap-2 sm:gap-0">
          <Button
            type="button"
            variant="secondary"
            onClick={() => onOpenChange(false)}
            disabled={!!saving}
            className="font-retro"
          >
            Cancel
          </Button>
          <Button
            type="button"
            onClick={() => onSave({ username: normalizeUsername(username), bio: bio.trim() })}
            disabled={!canSave}
            className="font-retro"
          >
            {saving ? "Saving" : "Save"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="frontend/src/components/Sidebar.tsx">
/**
 * Sidebar Component
 * Responsive navigation sidebar that becomes a drawer on mobile/tablet
 */

import { X } from "lucide-react";
import AnimatedNav from "./ui/animated-nav";
import { SocialTooltip } from "./ui/social-media";
import { navItems, socialLinks } from "@/constants/navigation";

// Use public brand assets so we can swap without touching the build pipeline.
const brandMark = "/assets/ticker.png";

interface SidebarProps {
  mobileMenuOpen: boolean;
  setMobileMenuOpen: (open: boolean) => void;
}

export const Sidebar = ({ mobileMenuOpen, setMobileMenuOpen }: SidebarProps) => {
  return (
    <>
      {/* Mobile/Tablet Overlay */}
      {mobileMenuOpen && (
        <div 
          className="fixed inset-0 bg-black/50 backdrop-blur-sm z-40 lg:hidden"
          onClick={() => setMobileMenuOpen(false)}
        />
      )}

      {/* Sidebar - Desktop: Fixed, Mobile/Tablet: Drawer */}
      <aside className={`
        fixed top-4 bottom-4 w-64 bg-sidebar/95 backdrop-blur-md border border-sidebar-border/50 rounded-2xl flex flex-col shadow-2xl z-50 transition-transform duration-300 ease-in-out
        ${mobileMenuOpen ? 'left-4' : '-left-72'}
        lg:hidden
      `}>
        {/* Mobile Close Button */}
        <button
          onClick={() => setMobileMenuOpen(false)}
          className="absolute top-4 right-4 lg:hidden p-2 hover:bg-muted rounded-lg transition-colors"
          aria-label="Close menu"
        >
          <X className="h-5 w-5" />
        </button>

        <div className="p-6 pl-4 flex items-center gap-3">
          <a href="/" onClick={() => setMobileMenuOpen(false)} className="flex items-center gap-3">
            <img src={brandMark} alt="Meme Battles" className="h-10 w-10" draggable={false} />
            <span className="font-retro text-sm">MemeBattles</span>
          </a>
        </div>

        <nav className="flex-1 px-4 overflow-y-auto">
          <AnimatedNav options={navItems} />
        </nav>

        <div className="p-4 md:p-6 border-t border-sidebar-border/50 space-y-4">
          <SocialTooltip items={socialLinks} />
          <p className="text-xs text-muted-foreground mt-4 hidden md:block"> 2026 MemeBattles. All rights reserved.</p>
        </div>
      </aside>
    </>
  );
};
</file>

<file path="frontend/src/components/token/AthBar.tsx">
import { useEffect, useMemo, useRef, useState } from "react";

function parseCompactUsd(input?: string | null): number | null {
  if (!input) return null;
  const raw = String(input).trim();
  if (!raw || raw === "") return null;

  // Only parse the first token (prevents misreading trailing units like "BNB").
  const first = raw.split(/\s+/)[0] ?? "";
  if (!first) return null;

  // Accept forms like "$340.1K", "340.1K", "$1.2M", "$12,345", "12.3K", etc.
  const cleaned = first
    .replace(/[,\s]/g, "")
    .replace(/^[^\d\-\.]+/, ""); // strip leading currency symbols/letters

  const m = cleaned.match(/^(-?\d+(?:\.\d+)?)([KMBT])?$/i);
  if (!m) {
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }

  const n = Number(m[1]);
  if (!Number.isFinite(n)) return null;

  const suffix = (m[2] ?? "").toUpperCase();
  const mult =
    suffix === "K" ? 1e3 :
    suffix === "M" ? 1e6 :
    suffix === "B" ? 1e9 :
    suffix === "T" ? 1e12 :
    1;

  return n * mult;
}

function formatCompactUsd(n: number | null | undefined): string {
  if (n == null || !Number.isFinite(n)) return "";
  const abs = Math.abs(n);
  const sign = n < 0 ? "-" : "";

  const fmt = (v: number, suffix: string) => {
    const decimals = v >= 100 ? 0 : v >= 10 ? 1 : 2;
    return `${sign}$${v.toFixed(decimals)}${suffix}`;
  };

  if (abs >= 1e12) return fmt(abs / 1e12, "T");
  if (abs >= 1e9) return fmt(abs / 1e9, "B");
  if (abs >= 1e6) return fmt(abs / 1e6, "M");
  if (abs >= 1e3) return fmt(abs / 1e3, "K");

  // Small values: show more precision to avoid looking "wrong" on tiny MCAPs.
  const decimals = abs >= 1 ? 2 : abs >= 0.01 ? 4 : 6;
  return `${sign}$${abs.toFixed(decimals)}`;
}

type AthBarProps = {
  /** Current market cap label as shown in UI (e.g. "$340.1K"). */
  currentLabel?: string | null;
  /** Optional stable key used for localStorage persistence. */
  storageKey: string;
  /** Optional className wrapper. */
  className?: string;
  /** Optional fixed bar width in pixels (card-friendly). */
  barWidthPx?: number;
  /** Optional max-width for the bar (e.g. "100%"). */
  barMaxWidth?: string;
};

export function AthBar({ currentLabel, storageKey, className, barWidthPx, barMaxWidth }: AthBarProps) {
  const current = useMemo(() => parseCompactUsd(currentLabel), [currentLabel]);

  // Bump the storage format version to avoid showing stale ATH values from older (buggy) USD calculations.
  const storageKeyV2 = useMemo(() => `${storageKey}:v2`, [storageKey]);

  const [ath, setAth] = useState<number | null>(null);
  const [burst, setBurst] = useState(0);
  const prevAthRef = useRef<number | null>(null);

  // Load persisted ATH (per token) once.
  useEffect(() => {
    try {
      const raw = localStorage.getItem(storageKeyV2);
      const n = raw ? Number(raw) : NaN;
      const stored = Number.isFinite(n) ? n : null;
      setAth(stored);
      prevAthRef.current = stored;
    } catch {
      // ignore
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [storageKeyV2]);

  // Update ATH if we surpass it.
  useEffect(() => {
    if (current == null || !Number.isFinite(current)) return;

    setAth((prev) => {
      const p = prev ?? prevAthRef.current;
      if (p == null || current > p) {
        // Spark burst on new ATH.
        setBurst((b) => b + 1);

        try {
          localStorage.setItem(storageKeyV2, String(current));
        } catch {
          // ignore
        }
        prevAthRef.current = current;
        return current;
      }
      prevAthRef.current = p;
      return prev;
    });
  }, [current, storageKeyV2]);

  const ratio = useMemo(() => {
    if (current == null || ath == null || ath <= 0) return 0;
    return Math.max(0, Math.min(1, current / ath));
  }, [current, ath]);

  const pct = Math.round(ratio * 1000) / 10; // 1 decimal %

  const athLabel = useMemo(() => formatCompactUsd(ath), [ath]);

  // Position spark at end of fill (clamped so it doesn't overflow container)
  const sparkLeft = useMemo(() => {
    const p = Math.max(2, Math.min(98, ratio * 100));
    return `${p}%`;
  }, [ratio]);

  return (
    <div className={className}>
      <style>
        {`
          @keyframes athSparkUp {
            0%   { transform: translate(0, 0) scale(1); opacity: 0.95; }
            65%  { opacity: 0.95; }
            100% { transform: translate(var(--dx), var(--dy)) scale(0.6); opacity: 0; }
          }
          @keyframes athGlowPulse {
            0%, 100% { opacity: 0.65; }
            50% { opacity: 1; }
          }
        `}
      </style>

      <div className="flex items-center gap-2">
        <div
          className="relative h-[10px] rounded-full bg-muted/40 overflow-hidden border border-border/40"
          style={{
            width: `${barWidthPx ?? 240}px`,
            maxWidth: barMaxWidth ?? "55vw",
          }}
        >
          {/* Fill */}
          <div
            className="absolute inset-y-0 left-0 rounded-full"
            style={{
              width: `${Math.max(0, Math.min(100, ratio * 100))}%`,
              // MemeBattles look: yellow -> orange -> red, with subtle vertical "block" stripes.
              background:
                "linear-gradient(90deg, #ffe55c 0%, #ff9f1c 55%, #ff3b3b 100%)",
              transition: "width 350ms ease",
            }}
          />

          {/* Stripes overlay (visual only) */}
          <div
            className="absolute inset-y-0 left-0 rounded-full pointer-events-none"
            style={{
              width: `${Math.max(0, Math.min(100, ratio * 100))}%`,
              background:
                "repeating-linear-gradient(90deg, rgba(0,0,0,0.18) 0px, rgba(0,0,0,0.18) 6px, rgba(0,0,0,0) 6px, rgba(0,0,0,0) 12px)",
              mixBlendMode: "overlay",
              opacity: 0.55,
              transition: "width 350ms ease",
            }}
          />

          {/* Subtle moving highlight at the leading edge */}
          <div
            className="absolute top-0 bottom-0 w-10"
            style={{
              left: `calc(${Math.max(0, Math.min(100, ratio * 100))}% - 20px)`,
              background: "linear-gradient(90deg, transparent, rgba(255,255,255,0.18), transparent)",
              filter: "blur(0.2px)",
              animation: "athGlowPulse 1.4s ease-in-out infinite",
              pointerEvents: "none",
            }}
          />

          {/* Spark burst on new ATH */}
          {burst > 0 && (
            <div
              key={burst}
              className="absolute top-1/2"
              style={{
                left: sparkLeft,
                transform: "translate(-50%, -50%)",
                pointerEvents: "none",
              }}
            >
              {Array.from({ length: 10 }).map((_, i) => {
                // deterministic-ish randomness per burst+index
                const dx = (Math.sin((burst + 1) * (i + 3)) * 18).toFixed(1);
                const dy = (-8 - (Math.abs(Math.cos((burst + 2) * (i + 5))) * 18)).toFixed(1);
                const delay = (i * 10).toFixed(0);
                return (
                  <span
                    key={i}
                    className="absolute block h-[2px] w-[8px] rounded-full"
                    style={{
  background: "rgba(255, 229, 92, 0.95)",
  boxShadow: "0 0 10px rgba(255, 159, 28, 0.75)",
  transform: "translate(0,0)",
  opacity: 0.9,
  animation: `athSparkUp 520ms ease-out ${delay}ms forwards`,
  "--dx": `${dx}px`,
  "--dy": `${dy}px`,
} as any}
                  />
                );
              })}
            </div>
          )}
        </div>

        <div className="text-[11px] whitespace-nowrap">
          <span className="text-muted-foreground">ATH</span>{" "}
          <span className="font-semibold text-foreground">{athLabel}</span>
          {ath != null && current != null && Number.isFinite(current) && ath > 0 && (
            <span className="ml-1 text-[10px] text-muted-foreground/80">{pct}%</span>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/token/TokenCandlestickChart.tsx">
// src/components/token/TokenCandlestickChart.tsx
// TradingView-like candlestick chart using TradingView Lightweight Charts.

import { useEffect, useMemo, useRef, useState } from "react";
import {
  createChart,
  CrosshairMode,
  ColorType,
  CandlestickSeries,
  type IChartApi,
  type ISeriesApi,
  type UTCTimestamp,
  type CandlestickData,
  type Time,
} from "lightweight-charts";
import { useCurveTrades, type CurveTradePoint } from "@/hooks/useCurveTrades";
import { useDexPairTrades } from "@/hooks/useDexPairTrades";
import { useWallet } from "@/hooks/useWallet";

type ChartStage = "curve" | "dex";

type TimeframeKey =
  | "1s"
  | "5s"
  | "1m"
  | "5m"
  | "15m"
  | "1h"
  | "4h"
  | "1w"
  | "1M"
  | "1Y";

const TIMEFRAMES: Array<{ key: TimeframeKey; label: string; seconds: number }> = [
  { key: "1s", label: "1s", seconds: 1 },
  { key: "5s", label: "5s", seconds: 5 },
  { key: "1m", label: "1m", seconds: 60 },
  { key: "5m", label: "5m", seconds: 5 * 60 },
  { key: "15m", label: "15m", seconds: 15 * 60 },
  { key: "1h", label: "1h", seconds: 60 * 60 },
  { key: "4h", label: "4h", seconds: 4 * 60 * 60 },
  { key: "1w", label: "1W", seconds: 7 * 24 * 60 * 60 },
  // Phase 1: fixed-length approximation for month/year.
  { key: "1M", label: "1M", seconds: 30 * 24 * 60 * 60 },
  { key: "1Y", label: "1Y", seconds: 365 * 24 * 60 * 60 },
];

type PricePoint = { timestamp: number; price: number };

function buildCandles(points: PricePoint[], intervalSec: number): CandlestickData<Time>[] {
  if (!points.length || intervalSec <= 0) return [];
  const sorted = [...points]
    .filter((p) => Number.isFinite(p.price) && p.price > 0 && Number.isFinite(p.timestamp))
    .sort((a, b) => a.timestamp - b.timestamp);

  const out: CandlestickData<Time>[] = [];
  let curBucket = -1;
  let cur: CandlestickData<Time> | null = null;

  for (const p of sorted) {
    const bucket = Math.floor(p.timestamp / intervalSec) * intervalSec;
    if (bucket !== curBucket) {
      if (cur) out.push(cur);
      curBucket = bucket;
      const t = bucket as UTCTimestamp;
      cur = {
        time: t,
        open: p.price,
        high: p.price,
        low: p.price,
        close: p.price,
      };
      continue;
    }

    if (!cur) continue;
    cur.high = Math.max(cur.high, p.price);
    cur.low = Math.min(cur.low, p.price);
    cur.close = p.price;
  }

  if (cur) out.push(cur);
  return out;
}

function choosePrecision(samplePrices: number[]): { precision: number; minMove: number } {
  const p = samplePrices.filter((x) => Number.isFinite(x) && x > 0).slice(0, 200);
  if (!p.length) return { precision: 8, minMove: 0.00000001 };

  // Heuristic: choose enough decimals so that minMove is meaningful.
  const min = Math.min(...p);
  if (!Number.isFinite(min) || min <= 0) return { precision: 8, minMove: 0.00000001 };

  let precision = 8;
  if (min >= 1) precision = 4;
  else if (min >= 0.01) precision = 6;
  else if (min >= 0.0001) precision = 8;
  else precision = 10;

  precision = Math.max(2, Math.min(12, precision));
  const minMove = Number((10 ** -precision).toFixed(precision));
  return { precision, minMove };
}

export function TokenCandlestickChart(props: {
  stage: ChartStage;
  symbol?: string;
  campaignAddress?: string;
  tokenAddress?: string;
  dexPairAddress?: string;
  chainId?: number;
  curvePointsOverride?: CurveTradePoint[];
  className?: string;
}) {
  const { stage, symbol, campaignAddress, tokenAddress, dexPairAddress, chainId: chainIdProp, curvePointsOverride, className } = props;
  const wallet = useWallet();
  const chainId = chainIdProp ?? wallet.chainId ?? 97; // or 56 for BSC mainnet

  const [tf, setTf] = useState<TimeframeKey>("15m");
  const tfSeconds = useMemo(() => TIMEFRAMES.find((x) => x.key === tf)?.seconds ?? 900, [tf]);

  const containerRef = useRef<HTMLDivElement | null>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const seriesRef = useRef<ISeriesApi<"Candlestick"> | null>(null);

  // Data sources
  const curve = useCurveTrades(stage === "curve" ? campaignAddress : undefined, { enabled: stage === "curve" && !curvePointsOverride, chainId });
  const dex = useDexPairTrades({
    tokenAddress: stage === "dex" ? tokenAddress : undefined,
    pairAddress: stage === "dex" ? dexPairAddress : undefined,
    enabled: stage === "dex",
    chainId,
  });

  const points: PricePoint[] = useMemo(() => {
    if (stage === "dex") {
      return (dex.points ?? []).map((p) => ({ timestamp: p.timestamp, price: p.pricePerToken }));
    }

    return (curvePointsOverride ?? curve.points ?? []).map((p) => ({ timestamp: p.timestamp, price: p.pricePerToken }));
  }, [stage, symbol, curve.points, dex.points, curvePointsOverride]);

  const candles = useMemo(() => buildCandles(points, tfSeconds), [points, tfSeconds]);

  const loading = stage === "dex" ? dex.loading : curve.loading;
  const error = stage === "dex" ? dex.error : curve.error;

  // Create chart once
  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    // Ensure container is empty on recreate
    el.innerHTML = "";

		const chart = createChart(el, {
      autoSize: true,
      layout: {
				background: { type: ColorType.Solid, color: "transparent" },
        textColor: "rgba(255,255,255,0.75)",
      },
      grid: {
        vertLines: { visible: false },
        horzLines: { visible: false },
      },
      crosshair: { mode: CrosshairMode.Magnet },
      rightPriceScale: {
        visible: true,
        borderVisible: false,
        scaleMargins: { top: 0.12, bottom: 0.12 },
      },
      leftPriceScale: { visible: false },
      timeScale: {
        borderVisible: false,
        rightOffset: 5,
        timeVisible: true,
        secondsVisible: tf.endsWith("s"),
      },
      handleScroll: {
        mouseWheel: true,
        pressedMouseMove: true,
        horzTouchDrag: true,
        vertTouchDrag: true,
      },
      handleScale: {
        axisPressedMouseMove: true,
        mouseWheel: true,
        pinch: true,
      },
    });

		// Lightweight Charts v5 uses `addSeries(SeriesType, options)`
		const series = chart.addSeries(CandlestickSeries, {
			upColor: "#22c55e",
			downColor: "#ef4444",
			borderUpColor: "#22c55e",
			borderDownColor: "#ef4444",
			wickUpColor: "#22c55e",
			wickDownColor: "#ef4444",
			wickVisible: true,
			borderVisible: true,
		});

    chartRef.current = chart;
    seriesRef.current = series;

    const ro = new ResizeObserver(() => {
      chart.applyOptions({
        timeScale: {
          timeVisible: true,
          secondsVisible: tf.endsWith("s"),
        },
      });
    });
    ro.observe(el);

    return () => {
      ro.disconnect();
      chart.remove();
      chartRef.current = null;
      seriesRef.current = null;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tf]);

  // Push candles into the chart
  useEffect(() => {
    const chart = chartRef.current;
    const series = seriesRef.current;
    if (!chart || !series) return;

    const sample = candles.slice(-200).map((c) => c.close);
    const fmt = choosePrecision(sample);
    series.applyOptions({
      priceFormat: {
        type: "price",
        precision: fmt.precision,
        minMove: fmt.minMove,
      },
    });

    series.setData(candles);

    // Keep last candle in view by default
    if (candles.length > 0) {
      chart.timeScale().fitContent();
    }
  }, [candles]);

  return (
    <div className={"w-full h-full flex flex-col " + (className ?? "")}> 
      <div className="flex items-center justify-between gap-2 px-3 py-2 border-b border-border/40 bg-card/10">
        <div className="flex items-center gap-1.5 flex-wrap">
          {TIMEFRAMES.map((x) => (
            <button
              key={x.key}
              onClick={() => setTf(x.key)}
              className={
                "h-7 px-2 rounded-md text-[10px] font-mono border transition-colors " +
                (tf === x.key
                  ? "bg-accent/20 border-border/60 text-foreground"
                  : "bg-transparent border-border/30 text-muted-foreground hover:text-foreground hover:bg-muted/20")
              }
              type="button"
            >
              {x.label}
            </button>
          ))}
        </div>

        <div className="text-[10px] text-muted-foreground font-mono">
          {loading ? "Loading" : error ? "Chart error" : ""}
        </div>
      </div>

      <div className="flex-1 min-h-0 relative">
        {error ? (
          <div className="absolute inset-0 flex items-center justify-center text-xs text-muted-foreground p-4">
            {error}
          </div>
        ) : candles.length === 0 ? (
          <div className="absolute inset-0 flex items-center justify-center text-xs text-muted-foreground p-4">
            {stage === "dex" ? "No DEX price data yet." : "No bonding-curve trades yet."}
          </div>
        ) : null}

        <div ref={containerRef} className="w-full h-full" />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/token/TokenComments.tsx">
import { useCallback, useEffect, useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Textarea } from "@/components/ui/textarea";
import { useWallet } from "@/hooks/useWallet";
import { toast } from "sonner";

type TokenCommentsProps = {
  chainId: number;
  campaignAddress: string;
  tokenAddress?: string;
};

type CommentRow = {
  id: number;
  body: string;
  createdAt: string; // ISO
  authorAddress: string;
  parentId?: number | null;
  authorDisplayName?: string | null;
  authorAvatarUrl?: string | null;
};

const isAddress = (v?: string | null) => /^0x[a-fA-F0-9]{40}$/.test(String(v ?? ""));

const shorten = (addr: string) =>
  addr.length > 10 ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : addr;

const initials = (nameOrAddr: string) => {
  const s = (nameOrAddr ?? "").trim();
  if (!s) return "?";
  const parts = s.split(/\s+/).filter(Boolean);
  if (parts.length >= 2) return (parts[0][0] + parts[1][0]).toUpperCase();
  return s.slice(0, 2).toUpperCase();
};

const timeAgo = (iso: string) => {
  const t = new Date(iso).getTime();
  if (!Number.isFinite(t)) return "";
  const now = Date.now();
  const diff = Math.max(0, now - t);
  const s = Math.floor(diff / 1000);
  if (s < 60) return "now";
  const m = Math.floor(s / 60);
  if (m < 60) return `${m}m`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}h`;
  const d = Math.floor(h / 24);
  if (d < 7) return `${d}d`;
  const w = Math.floor(d / 7);
  return `${w}w`;
};

async function readJson(res: Response) {
  const text = await res.text();
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

async function getNonce(chainId: number, address: string): Promise<string> {
  const url = `/api/auth/nonce?chainId=${encodeURIComponent(String(chainId))}&address=${encodeURIComponent(address)}`;
  const res = await fetch(url, { method: "GET" });
  if (!res.ok) {
    const j = await readJson(res);
    throw new Error(j?.error || `Nonce request failed (${res.status})`);
  }
  const j = await res.json();
  if (!j?.nonce) throw new Error("Nonce missing");
  return String(j.nonce);
}

function buildCommentMessage(args: {
  chainId: number;
  address: string;
  campaignAddress: string;
  nonce: string;
  body: string;
}) {
  // Keep this stable; the server verifies the exact string.
  const bodyPreview = args.body.replace(/\s+/g, " ").trim().slice(0, 180);
  return [
    "MemeBattles Comment",
    `Action: COMMENT_CREATE`,
    `ChainId: ${args.chainId}`,
    `Address: ${args.address.toLowerCase()}`,
    `Campaign: ${args.campaignAddress.toLowerCase()}`,
    `Nonce: ${args.nonce}`,
    "",
    bodyPreview,
  ].join("\n");
}

export function TokenComments({ chainId, campaignAddress, tokenAddress }: TokenCommentsProps) {
  const wallet = useWallet();
  const [items, setItems] = useState<CommentRow[]>([]);
  const [loading, setLoading] = useState(false);
  const [posting, setPosting] = useState(false);
  const [body, setBody] = useState("");
  const [error, setError] = useState<string | null>(null);

  const normalizedCampaign = useMemo(() => (campaignAddress ?? "").toLowerCase(), [campaignAddress]);
  const normalizedToken = useMemo(() => {
    const t = (tokenAddress ?? "").toLowerCase();
    return isAddress(t) ? t : undefined;
  }, [tokenAddress]);

  const load = useCallback(async () => {
    if (!isAddress(normalizedCampaign)) return;
    try {
      setLoading(true);
      setError(null);
      const url = `/api/comments?chainId=${encodeURIComponent(String(chainId))}&campaignAddress=${encodeURIComponent(normalizedCampaign)}`;
      const res = await fetch(url);
      if (!res.ok) {
        const j = await readJson(res);
        throw new Error(j?.error || `Failed to load comments (${res.status})`);
      }
      const j = await res.json();
      const rows = Array.isArray(j?.items) ? (j.items as CommentRow[]) : [];
      setItems(rows);
    } catch (e: any) {
      setError(e?.message || "Failed to load comments");
    } finally {
      setLoading(false);
    }
  }, [chainId, normalizedCampaign]);

  useEffect(() => {
    void load();
  }, [load]);

  const canPost = useMemo(() => body.trim().length > 0 && body.trim().length <= 500, [body]);

  const handlePost = useCallback(async () => {
    try {
      if (!isAddress(normalizedCampaign)) return;
      if (!canPost) return;

      if (!wallet.account) {
        await wallet.connect();
      }
      if (!wallet.signer || !wallet.account) {
        toast("Connect your wallet to comment.");
        return;
      }

      const author = wallet.account.toLowerCase();
      const nonce = await getNonce(chainId, author);
      const msg = buildCommentMessage({
        chainId,
        address: author,
        campaignAddress: normalizedCampaign,
        nonce,
        body,
      });
      const signature = await wallet.signer.signMessage(msg);

      setPosting(true);

      const res = await fetch("/api/comments", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({
          chainId,
          campaignAddress: normalizedCampaign,
          tokenAddress: normalizedToken,
          address: author,
          body: body.trim(),
          nonce,
          signature,
        }),
      });

      if (!res.ok) {
        const j = await readJson(res);
        throw new Error(j?.error || `Failed to post comment (${res.status})`);
      }

      setBody("");
      await load();
      toast("Comment posted.");
    } catch (e: any) {
      toast(e?.message || "Failed to post comment");
    } finally {
      setPosting(false);
    }
  }, [body, canPost, chainId, load, normalizedCampaign, normalizedToken, wallet]);

  return (
    <div className="h-full w-full flex flex-col min-h-0 gap-3">
      <Card className="bg-card/20 border border-border/40 rounded-xl p-3">
        <div className="flex items-start gap-3">
          <Avatar className="h-9 w-9">
            <AvatarImage src={undefined} />
            <AvatarFallback className="text-xs">
              {wallet.account ? initials(wallet.account) : "?"}
            </AvatarFallback>
          </Avatar>

          <div className="flex-1">
            <Textarea
              value={body}
              onChange={(e) => setBody(e.target.value)}
              placeholder={wallet.account ? "Write a comment" : "Connect wallet to comment"}
              className="min-h-[15px] resize-none"
              maxLength={500}
              disabled={posting}
            />
            <div className="mt-2 flex items-center justify-between">
              <span className="text-[11px] text-muted-foreground">
                {body.trim().length}/500
              </span>
              <div className="flex items-center gap-2">
                {!wallet.account ? (
                  <Button
                    variant="secondary"
                    size="sm"
                    onClick={() => wallet.connect()}
                    disabled={posting}
                  >
                    Connect wallet
                  </Button>
                ) : null}
                <Button
                  size="sm"
                  onClick={handlePost}
                  disabled={posting || !wallet.account || !canPost}
                >
                  {posting ? "Posting" : "Post"}
                </Button>
              </div>
            </div>
            {error ? (
              <p className="mt-2 text-xs text-destructive">{error}</p>
            ) : null}
          </div>
        </div>
      </Card>

      <div className="flex-1 min-h-0 overflow-auto pr-1">
        {loading ? (
          <div className="py-6 text-center text-xs text-muted-foreground">Loading comments</div>
        ) : items.length === 0 ? (
          <div className="py-6 text-center text-xs text-muted-foreground">No comments yet.</div>
        ) : (
          <div className="flex flex-col gap-3">
            {items.map((c) => {
              const label = (c.authorDisplayName ?? "").trim();
              const display = label.length ? label : shorten(c.authorAddress);
              return (
                <div
                  key={c.id}
                  className="flex items-start gap-3 rounded-xl border border-border/40 bg-card/20 p-3"
                >
                  <Avatar className="h-9 w-9">
                    {c.authorAvatarUrl ? <AvatarImage src={c.authorAvatarUrl} /> : null}
                    <AvatarFallback className="text-xs">
                      {initials(label.length ? label : c.authorAddress)}
                    </AvatarFallback>
                  </Avatar>

                  <div className="min-w-0 flex-1">
                    <div className="flex items-center justify-between gap-2">
                      <div className="min-w-0">
                        <span className="text-xs font-semibold text-foreground truncate">
                          {display}
                        </span>
                        <span className="ml-2 text-[11px] text-muted-foreground">
                          {timeAgo(c.createdAt)}
                        </span>
                      </div>
                    </div>
                    <p className="mt-1 whitespace-pre-wrap break-words text-xs text-foreground/90">
                      {c.body}
                    </p>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/token/TradingViewChart.tsx">
import { useEffect, useMemo, useRef, useState } from "react";

import {
  CandlestickSeries,
  HistogramSeries,
  ColorType,
  createChart,
  type IChartApi,
  type ISeriesApi,
  type UTCTimestamp,
} from "lightweight-charts";

export type TvTrade = {
  /** Unix timestamp in seconds */
  timestamp: number;
  /** Price (e.g., BNB per token) */
  price: number;
  /** Volume (e.g., BNB amount) */
  volume: number;
  /** Optional: used to color volume bars */
  side?: "buy" | "sell";
};

type Candle = {
  time: UTCTimestamp; // unix seconds
  open: number;
  high: number;
  low: number;
  close: number;
};

type VolumeBar = {
  time: UTCTimestamp;
  value: number;
  color?: string;
};

function cssHsl(varName: string, fallback = "0 0% 100%") {
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName);
  const clean = (v || "").trim();
  return `hsl(${clean || fallback})`;
}


function inferPriceFormat(prices: number[]): { precision: number; minMove: number } {
  const vals = prices.filter((p) => Number.isFinite(p) && p > 0);
  if (!vals.length) return { precision: 6, minMove: 1e-6 };

  // Use a robust "typical" price (median) to pick decimals for the price scale.
  const sorted = [...vals].sort((a, b) => a - b);
  const mid = sorted[Math.floor(sorted.length / 2)];

  // If prices are very small (common for BNB-per-token), default 2 decimals
  // will render everything as 0.00. Increase precision accordingly.
  let precision: number;
  if (mid >= 100) precision = 2;
  else if (mid >= 1) precision = 4;
  else if (mid >= 0.01) precision = 6;
  else {
    const exp = Math.ceil(absLog10(mid));
    precision = Math.min(12, Math.max(6, exp + 2));
  }

  const minMove = Math.pow(10, -precision);
  return { precision, minMove };
}

function absLog10(x: number): number {
  if (x <= 0) return 0;
  return Math.abs(Math.log10(x));
}

function bucketSec(ts: number, intervalSec: number): UTCTimestamp {
  const t = Math.floor(ts);
  const b = Math.floor(t / intervalSec) * intervalSec;
  return b as UTCTimestamp;
}

function toCandlesAndVolume(trades: TvTrade[], intervalSec: number): { candles: Candle[]; volumes: VolumeBar[] } {
  if (!trades?.length) return { candles: [], volumes: [] };

  const sorted = [...trades]
    .filter((t) => Number.isFinite(t?.timestamp) && Number.isFinite(t?.price) && Number.isFinite(t?.volume))
    .sort((a, b) => a.timestamp - b.timestamp);

  const candleBuckets = new Map<number, Candle>();
  const volBuckets = new Map<number, VolumeBar>();

  // Theme-ish volume colors (fallbacks)
  const buyCol = cssHsl("--primary", "142 71% 45%");
  const sellCol = cssHsl("--destructive", "0 84% 60%");
  const neutral = cssHsl("--muted-foreground", "240 5% 64%");

  for (const tr of sorted) {
    const t = bucketSec(tr.timestamp, intervalSec);
    const key = Number(t);

    const c = candleBuckets.get(key);
    if (!c) {
      candleBuckets.set(key, {
        time: t,
        open: tr.price,
        high: tr.price,
        low: tr.price,
        close: tr.price,
      });
    } else {
      c.high = Math.max(c.high, tr.price);
      c.low = Math.min(c.low, tr.price);
      c.close = tr.price;
    }

    const v = volBuckets.get(key);
    const barColor = tr.side === "buy" ? buyCol : tr.side === "sell" ? sellCol : neutral;
    if (!v) {
      volBuckets.set(key, {
        time: t,
        value: tr.volume,
        color: barColor,
      });
    } else {
      v.value += tr.volume;
      // keep existing color
    }
  }

  return {
    candles: Array.from(candleBuckets.values()).sort((a, b) => a.time - b.time),
    volumes: Array.from(volBuckets.values()).sort((a, b) => a.time - b.time),
  };
}

function applyTradeToLastBars(
  trade: TvTrade,
  intervalSec: number,
  lastCandle: Candle | null,
  lastVol: VolumeBar | null,
  colors: { buy: string; sell: string; neutral: string }
): { candle: Candle; vol: VolumeBar } {
  const t = bucketSec(trade.timestamp, intervalSec);
  const isNewBucket = !lastCandle || lastCandle.time !== t;

  const candle: Candle = isNewBucket
    ? { time: t, open: trade.price, high: trade.price, low: trade.price, close: trade.price }
    : {
        ...lastCandle,
        high: Math.max(lastCandle.high, trade.price),
        low: Math.min(lastCandle.low, trade.price),
        close: trade.price,
      };

  const color = trade.side === "buy" ? colors.buy : trade.side === "sell" ? colors.sell : colors.neutral;
  const vol: VolumeBar = isNewBucket
    ? { time: t, value: trade.volume, color }
    : { ...lastVol!, time: t, value: (lastVol?.value ?? 0) + trade.volume, color: lastVol?.color ?? color };

  return { candle, vol };
}

export function TradingViewChart({
  trades,
  className,
  emptyLabel = "No data.",
  candleIntervalSec,
  autoScroll = true,
}: {
  trades: TvTrade[] | undefined;
  className?: string;
  emptyLabel?: string;
  /** Optional. Defaults to 60 seconds (1m). */
  candleIntervalSec?: number;
  /** Auto-scroll to the latest bar as new trades arrive. */
  autoScroll?: boolean;
}) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<ISeriesApi<any> | null>(null);
  const volumeSeriesRef = useRef<ISeriesApi<any> | null>(null);
  const lastCandleRef = useRef<Candle | null>(null);
  const lastVolRef = useRef<VolumeBar | null>(null);
  const prevLenRef = useRef<number>(0);

  const [ready, setReady] = useState(false);

  const interval = useMemo(() => Math.max(15, candleIntervalSec ?? 60), [candleIntervalSec]);

  const { candles, volumes } = useMemo(() => {
    return toCandlesAndVolume(trades ?? [], interval);
  }, [trades, interval]);

  const priceFormat = useMemo(() => {
    return inferPriceFormat((trades ?? []).map((t) => t.price));
  }, [trades]);

  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    // Theme colors from Tailwind CSS variables in your app
    const text = cssHsl("--foreground", "0 0% 98%");
    const bg = cssHsl("--background", "240 10% 3.9%");
    const grid = cssHsl("--border", "240 3.7% 15.9%");
    const accent = cssHsl("--primary", "142 71% 45%");
    const down = cssHsl("--destructive", "0 84% 60%");
    const muted = cssHsl("--muted-foreground", "240 5% 64%");

    const chart = createChart(el, {
      autoSize: true,
      layout: {
        background: { type: ColorType.Solid, color: "transparent" },
        textColor: text,
        fontFamily: "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
      },
      grid: {
        // Subtle grid lines (TV-ish); your theme border color is already low-contrast.
        vertLines: { color: grid },
        horzLines: { color: grid },
      },
      rightPriceScale: {
        visible: true,
        borderVisible: true,
        borderColor: grid,
        ticksVisible: true,
        entireTextOnly: true,
        scaleMargins: { top: 0.08, bottom: 0.28 }, // reserve bottom for volume
      },
      leftPriceScale: { visible: false },
      timeScale: {
        borderVisible: true,
        borderColor: grid,
        timeVisible: true,
        secondsVisible: false,
        barSpacing: 8,
        rightOffset: 4,
      },
      crosshair: {
        vertLine: { color: grid, labelBackgroundColor: bg },
        horzLine: { color: grid, labelBackgroundColor: bg },
      },
      handleScale: { axisPressedMouseMove: false },
      handleScroll: { pressedMouseMove: true, mouseWheel: true, horzTouchDrag: true, vertTouchDrag: false },
    });

    const candleSeries = chart.addSeries(CandlestickSeries, {
      upColor: accent,
      downColor: down,
      borderUpColor: accent,
      borderDownColor: down,
      wickUpColor: accent,
      wickDownColor: down,
      wickVisible: true,
      borderVisible: true,
      priceFormat: { type: "price", precision: 8, minMove: 1e-8 },
      priceLineVisible: true,
      lastValueVisible: true,
    });

    // Volume (histogram) in the bottom area
const volumeSeries = chart.addSeries(HistogramSeries, {
  priceScaleId: "volume", // dedicated scale for volume
  priceFormat: { type: "volume" },
  lastValueVisible: false,
});
// Configure that volume price scale to occupy the bottom portion
chart.priceScale("volume").applyOptions({
  scaleMargins: { top: 0.78, bottom: 0.0 },
  visible: false,        // hide the scale (we only want bars)
  borderVisible: false,
});


    // Give a muted baseline color; per-bar color is provided in data.
    volumeSeries.applyOptions({
      color: muted,
    });

    chartRef.current = chart;
    candleSeriesRef.current = candleSeries;
    volumeSeriesRef.current = volumeSeries;
    setReady(true);

    const ro = new ResizeObserver(() => {
      // Keep it tight within your container. Fit once on resize.
      chart.timeScale().fitContent();
    });
    ro.observe(el);

    return () => {
      ro.disconnect();
      chart.remove();
      chartRef.current = null;
      candleSeriesRef.current = null;
      volumeSeriesRef.current = null;
      lastCandleRef.current = null;
      lastVolRef.current = null;
      prevLenRef.current = 0;
      setReady(false);
    };
  }, []);

  // Initial setData (and rebuild when interval changes)
  useEffect(() => {
    if (!ready) return;
    const candleSeries = candleSeriesRef.current;
    const volumeSeries = volumeSeriesRef.current;
    const chart = chartRef.current;
    if (!candleSeries || !volumeSeries || !chart) return;

    candleSeries.setData(candles as any);
    volumeSeries.setData(volumes as any);

    lastCandleRef.current = candles.length ? candles[candles.length - 1] : null;
    lastVolRef.current = volumes.length ? volumes[volumes.length - 1] : null;
    prevLenRef.current = (trades ?? []).length;

    chart.timeScale().fitContent();
  }, [ready, candles, volumes, interval]);

  // Keep the price scale readable for very small prices.
  useEffect(() => {
    if (!ready) return;
    const candleSeries = candleSeriesRef.current;
    if (!candleSeries) return;
    candleSeries.applyOptions({
      priceFormat: {
        type: "price",
        precision: priceFormat.precision,
        minMove: priceFormat.minMove,
      },
    });
  }, [ready, priceFormat]);

  // Realtime updates: if trades array grows, only update the new portion.
  useEffect(() => {
    if (!ready) return;
    const t = trades ?? [];
    const candleSeries = candleSeriesRef.current;
    const volumeSeries = volumeSeriesRef.current;
    const chart = chartRef.current;
    if (!candleSeries || !volumeSeries || !chart) return;

    const prevLen = prevLenRef.current;
    if (t.length <= prevLen) {
      prevLenRef.current = t.length;
      return;
    }

    // If we have no baseline yet, just let the setData effect handle it.
    if (!lastCandleRef.current || !lastVolRef.current) {
      prevLenRef.current = t.length;
      return;
    }

    const buyCol = cssHsl("--primary", "142 71% 45%");
    const sellCol = cssHsl("--destructive", "0 84% 60%");
    const neutral = cssHsl("--muted-foreground", "240 5% 64%");

    const newTrades = t.slice(prevLen);
    for (const tr of newTrades) {
      if (!Number.isFinite(tr.timestamp) || !Number.isFinite(tr.price) || !Number.isFinite(tr.volume)) continue;
      const { candle, vol } = applyTradeToLastBars(tr, interval, lastCandleRef.current, lastVolRef.current, {
        buy: buyCol,
        sell: sellCol,
        neutral,
      });

      candleSeries.update(candle as any);
      volumeSeries.update(vol as any);
      lastCandleRef.current = candle;
      lastVolRef.current = vol;
    }

    prevLenRef.current = t.length;

    if (autoScroll) {
      chart.timeScale().scrollToRealTime();
    }
  }, [ready, trades, interval, autoScroll]);

  const isEmpty = candles.length < 2;

  return (
    <div className={`relative h-full w-full ${className ?? ""}`.trim()}>
      <div ref={containerRef} className="absolute inset-0" />

      {isEmpty && (
        <div className="absolute inset-0 flex items-center justify-center">
          <div className="text-xs text-muted-foreground">{emptyLabel}</div>
        </div>
      )}

      {/* Lightweight Charts attribution (required by its license). */}
      <a
        href="https://www.tradingview.com"
        target="_blank"
        rel="noreferrer"
        className="absolute bottom-2 right-3 text-[10px] text-muted-foreground/80 hover:text-muted-foreground"
      >
        Charts by TradingView
      </a>
    </div>
  );
}
</file>

<file path="frontend/src/components/TrendingSection.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { GlowingEffect } from "@/components/ui/glowing-effect";
import { useEffect, useMemo, useState } from "react";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignSummary } from "@/lib/launchpadClient";

type TrendingItem = {
  rank: number;
  name: string;
  value: string;
  change: string;
};

// Best-effort parsing of formatted strings like:
//  - "12.34 BNB"
//  - "$67.31k"
//  - "$4.08m"
const parseFormattedNumber = (s: string): number => {
  if (!s) return 0;
  const str = String(s).trim().toLowerCase();

  // BNB: "12.34 bnb"
  if (str.includes("bnb")) {
    const n = Number(str.replace(/[^0-9.\-]/g, ""));
    return Number.isFinite(n) ? n : 0;
  }

  // USD-like compact formats (k/m)
  const match = str.match(/([-0-9.]+)\s*([kmb])?/);
  if (!match) return 0;
  const base = Number(match[1]);
  if (!Number.isFinite(base)) return 0;

  const suffix = match[2];
  const mult = suffix === "b" ? 1e9 : suffix === "m" ? 1e6 : suffix === "k" ? 1e3 : 1;
  return base * mult;
};

export const TrendingSection = () => {
  const { fetchCampaigns, fetchCampaignSummary } = useLaunchpad();
  const [items, setItems] = useState<TrendingItem[]>([]);

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        const campaigns = (await fetchCampaigns()) ?? [];
        const results = await Promise.allSettled(
          campaigns.map((c) => fetchCampaignSummary(c))
        );

        if (cancelled) return;

        const summaries: CampaignSummary[] = results
          .filter((r): r is PromiseFulfilledResult<CampaignSummary> => r.status === "fulfilled")
          .map((r) => r.value);

        // Simple, deterministic heuristic: top 3 by volume
        const sorted = [...summaries].sort((a, b) => {
          const av = parseFormattedNumber(a.stats.volume);
          const bv = parseFormattedNumber(b.stats.volume);
          return bv - av;
        });

        const top = sorted.slice(0, 3).map((s, idx) => {
          return {
            rank: idx + 1,
            name: s.campaign.symbol,
            value: `Vol ${s.stats.volume}`,
            change: `MC ${s.stats.marketCap}`,
          };
        });

        setItems(top);
      } catch (e) {
        console.error("[TrendingSection] Failed to load trending campaigns", e);
        if (!cancelled) setItems([]);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [fetchCampaigns, fetchCampaignSummary]);

  const display = useMemo(() => items, [items]);

  return (
    <div className="mb-12">
      <h2 className="text-2xl font-retro text-accent mb-6" style={{ textShadow: '0 0 10px hsl(var(--glow-accent))' }}>
        Trending Now
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {display.map((token) => (
          <div key={token.rank} className="relative h-full rounded-[1.25rem] border-[0.75px] border-border p-2">
            <GlowingEffect
              spread={40}
              glow={true}
              disabled={false}
              proximity={64}
              inactiveZone={0.01}
              borderWidth={3}
            />
            <Card className="relative bg-card/50 backdrop-blur-sm border-accent/30">
              <CardContent className="p-6">
                <div className="flex items-start justify-between mb-4">
                  <span className="text-3xl font-retro text-accent/50">#{token.rank}</span>
                  <span className="text-xs font-retro text-accent">{token.change}</span>
                </div>
                <h3 className="text-lg font-retro text-accent mb-2" style={{ textShadow: '0 0 5px hsl(var(--glow-accent))' }}>
                  {token.name}
                </h3>
                <p className="text-2xl font-retro text-foreground">{token.value}</p>
              </CardContent>
            </Card>
          </div>
        ))}
      </div>
    </div>
  );
};
</file>

<file path="frontend/src/components/ui/accordion.tsx">
import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item ref={ref} className={cn("border-b", className)} {...props} />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
</file>

<file path="frontend/src/components/ui/alert-dialog.tsx">
import * as React from "react";
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold", className)} {...props} />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
AlertDialogDescription.displayName = AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action ref={ref} className={cn(buttonVariants(), className)} {...props} />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(buttonVariants({ variant: "outline" }), "mt-2 sm:mt-0", className)}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};
</file>

<file path="frontend/src/components/ui/alert.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive: "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div ref={ref} role="alert" className={cn(alertVariants({ variant }), className)} {...props} />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h5 ref={ref} className={cn("mb-1 font-medium leading-none tracking-tight", className)} {...props} />
  ),
);
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("text-sm [&_p]:leading-relaxed", className)} {...props} />
  ),
);
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="frontend/src/components/ui/animated-nav.tsx">
"use client"

import { useNavigate, useLocation } from "react-router-dom"
import { LucideIcon } from "lucide-react"

interface NavOption {
  icon: LucideIcon | string
  label: string
  path: string
}

interface AnimatedNavProps {
  options: NavOption[]
}

export default function AnimatedNav({ options }: AnimatedNavProps) {
  const navigate = useNavigate()
  const location = useLocation()
  const selectedValue = location.pathname

  const handleChange = (path: string) => {
    navigate(path)
  }

  const getGliderTransform = () => {
    const index = options.findIndex((option) => option.path === selectedValue)
    return `translateY(${index * 100}%)`
  }

  const getGliderHeightClass = () => {
    // Calculate the height class based on number of options (h-1/3, h-1/4, h-1/5)
    return `h-1/${options.length}`
  }

  const isPageInMenu = options.some((option) => option.path === selectedValue)

  return (
    <div className="relative flex flex-col pl-3 w-full">
      {options.map((option) => (
        <div key={option.path} className="relative z-20 py-1 [-webkit-tap-highlight-color:transparent]">
          <input
            id={`nav-${option.path}`}
            name="navigation"
            type="radio"
            value={option.path}
            checked={selectedValue === option.path}
            onChange={(e) => handleChange(e.target.value)}
            className="absolute w-full h-full m-0 opacity-0 cursor-pointer z-30 appearance-none focus:outline-none focus:ring-0 focus-visible:outline-none ring-0 active:outline-none [-webkit-tap-highlight-color:transparent] accent-[hsl(var(--accent))]"
          />
          <label
            htmlFor={`nav-${option.path}`}
            className={`cursor-pointer flex items-center gap-3 text-base py-3 px-4 block transition-all duration-300 ease-in-out outline-none focus:outline-none focus-visible:outline-none [-webkit-tap-highlight-color:transparent] ${
              selectedValue === option.path
                ? "text-accent font-medium"
                : "text-sidebar-foreground hover:text-accent"
            }`}
          >
            {typeof option.icon === 'string' ? (
              <img 
                src={option.icon} 
                alt={option.label} 
                className={`w-5 h-5 transition-all duration-300 ${
                  selectedValue === option.path
                    ? "[filter:brightness(0)_saturate(100%)_invert(88%)_sepia(89%)_saturate(2686%)_hue-rotate(16deg)_brightness(104%)_contrast(104%)]"
                    : "opacity-70"
                }`}
              />
            ) : (
              <option.icon className="w-5 h-5" />
            )}
            <span>{option.label}</span>
          </label>
        </div>
      ))}

      <div className="absolute left-0 top-0 bottom-0 w-px bg-gradient-to-b from-transparent via-border to-transparent pointer-events-none">
        <div
          className={`relative w-full bg-gradient-to-b from-transparent via-accent to-transparent transition-all duration-[650ms] ease-[cubic-bezier(0.68,-0.55,0.265,1.55)] ${
            isPageInMenu ? 'opacity-100' : 'opacity-0'
          }`}
          style={{ 
            height: `${100 / options.length}%`,
            transform: getGliderTransform()
          }}
        />
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };
</file>

<file path="frontend/src/components/ui/avatar.tsx">
import * as React from "react";
import * as AvatarPrimitive from "@radix-ui/react-avatar";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image ref={ref} className={cn("aspect-square h-full w-full", className)} {...props} />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn("flex h-full w-full items-center justify-center rounded-full bg-muted", className)}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="frontend/src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />;
}

export { Badge, badgeVariants };
</file>

<file path="frontend/src/components/ui/border-beam.tsx">
"use client"

import React, { CSSProperties, useEffect, useRef } from "react"
import { motion } from "motion/react"

import { cn } from "@/lib/utils"

interface BorderBeamProps {
  lightWidth?: number
  duration?: number
  lightColor?: string
  borderWidth?: number
  className?: string
  [key: string]: unknown
}

export function BorderBeam({
  lightWidth = 200,
  duration = 10,
  lightColor = "#FAFAFA",
  borderWidth = 1,
  className,
  ...props
}: BorderBeamProps) {
  const pathRef = useRef<HTMLDivElement>(null)

  const updatePath = () => {
    if (pathRef.current) {
      const div = pathRef.current
      div.style.setProperty(
        "--path",
        `path("M 0 0 H ${div.offsetWidth} V ${div.offsetHeight} H 0 V 0")`
      )
    }
  }

  useEffect(() => {
    updatePath()
    window.addEventListener("resize", updatePath)

    return () => {
      window.removeEventListener("resize", updatePath)
    }
  }, [])

  return (
    <div
      style={
        {
          "--duration": duration,
          "--border-width": `${borderWidth}px`,
        } as CSSProperties
      }
      ref={pathRef}
      className={cn(
        `absolute z-0 h-full w-full rounded-[inherit]`,
        `after:absolute after:inset-[var(--border-width)] after:rounded-[inherit] after:content-['']`,
        "border-[length:var(--border-width)] ![mask-clip:padding-box,border-box]",
        "![mask-composite:intersect] [mask:linear-gradient(transparent,transparent),linear-gradient(red,red)]",
        `before:absolute before:inset-0 before:z-[-1] before:rounded-[inherit] before:border-[length:var(--border-width)] before:border-black/10 dark:before:border-white/10`,
        className
      )}
      {...props}
    >
      <motion.div
        className="absolute inset-0 aspect-square bg-[radial-gradient(ellipse_at_center,var(--light-color),transparent,transparent)]"
        style={
          {
            "--light-color": lightColor,
            "--light-width": `${lightWidth}px`,
            width: "var(--light-width)",
            offsetPath: "var(--path)",
          } as CSSProperties
        }
        animate={{
          offsetDistance: ["0%", "100%"],
        }}
        transition={{
          duration: duration,
          repeat: Infinity,
          ease: "linear",
        }}
      />
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/breadcrumb.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<HTMLOListElement, React.ComponentPropsWithoutRef<"ol">>(
  ({ className, ...props }, ref) => (
    <ol
      ref={ref}
      className={cn(
        "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
        className,
      )}
      {...props}
    />
  ),
);
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<HTMLLIElement, React.ComponentPropsWithoutRef<"li">>(
  ({ className, ...props }, ref) => (
    <li ref={ref} className={cn("inline-flex items-center gap-1.5", className)} {...props} />
  ),
);
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return <Comp ref={ref} className={cn("transition-colors hover:text-foreground", className)} {...props} />;
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<HTMLSpanElement, React.ComponentPropsWithoutRef<"span">>(
  ({ className, ...props }, ref) => (
    <span
      ref={ref}
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("font-normal text-foreground", className)}
      {...props}
    />
  ),
);
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({ children, className, ...props }: React.ComponentProps<"li">) => (
  <li role="presentation" aria-hidden="true" className={cn("[&>svg]:size-3.5", className)} {...props}>
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};
</file>

<file path="frontend/src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />;
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="frontend/src/components/ui/calendar.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { DayPicker } from "react-day-picker";

import { cn } from "@/lib/utils";
import { buttonVariants } from "@/components/ui/button";

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({ className, classNames, showOutsideDays = true, ...props }: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100",
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell: "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(buttonVariants({ variant: "ghost" }), "h-9 w-9 p-0 font-normal aria-selected:opacity-100"),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle: "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ..._props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ..._props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = "Calendar";

export { Calendar };
</file>

<file path="frontend/src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)} {...props} />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  ),
);
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
  ),
);
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  ),
);
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />,
);
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  ),
);
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
</file>

<file path="frontend/src/components/ui/carousel.tsx">
import * as React from "react";
import useEmblaCarousel, { type UseEmblaCarouselType } from "embla-carousel-react";
import { ArrowLeft, ArrowRight } from "lucide-react";

import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement> & CarouselProps>(
  ({ orientation = "horizontal", opts, setApi, plugins, className, children, ...props }, ref) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation: orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { carouselRef, orientation } = useCarousel();

    return (
      <div ref={carouselRef} className="overflow-hidden">
        <div
          ref={ref}
          className={cn("flex", orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col", className)}
          {...props}
        />
      </div>
    );
  },
);
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const { orientation } = useCarousel();

    return (
      <div
        ref={ref}
        role="group"
        aria-roledescription="slide"
        className={cn("min-w-0 shrink-0 grow-0 basis-full", orientation === "horizontal" ? "pl-4" : "pt-4", className)}
        {...props}
      />
    );
  },
);
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollPrev, canScrollPrev } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-left-12 top-1/2 -translate-y-1/2"
            : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollPrev}
        onClick={scrollPrev}
        {...props}
      >
        <ArrowLeft className="h-4 w-4" />
        <span className="sr-only">Previous slide</span>
      </Button>
    );
  },
);
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<HTMLButtonElement, React.ComponentProps<typeof Button>>(
  ({ className, variant = "outline", size = "icon", ...props }, ref) => {
    const { orientation, scrollNext, canScrollNext } = useCarousel();

    return (
      <Button
        ref={ref}
        variant={variant}
        size={size}
        className={cn(
          "absolute h-8 w-8 rounded-full",
          orientation === "horizontal"
            ? "-right-12 top-1/2 -translate-y-1/2"
            : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
          className,
        )}
        disabled={!canScrollNext}
        onClick={scrollNext}
        {...props}
      >
        <ArrowRight className="h-4 w-4" />
        <span className="sr-only">Next slide</span>
      </Button>
    );
  },
);
CarouselNext.displayName = "CarouselNext";

export { type CarouselApi, Carousel, CarouselContent, CarouselItem, CarouselPrevious, CarouselNext };
</file>

<file path="frontend/src/components/ui/chart.tsx">
import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "@/lib/utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & ({ color?: string; theme?: never } | { color?: never; theme: Record<keyof typeof THEMES, string> });
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig;
    children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>["children"];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>{children}</RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = "Chart";

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(([_, config]) => config.theme || config.color);

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color = itemConfig.theme?.[theme as keyof typeof itemConfig.theme] || itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: "line" | "dot" | "dashed";
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref,
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return <div className={cn("font-medium", labelClassName)}>{labelFormatter(value, payload)}</div>;
      }

      if (!value) {
        return null;
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>;
    }, [label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== "dot";

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className,
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center",
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          })}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center",
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">{itemConfig?.label || item.name}</span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);
ChartTooltipContent.displayName = "ChartTooltip";

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
  const { config } = useChart();

  if (!payload?.length) {
    return null;
  }

  return (
    <div
      ref={ref}
      className={cn("flex items-center justify-center gap-4", verticalAlign === "top" ? "pb-3" : "pt-3", className)}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);

        return (
          <div
            key={item.value}
            className={cn("flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground")}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
});
ChartLegendContent.displayName = "ChartLegend";

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload && typeof payload.payload === "object" && payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (key in payload && typeof payload[key as keyof typeof payload] === "string") {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[key as keyof typeof payloadPayload] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config];
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle };
</file>

<file path="frontend/src/components/ui/checkbox.tsx">
import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="frontend/src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };
</file>

<file path="frontend/src/components/ui/command.tsx">
import * as React from "react";
import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";

import { cn } from "@/lib/utils";
import { Dialog, DialogContent } from "@/components/ui/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />);

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator ref={ref} className={cn("-mx-1 h-px bg-border", className)} {...props} />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};
</file>

<file path="frontend/src/components/ui/context-menu.tsx">
import * as React from "react";
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold text-foreground", inset && "pl-8", className)}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-border", className)} {...props} />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};
</file>

<file path="frontend/src/components/ui/dialog.tsx">
import * as React from "react";
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-accent data-[state=open]:text-muted-foreground hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="frontend/src/components/ui/drawer.tsx">
import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({ shouldScaleBackground = true, ...props }: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root shouldScaleBackground={shouldScaleBackground} {...props} />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay ref={ref} className={cn("fixed inset-0 z-50 bg-black/80", className)} {...props} />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)} {...props} />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("mt-auto flex flex-col gap-2 p-4", className)} {...props} />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};
</file>

<file path="frontend/src/components/ui/dropdown-menu.tsx">
import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent focus:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest opacity-60", className)} {...props} />;
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="frontend/src/components/ui/effects/letter-glitch.tsx">
/**
 * Letter Glitch Effect Component
 * Creates a canvas-based text glitch effect with animated characters and colors
 */

import React, { useEffect, useRef } from "react";

interface LetterGlitchProps {
  text?: string;
  glitchColors?: string[];
  glitchSpeed?: number;
  fontSize?: number;
  fontFamily?: string;
  className?: string;
}

const LetterGlitch: React.FC<LetterGlitchProps> = ({
  text = "PROCESSING",
  glitchColors = ["#a3e635", "#bef264", "#84cc16"],
  glitchSpeed = 50,
  fontSize = 48,
  fontFamily = "monospace",
  className = "",
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameRef = useRef<number>();

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // Set canvas dimensions
    ctx.font = `${fontSize}px ${fontFamily}`;
    const textWidth = ctx.measureText(text).width;
    canvas.width = textWidth + 40;
    canvas.height = fontSize * 1.5;

    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
    let frameCount = 0;

    const draw = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = `${fontSize}px ${fontFamily}`;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const x = 20 + i * (textWidth / text.length);
        const y = canvas.height / 2 + fontSize / 3;

        // Randomize glitch effect
        if (Math.random() < 0.1 && frameCount % glitchSpeed === 0) {
          const glitchChar = chars[Math.floor(Math.random() * chars.length)];
          const color = glitchColors[Math.floor(Math.random() * glitchColors.length)];
          ctx.fillStyle = color;
          ctx.fillText(glitchChar, x + Math.random() * 4 - 2, y + Math.random() * 4 - 2);
        } else {
          ctx.fillStyle = "#ffffff";
          ctx.fillText(char, x, y);
        }
      }

      frameCount++;
      animationFrameRef.current = requestAnimationFrame(draw);
    };

    draw();

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [text, glitchColors, glitchSpeed, fontSize, fontFamily]);

  return <canvas ref={canvasRef} className={className} />;
};

export default LetterGlitch;
</file>

<file path="frontend/src/components/ui/form.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import { Controller, ControllerProps, FieldPath, FieldValues, FormProvider, useFormContext } from "react-hook-form";

import { cn } from "@/lib/utils";
import { Label } from "@/components/ui/label";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>({} as FormItemContextValue);

const FormItem = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => {
    const id = React.useId();

    return (
      <FormItemContext.Provider value={{ id }}>
        <div ref={ref} className={cn("space-y-2", className)} {...props} />
      </FormItemContext.Provider>
    );
  },
);
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return <Label ref={ref} className={cn(error && "text-destructive", className)} htmlFor={formItemId} {...props} />;
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<React.ElementRef<typeof Slot>, React.ComponentPropsWithoutRef<typeof Slot>>(
  ({ ...props }, ref) => {
    const { error, formItemId, formDescriptionId, formMessageId } = useFormField();

    return (
      <Slot
        ref={ref}
        id={formItemId}
        aria-describedby={!error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`}
        aria-invalid={!!error}
        {...props}
      />
    );
  },
);
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => {
    const { formDescriptionId } = useFormField();

    return <p ref={ref} id={formDescriptionId} className={cn("text-sm text-muted-foreground", className)} {...props} />;
  },
);
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, children, ...props }, ref) => {
    const { error, formMessageId } = useFormField();
    const body = error ? String(error?.message) : children;

    if (!body) {
      return null;
    }

    return (
      <p ref={ref} id={formMessageId} className={cn("text-sm font-medium text-destructive", className)} {...props}>
        {body}
      </p>
    );
  },
);
FormMessage.displayName = "FormMessage";

export { useFormField, Form, FormItem, FormLabel, FormControl, FormDescription, FormMessage, FormField };
</file>

<file path="frontend/src/components/ui/glass-button.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

function cn(...inputs: (string | undefined | null | false)[]): string {
  return inputs.filter(Boolean).join(" ");
}

const glassButtonVariants = cva(
  "relative isolate all-unset cursor-pointer rounded-full transition-all",
  {
    variants: {
      size: {
        default: "text-base font-medium",
        sm: "text-sm font-medium",
        lg: "text-lg font-medium",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      size: "default",
    },
  }
);

const glassButtonTextVariants = cva(
  "glass-button-text relative block select-none tracking-tighter",
  {
    variants: {
      size: {
        default: "px-6 py-3.5",
        sm: "px-4 py-2",
        lg: "px-8 py-4",
        icon: "flex h-10 w-10 items-center justify-center",
      },
    },
    defaultVariants: {
      size: "default",
    },
  }
);

export interface GlassButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof glassButtonVariants> {
  contentClassName?: string;
}

const GlassButton = React.forwardRef<HTMLButtonElement, GlassButtonProps>(
  ({ className, children, size, contentClassName, ...props }, ref) => {
    return (
      <div
        className={cn(
          "glass-button-wrap cursor-pointer rounded-full",
          className
        )}
      >
        <button
          className={cn("glass-button", glassButtonVariants({ size }))}
          ref={ref}
          {...props}
        >
          <span
            className={cn(
              glassButtonTextVariants({ size }),
              contentClassName
            )}
          >
            {children}
          </span>
        </button>
        <div className="glass-button-shadow rounded-full"></div>
      </div>
    );
  }
);
GlassButton.displayName = "GlassButton";

export { GlassButton, glassButtonVariants };
</file>

<file path="frontend/src/components/ui/glowing-button.tsx">
import { cn } from "@/lib/utils";
 
function hexToRgba(hex: string, alpha: number = 1): string {
  let hexValue = hex.replace("#", "");
 
  if (hexValue.length === 3) {
    hexValue = hexValue
      .split("")
      .map((char) => char + char)
      .join("");
  }
 
  const r = parseInt(hexValue.substring(0, 2), 16);
  const g = parseInt(hexValue.substring(2, 4), 16);
  const b = parseInt(hexValue.substring(4, 6), 16);
 
  if (isNaN(r) || isNaN(g) || isNaN(b)) {
    console.error("Invalid hex color:", hex);
    return "rgba(0, 0, 0, 1)";
  }
 
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
 
export function GlowingButton({
  children,
  className,
  glowColor = "#a3e635",
  onClick,
}: {
  children: React.ReactNode;
  className?: string;
  glowColor?: string;
  onClick?: () => void;
}) {
  const glowColorRgba = hexToRgba(glowColor);
  const glowColorVia = hexToRgba(glowColor, 0.075);
  const glowColorTo = hexToRgba(glowColor, 0.2);
 
  return (
    <button
      onClick={onClick}
      style={
        {
          "--glow-color": glowColorRgba,
          "--glow-color-via": glowColorVia,
          "--glow-color-to": glowColorTo,
        } as React.CSSProperties
      }
      className={cn(
        "w-min h-10 !px-5 text-sm rounded-md border flex items-center justify-center relative transition-colors overflow-hidden bg-gradient-to-t border-r-0 duration-200 whitespace-nowrap",
        "from-background to-muted text-foreground hover:text-muted-foreground border-border",
        "after:inset-0 after:absolute after:rounded-[inherit] after:bg-gradient-to-r after:from-transparent after:from-40% after:via-[var(--glow-color-via)] after:to-[var(--glow-color-to)] after:via-70% after:shadow-[hsl(var(--foreground)/0.15)_0px_1px_0px_inset] z-20",
        "before:absolute before:w-[5px] hover:before:translate-x-full before:transition-all before:duration-200 before:h-[60%] before:bg-[var(--glow-color)] before:right-0 before:rounded-l before:shadow-[-2px_0_10px_var(--glow-color)] z-10",
        className
      )}
    >
      {children}
    </button>
  );
}
</file>

<file path="frontend/src/components/ui/glowing-effect.tsx">
"use client";

import { memo, useCallback, useEffect, useRef } from "react";
import { cn } from "@/lib/utils";
import { animate } from "motion/react";

interface GlowingEffectProps {
  blur?: number;
  inactiveZone?: number;
  proximity?: number;
  spread?: number;
  variant?: "default" | "white";
  glow?: boolean;
  className?: string;
  disabled?: boolean;
  movementDuration?: number;
  borderWidth?: number;
}
const GlowingEffect = memo(
  ({
    blur = 0,
    inactiveZone = 0.7,
    proximity = 0,
    spread = 20,
    variant = "default",
    glow = false,
    className,
    movementDuration = 2,
    borderWidth = 1,
    disabled = true,
  }: GlowingEffectProps) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const lastPosition = useRef({ x: 0, y: 0 });
    const animationFrameRef = useRef<number>(0);

    const handleMove = useCallback(
      (e?: MouseEvent | { x: number; y: number }) => {
        if (!containerRef.current) return;

        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }

        animationFrameRef.current = requestAnimationFrame(() => {
          const element = containerRef.current;
          if (!element) return;

          const { left, top, width, height } = element.getBoundingClientRect();
          const mouseX = e?.x ?? lastPosition.current.x;
          const mouseY = e?.y ?? lastPosition.current.y;

          if (e) {
            lastPosition.current = { x: mouseX, y: mouseY };
          }

          const center = [left + width * 0.5, top + height * 0.5];
          const distanceFromCenter = Math.hypot(
            mouseX - center[0],
            mouseY - center[1]
          );
          const inactiveRadius = 0.5 * Math.min(width, height) * inactiveZone;

          if (distanceFromCenter < inactiveRadius) {
            element.style.setProperty("--active", "0");
            return;
          }

          const isActive =
            mouseX > left - proximity &&
            mouseX < left + width + proximity &&
            mouseY > top - proximity &&
            mouseY < top + height + proximity;

          element.style.setProperty("--active", isActive ? "1" : "0");

          if (!isActive) return;

          const currentAngle =
            parseFloat(element.style.getPropertyValue("--start")) || 0;
          let targetAngle =
            (180 * Math.atan2(mouseY - center[1], mouseX - center[0])) /
              Math.PI +
            90;

          const angleDiff = ((targetAngle - currentAngle + 180) % 360) - 180;
          const newAngle = currentAngle + angleDiff;

          animate(currentAngle, newAngle, {
            duration: movementDuration,
            ease: [0.16, 1, 0.3, 1],
            onUpdate: (value) => {
              element.style.setProperty("--start", String(value));
            },
          });
        });
      },
      [inactiveZone, proximity, movementDuration]
    );

    useEffect(() => {
      if (disabled) return;

      const handleScroll = () => handleMove();
      const handlePointerMove = (e: PointerEvent) => handleMove(e);

      window.addEventListener("scroll", handleScroll, { passive: true });
      document.body.addEventListener("pointermove", handlePointerMove, {
        passive: true,
      });

      return () => {
        if (animationFrameRef.current) {
          cancelAnimationFrame(animationFrameRef.current);
        }
        window.removeEventListener("scroll", handleScroll);
        document.body.removeEventListener("pointermove", handlePointerMove);
      };
    }, [handleMove, disabled]);

    return (
      <>
        <div
          className={cn(
            "pointer-events-none absolute -inset-px hidden rounded-[inherit] border opacity-0 transition-opacity",
            glow && "opacity-100",
            variant === "white" && "border-white",
            disabled && "!block"
          )}
        />
        <div
          ref={containerRef}
          style={
            {
              "--blur": `${blur}px`,
              "--spread": spread,
              "--start": "0",
              "--active": "0",
              "--glowingeffect-border-width": `${borderWidth}px`,
              "--repeating-conic-gradient-times": "5",
              "--gradient":
                variant === "white"
                  ? `repeating-conic-gradient(
                  from 236.84deg at 50% 50%,
                  var(--black),
                  var(--black) calc(25% / var(--repeating-conic-gradient-times))
                )`
                  : `radial-gradient(circle, #7CFC00 10%, #7CFC0000 20%),
                radial-gradient(circle at 30% 30%, #FFB6C1 8%, #FFB6C100 18%),
                radial-gradient(circle at 70% 70%, #00FFFF 10%, #00FFFF00 20%),
                radial-gradient(circle at 50% 80%, #FFFFE0 6%, #FFFFE000 16%),
                radial-gradient(circle at 40% 60%, #FFFFFF 5%, #FFFFFF00 15%),
                repeating-conic-gradient(
                  from 236.84deg at 50% 50%,
                  #7CFC00 0%,
                  #00FF00 calc(12.5% / var(--repeating-conic-gradient-times)),
                  #32CD32 calc(25% / var(--repeating-conic-gradient-times)),
                  #00FFFF calc(37.5% / var(--repeating-conic-gradient-times)),
                  #9ACD32 calc(50% / var(--repeating-conic-gradient-times)),
                  #FFB6C1 calc(62.5% / var(--repeating-conic-gradient-times)),
                  #FFFFE0 calc(75% / var(--repeating-conic-gradient-times)),
                  #FFFFFF calc(87.5% / var(--repeating-conic-gradient-times)),
                  #7CFC00 calc(100% / var(--repeating-conic-gradient-times))
                )`,
            } as React.CSSProperties
          }
          className={cn(
            "pointer-events-none absolute inset-0 rounded-[inherit] opacity-100 transition-opacity",
            glow && "opacity-100",
            blur > 0 && "blur-[var(--blur)] ",
            className,
            disabled && "!hidden"
          )}
        >
          <div
            className={cn(
              "glow",
              "rounded-[inherit]",
              'after:content-[""] after:rounded-[inherit] after:absolute after:inset-[calc(-1*var(--glowingeffect-border-width))]',
              "after:[border:var(--glowingeffect-border-width)_solid_transparent]",
              "after:[background:var(--gradient)] after:[background-attachment:fixed]",
              "after:opacity-[var(--active)] after:transition-opacity after:duration-300",
              "after:[mask-clip:padding-box,border-box]",
              "after:[mask-composite:intersect]",
              "after:[mask-image:linear-gradient(#0000,#0000),conic-gradient(from_calc((var(--start)-var(--spread))*1deg),#00000000_0deg,#fff,#00000000_calc(var(--spread)*2deg))]"
            )}
          />
        </div>
      </>
    );
  }
);

GlowingEffect.displayName = "GlowingEffect";

export { GlowingEffect };
</file>

<file path="frontend/src/components/ui/horizontal-scroll-carousel.tsx">
import { useRef, useEffect, useState, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { GlowingEffect } from "@/components/ui/glowing-effect";
import { Globe, Users, Copy, Check } from "lucide-react";
import { toast } from "sonner";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignInfo, CampaignMetrics, CampaignSummary, CampaignActivity } from "@/lib/launchpadClient";
import { getActiveChainId } from "@/lib/chainConfig";
import { AthBar } from "@/components/token/AthBar";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { useTokenStatsRealtime } from "@/hooks/useTokenStatsRealtime";
import { useWallet } from "@/hooks/useWallet";

// ---- Types ----
type CarouselCard = {
  id: number;
  image: string;
  ticker: string;
  tokenName: string;

  // Keep original campaign info around for lightweight stat refresh polling.
  campaignInfo?: CampaignInfo;

  // IMPORTANT: TokenDetails expects /token/:campaignAddress
  campaignAddress: string;

  // Optional token contract (post-graduation / or already known in your system)
  tokenAddress?: string;

  // Shown/copied in UI (prefer token, fallback campaign)
  contractAddress: string;

  description: string;
  marketCap: string; // BNB label (fallback)
  marketCapUsdLabel?: string | null; // preferred for UI + ATH tracking
  holders: string;
  volume: string;
  links: { website?: string; twitter?: string; telegram?: string; discord?: string };
};

const ZERO_ADDR = "0x0000000000000000000000000000000000000000";

// ---------- Helpers ----------
const isAddress = (s?: string) => /^0x[a-fA-F0-9]{40}$/.test((s ?? "").trim());
const isZeroAddress = (s?: string) => /^0x0{40}$/.test((s ?? "").trim());

function normalizeWebsiteUrl(url?: string): string | undefined {
  const u = (url ?? "").trim();
  if (!u) return undefined;
  if (u.startsWith("http://") || u.startsWith("https://")) return u;
  return `https://${u}`;
}

function normalizeTwitterUrl(input?: string): string | undefined {
  const v = (input ?? "").trim();
  if (!v) return undefined;
  if (v.startsWith("http://") || v.startsWith("https://")) return v;
  const handle = v.replace(/^@/, "");
  return `https://x.com/${handle}`;
}

// ---------- Market-cap conversion helpers (BNB label -> USD label) ----------
function parseCompactNumber(input: string): number | null {
  const raw = String(input ?? "").trim();
  if (!raw || raw === "") return null;

  const first = raw.split(/\s+/)[0] ?? "";
  const cleaned = first.replace(/[,$]/g, "");
  const m = cleaned.match(/^(-?\d+(?:\.\d+)?)([KMBT])?$/i);
  if (!m) {
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }
  const n = Number(m[1]);
  if (!Number.isFinite(n)) return null;
  const suf = (m[2] ?? "").toUpperCase();
  const mult = suf === "K" ? 1e3 : suf === "M" ? 1e6 : suf === "B" ? 1e9 : suf === "T" ? 1e12 : 1;
  return n * mult;
}

function formatCompactUsd(n: number | null): string | null {
  if (n == null || !Number.isFinite(n) || n <= 0) return null;
  const abs = Math.abs(n);
  const sign = n < 0 ? "-" : "";
  const fmt = (v: number, suffix: string) => `${sign}$${v.toFixed(v >= 100 ? 0 : v >= 10 ? 1 : 2)}${suffix}`;
  if (abs >= 1e12) return fmt(abs / 1e12, "T");
  if (abs >= 1e9) return fmt(abs / 1e9, "B");
  if (abs >= 1e6) return fmt(abs / 1e6, "M");
  if (abs >= 1e3) return fmt(abs / 1e3, "K");
  const decimals = abs >= 100 ? 0 : abs >= 10 ? 1 : abs >= 1 ? 2 : abs >= 0.01 ? 4 : 6;
  return `${sign}$${abs.toFixed(decimals)}`;
}

// ---------- Responsive card sizing ----------
const CARD_GAP = 16;

const clamp = (n: number, min: number, max: number) => Math.min(max, Math.max(min, n));

function computeCardWidth(containerWidth: number): number {
  // We size cards based on the *actual* carousel container width (not the full window)
  // so the layout stays correct next to the sidebar.
  const vw = typeof window !== "undefined" ? window.innerWidth : 1200;
  const cw = containerWidth > 0 ? containerWidth : vw;
  const mobile = vw < 768;

  if (mobile) {
    // One prominent card + peeks
    return Math.round(clamp(cw * 0.78, 240, 320));
  }

  // Desktop/tablet: two cards visible, centered card slightly larger
  return Math.round(clamp(cw * 0.36, 300, 420));
}

function getCardSize(containerWidth: number) {
  const width = computeCardWidth(containerWidth);
  return { width, totalWidth: width + CARD_GAP };
}

const Example = () => {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const scrollTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastDeltaRef = useRef(0);
  const [isSnapping, setIsSnapping] = useState(false);
  const hasInitialized = useRef(false);
  const hasMeasured = useRef(false);
  const [isMobile, setIsMobile] = useState(() =>
    typeof window !== "undefined" ? window.innerWidth < 768 : false
  );
  const [cardSize, setCardSize] = useState(() =>
    getCardSize(typeof window !== "undefined" ? window.innerWidth : 1200)
  );
  const { width: CARD_WIDTH, totalWidth: TOTAL_CARD_WIDTH } = cardSize;

  // Ensure we size cards based on the actual container width (accounts for the sidebar).
  useEffect(() => {
    const container = scrollContainerRef.current;
    if (!container) return;

    const next = getCardSize(container.offsetWidth);
    setCardSize(next);
    if (typeof window !== "undefined") setIsMobile(window.innerWidth < 768);
    hasMeasured.current = true;
  }, []);

  // Blockchain campaigns -> cards
  const { fetchCampaigns, fetchCampaignCardStats, activeChainId } = useLaunchpad();
  const chainIdForStorage = activeChainId ?? 97;
  const { price: bnbUsdPrice } = useBnbUsdPrice(true);
  const [cards, setCards] = useState<CarouselCard[]>([]);
  const [loadingCampaigns, setLoadingCampaigns] = useState(true);
  const [campaignError, setCampaignError] = useState<string | null>(null);
  

  // Keep a ref to the latest cards array so polling doesn't fight React's closure semantics.
  const cardsRef = useRef<CarouselCard[]>([]);
  useEffect(() => {
    cardsRef.current = cards;
  }, [cards]);

  // This is the array we actually render:
  const displayCards: CarouselCard[] = cards;

  // Scroll position (initially 0, we correct it in an effect once we know card count)
  const [scrollPosition, setScrollPosition] = useState(0);

  // Fetch campaigns on mount
  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setLoadingCampaigns(true);
        setCampaignError(null);

        const campaigns: CampaignInfo[] = await fetchCampaigns();

        // If no campaigns, keep cards empty so placeholders render.
        if (!campaigns || campaigns.length === 0) {
          if (!cancelled) setCards([]);
          return;
        }

        const mapped: CarouselCard[] = await Promise.all(
          campaigns.map(async (c, i) => {
            const stats = await fetchCampaignCardStats(c);

            // IMPORTANT: TokenDetails expects campaign address in route param
            const campaignAddress = String((c as any).campaign ?? "").trim();
            const tokenAddress = String((c as any).token ?? "").trim();

            // Prefer token address for copy, fallback campaign
            const contractAddress =
              tokenAddress && isAddress(tokenAddress)
                ? tokenAddress
                : campaignAddress && isAddress(campaignAddress)
                ? campaignAddress
                : ZERO_ADDR;

            const marketCapLabel = stats?.marketCap ?? "";

            // Convert "X BNB" -> USD label for UI + ATH tracking
            let marketCapUsdLabel: string | null = null;
            const mcBnb = marketCapLabel.toUpperCase().includes("BNB")
              ? parseCompactNumber(marketCapLabel.replace(/BNB/i, "").trim())
              : null;
            if (mcBnb != null && bnbUsdPrice && Number.isFinite(Number(bnbUsdPrice))) {
              marketCapUsdLabel = formatCompactUsd(mcBnb * Number(bnbUsdPrice));
            }

            return {
              id: Number((c as any).id ?? i + 1),
              image: c.logoURI || "/placeholder.svg",
              ticker: String(c.symbol ?? "").toUpperCase(),
              tokenName: c.name ?? "Token",

              campaignInfo: c,

              campaignAddress: isAddress(campaignAddress) ? campaignAddress : ZERO_ADDR,
              tokenAddress: isAddress(tokenAddress) ? tokenAddress : undefined,
              contractAddress,

              description: (c as any).description || (c as any).extraLink || "",
              marketCap: marketCapLabel,
              marketCapUsdLabel,
              holders: stats?.holders ?? "",
              volume: stats?.volume ?? "",
              links: {
                website: normalizeWebsiteUrl((c as any).website || undefined),
                twitter: normalizeTwitterUrl((c as any).xAccount || undefined),
                telegram: normalizeWebsiteUrl((c as any).telegram || undefined),
                discord: normalizeWebsiteUrl((c as any).discord || undefined),
              },
            };
          })
        );

        if (!cancelled) setCards(mapped);
      } catch (err) {
        console.error(err);
        if (!cancelled) setCampaignError("Failed to load campaigns");
      } finally {
        if (!cancelled) setLoadingCampaigns(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [fetchCampaigns, fetchCampaignCardStats, bnbUsdPrice]);

  // Poll lightweight stats (market cap/holders/volume) so the card + ATH bar feel "live".
  // This is best-effort and intentionally modest to avoid hammering the RPC.
  useEffect(() => {
    let cancelled = false;
    const intervalMs = 15_000;

    const tick = async () => {
      const snapshot = cardsRef.current;
      if (!snapshot.length) return;

      // Only refresh real campaigns (skip placeholders)
      const real = snapshot.filter((c) => c.campaignInfo && isAddress(c.campaignAddress) && !isZeroAddress(c.campaignAddress));
      if (!real.length) return;

      try {
        const updated = await Promise.all(
          real.map(async (card) => {
            const stats = card.campaignInfo ? await fetchCampaignCardStats(card.campaignInfo) : null;
            const marketCapLabel = stats?.marketCap ?? card.marketCap;

            let marketCapUsdLabel: string | null = null;
            const mcBnb = marketCapLabel.toUpperCase().includes("BNB")
              ? parseCompactNumber(marketCapLabel.replace(/BNB/i, "").trim())
              : null;
            if (mcBnb != null && bnbUsdPrice && Number.isFinite(Number(bnbUsdPrice))) {
              marketCapUsdLabel = formatCompactUsd(mcBnb * Number(bnbUsdPrice));
            }

            return {
              ...card,
              marketCap: marketCapLabel,
              marketCapUsdLabel,
              holders: stats?.holders ?? card.holders,
              volume: stats?.volume ?? card.volume,
            };
          })
        );

        if (cancelled) return;

        const byAddr = new Map(updated.map((u) => [String(u.campaignAddress).toLowerCase(), u]));
        setCards((prev) =>
          prev.map((p) => byAddr.get(String(p.campaignAddress).toLowerCase()) ?? p)
        );
      } catch (e) {
        console.warn("[carousel] stats refresh failed", e);
      }
    };

    // Initial tick (after mount) + interval
    tick();
    const id = window.setInterval(tick, intervalMs);
    return () => {
      cancelled = true;
      window.clearInterval(id);
    };
  }, [fetchCampaignCardStats, bnbUsdPrice]);

  // Save scroll position to sessionStorage whenever it changes
  useEffect(() => {
    sessionStorage.setItem("carousel-position", scrollPosition.toString());
  }, [scrollPosition]);

  // Initialize to center the first card on first mount, once we know how many cards we have
  useEffect(() => {
    if (!scrollContainerRef.current) return;
    if (!displayCards.length) return;
    if (!hasMeasured.current) return;

    const stored = sessionStorage.getItem("carousel-position");

    if (!hasInitialized.current) {
      const singleSetWidth = TOTAL_CARD_WIDTH * displayCards.length;

      if (!stored) {
        // No stored position - center the first card of the middle set
        const containerWidth = scrollContainerRef.current.offsetWidth;
        const firstCardCenter = singleSetWidth + CARD_WIDTH / 2;
        const targetPosition = firstCardCenter - containerWidth / 2;
        setScrollPosition(targetPosition);
      } else {
        // Has stored position - trigger a snap to ensure proper highlighting
        setTimeout(() => {
          if (!scrollContainerRef.current) return;
          const containerWidth = scrollContainerRef.current.offsetWidth;
          const storedPos = parseFloat(stored);

          const viewportCenter = storedPos + containerWidth / 2;
          const fIndex = (viewportCenter - CARD_WIDTH / 2) / TOTAL_CARD_WIDTH;
          let baseIndex = Math.round(fIndex);

          const cardCenter = baseIndex * TOTAL_CARD_WIDTH + CARD_WIDTH / 2;
          const rawTarget = cardCenter - containerWidth / 2;

          const W = singleSetWidth;
          const candidateShifts = [-2, -1, 0, 1, 2];

          let best = rawTarget,
            bestDist = Number.POSITIVE_INFINITY;

          for (const k of candidateShifts) {
            let c = rawTarget + k * W;

            // Normalize into the middle set [W, 2W)
            if (c < W) c += W;
            else if (c >= 2 * W) c -= W;

            const d = Math.abs(c - storedPos);
            if (d < bestDist) {
              best = c;
              bestDist = d;
            }
          }

          setScrollPosition(best);
          setIsSnapping(true);
          setTimeout(() => setIsSnapping(false), 600);
        }, 100);
      }

      hasInitialized.current = true;
    }
  }, [displayCards.length, TOTAL_CARD_WIDTH, CARD_WIDTH]);

  useEffect(() => {
    const container = scrollContainerRef.current;
    if (!container) return;
    if (!displayCards.length) return;

    // --- Wheel helpers ---
    const getWheelDelta = (evt: WheelEvent, el: HTMLDivElement) => {
      // deltaMode: 0=pixels, 1=lines, 2=pages
      if (evt.deltaMode === 1) return evt.deltaY * 16;
      if (evt.deltaMode === 2) return evt.deltaY * el.clientHeight;
      return evt.deltaY;
    };

    // IMPORTANT: Keep scrollPosition ALWAYS in the middle set [W, 2W)
    // so snapping logic (which normalizes to [W,2W)) cannot "fight" the wheel.
    const wrapIntoMiddleSet = (pos: number, W: number) => {
      const total = W * 3;
      if (!W || !Number.isFinite(pos)) return 0;

      // modulo into [0, total)
      let p = ((pos % total) + total) % total;

      // normalize into middle set [W, 2W)
      if (p < W) p += W;
      else if (p >= 2 * W) p -= W;

      return p;
    };

    const snapToNearestCard = (overrides?: { cardWidth?: number; totalCardWidth?: number }) => {
      if (!displayCards.length) return;

      const cw = overrides?.cardWidth ?? CARD_WIDTH;
      const tw = overrides?.totalCardWidth ?? TOTAL_CARD_WIDTH;

      const containerWidth = container.offsetWidth;
      const singleSetWidth = tw * displayCards.length;

      setScrollPosition((currentPos) => {
        if (!singleSetWidth) return currentPos;

        const viewportCenter = currentPos + containerWidth / 2;
        const fIndex = (viewportCenter - cw / 2) / tw;

        let baseIndex = Math.round(fIndex);

        if (lastDeltaRef.current > 0 && baseIndex * tw + cw / 2 < viewportCenter) {
          baseIndex += 1;
        } else if (lastDeltaRef.current < 0 && baseIndex * tw + cw / 2 > viewportCenter) {
          baseIndex -= 1;
        }

        const cardCenter = baseIndex * tw + cw / 2;
        const rawTarget = cardCenter - containerWidth / 2;

        const W = singleSetWidth;
        const candidateShifts = [-2, -1, 0, 1, 2];

        let best = rawTarget,
          bestDist = Number.POSITIVE_INFINITY;

        for (const k of candidateShifts) {
          let c = rawTarget + k * W;

          // normalize into [W,2W)
          if (c < W) c += W;
          else if (c >= 2 * W) c -= W;

          const d = Math.abs(c - currentPos);
          if (d < bestDist) {
            best = c;
            bestDist = d;
          }
        }

        return best;
      });

      setIsSnapping(true);
      setTimeout(() => setIsSnapping(false), 600);
    };

    // --- FIX: infinite scroll both directions on desktop wheel ---
    const handleWheel = (e: WheelEvent) => {
      e.preventDefault();

      const delta = getWheelDelta(e, container);
      lastDeltaRef.current = delta;

      if (isSnapping) setIsSnapping(false);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);

      setScrollPosition((prev) => {
        const W = TOTAL_CARD_WIDTH * displayCards.length;
        if (!W) return prev;

        // speed factor
        const next = prev + delta * 0.6;

        // keep it in the middle set so it never "runs out" in either direction
        return wrapIntoMiddleSet(next, W);
      });

      scrollTimeoutRef.current = setTimeout(() => snapToNearestCard(), 150);
    };

    // Handle window resize
    const handleResize = () => {
      const vw = typeof window !== "undefined" ? window.innerWidth : 1200;
      setIsMobile(vw < 768);

      const next = getCardSize(container.offsetWidth);
      setCardSize(next);
      snapToNearestCard({ cardWidth: next.width, totalCardWidth: next.totalWidth });
    };

    // Handle touch events for mobile swipe
    let touchStartX = 0;
    let touchStartScrollPos = 0;

    const handleTouchStart = (e: TouchEvent) => {
      touchStartX = e.touches[0].clientX;
      touchStartScrollPos = scrollPosition;
      if (isSnapping) setIsSnapping(false);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };

    const handleTouchMove = (e: TouchEvent) => {
      const touchX = e.touches[0].clientX;
      const deltaX = touchStartX - touchX;

      const W = TOTAL_CARD_WIDTH * displayCards.length;
      if (!W) return;

      setScrollPosition(() => {
        const next = touchStartScrollPos + deltaX;

        // keep it in the middle set for seamless infinite swipe
        return wrapIntoMiddleSet(next, W);
      });
    };

    const handleTouchEnd = () => {
      scrollTimeoutRef.current = setTimeout(() => snapToNearestCard(), 100);
    };

    container.addEventListener("wheel", handleWheel, { passive: false });
    container.addEventListener("touchstart", handleTouchStart, { passive: true });
    container.addEventListener("touchmove", handleTouchMove, { passive: true });
    container.addEventListener("touchend", handleTouchEnd, { passive: true });
    window.addEventListener("resize", handleResize);

    return () => {
      container.removeEventListener("wheel", handleWheel);
      container.removeEventListener("touchstart", handleTouchStart);
      container.removeEventListener("touchmove", handleTouchMove);
      container.removeEventListener("touchend", handleTouchEnd);
      window.removeEventListener("resize", handleResize);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [displayCards.length, isSnapping, scrollPosition, TOTAL_CARD_WIDTH, CARD_WIDTH]);

  // Calculate which absolute card index is centered for highlighting
  const getCenteredAbsIndex = () => {
    if (!scrollContainerRef.current || !displayCards.length) return 0;
    const containerWidth = scrollContainerRef.current.offsetWidth;
    const viewportCenter = scrollPosition + containerWidth / 2;
    const absIndex = Math.round((viewportCenter - CARD_WIDTH / 2) / TOTAL_CARD_WIDTH);
    return absIndex;
  };

  const centeredAbsIndex = getCenteredAbsIndex();
  const totalTriple = displayCards.length * 3 || 1;
  const centeredTripleIndex = ((centeredAbsIndex % totalTriple) + totalTriple) % totalTriple;

  // Handle card click to snap it to center
  const handleCardClick = (clickedIndex: number) => {
    if (!scrollContainerRef.current || !displayCards.length) return;
    const containerWidth = scrollContainerRef.current.offsetWidth;
    const W = TOTAL_CARD_WIDTH * displayCards.length;
    if (!W) return;

    // Center of the exact clicked instance in the triple set
    const clickedCenter = clickedIndex * TOTAL_CARD_WIDTH + CARD_WIDTH / 2;
    const rawTarget = clickedCenter - containerWidth / 2;

    setScrollPosition((currentPos) => {
      // Pick the nearest equivalent target by shifting by +/- W and +/- 2W
      const candidates = [rawTarget - 2 * W, rawTarget - W, rawTarget, rawTarget + W, rawTarget + 2 * W];
      let best = candidates[0];
      let bestDist = Infinity;

      for (let c of candidates) {
        let cn = c;

        // normalize into middle set [W,2W)
        if (cn < W) cn += W;
        else if (cn >= 2 * W) cn -= W;

        const d = Math.abs(cn - currentPos);
        if (d < bestDist) {
          best = cn;
          bestDist = d;
        }
      }
      return best;
    });

    setIsSnapping(true);
    setTimeout(() => setIsSnapping(false), 600);
  };

  return (
    <div
      ref={scrollContainerRef}
      className="h-full w-full flex items-center overflow-hidden relative touch-pan-x scrollbar-hidden py-8 md:py-12"
      style={{
        maskImage: isMobile
          ? "none"
          : "linear-gradient(to right, transparent 0%, black 10%, black 90%, transparent 100%)",
        WebkitMaskImage: isMobile
          ? "none"
          : "linear-gradient(to right, transparent 0%, black 10%, black 90%, transparent 100%)",
        scrollbarWidth: "none",
        msOverflowStyle: "none",
      }}
    >
      {displayCards.length === 0 ? (
  <div className="w-full py-10 text-center text-sm text-muted-foreground">
    No campaigns yet.
  </div>
) : (
  <div
    className="flex items-center"
    style={{
      transform: `translateX(-${scrollPosition}px)`,
      transition: isSnapping ? "transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)" : "none",
      gap: `${CARD_GAP}px`,
    }}
  >
    {/* Render cards 3 times for seamless infinite scroll */}
    {[...displayCards, ...displayCards, ...displayCards].map((card, index) => {
      const isCentered = index === centeredTripleIndex;
      return (
        <CardView
          card={card}
          key={`${card.id}-${index}`}
          isCentered={isCentered}
          cardWidth={CARD_WIDTH}
          isMobile={isMobile}
          chainIdForStorage={chainIdForStorage}
          bnbUsdPrice={bnbUsdPrice}
          onClick={() => handleCardClick(index)}
        />
      );
    })}
  </div>
)}
      {/* Optional: lightweight status (doesn't affect layout) */}
      {campaignError ? (
        <div className="absolute bottom-2 left-1/2 -translate-x-1/2 text-[10px] text-muted-foreground bg-background/40 border border-border/40 rounded-full px-2 py-0.5">
          {campaignError}
        </div>
      ) : loadingCampaigns ? (
        <div className="absolute bottom-2 left-1/2 -translate-x-1/2 text-[10px] text-muted-foreground bg-background/40 border border-border/40 rounded-full px-2 py-0.5">
          Loading
        </div>
      ) : null}
    </div>
  );
};

const CardView = ({
  card,
  isCentered,
  cardWidth,
  isMobile,
  chainIdForStorage,
  bnbUsdPrice,
  onClick,
}: {
  card: CarouselCard;
  isCentered: boolean;
  cardWidth: number;
  isMobile: boolean;
  chainIdForStorage: number;
  bnbUsdPrice?: number | null;
  onClick: () => void;
}) => {
  const [copied, setCopied] = useState(false);
  const navigate = useNavigate();

  const handleCopy = async (e: React.MouseEvent) => {
    e.stopPropagation();
    const addr = (card.contractAddress ?? "").trim();
    if (!addr) return;

    try {
      await navigator.clipboard.writeText(addr);
      setCopied(true);
      toast.success("Contract address copied!");
      setTimeout(() => setCopied(false), 1200);
    } catch {
      toast.error("Copy failed");
    }
  };

  const wallet = useWallet();

  const campaignAddr = String(card.campaignAddress ?? "").trim().toLowerCase();
  const isDummy = !campaignAddr || !isAddress(campaignAddr) || isZeroAddress(campaignAddr);

  // Realtime stats from Railway/Ably (same hook TokenDetails uses)
  const { stats: rtStats } = useTokenStatsRealtime(
    campaignAddr,
    wallet.chainId,
    !isDummy
  );

  // Preferred: raw marketcapBnb -> USD (no parsing from rounded labels)
  const marketCapUsdLabelPrecise = useMemo(() => {
    const mcBnb = rtStats?.marketcapBnb;
    if (mcBnb == null || !Number.isFinite(Number(mcBnb))) return null;
    if (bnbUsdPrice == null || !Number.isFinite(Number(bnbUsdPrice)) || Number(bnbUsdPrice) <= 0) return null;

    const usd = Number(mcBnb) * Number(bnbUsdPrice);
    return Number.isFinite(usd) && usd > 0 ? formatCompactUsd(usd) : null;
  }, [rtStats?.marketcapBnb, bnbUsdPrice]);

  const handleClick = () => {
    if (isCentered && !isDummy) {
      // Navigate to token details if centered/highlighted AND we have a real campaign address
      navigate(`/token/${campaignAddr}`);
      return;
    }

    // Otherwise just center the card
    onClick();
  };

  // IMPORTANT: display + AthBar should prefer precise USD label.
  const mcapDisplay =
    marketCapUsdLabelPrecise ??
    (card.marketCapUsdLabel ?? null) ??
    (card.marketCap ?? "");

  const barWidthPx = Math.round(Math.max(110, Math.min(170, cardWidth * 0.45)));

  return (
    <div
      className="relative cursor-pointer transition-[transform,filter,opacity] duration-500 ease-out will-change-transform"
      style={{
        // Keep the "featured" card prominent, but avoid blowing up the layout.
        transform: isCentered ? (isMobile ? "scale(1.10)" : "scale(1.22)") : "scale(1)",
        transformOrigin: "center",
        minWidth: `${cardWidth}px`,
        minHeight: `${cardWidth}px`,
        zIndex: isCentered ? 10 : 1,
        // Make the centered card crisp and push the depth effect to the side cards.
        opacity: isMobile ? 1 : isCentered ? 1 : 0.78,
        filter: isMobile ? "none" : isCentered ? "none" : "blur(1.1px)",
      }}
      onClick={handleClick}
    >
      <div
        className={`relative rounded-[1.25rem] p-[1px] ${
          isCentered
            ? //? "ring-2 ring-accent/60 shadow-xl shadow-accent/10"
              ""
            : //: "border border-border/40"
              ""
        }`}
        style={{
          height: `${cardWidth}px`,
          width: `${cardWidth}px`,
        }}
      >
        <GlowingEffect
          spread={32}
          glow={false}
          disabled={false}
          proximity={80}
          inactiveZone={0.01}
          borderWidth={2}
        />
        <div
          className={`relative flex h-full w-full flex-col overflow-hidden rounded-[1.15rem] border border-border/40 bg-card/80 p-6 shadow-sm ${
            // IMPORTANT: backdrop-blur on the top (center) card will blur the cards behind it.
            // We only apply backdrop-blur on the side cards.
            !isMobile && !isCentered ? "backdrop-blur" : ""
          }`}
        >
          {/* Top Section: Links and Stats */}
          <div className="flex items-start justify-between mb-4">
            {/* Social Links - Top Left */}
            <div className="flex gap-2">
              {card.links.website && (
                <a
                  href={card.links.website}
                  target="_blank"
                  rel="noopener noreferrer"
                  onClick={(e) => e.stopPropagation()}
                  className="w-8 h-8 rounded-lg border border-border bg-muted flex items-center justify-center text-muted-foreground hover:text-accent hover:border-accent transition-colors"
                >
                  <Globe className="h-4 w-4" />
                </a>
              )}
              {card.links.twitter && (
                <a
                  href={card.links.twitter}
                  target="_blank"
                  rel="noopener noreferrer"
                  onClick={(e) => e.stopPropagation()}
                  className="w-8 h-8 rounded-lg border border-border bg-muted flex items-center justify-center text-muted-foreground hover:text-accent hover:border-accent transition-colors"
                >
                  <svg className="h-4 w-4" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                  </svg>
                </a>
              )}
            </div>

            {/* Holders and Volume - Top Right */}
            <div className="flex flex-col items-end gap-1 text-xs font-retro">
              <div className="flex items-center gap-1 text-muted-foreground">
                <Users className="h-3 w-3" />
                <span>{card.holders}</span>
              </div>
              <div className="flex items-center gap-1 text-accent">
                <span>Vol {card.volume}</span>
              </div>
            </div>
          </div>

          {/* Center: Token Image */}
          <div className="flex-1 flex items-center justify-center mb-4">
            <div
              className="rounded-full overflow-hidden bg-muted border-2 border-border"
              style={{
                width: isMobile ? "80px" : "128px",
                height: isMobile ? "80px" : "128px",
              }}
            >
              <img src={card.image} alt={card.ticker} className="w-full h-full object-cover" />
            </div>
          </div>

          {/* Token Info */}
          <div className="flex flex-col items-center gap-2 mb-4">
            <h3 className="text-2xl font-retro tracking-tight text-foreground">{card.ticker}</h3>
            <div className="flex items-center gap-2">
              <span className="text-sm font-retro text-muted-foreground">{card.tokenName}</span>
              <button
                onClick={handleCopy}
                className="p-1 hover:bg-muted rounded transition-colors"
                title="Copy contract address"
              >
                {copied ? <Check className="h-3 w-3 text-accent" /> : <Copy className="h-3 w-3 text-muted-foreground" />}
              </button>
            </div>
            <p className="text-[10px] font-retro text-muted-foreground text-center leading-relaxed line-clamp-2">
              {card.description}
            </p>
          </div>

          {/* Bottom: MC (USD) + ATH bar */}
          <div className="flex items-center justify-between gap-3">
            <AthBar
              currentLabel={marketCapUsdLabelPrecise ?? card.marketCapUsdLabel ?? null}
              storageKey={`ath:${String(chainIdForStorage)}:${String(card.campaignAddress).toLowerCase()}`}
              className="text-[10px]"
              barWidthPx={barWidthPx}
              barMaxWidth="100%"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default Example;
</file>

<file path="frontend/src/components/ui/hover-card.tsx">
import * as React from "react";
import * as HoverCardPrimitive from "@radix-ui/react-hover-card";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };
</file>

<file path="frontend/src/components/ui/input-otp.tsx">
import * as React from "react";
import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";

import { cn } from "@/lib/utils";

const InputOTP = React.forwardRef<React.ElementRef<typeof OTPInput>, React.ComponentPropsWithoutRef<typeof OTPInput>>(
  ({ className, containerClassName, ...props }, ref) => (
    <OTPInput
      ref={ref}
      containerClassName={cn("flex items-center gap-2 has-[:disabled]:opacity-50", containerClassName)}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  ),
);
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("flex items-center", className)} {...props} />,
);
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<React.ElementRef<"div">, React.ComponentPropsWithoutRef<"div">>(
  ({ ...props }, ref) => (
    <div ref={ref} role="separator" {...props}>
      <Dot />
    </div>
  ),
);
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };
</file>

<file path="frontend/src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="frontend/src/components/ui/label.tsx">
import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70");

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="frontend/src/components/ui/loaders/custom-loader.tsx">
/**
 * Custom Loader Component
 * Renders a CSS-animated loading spinner
 */

import React, { useEffect } from "react";
import { cn } from "@/lib/utils";

interface CustomLoaderProps {
  className?: string;
  size?: "sm" | "md" | "lg";
}

const sizeMap = {
  sm: "h-6 w-6",
  md: "h-8 w-8",
  lg: "h-12 w-12",
};

const CustomLoader: React.FC<CustomLoaderProps> = ({ className = "", size = "md" }) => {
  useEffect(() => {
    // Inject CSS if not already present
    if (!document.getElementById("custom-loader-styles")) {
      const style = document.createElement("style");
      style.id = "custom-loader-styles";
      style.textContent = `
.custom-loader-5{height:32px;width:32px;position:relative;animation:loader-5-1 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}
@keyframes loader-5-1{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.custom-loader-5::before,.custom-loader-5::after,.custom-loader-5 span::before,.custom-loader-5 span::after{
content:"";display:block;position:absolute;margin:auto;background:#ffffff;border-radius:50%}
.custom-loader-5::before{top:0;left:0;bottom:0;right:auto;width:8px;height:8px;animation:loader-5-2 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}
@keyframes loader-5-2{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(24px,0,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}
.custom-loader-5::after{top:0;left:auto;bottom:0;right:0;width:8px;height:8px;animation:loader-5-3 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}
@keyframes loader-5-3{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(-24px,0,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}
.custom-loader-5 span::before{top:0;left:0;bottom:auto;right:0;width:8px;height:8px;animation:loader-5-4 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}
@keyframes loader-5-4{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(0,24px,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}
.custom-loader-5 span::after{top:auto;left:0;bottom:0;right:0;width:8px;height:8px;animation:loader-5-5 2s cubic-bezier(0.770,0.000,0.175,1.000) infinite}
@keyframes loader-5-5{0%{transform:translate3d(0,0,0)scale(1)}50%{transform:translate3d(0,-24px,0)scale(.5)}100%{transform:translate3d(0,0,0)scale(1)}}
      `;
      document.head.appendChild(style);
    }
  }, []);

  return (
    <div className={cn("custom-loader-5", sizeMap[size], className)}>
      <span></span>
    </div>
  );
};

export default CustomLoader;
</file>

<file path="frontend/src/components/ui/menubar.tsx">
import * as React from "react";
import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn("flex h-10 items-center space-x-1 rounded-md border bg-background p-1", className)}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[state=open]:bg-accent data-[state=open]:text-accent-foreground focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(({ className, align = "start", alignOffset = -4, sideOffset = 8, ...props }, ref) => (
  <MenubarPrimitive.Portal>
    <MenubarPrimitive.Content
      ref={ref}
      align={align}
      alignOffset={alignOffset}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </MenubarPrimitive.Portal>
));
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return <span className={cn("ml-auto text-xs tracking-widest text-muted-foreground", className)} {...props} />;
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};
</file>

<file path="frontend/src/components/ui/navigation-menu.tsx">
import * as React from "react";
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn("relative z-10 flex max-w-max flex-1 items-center justify-center", className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn("group flex flex-1 list-none items-center justify-center space-x-1", className)}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};
</file>

<file path="frontend/src/components/ui/pagination.tsx">
import * as React from "react";
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react";

import { cn } from "@/lib/utils";
import { ButtonProps, buttonVariants } from "@/components/ui/button";

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
);
Pagination.displayName = "Pagination";

const PaginationContent = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul ref={ref} className={cn("flex flex-row items-center gap-1", className)} {...props} />
  ),
);
PaginationContent.displayName = "PaginationContent";

const PaginationItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
));
PaginationItem.displayName = "PaginationItem";

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">;

const PaginationLink = ({ className, isActive, size = "icon", ...props }: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = "PaginationLink";

const PaginationPrevious = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to previous page" size="default" className={cn("gap-1 pl-2.5", className)} {...props}>
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = "PaginationPrevious";

const PaginationNext = ({ className, ...props }: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink aria-label="Go to next page" size="default" className={cn("gap-1 pr-2.5", className)} {...props}>
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = "PaginationNext";

const PaginationEllipsis = ({ className, ...props }: React.ComponentProps<"span">) => (
  <span aria-hidden className={cn("flex h-9 w-9 items-center justify-center", className)} {...props}>
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = "PaginationEllipsis";

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};
</file>

<file path="frontend/src/components/ui/popover.tsx">
import * as React from "react";
import * as PopoverPrimitive from "@radix-ui/react-popover";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };
</file>

<file path="frontend/src/components/ui/processing-card-refactored.tsx">
/**
 * Processing Card Component
 * Displays token creation progress with glitch effects and animations
 */

import React, { useEffect, useState } from "react";
import { motion } from "framer-motion";
import { CheckCircle2, XCircle, Clock } from "lucide-react";
import { cn } from "@/lib/utils";
import LetterGlitch from "@/components/ui/effects/letter-glitch";
import CustomLoader from "@/components/ui/loaders/custom-loader";
import AsciiProgressBar from "@/components/ui/progress/ascii-progress-bar";
import { PROCESSING_STAGES } from "@/constants/processingStages";
import { ProcessingStatus } from "@/types/token";

interface ProcessingCardProps {
  name?: string;
  className?: string;
  status?: ProcessingStatus;
  progress?: number;
}

const ProcessingCard: React.FC<ProcessingCardProps> = ({
  name = "Token",
  className = "",
  status = "queued",
  progress = 0,
}) => {
  const [displayProgress, setDisplayProgress] = useState(0);
  const [currentStage, setCurrentStage] = useState(PROCESSING_STAGES[0].label);

  // Update displayed progress with smoothing
  useEffect(() => {
    const interval = setInterval(() => {
      setDisplayProgress((prev) => {
        const diff = progress - prev;
        if (Math.abs(diff) < 0.1) return progress;
        return prev + diff * 0.1;
      });
    }, 50);

    return () => clearInterval(interval);
  }, [progress]);

  // Update current stage based on progress
  useEffect(() => {
    const stage = PROCESSING_STAGES.find(
      (s) => displayProgress >= s.minProgress && displayProgress < s.maxProgress
    );
    if (stage) {
      setCurrentStage(stage.label);
    }
  }, [displayProgress]);

  const getStatusIcon = () => {
    switch (status) {
      case "succeeded":
        return <CheckCircle2 className="h-12 w-12 text-lime-400" />;
      case "failed":
        return <XCircle className="h-12 w-12 text-red-500" />;
      case "queued":
        return <Clock className="h-12 w-12 text-muted-foreground" />;
      default:
        return <CustomLoader size="lg" />;
    }
  };

  const getStatusText = () => {
    switch (status) {
      case "succeeded":
        return "Token Created Successfully!";
      case "failed":
        return "Token Creation Failed";
      case "queued":
        return "Queued for Processing...";
      default:
        return currentStage;
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className={cn(
        "relative p-8 bg-gradient-to-br from-background/95 to-background/90 backdrop-blur-xl",
        className
      )}
    >
      {/* Header */}
      <div className="text-center mb-8">
        <h2 className="text-3xl font-retro text-foreground mb-2">Creating {name}</h2>
        <p className="text-sm text-muted-foreground">Please wait while we process your token</p>
      </div>

      {/* Glitch Effect Title */}
      {status === "running" && (
        <div className="flex justify-center mb-6">
          <LetterGlitch
            text="PROCESSING"
            glitchColors={["#a3e635", "#bef264", "#84cc16"]}
            glitchSpeed={50}
            fontSize={48}
          />
        </div>
      )}

      {/* Status Icon */}
      <div className="flex justify-center mb-6">
        <motion.div
          initial={{ scale: 0.8 }}
          animate={{ scale: 1 }}
          transition={{ duration: 0.3 }}
        >
          {getStatusIcon()}
        </motion.div>
      </div>

      {/* Status Text */}
      <div className="text-center mb-8">
        <p className="text-lg font-retro text-foreground">{getStatusText()}</p>
      </div>

      {/* Progress Bar */}
      {(status === "running" || status === "queued") && (
        <div className="mt-8">
          <AsciiProgressBar progress={displayProgress} />
        </div>
      )}

      {/* Success/Failure Message */}
      {status === "succeeded" && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3 }}
          className="text-center mt-6 text-sm text-muted-foreground"
        >
          Redirecting to token page...
        </motion.div>
      )}

      {status === "failed" && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.3 }}
          className="text-center mt-6 text-sm text-red-500"
        >
          Please try again or contact support
        </motion.div>
      )}
    </motion.div>
  );
};

export default ProcessingCard;
</file>

<file path="frontend/src/components/ui/processing-card.tsx">
/**
 * Processing Card Component (Legacy Export)
 * Re-exports the refactored ProcessingCard component for backwards compatibility
 */

export { default } from "./processing-card-refactored";
</file>

<file path="frontend/src/components/ui/progress.tsx">
import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-4 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="frontend/src/components/ui/progress/ascii-progress-bar.tsx">
/**
 * ASCII Progress Bar Component
 * Displays a progress bar using ASCII characters with animations
 */

import React from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface AsciiProgressBarProps {
  progress: number;
  className?: string;
}

const PROGRESS_BAR_LENGTH = 40;
const FILLED_CHAR = "";
const EMPTY_CHAR = "";

const AsciiProgressBar: React.FC<AsciiProgressBarProps> = ({ progress, className = "" }) => {
  const filledCount = Math.round((progress / 100) * PROGRESS_BAR_LENGTH);
  const emptyCount = PROGRESS_BAR_LENGTH - filledCount;

  return (
    <div className={cn("font-mono text-sm leading-relaxed", className)}>
      <div className="flex items-center gap-3 mb-2">
        <span className="text-muted-foreground">Progress:</span>
        <span className="text-foreground font-semibold">{progress.toFixed(1)}%</span>
      </div>
      
      <div className="flex">
        {Array.from({ length: filledCount }).map((_, i) => (
          <motion.span
            key={`filled-${i}`}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: i * 0.01 }}
            className="text-lime-400"
          >
            {FILLED_CHAR}
          </motion.span>
        ))}
        {Array.from({ length: emptyCount }).map((_, i) => (
          <span key={`empty-${i}`} className="text-muted-foreground/30">
            {EMPTY_CHAR}
          </span>
        ))}
      </div>
    </div>
  );
};

export default AsciiProgressBar;
</file>

<file path="frontend/src/components/ui/radio-group.tsx">
import * as React from "react";
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return <RadioGroupPrimitive.Root className={cn("grid gap-2", className)} {...props} ref={ref} />;
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="frontend/src/components/ui/resizable.tsx">
import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({ className, ...props }: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn("flex h-full w-full data-[panel-group-direction=vertical]:flex-col", className)}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };
</file>

<file path="frontend/src/components/ui/scroll-area.tsx">
import * as React from "react";
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root ref={ref} className={cn("relative overflow-hidden", className)} {...props}>
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">{children}</ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "hidden", // Hide scrollbar completely
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };
</file>

<file path="frontend/src/components/ui/scrolling-holographic-card-feed.tsx">
import React from 'react';

// --- Reusable UI Element Components ---

export const DataReadout = ({ value }: { value: string }) => (
    <div className="font-['Orbitron'] text-cyan-400 text-4xl" style={{ textShadow: '0 0 5px var(--cyan-glow)' }}>
        {value}
    </div>
);

export const HoloButton = ({ text }: { text: string }) => (
    <button className="holo-button">
        {text}
    </button>
);

export const ProgressBar = ({ progress }: { progress: number }) => (
    <div className="progress-bar">
        <div 
            className="progress-bar-inner" 
            style={{ width: `${progress}%` }}
        ></div>
    </div>
);

export const DataViz = ({ bars = 5 }: { bars?: number }) => (
    <div className="flex gap-1 items-end h-12">
        {Array.from({ length: bars }).map((_, i) => (
            <div 
                key={i}
                className="data-viz-bar" 
                style={{ animationDelay: `${i * 0.2}s` } as React.CSSProperties}
            ></div>
        ))}
    </div>
);

export const GlowingOrb = ({ color }: { color?: string }) => (
    <div 
        className="glowing-orb"
        style={{ 
            '--orb-color': color || 'var(--cyan-bright)',
            '--orb-glow': color ? '#FF8C00' : 'var(--cyan-glow)'
        } as React.CSSProperties}
    ></div>
);

// --- Core Components ---

export const HoloCard = ({ typeInfo }: { typeInfo: any }) => {
    const Component = typeInfo.component;
    return (
        <article className="holo-card">
            <div className="card-content">
                <div className="card-preview-content">
                    <Component {...typeInfo.props} />
                </div>
                <a className="fake-link" href="#">Link to post</a>
            </div>
        </article>
    );
};

export const ScrollingRow = ({ cards, duration, direction = 'left' }: { cards: any[], duration: string, direction?: 'left' | 'right' }) => {
    const rowContent = [...cards, ...cards]; // Duplicate for seamless animation

    return (
        <div className="grid-container">
            <div 
                className="scrolling-grid"
                style={{ 
                    '--scroll-duration': duration,
                    animationName: direction === 'left' ? 'scroll-left' : 'scroll-right',
                } as React.CSSProperties}
            >
                {rowContent.map((card, index) => <HoloCard key={`${card.id}-${index}`} typeInfo={card} />)}
            </div>
        </div>
    );
};

export const Starfield = () => <div className="starfield" />;
</file>

<file path="frontend/src/components/ui/search-bar.tsx">
"use client";

import type React from "react";
import { useEffect, useMemo, useRef, useState } from "react";
import { Search, CircleDot, Loader2 } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import type { TokenSearchResult } from "@/types/search";

const GooeyFilter = () => (
  <svg style={{ position: "absolute", width: 0, height: 0 }} aria-hidden="true">
    <defs>
      <filter id="gooey-effect">
        <feGaussianBlur in="SourceGraphic" stdDeviation="7" result="blur" />
        <feColorMatrix
          in="blur"
          type="matrix"
          values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -8"
          result="goo"
        />
        <feComposite in="SourceGraphic" in2="goo" operator="atop" />
      </filter>
    </defs>
  </svg>
);

interface SearchBarProps {
  placeholder?: string;
  value: string;
  onValueChange: (query: string) => void;
  results: TokenSearchResult[];
  loading?: boolean;
  error?: string | null;
  onSelectResult: (r: TokenSearchResult) => void;
}

const SearchBar = ({
  placeholder = "Search...",
  value,
  onValueChange,
  results,
  loading,
  error,
  onSelectResult,
}: SearchBarProps) => {
  const inputRef = useRef<HTMLInputElement>(null);
  const itemRefs = useRef<Array<HTMLDivElement | null>>([]);

  const [isFocused, setIsFocused] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  const [isClicked, setIsClicked] = useState(false);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const [activeIndex, setActiveIndex] = useState<number>(-1);

  const isUnsupportedBrowser = useMemo(() => {
    if (typeof window === "undefined") return false;
    const ua = navigator.userAgent.toLowerCase();
    const isSafari = ua.includes("safari") && !ua.includes("chrome") && !ua.includes("chromium");
    const isChromeOniOS = ua.includes("crios");
    return isSafari || isChromeOniOS;
  }, []);

  const showDropdown = isFocused && (results.length > 0 || Boolean(error));

  useEffect(() => {
    if (isFocused && inputRef.current) inputRef.current.focus();
  }, [isFocused]);

  useEffect(() => {
    // Reset active selection when results change.
    setActiveIndex(results.length ? 0 : -1);
    itemRefs.current = itemRefs.current.slice(0, results.length);
  }, [results.length, value]);

  useEffect(() => {
    if (activeIndex < 0) return;
    itemRefs.current[activeIndex]?.scrollIntoView({ block: "nearest" });
  }, [activeIndex]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!results.length) return;
    const idx = activeIndex >= 0 ? activeIndex : 0;
    const r = results[idx];
    if (!r) return;

    setIsAnimating(true);
    window.setTimeout(() => setIsAnimating(false), 700);
    onSelectResult(r);
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isFocused) return;
    const rect = e.currentTarget.getBoundingClientRect();
    setMousePosition({ x: e.clientX - rect.left, y: e.clientY - rect.top });
  };

  const handleClick = (e: React.MouseEvent) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setMousePosition({ x: e.clientX - rect.left, y: e.clientY - rect.top });
    setIsClicked(true);
    window.setTimeout(() => setIsClicked(false), 800);
  };

  const searchIconVariants = {
    initial: { scale: 1 },
    animate: {
      rotate: isAnimating ? [0, -15, 15, -10, 10, 0] : 0,
      scale: isAnimating ? [1, 1.2, 1] : 1,
      transition: { duration: 0.6, ease: "easeInOut" as const },
    },
  };

  const particles = Array.from({ length: isFocused ? 18 : 0 }, (_, i) => (
    <motion.div
      key={i}
      initial={{ scale: 0 }}
      animate={{
        x: [0, (Math.random() - 0.5) * 40],
        y: [0, (Math.random() - 0.5) * 40],
        scale: [0, Math.random() * 0.8 + 0.4],
        opacity: [0, 0.8, 0],
      }}
      transition={{
        duration: Math.random() * 1.5 + 1.5,
        ease: "easeInOut",
        repeat: Infinity,
        repeatType: "reverse",
      }}
      className="absolute w-3 h-3 rounded-full bg-accent/80"
      style={{
        left: `${Math.random() * 100}%`,
        top: `${Math.random() * 100}%`,
        filter: "blur(2px)",
      }}
    />
  ));

  const clickParticles = isClicked
    ? Array.from({ length: 14 }, (_, i) => (
        <motion.div
          key={`click-${i}`}
          initial={{ x: mousePosition.x, y: mousePosition.y, scale: 0, opacity: 1 }}
          animate={{
            x: mousePosition.x + (Math.random() - 0.5) * 160,
            y: mousePosition.y + (Math.random() - 0.5) * 160,
            scale: Math.random() * 0.8 + 0.2,
            opacity: [1, 0],
          }}
          transition={{ duration: Math.random() * 0.8 + 0.5, ease: "easeOut" }}
          className="absolute w-3 h-3 rounded-full"
          style={{
            background: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(
              Math.random() * 200
            ) + 55}, ${Math.floor(Math.random() * 255)}, 0.8)`,
            boxShadow: "0 0 8px rgba(255, 255, 255, 0.8)",
          }}
        />
      ))
    : null;

  return (
    <div className="relative w-full">
      <GooeyFilter />
      <motion.form
        onSubmit={handleSubmit}
        className="relative flex items-center justify-center w-full mx-auto"
        initial={{ width: "240px" }}
        animate={{ width: isFocused ? "340px" : "240px", scale: isFocused ? 1.05 : 1 }}
        transition={{ type: "spring", stiffness: 400, damping: 25 }}
        onMouseMove={handleMouseMove}
      >
        <motion.div
          className={cn(
            "flex items-center w-full rounded-full border relative overflow-hidden backdrop-blur-md",
            isFocused ? "border-accent/50 shadow-glow-accent" : "border-border bg-card/30"
          )}
          animate={{
            boxShadow: isClicked
              ? "0 0 40px hsl(var(--accent) / 0.5), 0 0 15px hsl(var(--primary) / 0.7) inset"
              : isFocused
              ? "0 0 30px hsl(var(--accent) / 0.4)"
              : "0 0 0 rgba(0, 0, 0, 0)",
          }}
          onClick={handleClick}
        >
          {isFocused && (
            <motion.div
              className="absolute inset-0 -z-10"
              initial={{ opacity: 0 }}
              animate={{
                opacity: 0.15,
                background: [
                  "linear-gradient(90deg, #f6d365 0%, #fda085 100%)",
                  "linear-gradient(90deg, #a1c4fd 0%, #c2e9fb 100%)",
                  "linear-gradient(90deg, #d4fc79 0%, #96e6a1 100%)",
                  "linear-gradient(90deg, #f6d365 0%, #fda085 100%)",
                ],
              }}
              transition={{ duration: 15, repeat: Infinity, ease: "linear" }}
            />
          )}

          <div
            className="absolute inset-0 overflow-hidden rounded-full -z-5"
            style={{ filter: isUnsupportedBrowser ? "none" : "url(#gooey-effect)" }}
          >
            {particles}
          </div>

          {isClicked && (
            <>
              <motion.div
                className="absolute inset-0 -z-5 rounded-full bg-accent/10"
                initial={{ scale: 0, opacity: 0.7 }}
                animate={{ scale: 2, opacity: 0 }}
                transition={{ duration: 0.8, ease: "easeOut" }}
              />
              <motion.div
                className="absolute inset-0 -z-5 rounded-full bg-white dark:bg-white/20"
                initial={{ opacity: 0.5 }}
                animate={{ opacity: 0 }}
                transition={{ duration: 0.3, ease: "easeOut" }}
              />
            </>
          )}

          {clickParticles}

          <motion.div className="pl-4 py-3" variants={searchIconVariants} initial="initial" animate="animate">
            <Search
              size={20}
              strokeWidth={isFocused ? 2.5 : 2}
              className={cn(
                "transition-all duration-300",
                isAnimating ? "text-accent" : isFocused ? "text-accent" : "text-muted-foreground"
              )}
            />
          </motion.div>

          <input
            ref={inputRef}
            type="text"
            placeholder={placeholder}
            value={value}
            onChange={(e) => onValueChange(e.target.value)}
            onFocus={() => setIsFocused(true)}
            onBlur={() => window.setTimeout(() => setIsFocused(false), 200)}
            onKeyDown={(e) => {
              if (!showDropdown) return;
              if (e.key === "ArrowDown") {
                e.preventDefault();
                setActiveIndex((i) => Math.min(results.length - 1, (i < 0 ? 0 : i + 1)));
              } else if (e.key === "ArrowUp") {
                e.preventDefault();
                setActiveIndex((i) => Math.max(0, (i < 0 ? 0 : i - 1)));
              } else if (e.key === "Escape") {
                setIsFocused(false);
              }
            }}
            className={cn(
              "w-full py-3 bg-transparent outline-none placeholder:text-muted-foreground font-medium text-base relative z-10",
              isFocused ? "text-foreground tracking-wide" : "text-foreground/80"
            )}
          />

          <AnimatePresence>
            {value.trim() && (
              <motion.button
                type="submit"
                initial={{ opacity: 0, scale: 0.8, x: -20 }}
                animate={{ opacity: 1, scale: 1, x: 0 }}
                exit={{ opacity: 0, scale: 0.8, x: -20 }}
                whileHover={{
                  scale: 1.05,
                  boxShadow: "0 10px 25px -5px hsl(var(--accent) / 0.5)",
                }}
                whileTap={{ scale: 0.95 }}
                className="px-4 py-2 mr-2 text-sm font-medium rounded-full bg-accent text-accent-foreground backdrop-blur-sm transition-all shadow-lg hover:shadow-glow-accent"
              >
                {loading ? <Loader2 className="h-4 w-4 animate-spin" /> : "Search"}
              </motion.button>
            )}
          </AnimatePresence>
        </motion.div>
      </motion.form>

      <AnimatePresence>
        {showDropdown && (
          <motion.div
            initial={{ opacity: 0, y: 10, height: 0 }}
            animate={{ opacity: 1, y: 0, height: "auto" }}
            exit={{ opacity: 0, y: 10, height: 0 }}
            transition={{ duration: 0.2 }}
            className="absolute z-10 w-full mt-2 overflow-hidden bg-card/90 backdrop-blur-md rounded-lg shadow-xl border border-border"
            style={{ maxHeight: "300px", overflowY: "auto" }}
          >
            <div className="p-2">
              {error ? (
                <div className="px-4 py-2 text-xs text-destructive">{error}</div>
              ) : results.length === 0 ? (
                <div className="px-4 py-2 text-xs text-muted-foreground">No results.</div>
              ) : (
                results.map((r, index) => (
                  <div
                    key={`${r.campaignAddress}-${r.symbol}`}
                    ref={(el) => {
                      itemRefs.current[index] = el;
                    }}
                    onMouseEnter={() => setActiveIndex(index)}
                    onMouseDown={(e) => e.preventDefault()}
                    onClick={() => onSelectResult(r)}
                    className={cn(
                      "flex items-center gap-2 px-4 py-2 cursor-pointer rounded-md hover:bg-accent/10 group",
                      activeIndex === index && "bg-accent/10"
                    )}
                  >
                    <CircleDot size={16} className="text-accent/70 group-hover:text-accent" />
                    <div className="min-w-0 flex-1">
                      <div className="flex items-center justify-between gap-3">
                        <span className="text-foreground group-hover:text-accent truncate">
                          {r.name}
                        </span>
                        <span className="text-[11px] text-muted-foreground font-mono">
                          {r.symbol}
                        </span>
                      </div>
                      <div className="text-[10px] text-muted-foreground font-mono truncate">
                        {r.campaignAddress}
                      </div>
                    </div>
                  </div>
                ))
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export { SearchBar };
</file>

<file path="frontend/src/components/ui/select.tsx">
import * as React from "react";
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label ref={ref} className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)} {...props} />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="frontend/src/components/ui/separator.tsx">
import * as React from "react";
import * as SeparatorPrimitive from "@radix-ui/react-separator";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(({ className, orientation = "horizontal", decorative = true, ...props }, ref) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn("shrink-0 bg-border", orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]", className)}
    {...props}
  />
));
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="frontend/src/components/ui/sheet.tsx">
import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<React.ElementRef<typeof SheetPrimitive.Content>, SheetContentProps>(
  ({ side = "right", className, children, ...props }, ref) => (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
        {children}
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity data-[state=open]:bg-secondary hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  ),
);
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title ref={ref} className={cn("text-lg font-semibold text-foreground", className)} {...props} />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};
</file>

<file path="frontend/src/components/ui/sidebar.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { VariantProps, cva } from "class-variance-authority";
import { PanelLeft } from "lucide-react";

import { useIsMobile } from "@/hooks/use-mobile";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent } from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

const SIDEBAR_COOKIE_NAME = "sidebar:state";
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = "16rem";
const SIDEBAR_WIDTH_MOBILE = "18rem";
const SIDEBAR_WIDTH_ICON = "3rem";
const SIDEBAR_KEYBOARD_SHORTCUT = "b";

type SidebarContext = {
  state: "expanded" | "collapsed";
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};

const SidebarContext = React.createContext<SidebarContext | null>(null);

function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.");
  }

  return context;
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean;
    open?: boolean;
    onOpenChange?: (open: boolean) => void;
  }
>(({ defaultOpen = true, open: openProp, onOpenChange: setOpenProp, className, style, children, ...props }, ref) => {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open],
  );

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === SIDEBAR_KEYBOARD_SHORTCUT && (event.metaKey || event.ctrlKey)) {
        event.preventDefault();
        toggleSidebar();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar]);

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed";

  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  );

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn("group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar", className)}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
});
SidebarProvider.displayName = "SidebarProvider";

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right";
    variant?: "sidebar" | "floating" | "inset";
    collapsible?: "offcanvas" | "icon" | "none";
  }
>(({ side = "left", variant = "sidebar", collapsible = "offcanvas", className, children, ...props }, ref) => {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();

  if (collapsible === "none") {
    return (
      <div
        className={cn("flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground", className)}
        ref={ref}
        {...props}
      >
        {children}
      </div>
    );
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-mobile="true"
          className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }

  return (
    <div
      ref={ref}
      className="group peer hidden text-sidebar-foreground md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          "relative h-svh w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]",
        )}
      />
      <div
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
            : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
        >
          {children}
        </div>
      </div>
    </div>
  );
});
Sidebar.displayName = "Sidebar";

const SidebarTrigger = React.forwardRef<React.ElementRef<typeof Button>, React.ComponentProps<typeof Button>>(
  ({ className, onClick, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <Button
        ref={ref}
        data-sidebar="trigger"
        variant="ghost"
        size="icon"
        className={cn("h-7 w-7", className)}
        onClick={(event) => {
          onClick?.(event);
          toggleSidebar();
        }}
        {...props}
      >
        <PanelLeft />
        <span className="sr-only">Toggle Sidebar</span>
      </Button>
    );
  },
);
SidebarTrigger.displayName = "SidebarTrigger";

const SidebarRail = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button">>(
  ({ className, ...props }, ref) => {
    const { toggleSidebar } = useSidebar();

    return (
      <button
        ref={ref}
        data-sidebar="rail"
        aria-label="Toggle Sidebar"
        tabIndex={-1}
        onClick={toggleSidebar}
        title="Toggle Sidebar"
        className={cn(
          "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] group-data-[side=left]:-right-4 group-data-[side=right]:left-0 hover:after:bg-sidebar-border sm:flex",
          "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
          "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
          "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
          "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
          "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarRail.displayName = "SidebarRail";

const SidebarInset = React.forwardRef<HTMLDivElement, React.ComponentProps<"main">>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className,
      )}
      {...props}
    />
  );
});
SidebarInset.displayName = "SidebarInset";

const SidebarInput = React.forwardRef<React.ElementRef<typeof Input>, React.ComponentProps<typeof Input>>(
  ({ className, ...props }, ref) => {
    return (
      <Input
        ref={ref}
        data-sidebar="input"
        className={cn(
          "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarInput.displayName = "SidebarInput";

const SidebarHeader = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="header" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarHeader.displayName = "SidebarHeader";

const SidebarFooter = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return <div ref={ref} data-sidebar="footer" className={cn("flex flex-col gap-2 p-2", className)} {...props} />;
});
SidebarFooter.displayName = "SidebarFooter";

const SidebarSeparator = React.forwardRef<React.ElementRef<typeof Separator>, React.ComponentProps<typeof Separator>>(
  ({ className, ...props }, ref) => {
    return (
      <Separator
        ref={ref}
        data-sidebar="separator"
        className={cn("mx-2 w-auto bg-sidebar-border", className)}
        {...props}
      />
    );
  },
);
SidebarSeparator.displayName = "SidebarSeparator";

const SidebarContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarContent.displayName = "SidebarContent";

const SidebarGroup = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  );
});
SidebarGroup.displayName = "SidebarGroup";

const SidebarGroupLabel = React.forwardRef<HTMLDivElement, React.ComponentProps<"div"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "div";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-label"
        className={cn(
          "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupLabel.displayName = "SidebarGroupLabel";

const SidebarGroupAction = React.forwardRef<HTMLButtonElement, React.ComponentProps<"button"> & { asChild?: boolean }>(
  ({ className, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";

    return (
      <Comp
        ref={ref}
        data-sidebar="group-action"
        className={cn(
          "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
          // Increases the hit area of the button on mobile.
          "after:absolute after:-inset-2 after:md:hidden",
          "group-data-[collapsible=icon]:hidden",
          className,
        )}
        {...props}
      />
    );
  },
);
SidebarGroupAction.displayName = "SidebarGroupAction";

const SidebarGroupContent = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div ref={ref} data-sidebar="group-content" className={cn("w-full text-sm", className)} {...props} />
  ),
);
SidebarGroupContent.displayName = "SidebarGroupContent";

const SidebarMenu = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(({ className, ...props }, ref) => (
  <ul ref={ref} data-sidebar="menu" className={cn("flex w-full min-w-0 flex-col gap-1", className)} {...props} />
));
SidebarMenu.displayName = "SidebarMenu";

const SidebarMenuItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ className, ...props }, ref) => (
  <li ref={ref} data-sidebar="menu-item" className={cn("group/menu-item relative", className)} {...props} />
));
SidebarMenuItem.displayName = "SidebarMenuItem";

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    isActive?: boolean;
    tooltip?: string | React.ComponentProps<typeof TooltipContent>;
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(({ asChild = false, isActive = false, variant = "default", size = "default", tooltip, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";
  const { isMobile, state } = useSidebar();

  const button = (
    <Comp
      ref={ref}
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );

  if (!tooltip) {
    return button;
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    };
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent side="right" align="center" hidden={state !== "collapsed" || isMobile} {...tooltip} />
    </Tooltip>
  );
});
SidebarMenuButton.displayName = "SidebarMenuButton";

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean;
    showOnHover?: boolean;
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform peer-hover/menu-button:text-sidebar-accent-foreground hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuAction.displayName = "SidebarMenuAction";

const SidebarMenuBadge = React.forwardRef<HTMLDivElement, React.ComponentProps<"div">>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-sidebar="menu-badge"
      className={cn(
        "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuBadge.displayName = "SidebarMenuBadge";

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean;
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && <Skeleton className="size-4 rounded-md" data-sidebar="menu-skeleton-icon" />}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  );
});
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton";

const SidebarMenuSub = React.forwardRef<HTMLUListElement, React.ComponentProps<"ul">>(
  ({ className, ...props }, ref) => (
    <ul
      ref={ref}
      data-sidebar="menu-sub"
      className={cn(
        "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  ),
);
SidebarMenuSub.displayName = "SidebarMenuSub";

const SidebarMenuSubItem = React.forwardRef<HTMLLIElement, React.ComponentProps<"li">>(({ ...props }, ref) => (
  <li ref={ref} {...props} />
));
SidebarMenuSubItem.displayName = "SidebarMenuSubItem";

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean;
    size?: "sm" | "md";
    isActive?: boolean;
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring aria-disabled:pointer-events-none aria-disabled:opacity-50 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className,
      )}
      {...props}
    />
  );
});
SidebarMenuSubButton.displayName = "SidebarMenuSubButton";

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};
</file>

<file path="frontend/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {
  return <div className={cn("animate-pulse rounded-md bg-muted", className)} {...props} />;
}

export { Skeleton };
</file>

<file path="frontend/src/components/ui/slider.tsx">
import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn("relative flex w-full touch-none select-none items-center", className)}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="frontend/src/components/ui/social-media.tsx">
import React from "react";
import { Link } from "react-router-dom";
import { cn } from "@/lib/utils";

// Define the type for a single social media item
export interface SocialItem {
  href: string;
  ariaLabel: string;
  tooltip: string;
  svgUrl: string;
  color: string;
}

// Define the props for the SocialTooltip component
export interface SocialTooltipProps extends React.HTMLAttributes<HTMLUListElement> {
  items: SocialItem[];
}

const SocialTooltip = React.forwardRef<HTMLUListElement, SocialTooltipProps>(
  ({ className, items, ...props }, ref) => {
    const baseIconStyles =
      "relative flex items-center justify-center w-10 h-10 rounded-full bg-transparent overflow-hidden transition-all duration-300 ease-in-out group-hover:shadow-lg";
    const baseSvgStyles =
      "relative z-10 w-5 h-5 grayscale brightness-75 transition-all duration-300 ease-in-out group-hover:grayscale-0 group-hover:brightness-100";
    const baseFilledStyles =
      "absolute bottom-0 left-0 w-full h-0 transition-all duration-300 ease-in-out group-hover:h-full";
    const baseTooltipStyles =
      "absolute bottom-[-40px] left-1/2 -translate-x-1/2 px-2.5 py-1.5 text-sm text-white whitespace-nowrap rounded-md opacity-0 invisible transition-all duration-300 ease-in-out group-hover:opacity-100 group-hover:visible group-hover:bottom-[-50px]";

    const isExternalHref = (href: string) => /^https?:\/\//i.test(href);

    return (
      <ul
        ref={ref}
        className={cn("flex items-center justify-center gap-3", className)}
        {...props}
      >
        {items.map((item, index) => {
          const external = isExternalHref(item.href);

          const Content = (
            <>
              <div className={cn(baseFilledStyles)} style={{ backgroundColor: item.color }} />
              <img src={item.svgUrl} alt={item.ariaLabel} className={cn(baseSvgStyles)} />
            </>
          );

          return (
            <li key={index} className="relative group">
              {external ? (
                <a
                  href={item.href}
                  aria-label={item.ariaLabel}
                  className={cn(baseIconStyles)}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  {Content}
                </a>
              ) : (
                <Link
                  to={item.href}
                  aria-label={item.ariaLabel}
                  className={cn(baseIconStyles)}
                >
                  {Content}
                </Link>
              )}

              <div className={cn(baseTooltipStyles)} style={{ backgroundColor: item.color }}>
                {item.tooltip}
              </div>
            </li>
          );
        })}
      </ul>
    );
  }
);

SocialTooltip.displayName = "SocialTooltip";

export { SocialTooltip };
</file>

<file path="frontend/src/components/ui/sonner.tsx">
import { useTheme } from "next-themes";
import { Toaster as Sonner, toast } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster, toast };
</file>

<file path="frontend/src/components/ui/space-background.tsx">
"use client"

import { useEffect, useRef, useState } from "react"

interface Particle {
  color: string
  radius: number
  x: number
  y: number
  ring: number
  move: number
  random: number
}

interface SpaceBackgroundProps {
  particleCount?: number
  particleColor?: string // override
  backgroundColor?: string
  className?: string
}

// --- Utility: parse RGB/hex colors ---
function parseRGB(cssColor: string) {
  if (!cssColor) return null
  cssColor = cssColor.trim()

  // hex
  if (cssColor[0] === "#") {
    let hex = cssColor.slice(1)
    if (hex.length === 3) hex = hex.split("").map((c) => c + c).join("")
    const r = parseInt(hex.slice(0, 2), 16)
    const g = parseInt(hex.slice(2, 4), 16)
    const b = parseInt(hex.slice(4, 6), 16)
    return [r, g, b]
  }

  // rgb/rgba
  const m = cssColor.match(/rgba?\(([^)]+)\)/)
  if (m) {
    const parts = m[1].split(",").map((s) => parseFloat(s.trim()))
    return [parts[0], parts[1], parts[2]]
  }

  return null
}

function luminanceFromRgb([r, g, b]: number[]) {
  const srgb = [r / 255, g / 255, b / 255].map((v) =>
    v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)
  )
  return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2]
}

export function SpaceBackground({
  particleCount = 450,
  particleColor = "blue",
  backgroundColor = "transparent",
  className = "",
}: SpaceBackgroundProps) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const animationRef = useRef<number | null>(null)
  const [resolvedColor, setResolvedColor] = useState<string | undefined>(undefined)

  // --- Detect effective background color ---
  const detectBackgroundColor = () => {
    if (backgroundColor && backgroundColor !== "transparent") return backgroundColor

    const candidates = [document.body, document.documentElement]
    for (const el of candidates) {
      if (!el) continue
      const cs = getComputedStyle(el)
      const bg = cs.backgroundColor || cs.background
      if (!bg) continue
      const rgb = parseRGB(bg)
      if (!rgb) continue

      if (/rgba/.test(bg)) {
        const alpha = parseFloat(bg.split(",").pop() || "1")
        if (isNaN(alpha) || alpha === 0) continue
      }
      return bg
    }

    const media = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)")
    return media && media.matches ? "black" : "white"
  }

  // --- Compute high contrast particle color ---
  useEffect(() => {
    if (particleColor) {
      setResolvedColor(particleColor)
      return
    }

    const setContrast = () => {
      let bg = detectBackgroundColor()
      if (!bg || bg === "transparent") {
        const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches
        bg = isDark ? "black" : "white"
      }

      const rgb = parseRGB(bg)
      if (rgb) {
        const lum = luminanceFromRgb(rgb)
        // improved opacity for visibility in light mode
        if (lum < 0.5) {
          setResolvedColor("rgba(255,255,255,0.85)") // dark background  bright stars
        } else {
          setResolvedColor("rgba(0,0,0,0.85)") // light background  visible dark stars
        }
      } else {
        const media = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)")
        setResolvedColor(media && media.matches ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.85)")
      }
    }

    setContrast()

    const media = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)")
    const onMedia = () => setContrast()
    if (media && media.addEventListener) media.addEventListener("change", onMedia)

    const mo = new MutationObserver(() => setTimeout(setContrast, 10))
    mo.observe(document.documentElement, { attributes: true, attributeFilter: ["class", "style"] })
    mo.observe(document.body, { attributes: true, attributeFilter: ["class", "style"] })

    return () => {
      if (media && media.removeEventListener) media.removeEventListener("change", onMedia)
      mo.disconnect()
    }
  }, [particleColor, backgroundColor])

  // --- Draw / animate ---
  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext("2d")
    if (!ctx) return
    if (!resolvedColor) return

    let ratio = window.innerHeight < 400 ? 0.6 : 1
    const state = {
      particles: [] as Particle[],
      r: 120,
      counter: 0,
    }

    const setupCanvas = () => {
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      ctx.setTransform(ratio, 0, 0, -ratio, canvas.width / 2, canvas.height / 2)
    }
    setupCanvas()

    const createParticle = () => {
      state.particles.push({
        color: resolvedColor,
        radius: Math.random() * 5,
        x: Math.cos(Math.random() * 7 + Math.PI) * state.r,
        y: Math.sin(Math.random() * 7 + Math.PI) * state.r,
        ring: Math.random() * state.r * 3,
        move: (Math.random() * 4 + 1) / 500,
        random: Math.random() * 7,
      })
    }
    for (let i = 0; i < particleCount; i++) createParticle()

    const moveParticle = (p: Particle) => {
      p.ring = Math.max(p.ring - 1, state.r)
      p.random += p.move
      p.x = Math.cos(p.random + Math.PI) * p.ring
      p.y = Math.sin(p.random + Math.PI) * p.ring
    }

    const resetParticle = (p: Particle) => {
      p.ring = Math.random() * state.r * 3
      p.radius = Math.random() * 5
    }

    const disappear = (p: Particle) => {
      if (p.radius < 0.8) resetParticle(p)
      p.radius *= 0.994
    }

    const draw = (p: Particle) => {
      ctx.beginPath()
      ctx.fillStyle = p.color
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2)
      ctx.fill()
    }

    const loop = () => {
      ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2)
      if (state.counter < state.particles.length) state.counter++
      for (let i = 0; i < state.counter; i++) {
        disappear(state.particles[i])
        moveParticle(state.particles[i])
        draw(state.particles[i])
      }
      animationRef.current = requestAnimationFrame(loop)
    }

    animationRef.current = requestAnimationFrame(loop)

    const handleResize = () => {
      ratio = window.innerHeight < 400 ? 0.6 : 1
      setupCanvas()
    }
    window.addEventListener("resize", handleResize)

    return () => {
      window.removeEventListener("resize", handleResize)
      if (animationRef.current) cancelAnimationFrame(animationRef.current)
    }
  }, [particleCount, resolvedColor])

  return (
    <canvas
      ref={canvasRef}
      className={className}
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: -1,
        display: "block",
        width: "100%",
        height: "100%",
        background: backgroundColor,
        pointerEvents: "none",
      }}
    />
  )
}
</file>

<file path="frontend/src/components/ui/switch.tsx">
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="frontend/src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<HTMLTableElement, React.HTMLAttributes<HTMLTableElement>>(
  ({ className, ...props }, ref) => (
    <div className="relative w-full overflow-auto">
      <table ref={ref} className={cn("w-full caption-bottom text-sm", className)} {...props} />
    </div>
  ),
);
Table.displayName = "Table";

const TableHeader = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />,
);
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tbody ref={ref} className={cn("[&_tr:last-child]:border-0", className)} {...props} />
  ),
);
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<HTMLTableSectionElement, React.HTMLAttributes<HTMLTableSectionElement>>(
  ({ className, ...props }, ref) => (
    <tfoot ref={ref} className={cn("border-t bg-muted/50 font-medium [&>tr]:last:border-b-0", className)} {...props} />
  ),
);
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<HTMLTableRowElement, React.HTMLAttributes<HTMLTableRowElement>>(
  ({ className, ...props }, ref) => (
    <tr
      ref={ref}
      className={cn("border-b transition-colors data-[state=selected]:bg-muted hover:bg-muted/50", className)}
      {...props}
    />
  ),
);
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<HTMLTableCellElement, React.ThHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <th
      ref={ref}
      className={cn(
        "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
        className,
      )}
      {...props}
    />
  ),
);
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<HTMLTableCellElement, React.TdHTMLAttributes<HTMLTableCellElement>>(
  ({ className, ...props }, ref) => (
    <td ref={ref} className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)} {...props} />
  ),
);
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<HTMLTableCaptionElement, React.HTMLAttributes<HTMLTableCaptionElement>>(
  ({ className, ...props }, ref) => (
    <caption ref={ref} className={cn("mt-4 text-sm text-muted-foreground", className)} {...props} />
  ),
);
TableCaption.displayName = "TableCaption";

export { Table, TableHeader, TableBody, TableFooter, TableHead, TableRow, TableCell, TableCaption };
</file>

<file path="frontend/src/components/ui/tabs.tsx">
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="frontend/src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="frontend/src/components/ui/toast.tsx">
import * as React from "react";
import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> & VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return <ToastPrimitives.Root ref={ref} className={cn(toastVariants({ variant }), className)} {...props} />;
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="frontend/src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast";
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "@/components/ui/toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && <ToastDescription>{description}</ToastDescription>}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="frontend/src/components/ui/toggle-group.tsx">
import * as React from "react";
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { toggleVariants } from "@/components/ui/toggle";

const ToggleGroupContext = React.createContext<VariantProps<typeof toggleVariants>>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root ref={ref} className={cn("flex items-center justify-center gap-1", className)} {...props}>
    <ToggleGroupContext.Provider value={{ variant, size }}>{children}</ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> & VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };
</file>

<file path="frontend/src/components/ui/toggle.tsx">
import * as React from "react";
import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline: "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> & VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root ref={ref} className={cn(toggleVariants({ variant, size, className }))} {...props} />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };
</file>

<file path="frontend/src/components/ui/tooltip.tsx">
import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="frontend/src/components/ui/use-toast.ts">
import { useToast, toast } from "@/hooks/use-toast";

export { useToast, toast };
</file>

<file path="frontend/src/constants/filters.ts">
export const FILTERS = ["All", "Bonding", "DEX", "New", "Trending"] as const;
export type FilterKey = (typeof FILTERS)[number];
</file>

<file path="frontend/src/constants/processingStages.ts">
/**
 * Token creation processing stages configuration
 */

export interface ProcessingStage {
  minProgress: number;
  maxProgress: number;
  label: string;
}

export const PROCESSING_STAGES: ProcessingStage[] = [
  { minProgress: 0, maxProgress: 25, label: "Initializing token creation..." },
  { minProgress: 25, maxProgress: 50, label: "Preparing blockchain deployment..." },
  { minProgress: 50, maxProgress: 75, label: "Deploying smart contract..." },
  { minProgress: 75, maxProgress: 90, label: "Verifying token on network..." },
  { minProgress: 90, maxProgress: 100, label: "Finalizing token setup..." },
];

export const PROCESSING_TIMING = {
  QUEUED_TO_RUNNING_DELAY: 800,
  PROGRESS_UPDATE_INTERVAL: 500,
  MIN_PROGRESS_INCREMENT: 5,
  MAX_PROGRESS_INCREMENT: 15,
  MAX_PROGRESS_THRESHOLD: 95,
  TOTAL_PROCESS_DURATION: 6000,
  SUCCESS_NAVIGATION_DELAY: 1000,
} as const;
</file>

<file path="frontend/src/constants/validation.ts">
/**
 * Form validation constants and schemas
 */

import { z } from "zod";

export const TOKEN_VALIDATION_LIMITS = {
  NAME_MAX_LENGTH: 100,
  TICKER_MAX_LENGTH: 10,
  DESCRIPTION_MAX_LENGTH: 1000,
} as const;

export const tokenSchema = z.object({
  name: z
    .string()
    .trim()
    .min(1, "Token name is required")
    .max(TOKEN_VALIDATION_LIMITS.NAME_MAX_LENGTH, `Token name must be less than ${TOKEN_VALIDATION_LIMITS.NAME_MAX_LENGTH} characters`),
  ticker: z
    .string()
    .trim()
    .min(1, "Ticker is required")
    .max(TOKEN_VALIDATION_LIMITS.TICKER_MAX_LENGTH, `Ticker must be less than ${TOKEN_VALIDATION_LIMITS.TICKER_MAX_LENGTH} characters`),
  description: z
    .string()
    .max(TOKEN_VALIDATION_LIMITS.DESCRIPTION_MAX_LENGTH, `Description must be less than ${TOKEN_VALIDATION_LIMITS.DESCRIPTION_MAX_LENGTH} characters`)
    .optional(),
  website: z.string().url("Invalid URL").optional().or(z.literal("")),
  twitter: z.string().url("Invalid URL").optional().or(z.literal("")),
  otherLink: z.string().url("Invalid URL").optional().or(z.literal("")),
});
</file>

<file path="frontend/src/hooks/use-mobile.tsx">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined);

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="frontend/src/hooks/use-toast.ts">
import * as React from "react";

import type { ToastActionElement, ToastProps } from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) => (t.id === action.toast.id ? { ...t, ...action.toast } : t)),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast };
</file>

<file path="frontend/src/hooks/useAblyTokenChannel.ts">
import { useEffect, useMemo, useState } from "react";
import Ably from "ably";

// Realtime-indexer HTTP base (Railway). Example: https://upmeme-production.up.railway.app
const API_BASE = String(import.meta.env.VITE_REALTIME_API_BASE || "").replace(/\/$/, "");

type Entry = {
  key: string;
  client: Ably.Realtime;
  channelName: string;
  channel: any;
  refs: number;
  closeTimer: any | null;
};

// Cache Ably connections per (chainId,campaign) to prevent multiple WebSockets
// being opened/closed within the same page. This eliminates the "reload" feel
// and prevents "WebSocket is closed before the connection is established" noise.
const CACHE = new Map<string, Entry>();

function channelNameFor(chainId: number, campaign: string) {
  return `token:${chainId}:${campaign.toLowerCase()}`;
}

function authUrlFor(chainId: number, campaign: string) {
  const base = String(API_BASE || "").replace(/\/$/, "");
  return `${base}/api/ably/token?chainId=${chainId}&campaign=${campaign.toLowerCase()}`;
}

function acquire(chainId: number, campaign: string) {
  const key = `${chainId}:${campaign.toLowerCase()}`;
  const existing = CACHE.get(key);
  if (existing) {
    existing.refs += 1;
    if (existing.closeTimer) {
      clearTimeout(existing.closeTimer);
      existing.closeTimer = null;
    }
    return existing;
  }

  const authUrl = authUrlFor(chainId, campaign);
  const client = new Ably.Realtime({
    authUrl,
    authMethod: "GET",
  });

  const chName = channelNameFor(chainId, campaign);
  const channel = client.channels.get(chName);

  // Rewind a short window so reconnects pick up recent updates.
  // This is safe even if publish frequency is low.
  try {
    channel.setOptions({ params: { rewind: "120s" } });
  } catch {
    // ignore
  }

  // Attach eagerly
  try {
    channel.attach();
  } catch {
    // ignore
  }

  const entry: Entry = {
    key,
    client,
    channelName: chName,
    channel,
    refs: 1,
    closeTimer: null,
  };
  CACHE.set(key, entry);
  return entry;
}

function release(key: string) {
  const entry = CACHE.get(key);
  if (!entry) return;
  entry.refs -= 1;
  if (entry.refs > 0) return;

  // Delay close slightly to avoid rapid open/close cycles during React rerenders
  // and route transitions, which can trigger "closed before established".
  entry.closeTimer = setTimeout(() => {
    try {
      entry.channel.unsubscribe();
    } catch {
      // ignore
    }
    try {
      entry.client.close();
    } catch {
      // ignore
    }
    CACHE.delete(key);
  }, 1500);
}

export function useAblyTokenChannel(opts: {
  enabled: boolean;
  chainId: number;
  campaignAddress?: string;
}) {
  const { enabled, chainId, campaignAddress } = opts;

  const key = useMemo(() => {
    if (!enabled || !campaignAddress) return "";
    return `${chainId}:${campaignAddress.toLowerCase()}`;
  }, [enabled, chainId, campaignAddress]);

  const [entry, setEntry] = useState<Entry | null>(null);

  useEffect(() => {
    if (!enabled || !campaignAddress) {
      setEntry(null);
      return;
    }
    if (!API_BASE) {
      setEntry(null);
      return;
    }
    const e = acquire(chainId, campaignAddress);
    setEntry(e);
    return () => {
      release(e.key);
    };
  }, [enabled, chainId, campaignAddress]);

  return {
    client: entry?.client ?? null,
    channel: entry?.channel ?? null,
    channelName: entry?.channelName ?? null,
    ready: Boolean(entry && entry.client && entry.channel),
    missingBase: enabled && !!campaignAddress && !API_BASE,
    cacheKey: key,
  };
}
</file>

<file path="frontend/src/hooks/useBnbUsdPrice.ts">
import { useEffect, useMemo, useState } from "react";

type BnbUsdState = {
  price: number | null;
  loading: boolean;
  error: string | null;
  updatedAt: number | null;
};

const STORAGE_KEY = "launchit:bnbUsdPrice:v1";
const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

function readCache(): { price: number; updatedAt: number } | null {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw) as { price?: unknown; updatedAt?: unknown };
    const price = typeof parsed.price === "number" ? parsed.price : null;
    const updatedAt = typeof parsed.updatedAt === "number" ? parsed.updatedAt : null;
    if (price == null || updatedAt == null) return null;
    return { price, updatedAt };
  } catch {
    return null;
  }
}

function writeCache(price: number) {
  try {
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ price, updatedAt: Date.now() })
    );
  } catch {
    // ignore
  }
}

/**
 * Fetches BNB/USD reference price for UI conversions (e.g., Market Cap in USD).
 * Source: CoinGecko simple price endpoint.
 *
 * Notes:
 * - Best-effort utility for display purposes only.
 * - Uses localStorage caching to reduce request volume.
 */
export function useBnbUsdPrice(enabled: boolean = true, refreshMs: number = 60_000): BnbUsdState {
  const cached = useMemo(() => (typeof window !== "undefined" ? readCache() : null), []);

  const [price, setPrice] = useState<number | null>(cached?.price ?? null);
  const [updatedAt, setUpdatedAt] = useState<number | null>(cached?.updatedAt ?? null);
  const [loading, setLoading] = useState<boolean>(enabled && !(cached && Date.now() - cached.updatedAt < CACHE_TTL_MS));
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!enabled) return;

    let cancelled = false;
    let intervalId: number | undefined;

    const fetchPrice = async () => {
      try {
        setError(null);

        const cache = readCache();
        if (cache && Date.now() - cache.updatedAt < CACHE_TTL_MS) {
          if (!cancelled) {
            setPrice(cache.price);
            setUpdatedAt(cache.updatedAt);
            setLoading(false);
          }
          return;
        }

        setLoading(true);

        const res = await fetch(
          "https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd",
          { headers: { Accept: "application/json" } }
        );

        if (!res.ok) throw new Error(`BNB price fetch failed (${res.status})`);
        const data = (await res.json()) as any;

        const p = Number(data?.binancecoin?.usd);
        if (!Number.isFinite(p) || p <= 0) throw new Error("Invalid BNB/USD price");

        writeCache(p);

        if (!cancelled) {
          setPrice(p);
          setUpdatedAt(Date.now());
          setLoading(false);
        }
      } catch (e: any) {
        if (!cancelled) {
          setLoading(false);
          setError(e?.message ? String(e.message) : "BNB price fetch failed");
        }
      }
    };

    fetchPrice();
    intervalId = window.setInterval(fetchPrice, refreshMs);

    return () => {
      cancelled = true;
      if (intervalId) window.clearInterval(intervalId);
    };
  }, [enabled, refreshMs]);

  return { price, loading, error, updatedAt };
}
</file>

<file path="frontend/src/hooks/useDexPairTrades.ts">
import { Contract, ethers } from "ethers";
import { useEffect, useMemo, useRef, useState } from "react";
import { getReadProvider } from "@/lib/readProvider";
import { getActiveChainId, type SupportedChainId } from "@/lib/chainConfig";

const PAIR_ABI = [
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
  "event Sync(uint112 reserve0, uint112 reserve1)",
] as const;

export type DexPricePoint = {
  timestamp: number; // seconds
  pricePerToken: number; // paired asset per token (usually WBNB per token)
  txHash: string;
  blockNumber: number;
};

type Args = {
  tokenAddress?: string;
  pairAddress?: string;
  enabled?: boolean;
  chainId?: number;
  lookbackBlocks?: number;
  pollIntervalMs?: number;
};

const isAddress = (a?: string | null) => /^0x[a-fA-F0-9]{40}$/.test(String(a ?? ""));

export function useDexPairTrades(args: Args) {
  const enabled = args.enabled ?? true;
  const chainId = getActiveChainId(args.chainId ?? null) as SupportedChainId;
  const lookbackBlocks = Math.max(1_000, Number(args.lookbackBlocks ?? 30_000));
  const pollIntervalMs = Math.max(7_500, Number(args.pollIntervalMs ?? 20_000));

  const tokenAddress = useMemo(() => (args.tokenAddress ?? "").trim().toLowerCase(), [args.tokenAddress]);
  const pairAddress = useMemo(() => (args.pairAddress ?? "").trim(), [args.pairAddress]);

  const [points, setPoints] = useState<DexPricePoint[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const tsCacheRef = useRef<Map<number, number>>(new Map());

  useEffect(() => {
    if (!enabled) return;

    if (!isAddress(tokenAddress) || !isAddress(pairAddress)) {
      setPoints([]);
      setLoading(false);
      setError(null);
      return;
    }

    let cancelled = false;
    const provider = getReadProvider(chainId);

    const load = async () => {
      try {
        setLoading(true);
        setError(null);

        const latest = await provider.getBlockNumber();
        const fromBlock = Math.max(0, latest - lookbackBlocks);

        const pair = new Contract(pairAddress, PAIR_ABI, provider) as any;

        const [t0, t1] = await Promise.all([pair.token0(), pair.token1()]);
        const token0 = String(t0).toLowerCase();
        const token1 = String(t1).toLowerCase();

        const tokenIs0 = tokenAddress === token0;
        const tokenIs1 = tokenAddress === token1;
        if (!tokenIs0 && !tokenIs1) {
          // Pair does not contain this token (misconfigured)
          if (!cancelled) {
            setPoints([]);
            setError("Pair does not contain token");
          }
          return;
        }

        const syncTopic = pair.filters.Sync().topicHash;

        const logs: any[] = [];
        const step = 2_000;
        for (let start = fromBlock; start <= latest; start += step) {
          const end = Math.min(latest, start + step - 1);
          const chunk = await provider.getLogs({
            address: pairAddress,
            fromBlock: start,
            toBlock: end,
            topics: [syncTopic],
          });
          logs.push(...chunk);
        }

        logs.sort((a, b) => (a.blockNumber - b.blockNumber) || (a.logIndex - b.logIndex));

        // Resolve timestamps with caching
        const uniqueBlocks = Array.from(new Set(logs.map((l) => Number(l.blockNumber)))).filter((n) => Number.isFinite(n));
        const missing = uniqueBlocks.filter((bn) => !tsCacheRef.current.has(bn));
        for (const bn of missing) {
          const b = await provider.getBlock(bn);
          const ts = Number(b?.timestamp ?? 0);
          if (ts) tsCacheRef.current.set(bn, ts);
        }

        const next: DexPricePoint[] = logs.map((log) => {
          const parsed = pair.interface.parseLog(log);
          const reserve0 = BigInt(parsed?.args?.reserve0 ?? 0n);
          const reserve1 = BigInt(parsed?.args?.reserve1 ?? 0n);

          // Assume 18 decimals for both sides (good enough for WBNB + most MemeBattles tokens).
          // If you introduce non-18 decimals, we should fetch decimals from ERC20s and normalize.
          const r0 = Number(ethers.formatUnits(reserve0, 18));
          const r1 = Number(ethers.formatUnits(reserve1, 18));

          let price = 0;
          if (tokenIs0) price = r0 > 0 ? r1 / r0 : 0;
          else price = r1 > 0 ? r0 / r1 : 0;

          const bn = Number(log.blockNumber);
          const ts = tsCacheRef.current.get(bn) ?? 0;

          return {
            timestamp: ts,
            pricePerToken: Number.isFinite(price) ? price : 0,
            txHash: String(log.transactionHash),
            blockNumber: bn,
          };
        });

        if (!cancelled) setPoints(next);
      } catch (e: any) {
        console.warn("[useDexPairTrades] failed", e);
        if (!cancelled) setError(e?.message ?? "Failed to load DEX data");
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    const t = setInterval(load, pollIntervalMs);

    return () => {
      cancelled = true;
      clearInterval(t);
    };
  }, [enabled, tokenAddress, pairAddress, chainId, lookbackBlocks, pollIntervalMs]);

  return { points, loading, error };
}
</file>

<file path="frontend/src/hooks/useDexScreenerChart.ts">
import { useEffect, useState } from "react";

// "Chart only" query params
const CHART_QUERY =
  "embed=1&theme=dark&chartTheme=dark&tabs=0&trades=0&info=0&interval=15";

const buildChartOnlyUrl = (base: string) =>
  base.includes("?") ? `${base}&${CHART_QUERY}` : `${base}?${CHART_QUERY}`;

type DexChartState = {
  url?: string;
  baseUrl?: string; // non-embed page URL
  liquidityBnb?: number; // best-effort, only when quote is BNB/WBNB
  loading: boolean;
  error?: string;
};

export function useDexScreenerChart(tokenAddress?: string): DexChartState {
  const [url, setUrl] = useState<string | undefined>();
  const [baseUrl, setBaseUrl] = useState<string | undefined>();
  const [liquidityBnb, setLiquidityBnb] = useState<number | undefined>();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();

  useEffect(() => {
    setUrl(undefined);
    setBaseUrl(undefined);
    setLiquidityBnb(undefined);
    setError(undefined);

    if (!tokenAddress) return;

    let cancelled = false;

    const load = async () => {
      try {
        setLoading(true);
        setError(undefined);

        const res = await fetch(
          `https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`
        );

        if (!res.ok) {
          throw new Error(`DexScreener HTTP ${res.status}`);
        }

        const data = await res.json();
        const pairs: any[] = data.pairs ?? [];

        if (!pairs.length) {
          if (!cancelled) setUrl(undefined);
          return;
        }

        // Prefer BSC + Pancake pair; fallback to first
        const bestPair =
          pairs.find(
            (p) =>
              p.chainId?.toLowerCase() === "bsc" &&
              p.dexId?.toLowerCase().includes("pancake")
          ) ?? pairs[0];

        if (!bestPair) {
          if (!cancelled) setUrl(undefined);
          return;
        }

        const chain = bestPair.chainId;
        const pairAddress = bestPair.pairAddress;
        const base = `https://dexscreener.com/${chain}/${pairAddress}`;

        // Best-effort liquidity in BNB equivalent.
        // DexScreener provides liquidity.usd and priceUsd/priceNative for the base token.
        // If the quote token is BNB/WBNB, we can estimate bnbUsd = priceUsd / priceNative.
        const quoteSym = (bestPair.quoteToken?.symbol ?? "").toUpperCase();
        const liqUsd = Number(bestPair.liquidity?.usd ?? NaN);
        const priceUsd = Number(bestPair.priceUsd ?? NaN);
        const priceNative = Number(bestPair.priceNative ?? NaN);

        let liqBnb: number | undefined;
        if ((quoteSym === "BNB" || quoteSym === "WBNB") && Number.isFinite(liqUsd) && Number.isFinite(priceUsd) && Number.isFinite(priceNative) && priceNative > 0) {
          const bnbUsd = priceUsd / priceNative;
          if (Number.isFinite(bnbUsd) && bnbUsd > 0) {
            liqBnb = liqUsd / bnbUsd;
          }
        }

        if (!cancelled) {
          setBaseUrl(base);
          setUrl(buildChartOnlyUrl(base));
          setLiquidityBnb(liqBnb);
        }
      } catch (e: any) {
        console.error("DexScreener fetch failed", e);
        if (!cancelled) {
          setError(e?.message || "Failed to load chart");
          setUrl(undefined);
          setBaseUrl(undefined);
          setLiquidityBnb(undefined);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();

    return () => {
      cancelled = true;
    };
  }, [tokenAddress]);

  return { url, baseUrl, liquidityBnb, loading, error };
}
</file>

<file path="frontend/src/hooks/useTokenForm.ts">
/**
 * Custom hook for managing token creation form state
 */

import { useState } from "react";
import { toast } from "sonner";
import { TokenCategory, TokenFormData } from "@/types/token";

const initialFormData: TokenFormData = {
  name: "",
  ticker: "",
  description: "",
  category: "meme",
  image: null,
  imagePreview: "",
  website: "",
  twitter: "",
  otherLink: "",
  showSocialLinks: false,
};

export const useTokenForm = () => {
  const [formData, setFormData] = useState<TokenFormData>(initialFormData);

  const setTokenName = (name: string) => {
    setFormData((prev) => ({ ...prev, name }));
  };

  const setTicker = (ticker: string) => {
    setFormData((prev) => ({ ...prev, ticker: ticker.toUpperCase() }));
  };

  const setDescription = (description: string) => {
    setFormData((prev) => ({ ...prev, description }));
  };

  const setCategory = (category: TokenCategory) => {
    setFormData((prev) => ({ ...prev, category }));
  };

  const setWebsite = (website: string) => {
    setFormData((prev) => ({ ...prev, website }));
  };

  const setTwitter = (twitter: string) => {
    setFormData((prev) => ({ ...prev, twitter }));
  };

  const setOtherLink = (otherLink: string) => {
    setFormData((prev) => ({ ...prev, otherLink }));
  };

  const setShowSocialLinks = (show: boolean) => {
    setFormData((prev) => ({ ...prev, showSocialLinks: show }));
  };

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setFormData((prev) => ({ ...prev, image: file }));
      
      const reader = new FileReader();
      reader.onloadend = () => {
        setFormData((prev) => ({ ...prev, imagePreview: reader.result as string }));
      };
      reader.readAsDataURL(file);
      toast.success("Image uploaded successfully!");
    }
  };

  const handleRemoveImage = () => {
    setFormData((prev) => ({ ...prev, image: null, imagePreview: "" }));
  };

  const handleReset = () => {
    setFormData(initialFormData);
    toast.success("Form reset!");
  };

  const clearSocialLinks = () => {
    setFormData((prev) => ({
      ...prev,
      showSocialLinks: false,
      website: "",
      twitter: "",
      otherLink: "",
    }));
  };

  return {
    formData,
    setTokenName,
    setTicker,
    setDescription,
    setCategory,
    setWebsite,
    setTwitter,
    setOtherLink,
    setShowSocialLinks,
    handleImageChange,
    handleRemoveImage,
    handleReset,
    clearSocialLinks,
  };
};
</file>

<file path="frontend/src/hooks/useTokenRealtime.ts">
import { useEffect, useMemo, useRef, useState } from "react";
import Ably from "ably";

const API_BASE = import.meta.env.VITE_REALTIME_API_BASE as string;

export type RealtimeTrade = {
  type: "trade";
  chainId: number;
  token: string; // campaign
  txHash: string;
  logIndex: number;
  side: "buy" | "sell";
  wallet: string;
  tokenAmount: string;
  bnbAmount: string;
  priceBnb: string | null;
  ts: number; // seconds
  blockNumber: number;
};

export type StatsPatch = {
  type: "stats_patch";
  lastPriceBnb: string | null;
  marketcapBnb: string | null;
  vol24hBnb: string | null;
};

export type CandleUpsert = {
  type: "candle_upsert";
  tf: string;
  bucket: number;
  c?: string;
  v?: string;
};

type Msg = RealtimeTrade | StatsPatch | CandleUpsert;

function tokenChannel(chainId: number, campaign: string) {
  return `token:${chainId}:${campaign.toLowerCase()}`;
}

// simple batching to prevent render storms
function useBatchedQueue<T>(flushMs = 250) {
  const queueRef = useRef<T[]>([]);
  const [, setTick] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      if (queueRef.current.length > 0) setTick((x) => x + 1);
    }, flushMs);
    return () => clearInterval(id);
  }, [flushMs]);

  return queueRef;
}

export function useTokenRealtime(chainId: number, campaign: string) {
  const [connected, setConnected] = useState(false);
  const [messagesTick, setMessagesTick] = useState(0);

  const tradesRef = useRef<Map<string, RealtimeTrade>>(new Map());
  const lastStatsRef = useRef<StatsPatch | null>(null);

  const queueRef = useBatchedQueue<Msg>(250);

  // expose stable arrays for UI
  const trades = useMemo(() => {
    // on each tick, rebuild sorted array
    const arr = Array.from(tradesRef.current.values());
    arr.sort((a, b) => (b.blockNumber - a.blockNumber) || (b.logIndex - a.logIndex));
    return arr;
  }, [messagesTick]);

  const stats = useMemo(() => lastStatsRef.current, [messagesTick]);

  useEffect(() => {
    if (!API_BASE || !campaign) return;

    const base = String(API_BASE || "").replace(/\/$/, "");
const client = new Ably.Realtime({
  authUrl: `${base}/api/ably/token?chainId=${chainId}&campaign=${campaign.toLowerCase()}`,
  authMethod: "GET",
});

    const chName = tokenChannel(chainId, campaign);
    const channel = client.channels.get(chName);

    // connection state
    client.connection.on((stateChange) => {
      setConnected(stateChange.current === "connected");
    });

    // Rewind last ~2 minutes of messages to avoid missing on refresh/reconnect
    // Ably supports rewind on attach via channel params.
    // If you prefer a fixed message count, use `rewind=100`.
    channel.setOptions({ params: { rewind: "120s" } });

    const applyMsg = (msg: Msg) => {
      if (msg.type === "trade") {
        const key = `${msg.txHash.toLowerCase()}:${msg.logIndex}`;
        tradesRef.current.set(key, msg);
      } else if (msg.type === "stats_patch") {
        lastStatsRef.current = msg;
      }
      // candles are handled by your chart component; well wire that next
    };

    const flush = () => {
      const q = queueRef.current;
      if (q.length === 0) return;
      const batch = q.splice(0, q.length);
      for (const m of batch) applyMsg(m);
      setMessagesTick((x) => x + 1);
    };

    const flushId = setInterval(flush, 250);

    channel.subscribe((message) => {
      const data = message.data as Msg;
      if (!data || typeof data !== "object") return;
      queueRef.current.push(data);
    });

    channel.attach();

    return () => {
      clearInterval(flushId);
      channel.unsubscribe();
      client.close();
    };
  }, [chainId, campaign]);

  return { connected, trades, stats };
}
</file>

<file path="frontend/src/hooks/useTokenSearch.ts">
import { useEffect, useMemo, useRef, useState } from "react";
import type { CampaignInfo } from "@/lib/launchpadClient";
import type { TokenSearchResult } from "@/types/search";
import { searchTokensRemote } from "@/lib/searchClient";

function normalize(s: string): string {
  return (s ?? "").toLowerCase().trim();
}

function scoreCampaign(query: string, c: CampaignInfo): number {
  const q = normalize(query);
  const sym = normalize(c.symbol ?? "");
  const name = normalize(c.name ?? "");
  const addr = normalize(c.campaign ?? "");
  if (!q) return 0;

  // Exact matches first
  if (sym === q) return 1000;
  if (name === q) return 900;

  // Prefix matches
  if (sym.startsWith(q)) return 800;
  if (name.startsWith(q)) return 700;

  // Substring matches
  if (sym.includes(q)) return 600;
  if (name.includes(q)) return 500;
  if (addr.includes(q)) return 400;

  return 0;
}

function localSearch(query: string, campaigns: CampaignInfo[], limit: number): TokenSearchResult[] {
  const q = normalize(query);
  if (q.length < 2) return [];

  const ranked = (campaigns ?? [])
    .filter((c) => !!c && typeof c.symbol === "string" && typeof c.name === "string")
    .map((c) => ({ c, score: scoreCampaign(q, c) }))
    .filter((x) => x.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit)
    .map(({ c }) => ({
      campaignAddress: String(c.campaign ?? "").toLowerCase(),
      tokenAddress: (c as any)?.token ? String((c as any).token).toLowerCase() : undefined,
      name: c.name,
      symbol: c.symbol,
      status: "unknown" as const,
      logoURI: (c as any).logoURI ? String((c as any).logoURI) : undefined,
    }))
    .filter((r) => /^0x[a-f0-9]{40}$/.test(r.campaignAddress));

  return ranked;
}

export function useTokenSearch(
  query: string,
  campaigns?: CampaignInfo[],
  opts?: { limit?: number; debounceMs?: number }
) {
  const limit = opts?.limit ?? 10;
  const debounceMs = opts?.debounceMs ?? 250;

  const [results, setResults] = useState<TokenSearchResult[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const abortRef = useRef<AbortController | null>(null);

  const localResults = useMemo(() => {
    return campaigns ? localSearch(query, campaigns, limit) : [];
  }, [campaigns, query, limit]);

  useEffect(() => {
    const q = (query ?? "").trim();
    setError(null);

    // For short queries, just show local results (likely empty)
    if (q.length < 2) {
      setResults([]);
      setLoading(false);
      return;
    }

    // Always show local results immediately (fast UI)
    setResults(localResults);

    // Remote search is optional; only attempt if env var is present.
    const apiBase = String((import.meta as any).env?.VITE_SEARCH_API_URL ?? "").trim();
    if (!apiBase) {
      setLoading(false);
      return;
    }

    setLoading(true);
    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    const t = window.setTimeout(async () => {
      try {
        const remote = await searchTokensRemote(q, { limit, signal: controller.signal });
        // Merge: prefer remote, but fall back to local if remote returns empty
        setResults(remote.length ? remote : localResults);
      } catch (e: any) {
        if (e?.name === "AbortError") return;
        setError("Search failed");
        setResults(localResults);
      } finally {
        setLoading(false);
      }
    }, debounceMs);

    return () => {
      window.clearTimeout(t);
      controller.abort();
    };
  }, [query, limit, debounceMs, localResults]);

  return { results, loading, error };
}
</file>

<file path="frontend/src/hooks/useTokenStatsRealtime.ts">
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { getActiveChainId, type SupportedChainId } from "@/lib/chainConfig";
import { useAblyTokenChannel } from "@/hooks/useAblyTokenChannel";

const API_BASE = String(import.meta.env.VITE_REALTIME_API_BASE || "").replace(/\/$/, "");

export type TokenStatsRealtime = {
  lastPriceBnb: number | null;
  marketcapBnb: number | null;
  vol24hBnb: number;
  soldTokens: number | null;
  updatedAt?: string;
};

async function fetchJson(url: string, signal?: AbortSignal) {
  const r = await fetch(url, { method: "GET", signal });
  if (!r.ok) {
    const text = await r.text().catch(() => "");
    throw new Error(text || `HTTP ${r.status}`);
  }
  return r.json();
}

function num(v: unknown): number | null {
  if (v == null) return null;
  const n = typeof v === "number" ? v : Number(String(v));
  return Number.isFinite(n) ? n : null;
}

export function useTokenStatsRealtime(campaignAddress?: string, chainId?: number, enabled = true) {
  const [stats, setStats] = useState<TokenStatsRealtime | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const initialLoadedRef = useRef(false);

  const cid = useMemo<SupportedChainId>(() => getActiveChainId(Number(chainId ?? 97)), [chainId]);

  const url = useMemo(() => {
    if (!API_BASE || !campaignAddress) return "";
    return `${API_BASE}/api/token/${campaignAddress.toLowerCase()}/summary?chainId=${cid}`;
  }, [campaignAddress, cid]);

  const pull = useCallback(async (signal?: AbortSignal) => {
    if (!enabled || !campaignAddress) {
      setStats(null);
      setLoading(false);
      setError(null);
      return;
    }
    if (!url) {
      setError("Missing VITE_REALTIME_API_BASE");
      setLoading(false);
      return;
    }
    try {
      if (!initialLoadedRef.current) setLoading(true);
      const row = await fetchJson(url, signal);
      if (!row) {
        setStats(null);
        setError(null);
        return;
      }
      setStats({
        lastPriceBnb: num(row.last_price_bnb),
        marketcapBnb: num(row.marketcap_bnb),
        vol24hBnb: Number(num(row.vol_24h_bnb) ?? 0),
        soldTokens: num(row.sold_tokens),
        updatedAt: String(row.updated_at ?? ""),
      });
      setError(null);
      initialLoadedRef.current = true;
    } catch (e: any) {
      setError(String(e?.message || "Failed to load token stats"));
    } finally {
      setLoading(false);
    }
  }, [enabled, campaignAddress, url]);

  // Initial + reconcile polling (lightweight)
  useEffect(() => {
    const ac = new AbortController();
    setLoading(true);
    setError(null);
    initialLoadedRef.current = false;
    pull(ac.signal);
    if (!enabled || !campaignAddress) return () => ac.abort();
    const t = setInterval(() => pull(ac.signal), 15_000);
    return () => {
      clearInterval(t);
      ac.abort();
    };
  }, [enabled, campaignAddress, cid, pull]);

  // Ably live patches (shared channel; avoids multiple WebSockets per TokenDetails page)
  const ably = useAblyTokenChannel({ enabled: enabled && !!campaignAddress, chainId: cid, campaignAddress });
  useEffect(() => {
    if (!enabled || !campaignAddress) return;
    if (ably.missingBase || !ably.channel || !ably.client) return;

    const onStats = (msg: any) => {
      const data: any = msg?.data;
      if (!data) return;
      if ((msg?.name || "") !== "stats_patch" && String(data.type || "") !== "stats_patch") return;

      setStats((prev) => {
        const next: TokenStatsRealtime = {
          lastPriceBnb: num(data.lastPriceBnb) ?? prev?.lastPriceBnb ?? null,
          marketcapBnb: num(data.marketcapBnb) ?? prev?.marketcapBnb ?? null,
          vol24hBnb: Number(num(data.vol24hBnb) ?? prev?.vol24hBnb ?? 0),
          soldTokens: prev?.soldTokens ?? null,
          updatedAt: prev?.updatedAt,
        };
        return next;
      });
    };

    const onConn = (c: any) => {
      if (c?.current === "connected") pull();
    };

    try {
      ably.client.connection.on(onConn);
    } catch {
      // ignore
    }
    try {
      ably.channel.subscribe("stats_patch", onStats);
    } catch {
      // ignore
    }

    return () => {
      try { ably.channel.unsubscribe("stats_patch", onStats); } catch {}
      try { ably.client.connection.off(onConn); } catch {}
    };
  }, [enabled, campaignAddress, cid, pull, ably.channel, ably.client, ably.missingBase]);

  return { stats, loading, error };
}
</file>

<file path="frontend/src/hooks/useWallet.ts">
import { BrowserProvider, JsonRpcSigner } from "ethers";
import { useCallback, useEffect, useMemo, useState } from "react";

export type WalletType = "metamask" | "binance" | "injected";

type WalletHook = {
  provider: BrowserProvider | null;
  signer: JsonRpcSigner | null;
  account: string;
  chainId?: number;
  connecting: boolean;
  connect: (wallet?: WalletType) => Promise<void>;
  disconnect: () => void;          // <- ADD THIS
  isConnected: boolean;
};

export function useWallet(): WalletHook {
  const [provider, setProvider] = useState<BrowserProvider | null>(null);
  const [signer, setSigner] = useState<JsonRpcSigner | null>(null);
  const [account, setAccount] = useState("");
  const [chainId, setChainId] = useState<number>();
  const [connecting, setConnecting] = useState(false);

  // Detect default wallet on mount (for read-only state)
  useEffect(() => {
    if (typeof window === "undefined") return;

    const anyWindow = window as any;
    const ethereum = anyWindow.ethereum;
    if (!ethereum) {
      return;
    }

    // Prefer MetaMask if multiple providers are injected
    const injected = ethereum.providers?.find?.((p: any) => p.isMetaMask) || ethereum;

    if (!injected || typeof injected.request !== "function") return;
    // IMPORTANT (ethers v6): BrowserProvider throws NETWORK_ERROR if the wallet
    // changes networks after the provider is created. So we recreate the
    // BrowserProvider on chainChanged.
    let browserProvider = new BrowserProvider(injected);
    setProvider(browserProvider);

    const handleAccountsChanged = (accounts: string[]) => {
      const primary = accounts[0] ?? "";
      setAccount(primary);

      if (!primary) {
        setSigner(null);
        return;
      }

      browserProvider
        .getSigner()
        .then((s) => setSigner(s))
        .catch(() => setSigner(null));
    };

    const handleChainChanged = (hexChainId: string) => {
      try {
        setChainId(Number(BigInt(hexChainId)));
      } catch {
        setChainId(undefined);
      }

      // Recreate provider + signer to avoid "network changed" errors.
      try {
        browserProvider = new BrowserProvider(injected);
        setProvider(browserProvider);
        // Refresh signer based on current accounts
        browserProvider
          .send("eth_accounts", [])
          .then(handleAccountsChanged)
          .catch(() => setSigner(null));
      } catch {
        // ignore
      }
    };

    // Initialize from current accounts
    browserProvider
      .send("eth_accounts", [])
      .then(handleAccountsChanged)
      .catch(() => {});

    // Initialize from current network
    browserProvider
      .getNetwork()
      .then((network) => setChainId(Number(network.chainId)))
      .catch(() => {});

    injected?.on?.("accountsChanged", handleAccountsChanged);
    injected?.on?.("chainChanged", handleChainChanged);

    return () => {
      injected?.removeListener?.("accountsChanged", handleAccountsChanged);
      injected?.removeListener?.("chainChanged", handleChainChanged);
    };
  }, []);

  // Helper: pick a specific injected wallet
  const pickInjected = (wallet: WalletType | undefined) => {
    const anyWindow = window as any;
    const ethereum = anyWindow.ethereum;
    if (!ethereum) return null;

    const providers = ethereum.providers || [ethereum];

    if (wallet === "metamask") {
      return providers.find((p: any) => p.isMetaMask) || providers[0];
    }

    if (wallet === "binance") {
      // Many Binance wallets expose isBinance or similar
      return providers.find((p: any) => p.isBinance) || providers[0];
    }

    // Generic injected fallback
    return providers[0];
  };

  const connect = useCallback(
    async (wallet?: WalletType) => {
      if (typeof window === "undefined") {
        throw new Error("No browser environment detected.");
      }

      const selected = pickInjected(wallet);
      if (!selected) {
        throw new Error("No EVM wallet found. Please install MetaMask or another BSC-capable wallet.");
      }

      setConnecting(true);
      try {
        // Request accounts from the selected provider
        const accounts: string[] = await selected.request({
          method: "eth_requestAccounts",
        });

        if (!accounts || accounts.length === 0) {
          throw new Error("No accounts returned from wallet.");
        }

        const browserProvider = new BrowserProvider(selected);
        setProvider(browserProvider);
        setAccount(accounts[0]);

        const signer = await browserProvider.getSigner();
        setSigner(signer);

        const network = await browserProvider.getNetwork();
        setChainId(Number(network.chainId));

        // Optional: enforce a BSC chain (read from env if you want)
        // const targetChain = import.meta.env.VITE_TARGET_CHAIN_ID; // e.g. "56" or "97"
        // if (targetChain && Number(network.chainId) !== Number(targetChain)) {
        //   const chainIdHex = "0x" + Number(targetChain).toString(16);
        //   try {
        //     await selected.request({
        //       method: "wallet_switchEthereumChain",
        //       params: [{ chainId: chainIdHex }],
        //     });
        //   } catch (e) {
        //     console.warn("Failed to switch chain", e);
        //   }
        // }
      } finally {
        setConnecting(false);
      }
    },
    []
  );
 const disconnect = useCallback(() => {
    setAccount("");
    setSigner(null);
    // We keep provider so read-only RPC still works; 
    // if you want a hard reset you could also do: setProvider(null);
  }, []);
  return useMemo(
    () => ({
      provider,
      signer,
      account,
      chainId,
      connecting,
      connect,
      disconnect,          // <- ADD THIS
      isConnected: Boolean(account),
    }),
    [provider, signer, account, chainId, connecting, connect, disconnect]
  );
}
</file>

<file path="frontend/src/lib/chainConfig.ts">
// src/lib/chainConfig.ts
// Centralized chain + env config for MemeBattles (BSC mainnet + testnet).
//
// Design goal:
// - Reads follow the wallet's connected chain (if allowed), otherwise fall back to default chain.
// - No redeploy needed to switch between testnet/mainnet; only switch the wallet network.

export type SupportedChainId = 56 | 97;

const DEFAULT_ALLOWED: SupportedChainId[] = [56, 97];
const DEFAULT_CHAIN: SupportedChainId = 97;

const parseCsvNumbers = (raw?: string): number[] => {
  if (!raw) return [];
  return raw
    .split(",")
    .map((s) => Number(String(s).trim()))
    .filter((n) => Number.isFinite(n) && n > 0);
};

export function getAllowedChainIds(): SupportedChainId[] {
  const raw = import.meta.env.VITE_ALLOWED_CHAIN_IDS as string | undefined;
  const parsed = parseCsvNumbers(raw) as SupportedChainId[];
  return parsed.length ? parsed : DEFAULT_ALLOWED;
}

export function getDefaultChainId(): SupportedChainId {
  const raw =
    (import.meta.env.VITE_DEFAULT_CHAIN_ID as string | undefined) ??
    (import.meta.env.VITE_TARGET_CHAIN_ID as string | undefined); // backward-compat
  const n = Number(raw);
  return (Number.isFinite(n) ? (n as SupportedChainId) : DEFAULT_CHAIN) ?? DEFAULT_CHAIN;
}

export function isAllowedChainId(chainId?: number | null): boolean {
  if (!chainId) return false;
  return getAllowedChainIds().includes(chainId as SupportedChainId);
}

export function getActiveChainId(walletChainId?: number | null): SupportedChainId {
  if (walletChainId && isAllowedChainId(walletChainId)) return walletChainId as SupportedChainId;
  return getDefaultChainId();
}

export function getPublicRpcUrl(chainId: SupportedChainId): string {
  // NOTE: In Vite, only VITE_* env vars are exposed to the frontend bundle.
  // We support comma-separated lists for redundancy.

  const normalize = (u: string) => {
    const s = u.trim();
    // common typo: "https//" (missing colon)
    if (s.startsWith("https//")) return "https:" + s.slice("https".length);
    if (s.startsWith("http//")) return "http:" + s.slice("http".length);
    return s;
  };

  const firstFromCsv = (raw?: string) => {
    if (!raw) return "";
    const parts = String(raw)
      .split(",")
      .map((p) => normalize(p))
      .filter(Boolean);
    return parts[0] ?? "";
  };

  // Preferred env keys (explicit per-chain)
  const explicit =
    (import.meta.env[`VITE_PUBLIC_RPC_${chainId}`] as string | undefined) ??
    (import.meta.env[`VITE_BSC_RPC_${chainId}`] as string | undefined);

  const explicitFirst = firstFromCsv(explicit);
  if (explicitFirst) return explicitFirst;

  // Secondary env keys (common naming)
  if (chainId === 56) {
    const v =
      (import.meta.env.VITE_BSC_MAINNET_RPC as string | undefined) ??
      (import.meta.env.VITE_PUBLIC_RPC_MAINNET as string | undefined);
    const vFirst = firstFromCsv(v);
    if (vFirst) return vFirst;
    return "https://bsc-dataseed.binance.org/";
  }

  // 97
  const v =
    (import.meta.env.VITE_BSC_TESTNET_RPC as string | undefined) ??
    (import.meta.env.VITE_PUBLIC_RPC_TESTNET as string | undefined);
  const vFirst = firstFromCsv(v);
  if (vFirst) return vFirst;
  return "https://data-seed-prebsc-1-s1.binance.org:8545/";
}

// For redundancy: get *all* configured public RPC URLs for a chain.
export function getPublicRpcUrls(chainId: SupportedChainId): string[] {
  const normalize = (u: string) => {
    const s = u.trim();
    if (s.startsWith("https//")) return "https:" + s.slice("https".length);
    if (s.startsWith("http//")) return "http:" + s.slice("http".length);
    return s;
  };

  const fromCsv = (raw?: string) => {
    if (!raw) return [];
    return String(raw)
      .split(",")
      .map((p) => normalize(p))
      .filter((p) => Boolean(p));
  };

  const explicit =
    (import.meta.env[`VITE_PUBLIC_RPC_${chainId}`] as string | undefined) ??
    (import.meta.env[`VITE_BSC_RPC_${chainId}`] as string | undefined);

  const explicitList = fromCsv(explicit);
  if (explicitList.length) return explicitList;

  if (chainId === 56) {
    const v =
      (import.meta.env.VITE_BSC_MAINNET_RPC as string | undefined) ??
      (import.meta.env.VITE_PUBLIC_RPC_MAINNET as string | undefined);
    const list = fromCsv(v);
    return list.length ? list : ["https://bsc-dataseed.binance.org/"];
  }

  const v =
    (import.meta.env.VITE_BSC_TESTNET_RPC as string | undefined) ??
    (import.meta.env.VITE_PUBLIC_RPC_TESTNET as string | undefined);
  const list = fromCsv(v);
  return list.length ? list : ["https://data-seed-prebsc-1-s1.binance.org:8545/"];
}

export function getFactoryAddress(chainId: SupportedChainId): string {
  // Preferred per-chain vars
  const perChain = (import.meta.env[`VITE_FACTORY_ADDRESS_${chainId}`] as string | undefined) ?? "";
  if (perChain.trim()) return perChain.trim();

  // Backward-compat single var
  const fallback = (import.meta.env.VITE_FACTORY_ADDRESS as string | undefined) ?? "";
  return fallback.trim();
}

export function getVoteTreasuryAddress(chainId: SupportedChainId): string {
  // Preferred per-chain vars
  const perChain = (import.meta.env[`VITE_VOTE_TREASURY_ADDRESS_${chainId}`] as string | undefined) ?? "";
  if (perChain.trim()) return perChain.trim();

  // Backward-compat single var
  const fallback = (import.meta.env.VITE_VOTE_TREASURY_ADDRESS as string | undefined) ?? "";
  return fallback.trim();
}

export function getExplorerTxBase(chainId: SupportedChainId): string {
  return chainId === 97 ? "https://testnet.bscscan.com/tx/" : "https://bscscan.com/tx/";
}

export function getChainParams(chainId: SupportedChainId) {
  if (chainId === 56) {
    return {
      chainId: "0x38",
      chainName: "BNB Smart Chain",
      nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
      rpcUrls: [getPublicRpcUrl(56)],
      blockExplorerUrls: ["https://bscscan.com/"],
    };
  }
  return {
    chainId: "0x61",
    chainName: "BNB Smart Chain Testnet",
    nativeCurrency: { name: "tBNB", symbol: "tBNB", decimals: 18 },
    rpcUrls: [getPublicRpcUrl(97)],
    blockExplorerUrls: ["https://testnet.bscscan.com/"],
  };
}
</file>

<file path="frontend/src/lib/chart/buildCandles.ts">
// src/lib/chart/buildCandles.ts

/**
 * Generic chart input point.
 * You control what "value" represents (e.g. marketCapUsd).
 */
export type CurveTradePoint = {
  ts: number; // milliseconds
  value: number; // e.g. marketCapUsd
  volume?: number; // optional (USD)
};

export type Candle = {
  time: number; // unix seconds (Lightweight Charts format)
  open: number;
  high: number;
  low: number;
  close: number;
};

export type VolumeBar = {
  time: number; // unix seconds
  value: number;
  color?: string;
};

type BuildOpts = {
  /** If true, fills gaps and extends candles up to "now" with flat candles. */
  extendToNow?: boolean;
  /** Override "now" (unix seconds). Defaults to current time. */
  nowSec?: number;
};

function bucketStartSec(tsMs: number, intervalSec: number): number {
  const tSec = Math.floor(tsMs / 1000);
  return Math.floor(tSec / intervalSec) * intervalSec;
}

/**
 * Build OHLC candles from raw points.
 *
 * TradingView-like behavior:
 * - When a new bucket starts, OPEN = previous candle CLOSE.
 *   This ensures you get a visible candle body even if there is only 1 trade in that bucket.
 * - Fills missing buckets with flat candles.
 * - If extendToNow is enabled, extends to the current bucket with flat candles.
 */
export function buildCandles(
  points: CurveTradePoint[],
  intervalSec: number,
  opts?: BuildOpts
): { candles: Candle[]; volumes: VolumeBar[] } {
  const extendToNow = !!opts?.extendToNow;
  const nowSec = Math.floor(opts?.nowSec ?? Date.now() / 1000);

  if (!intervalSec || intervalSec <= 0) return { candles: [], volumes: [] };

  const sorted = (points || [])
    .filter((p) => Number.isFinite(p.ts) && Number.isFinite(p.value))
    .slice()
    .sort((a, b) => a.ts - b.ts);

  if (sorted.length === 0) return { candles: [], volumes: [] };

  const candles: Candle[] = [];
  const volumes: VolumeBar[] = [];

  const pushBucket = (bucketSec: number, o: number, h: number, l: number, c: number, v: number) => {
    candles.push({ time: bucketSec, open: o, high: h, low: l, close: c });
    volumes.push({ time: bucketSec, value: v });
  };

  // Initialize first bucket from first point
  let curBucket = bucketStartSec(sorted[0].ts, intervalSec);
  let open = sorted[0].value;
  let high = sorted[0].value;
  let low = sorted[0].value;
  let close = sorted[0].value;
  let vol = sorted[0].volume ?? 0;

  for (let i = 1; i < sorted.length; i++) {
    const p = sorted[i];
    const bSec = bucketStartSec(p.ts, intervalSec);

    if (bSec !== curBucket) {
      // finalize current bucket
      pushBucket(curBucket, open, high, low, close, vol);

      const prevClose = close;

      // fill gaps with flat candles (prevClose)
      if (bSec > curBucket + intervalSec) {
        let fill = curBucket + intervalSec;
        while (fill < bSec) {
          pushBucket(fill, prevClose, prevClose, prevClose, prevClose, 0);
          fill += intervalSec;
        }
      }

      // start NEW bucket with TradingView-like OPEN = prevClose
      curBucket = bSec;
      open = prevClose;
      high = Math.max(prevClose, p.value);
      low = Math.min(prevClose, p.value);
      close = p.value;
      vol = p.volume ?? 0;
      continue;
    }

    // same bucket update
    high = Math.max(high, p.value);
    low = Math.min(low, p.value);
    close = p.value;
    vol += p.volume ?? 0;
  }

  // finalize last real bucket
  pushBucket(curBucket, open, high, low, close, vol);

  // extend to now with flat candles
  if (extendToNow) {
    const endBucket = Math.floor(nowSec / intervalSec) * intervalSec;
    let fill = curBucket + intervalSec;
    while (fill <= endBucket) {
      pushBucket(fill, close, close, close, close, 0);
      fill += intervalSec;
    }
  }

  return { candles, volumes };
}
</file>

<file path="frontend/src/lib/chart/CurveTradesChart.tsx">
// src/lib/chart/CurveTradesChart.tsx
// TradingView-style chart using TradingView Lightweight Charts (free).

import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  createChart,
  CrosshairMode,
  ColorType,
  CandlestickSeries,
  type IChartApi,
} from "lightweight-charts";

import { buildCandles, type CurveTradePoint } from "@/lib/chart/buildCandles";

type Props = {
  /** Points with ts in ms and value in USD marketcap. */
  points: CurveTradePoint[];
  /** Candle interval (seconds): 5, 60, 300, 900, 3600 */
  intervalSec: number;
  /** Optional fixed height (px). If omitted, fills container height. */
  height?: number;
};

function formatUsd(n: number) {
  if (!Number.isFinite(n)) return "";
  const abs = Math.abs(n);
  const sign = n < 0 ? "-" : "";
  const v = Math.abs(n);

  if (abs >= 1_000_000_000) return `${sign}$${(v / 1_000_000_000).toFixed(2)}B`;
  if (abs >= 1_000_000) return `${sign}$${(v / 1_000_000).toFixed(2)}M`;
  if (abs >= 1_000) return `${sign}$${(v / 1_000).toFixed(1)}K`;
  return `${sign}$${v.toFixed(2)}`;
}

export const CurveTradesChart: React.FC<Props> = ({ points, intervalSec, height }) => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const chartRef = useRef<IChartApi | null>(null);
  const candleSeriesRef = useRef<any>(null);
  const roRef = useRef<ResizeObserver | null>(null);

  // Desired candle width in pixels. We compute how many bars to show from container width
  // so candles look consistent across timeframes and when resizing.
  const DESIRED_BAR_PX = 10;
  // On small screens we may only fit ~1530 bars at the desired pixel width.
  // Keep this low to avoid squeezing candles into sub-pixel widths.
  const MIN_VISIBLE_BARS = 20;
  const MAX_VISIBLE_BARS = 260;

  const lastBarCountRef = useRef(0);

  // Re-render once per second so we always extend candles to "now"
  const [nowTick, setNowTick] = useState(0);
  useEffect(() => {
    const id = window.setInterval(() => setNowTick((x) => x + 1), 1000);
    return () => window.clearInterval(id);
  }, []);

  // Build candles (fills gaps + extends to now)
  const { candles } = useMemo(() => {
    const nowSec = Math.floor(Date.now() / 1000);
    return buildCandles(points ?? [], intervalSec, { extendToNow: true, nowSec });
  }, [points, intervalSec, nowTick]);

  // Fit only once per interval to avoid "jumping" during realtime updates
  const fittedRef = useRef<{ intervalSec: number; fitted: boolean }>({ intervalSec, fitted: false });

  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;

    roRef.current?.disconnect();
    roRef.current = null;

    if (chartRef.current) {
      chartRef.current.remove();
      chartRef.current = null;
    }

    fittedRef.current = { intervalSec, fitted: false };

    const rect = el.getBoundingClientRect();
    const initW = Math.max(10, rect.width || el.clientWidth || 10);
    const inferredH = rect.height || el.clientHeight || 360;
    const initH = Math.max(200, height ?? inferredH);

    const chart = createChart(el, {
      width: initW,
      height: initH,

      layout: {
        background: { type: ColorType.Solid, color: "transparent" },
        textColor: "rgba(255,255,255,0.72)",
      },

      // Horizontal grid lines only (price), no vertical time lines
      grid: {
        vertLines: { visible: false },
        horzLines: { visible: true, color: "rgba(255,255,255,0.06)" },
      },

      crosshair: { mode: CrosshairMode.Normal },

      rightPriceScale: {
        visible: true,
        autoScale: true,
        borderVisible: true,
        borderColor: "rgba(255,255,255,0.18)",
        ticksVisible: true,
        textColor: "rgba(255,255,255,0.90)",
        minimumWidth: 80, // ensures the full price ladder is visible
        scaleMargins: { top: 0.08, bottom: 0.08 },
      },

      timeScale: {
        borderVisible: true,
        borderColor: "rgba(255,255,255,0.12)",
        timeVisible: true,
        secondsVisible: intervalSec <= 60,
        rightOffset: 6,
        // Keep candles readable; actual visible bar count is computed from width.
        barSpacing: DESIRED_BAR_PX,
        minBarSpacing: Math.max(4, Math.floor(DESIRED_BAR_PX * 0.7)),
        lockVisibleTimeRangeOnResize: true,
        fixLeftEdge: true,
        fixRightEdge: true,
      },

      handleScroll: {
        mouseWheel: true,
        pressedMouseMove: true,
        horzTouchDrag: true,
        vertTouchDrag: false,
      },
      handleScale: {
        mouseWheel: true,
        pinch: true,
        axisPressedMouseMove: { time: true, price: true },
      },
    });

    // v5 API: addSeries(SeriesDefinition, options)
    const candleSeries = chart.addSeries(CandlestickSeries, {
      upColor: "#26a69a",
      downColor: "#ef5350",
      // Borders help visually separate doji/flat candles (otherwise they can look like a continuous line).
      borderVisible: true,
      borderUpColor: "rgba(38,166,154,0.95)",
      borderDownColor: "rgba(239,83,80,0.95)",
      wickUpColor: "#26a69a",
      wickDownColor: "#ef5350",
      priceLineVisible: true,
      lastValueVisible: true,
      priceFormat: {
        type: "custom",
        minMove: 0.01,
        formatter: (p: number) => formatUsd(p),
      },
    });

    // Extra safety: force right scale ladder visibility
    chart.priceScale("right").applyOptions({
      ticksVisible: true,
      textColor: "rgba(255,255,255,0.90)",
      borderColor: "rgba(255,255,255,0.18)",
      minimumWidth: 80,
    });

    chartRef.current = chart;
    candleSeriesRef.current = candleSeries;

    const ro = new ResizeObserver(() => {
      const c = containerRef.current;
      if (!c) return;
      const r = c.getBoundingClientRect();
      const w = Math.max(10, r.width || c.clientWidth || 10);
      const inferred = r.height || c.clientHeight || 360;
      const h2 = Math.max(200, height ?? inferred);
      chart.applyOptions({ width: w, height: h2 });

      // Keep the visual candle width consistent after resize.
      chart.timeScale().applyOptions({
        barSpacing: DESIRED_BAR_PX,
        minBarSpacing: Math.max(4, Math.floor(DESIRED_BAR_PX * 0.7)),
      });

       const bars = lastBarCountRef.current;
       if (bars > 5) {
         const visibleBars = Math.max(
           MIN_VISIBLE_BARS,
           Math.min(MAX_VISIBLE_BARS, Math.floor(w / DESIRED_BAR_PX))
         );
         const from = Math.max(0, bars - visibleBars);
         const to = bars + 5;
         chart.timeScale().setVisibleLogicalRange({ from, to });
       }
    });

    ro.observe(el);
    roRef.current = ro;

    return () => {
      ro.disconnect();
      roRef.current = null;
      chart.remove();
      chartRef.current = null;
      candleSeriesRef.current = null;
    };
  }, [height, intervalSec]);

  useEffect(() => {
    const series = candleSeriesRef.current;
    if (!series) return;

    series.setData(candles as any);

    lastBarCountRef.current = candles.length;

    if (fittedRef.current.intervalSec !== intervalSec) {
      fittedRef.current = { intervalSec, fitted: false };
    }

    // Initial auto-range per timeframe (show last N bars based on container width)
    const chart = chartRef.current;
    const el = containerRef.current;
    if (!chart || !el) return;

    if (!fittedRef.current.fitted && candles.length > 5) {
      const w = Math.max(10, el.getBoundingClientRect().width || el.clientWidth || 10);

      // Ensure bar spacing stays consistent (users can still zoom; this establishes the default).
      chart.timeScale().applyOptions({
        barSpacing: DESIRED_BAR_PX,
        minBarSpacing: Math.max(4, Math.floor(DESIRED_BAR_PX * 0.7)),
      });

      const visibleBars = Math.max(
        MIN_VISIBLE_BARS,
        Math.min(MAX_VISIBLE_BARS, Math.floor(w / DESIRED_BAR_PX))
      );
      const from = Math.max(0, candles.length - visibleBars);
      const to = candles.length + 5;
      chart.timeScale().setVisibleLogicalRange({ from, to });
      fittedRef.current.fitted = true;
    }
  }, [candles, intervalSec]);

  return (
    <div style={{ width: "100%", height: height ? `${height}px` : "100%" }}>
      {/* Inner wrapper defines the exact drawing box (prevents 'cut off' look in padded cards). */}
      <div
        style={{
          width: "100%",
          height: "100%",
          position: "relative",
          paddingLeft: 8,
          paddingRight: 12, // room for the right price scale
        }}
      >
        <div ref={containerRef} style={{ position: "absolute", inset: 0 }} />
      </div>
    </div>
  );
};
</file>

<file path="frontend/src/lib/followApi.ts">
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL as string;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY as string;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase env vars (VITE_SUPABASE_URL / VITE_SUPABASE_ANON_KEY)');
}

const supabase = createClient(supabaseUrl, supabaseAnonKey);

export async function followUser(followingId: string): Promise<void> {
  const { error } = await supabase
    .from('user_follows')
    .insert({ following_id: followingId.toLowerCase() });
  if (error) throw error;
}

export async function unfollowUser(followingId: string): Promise<void> {
  const { error } = await supabase
    .from('user_follows')
    .delete()
    .eq('following_id', followingId.toLowerCase());
  if (error) throw error;
}

export async function isFollowingUser(followingId: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('user_follows')
    .select('id')
    .eq('following_id', followingId.toLowerCase())
    .maybeSingle();
  if (error && error.code !== 'PGRST116') throw error;
  return !!data;
}

export async function getFollowersCount(userId: string): Promise<number> {
  const { count, error } = await supabase
    .from('user_follows')
    .select('*', { count: 'exact', head: true })
    .eq('following_id', userId.toLowerCase());
  if (error) throw error;
  return count ?? 0;
}

export async function getFollowingCount(userId: string): Promise<number> {
  const { count, error } = await supabase
    .from('user_follows')
    .select('*', { count: 'exact', head: true })
    .eq('follower_id', userId.toLowerCase());
  if (error) throw error;
  return count ?? 0;
}

export async function getFollowers(userId: string) {
  const { data, error } = await supabase
    .from('user_follows')
    .select('follower_id, profiles!inner(*)')
    .eq('following_id', userId.toLowerCase());
  if (error) throw error;
  return (data || []).map(d => ({ id: d.follower_id, profile: d.profiles }));
}

export async function getFollowing(userId: string) {
  const { data, error } = await supabase
    .from('user_follows')
    .select('following_id, profiles!inner(*)')
    .eq('follower_id', userId.toLowerCase());
  if (error) throw error;
  return (data || []).map(d => ({ id: d.following_id, profile: d.profiles }));
}

// Campaign follows
export async function followCampaign(campaignAddress: string): Promise<void> {
  const { error } = await supabase
    .from('campaign_follows')
    .insert({ campaign_address: campaignAddress.toLowerCase() });
  if (error) throw error;
}

export async function unfollowCampaign(campaignAddress: string): Promise<void> {
  const { error } = await supabase
    .from('campaign_follows')
    .delete()
    .eq('campaign_address', campaignAddress.toLowerCase());
  if (error) throw error;
}

export async function isFollowingCampaign(campaignAddress: string): Promise<boolean> {
  const { data, error } = await supabase
    .from('campaign_follows')
    .select('id')
    .eq('campaign_address', campaignAddress.toLowerCase())
    .maybeSingle();
  if (error && error.code !== 'PGRST116') throw error;
  return !!data;
}

export async function getFollowedCampaigns(userId: string): Promise<string[]> {
  const { data, error } = await supabase
    .from('campaign_follows')
    .select('campaign_address')
    .eq('user_id', userId.toLowerCase());
  if (error) throw error;
  return (data || []).map(d => d.campaign_address);
}
</file>

<file path="frontend/src/lib/profileApi.ts">
/**
 * Client for the repo's Vercel functions:
 * - GET  /api/profile?chainId=...&address=...
 * - POST /api/profile
 * - GET  /api/auth/nonce?chainId=...&address=...
 */

export type UserProfile = {
  chainId: number;
  address: string;
  displayName: string | null;
  bio: string | null;
  avatarUrl: string | null;
  updatedAt?: string | null;
};

const rawBase = String(import.meta.env.VITE_API_BASE_URL ?? "").trim();
const API_BASE = rawBase.replace(/\/$/, "");

function buildUrl(pathWithQuery: string): string {
  // Absolute base URL: VITE_API_BASE_URL=https://<your-vercel-domain>
  if (API_BASE && /^https?:\/\//i.test(API_BASE)) {
    return `${API_BASE}${pathWithQuery.startsWith("/") ? pathWithQuery : `/${pathWithQuery}`}`;
  }
  // Default: same-origin /api/*
  return new URL(pathWithQuery, window.location.origin).toString();
}

async function readJson(res: Response): Promise<any> {
  const text = await res.text();
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function normalizeAddress(addr: string): string {
  return String(addr ?? "").trim().toLowerCase();
}

export function buildProfileMessage(args: {
  chainId: number;
  address: string;
  nonce: string;
  displayName?: string | null;
  avatarUrl?: string | null;
}): string {
  // Must match frontend/api/profile.js exactly.
  const name = String(args.displayName ?? "").trim().slice(0, 32);
  const avatar = String(args.avatarUrl ?? "").trim().slice(0, 200);
  return [
    "MemeBattles Profile",
    "Action: PROFILE_UPSERT",
    `ChainId: ${args.chainId}`,
    `Address: ${normalizeAddress(args.address)}`,
    `Nonce: ${args.nonce}`,
    "",
    `DisplayName: ${name}`,
    `AvatarUrl: ${avatar}`,
  ].join("\n");
}

export async function fetchUserProfile(chainId: number, address: string): Promise<UserProfile | null> {
  const addr = normalizeAddress(address);
  const url = buildUrl(
    `/api/profile?chainId=${encodeURIComponent(String(chainId))}&address=${encodeURIComponent(addr)}`
  );

  const res = await fetch(url, { method: "GET" });
  if (!res.ok) {
    // If API isn't available in local dev, fail gracefully.
    if (res.status === 404) return null;
    const j = await readJson(res);
    throw new Error(j?.error || `Failed to load profile (${res.status})`);
  }

  const j = await readJson(res);
  const p = j?.profile ?? null;
  if (!p) return null;

  return {
    chainId: Number(p.chainId ?? chainId),
    address: String(p.address ?? addr),
    displayName: (p.displayName ?? null) as string | null,
    avatarUrl: (p.avatarUrl ?? null) as string | null,
    bio: (p.bio ?? null) as string | null,
    updatedAt: (p.updatedAt ?? null) as string | null,
  };
}

export async function requestNonce(chainId: number, address: string): Promise<string> {
  const addr = normalizeAddress(address);
  const url = buildUrl(
    `/api/auth/nonce?chainId=${encodeURIComponent(String(chainId))}&address=${encodeURIComponent(addr)}`
  );
  const res = await fetch(url, { method: "GET" });
  if (!res.ok) {
    const j = await readJson(res);
    throw new Error(j?.error || `Nonce request failed (${res.status})`);
  }
  const j = await res.json();
  if (!j?.nonce) throw new Error("Nonce missing");
  return String(j.nonce);
}

export type SaveProfileInput = {
  chainId: number;
  address: string;
  displayName: string | null;
  bio: string | null;
  avatarUrl: string | null;
  nonce: string;
  signature: string;
};

export async function saveUserProfile(input: SaveProfileInput): Promise<void> {
  const url = buildUrl(`/api/profile`);
  const res = await fetch(url, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      chainId: input.chainId,
      address: normalizeAddress(input.address),
      displayName: input.displayName,
      avatarUrl: input.avatarUrl,
      bio: input.bio,
      nonce: input.nonce,
      signature: input.signature,
    }),
  });

  if (!res.ok) {
    const j = await readJson(res);
    throw new Error(j?.error || `Failed to save profile (${res.status})`);
  }
}
</file>

<file path="frontend/src/lib/readProvider.ts">
import { ethers } from "ethers";
import { getPublicRpcUrls, type SupportedChainId } from "./chainConfig";

// Cache 1 read provider per chain id
const providerCache = new Map<number, ethers.AbstractProvider>();

function networkName(chainId: number) {
  return chainId === 56 ? "bsc" : "bsc-testnet";
}

/**
 * Read-only JSON-RPC provider for public data (logs, reads).
 *
 * IMPORTANT:
 * - We DISABLE batching (batchMaxCount: 1) because public BSC endpoints
 *   often rate-limit when getLogs requests are batched.
 * - We set staticNetwork to avoid extra "detectNetwork" chatter.
 */
export function getReadProvider(chainId: SupportedChainId): ethers.AbstractProvider {
  const cached = providerCache.get(chainId);
  if (cached) return cached as any;

  const urls = getPublicRpcUrls(chainId);
  if (!urls.length) throw new Error(`Missing public RPC url for chainId=${chainId}`);

  // Pin network to avoid ethers "network changed" errors when the wallet/network flips or
  // when an endpoint is flaky during detection.
  const network = ethers.Network.from(chainId);
  (network as any).name = networkName(chainId);

  const mk = (url: string) =>
    new ethers.JsonRpcProvider(
      url,
      network,
      {
        // IMPORTANT: In ethers v6, set staticNetwork to the Network object (not boolean).
        staticNetwork: network,
        // Disable batching to reduce "-32005 rate limit" issues
        batchMaxCount: 1,
        batchStallTime: 0,
      } as any
    );

  const provider: ethers.AbstractProvider =
    urls.length === 1
      ? mk(urls[0])
      : new ethers.FallbackProvider(
          urls.map((u) => ({ provider: mk(u), weight: 1, priority: 1 })),
          network
        );

  providerCache.set(chainId, provider);
  return provider;
}
</file>

<file path="frontend/src/lib/searchClient.ts">
import type { TokenSearchResult } from "@/types/search";

const rawBase = String(import.meta.env.VITE_SEARCH_API_URL ?? "").trim();
const API_BASE = rawBase.replace(/\/$/, "");

function buildSearchUrl(q: string, limit: number): string {
  // Absolute base URL: VITE_SEARCH_API_URL=https://api.example.com
  if (API_BASE && /^https?:\/\//i.test(API_BASE)) {
    const u = new URL(`${API_BASE}/search`);
    u.searchParams.set("q", q);
    u.searchParams.set("limit", String(limit));
    return u.toString();
  }

  // Relative (dev) fallback: /api/search
  const url = new URL(`/api/search`, window.location.origin);
  url.searchParams.set("q", q);
  url.searchParams.set("limit", String(limit));
  return url.toString();
}

/**
 * Remote search (optional).
 * - If VITE_SEARCH_API_URL is not set, the caller should not rely on this.
 * - Supports either response shape: { results: [...] } or [...]
 */
export async function searchTokensRemote(
  q: string,
  opts?: { limit?: number; signal?: AbortSignal }
): Promise<TokenSearchResult[]> {
  const query = (q ?? "").trim();
  if (query.length < 2) return [];

  // If no base is configured, treat as disabled.
  if (!API_BASE) return [];

  const limit = opts?.limit ?? 10;
  try {
    const res = await fetch(buildSearchUrl(query, limit), {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: opts?.signal,
    });

    if (!res.ok) return [];

    const data = (await res.json()) as any;
    const results: any[] = Array.isArray(data) ? data : Array.isArray(data?.results) ? data.results : [];

    return results
      .filter(Boolean)
      .map((r) => ({
        campaignAddress: String(r.campaignAddress ?? r.campaign ?? "").toLowerCase(),
        tokenAddress: r.tokenAddress ? String(r.tokenAddress).toLowerCase() : undefined,
        name: String(r.name ?? ""),
        symbol: String(r.symbol ?? ""),
        status: (r.status ?? "unknown") as TokenSearchResult["status"],
        logoURI: r.logoURI ? String(r.logoURI) : undefined,
      }))
      .filter((r) => /^0x[a-f0-9]{40}$/.test(r.campaignAddress) && r.symbol.length > 0);
  } catch (e: any) {
    if (e?.name === "AbortError") return [];
    return [];
  }
}
</file>

<file path="frontend/src/lib/tradeMapper.ts">
import type { RawTradeEvent, Transaction } from "@/types/token";

// App convention: everything is expressed in BNB (no USD conversion)
export function mapRawTradeToTransaction(
  raw: RawTradeEvent,
  opts?: { marketCapBnb?: string }
): Transaction {
  const date = new Date(raw.timestamp * 1000);

  const bnb = Number(raw.baseAmountWei) / 1e18;
  const token = Number(raw.tokenAmount) / 1e18;
  const price = token > 0 ? bnb / token : 0;

  return {
    time: date.toLocaleTimeString(), // e.g. "14:32:11" (you can switch to relative-time if you prefer)
    type: raw.side,
    amount: token.toFixed(0),
    bnb: `${bnb.toFixed(4)} BNB`,
    price: `${price.toFixed(8)} BNB`,
    mcap: opts?.marketCapBnb ?? "",
    trader: shortenAddress(raw.trader),
    tx: raw.txHash,
  };
}

function shortenAddress(addr: string): string {
  if (!addr) return "";
  return addr.length > 10
    ? `${addr.slice(0, 6)}...${addr.slice(-4)}`
    : addr;
}
</file>

<file path="frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="frontend/src/main.tsx">
/**
 * Application Entry Point
 * Initializes and mounts the React application to the DOM
 */

import { createRoot } from "react-dom/client";
import App from "./App.tsx";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);
</file>

<file path="frontend/src/pages/HowItWorks.tsx">
/**
 * How It Works Page
 * Educational page explaining the platform's token launch and trading process
 */

const HowItWorks = () => {
  return (
    <>
      <h1 className="text-3xl font-bold mb-6">How it works</h1>
      <p className="text-muted-foreground">Learn how to launch and trade tokens on our platform.</p>
    </>
  );
};

export default HowItWorks;
</file>

<file path="frontend/src/pages/NotFound.tsx">
/**
 * Not Found (404) Page
 * Displays a user-friendly 404 error page when users navigate to non-existent routes
 * Logs the attempted route to console for debugging purposes
 */

import { useLocation } from "react-router-dom";
import { useEffect } from "react";

const NotFound = () => {
  const location = useLocation();

  useEffect(() => {
    console.error("404 Error: User attempted to access non-existent route:", location.pathname);
  }, [location.pathname]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="text-center">
        <h1 className="mb-4 text-4xl font-bold">404</h1>
        <p className="mb-4 text-xl text-gray-600">Oops! Page not found</p>
        <a href="/" className="text-blue-500 underline hover:text-blue-700">
          Return to Home
        </a>
      </div>
    </div>
  );
};

export default NotFound;
</file>

<file path="frontend/src/pages/Status.tsx">
import { useEffect, useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

type TelemetryResponse = {
  ts: number;
  services: Record<string, any>;
};

function fmtAge(seconds: number) {
  if (seconds < 0) seconds = 0;
  if (seconds < 60) return `${seconds}s`;
  const m = Math.floor(seconds / 60);
  if (m < 60) return `${m}m`;
  const h = Math.floor(m / 60);
  return `${h}h`;
}

function statusColor(kind: "green" | "yellow" | "red") {
  return kind === "green" ? "text-emerald-400" : kind === "yellow" ? "text-yellow-300" : "text-red-400";
}

export default function Status() {
  const [token, setToken] = useState(() => localStorage.getItem("upmeme_status_token") || "");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [data, setData] = useState<TelemetryResponse | null>(null);
  const [auto, setAuto] = useState(true);

  const now = Date.now();

  const rows = useMemo(() => {
    const services = data?.services || {};
    return Object.keys(services)
      .sort()
      .map((name) => {
        const s = services[name] || {};
        const ts = Number(s.ts || 0) * 1000;
        const ageSec = ts ? Math.floor((now - ts) / 1000) : 0;
        let overall: "green" | "yellow" | "red" = "green";
        if (ageSec > 120) overall = "red";
        else if (ageSec > 45) overall = "yellow";
        if (s.ok === false && overall !== "red") overall = "yellow";
        return {
          name,
          overall,
          ageSec,
          rps1m: s.rps_1m,
          err1m: s.errors_1m,
          lag: s.lag_blocks,
          lastIndexed: s.last_indexed_block,
          head: s.head_block,
        };
      });
  }, [data, now]);

  async function fetchStatus(tok: string) {
    setLoading(true);
    setError(null);
    try {
      const r = await fetch("/api/status", {
        headers: {
          authorization: `Bearer ${tok}`,
        },
      });
      if (!r.ok) {
        const j = await r.json().catch(() => null);
        throw new Error(j?.error || `HTTP ${r.status}`);
      }
      const j = (await r.json()) as TelemetryResponse;
      setData(j);
    } catch (e: any) {
      setError(String(e?.message || e));
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    if (!auto) return;
    if (!token) return;
    fetchStatus(token);
    const t = window.setInterval(() => fetchStatus(token), 10_000);
    return () => window.clearInterval(t);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [auto, token]);

  function saveToken() {
    localStorage.setItem("upmeme_status_token", token);
    fetchStatus(token);
  }

  return (
    <div className="w-full h-full overflow-auto">
      <div className="max-w-5xl mx-auto">
        <Card className="bg-card/60 backdrop-blur border-border">
          <CardHeader>
            <CardTitle className="font-retro text-lg">UPMEME Status (Private)</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex flex-col md:flex-row gap-3 items-start md:items-center">
              <div className="flex-1 w-full">
                <Input
                  value={token}
                  onChange={(e) => setToken(e.target.value)}
                  placeholder="Enter status token"
                />
              </div>
              <Button onClick={saveToken} disabled={!token || loading}>
                {loading ? "Loading" : "Load"}
              </Button>
              <Button
                variant={auto ? "default" : "outline"}
                onClick={() => setAuto((v) => !v)}
              >
                Auto-refresh: {auto ? "ON" : "OFF"}
              </Button>
            </div>

            {error && (
              <div className="text-sm text-red-400">{error}</div>
            )}

            {!data ? (
              <div className="text-sm text-muted-foreground">
                Enter your token to view telemetry.
              </div>
            ) : (
              <div className="border border-border rounded-xl overflow-hidden">
                <div className="grid grid-cols-6 gap-0 text-xs font-semibold bg-muted/30">
                  <div className="p-3 col-span-2">Service</div>
                  <div className="p-3">Status</div>
                  <div className="p-3">Freshness</div>
                  <div className="p-3">Lag</div>
                  <div className="p-3">RPS / Errors</div>
                </div>
                {rows.length === 0 ? (
                  <div className="p-4 text-sm text-muted-foreground">No telemetry received yet.</div>
                ) : (
                  rows.map((r) => (
                    <div key={r.name} className="grid grid-cols-6 gap-0 text-sm border-t border-border">
                      <div className="p-3 col-span-2 font-mono truncate">{r.name}</div>
                      <div className={`p-3 font-semibold ${statusColor(r.overall)}`}>{r.overall.toUpperCase()}</div>
                      <div className="p-3">{fmtAge(r.ageSec)} ago</div>
                      <div className="p-3">
                        {typeof r.lag === "number" ? `${r.lag} blocks` : ""}
                      </div>
                      <div className="p-3">
                        {typeof r.rps1m === "number" ? `${r.rps1m.toFixed(1)} rps` : ""}
                        {typeof r.err1m === "number" ? ` / ${r.err1m}e` : ""}
                      </div>
                    </div>
                  ))
                )}
              </div>
            )}

            {data && (
              <div className="text-xs text-muted-foreground">
                Last update: {new Date((data.ts || 0) * 1000).toLocaleString()}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/UpDashboard.tsx">
/**
 * UP Dashboard Page
 * Displays three categories of campaigns.
 *
 * IMPORTANT:
 * - Uses the same data source as the carousel: useLaunchpad().fetchCampaigns()
 * - In live mode: returns on-chain/live campaigns
 */

import { useEffect, useMemo, useState } from "react";
import { Sparkles, TrendingUp, Target, Globe, Users, Rocket } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignMetrics, CampaignSummary } from "@/lib/launchpadClient";
import type { Token } from "@/types/token";

type Tab = "up" | "higher" | "moon";

const isAddress = (s?: string) => /^0x[a-fA-F0-9]{40}$/.test((s ?? "").trim());

const TokenCard = ({ token, className }: { token: Token; className?: string }) => {
  const navigate = useNavigate();

  return (
    <div
      className={`bg-card/40 backdrop-blur-sm rounded-xl p-3 md:p-4 border border-border hover:border-accent/50 transition-all cursor-pointer ${
        className ?? ""
      }`}
      onClick={() => {
        const addr = (token.campaignAddress ?? "").trim();
        if (!addr || !isAddress(addr)) return;
        navigate(`/token/${addr.toLowerCase()}`);
      }}
    >
      <div className="flex items-start gap-3">
        <img
          src={token.image}
          alt={token.ticker}
          className="w-12 h-12 md:w-14 md:h-14 rounded-full border-2 border-border object-cover"
        />

        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2 mb-2">
            <div className="min-w-0">
              <h3 className="font-retro text-foreground text-xs md:text-sm truncate">
                {token.ticker}
              </h3>
              <p className="font-retro text-muted-foreground text-xs truncate">
                {token.name}
              </p>
            </div>

            <div className="text-right shrink-0">
              <div className="flex items-center justify-end gap-1 text-xs font-retro text-muted-foreground">
                <Users className="h-3 w-3" />
                <span>{token.holders}</span>
              </div>
              <p className="text-xs font-retro text-accent mt-1">
                Vol {token.volume}
              </p>
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex gap-2">
              {token.hasWebsite && (
                <button
                  className="w-6 h-6 rounded-md border border-border bg-muted flex items-center justify-center hover:border-accent transition-colors"
                  onClick={(e) => e.stopPropagation()}
                >
                  <Globe className="h-3 w-3 text-muted-foreground" />
                </button>
              )}
              {token.hasTwitter && (
                <button
                  className="w-6 h-6 rounded-md border border-border bg-muted flex items-center justify-center hover:border-accent transition-colors"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg
                    className="h-3 w-3 text-muted-foreground"
                    fill="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                  </svg>
                </button>
              )}
            </div>
            <p className="text-xs font-retro text-accent">MC {token.marketCap}</p>
          </div>

          <p className="text-[10px] font-retro text-muted-foreground mt-2">
            {token.timeAgo}
          </p>
        </div>
      </div>
    </div>
  );
};

const formatTimeAgo = (createdAt?: number): string => {
  if (!createdAt) return "";
  const now = Math.floor(Date.now() / 1000);
  const diff = Math.max(0, now - createdAt);
  if (diff < 60) return "now";
  const mins = Math.floor(diff / 60);
  if (mins < 60) return `${mins}m`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h`;
  const days = Math.floor(hours / 24);
  if (days < 7) return `${days}d`;
  const weeks = Math.floor(days / 7);
  return `${weeks}w`;
};

const toTokenFromSummary = (s: CampaignSummary, fallbackId: number): Token => {
  const c = s.campaign;
  const anyC = c as any;

  const campaignAddress = String(anyC.campaign ?? "").trim();
  const tokenAddress = String(anyC.token ?? "").trim();

  return {
    id: typeof c.id === "number" ? c.id : fallbackId,
    image: c.logoURI || "/placeholder.svg",
    ticker: c.symbol,
    name: c.name,

    // Address-first routing (TokenDetails expects campaign address)
    campaignAddress: isAddress(campaignAddress) ? campaignAddress : undefined,
    tokenAddress: isAddress(tokenAddress) ? tokenAddress : undefined,

    holders: s.stats.holders ?? anyC.holders ?? "",
    volume: s.stats.volume ?? anyC.volume ?? "",
    marketCap: s.stats.marketCap ?? anyC.marketCap ?? "",
    timeAgo: anyC.timeAgo || formatTimeAgo(c.createdAt),
    hasWebsite: Boolean(c.website && c.website.length > 0),
    hasTwitter: Boolean(c.xAccount && c.xAccount.length > 0),
  };
};

const classifyTab = (m: CampaignMetrics | null): Tab => {
  // Live data currently doesn't have market-cap stages in the UI.
  // We classify by bonding progress (sold / graduationTarget)
  if (!m) return "up";

  try {
    if (m.graduationTarget <= 0n) return "up";
    const bps = (m.sold * 10_000n) / m.graduationTarget; // 0..10000

    if (bps < 3333n) return "up";
    if (bps < 6666n) return "higher";
    return "moon";
  } catch {
    return "up";
  }
};

const isGraduatedFromMetrics = (m: CampaignMetrics | null): boolean => {
  if (!m) return false;

  // Prefer explicit flags when available; otherwise fall back to sold >= target
  // so the UI works across older/newer deployments.
  const hasLaunchFlag = (m as any)?.launched !== undefined || (m as any)?.finalizedAt !== undefined;

  if (hasLaunchFlag) {
    const launched = Boolean((m as any)?.launched);
    const finalizedAt = (m as any)?.finalizedAt;

    try {
      const finalizedAtBig =
        typeof finalizedAt === "bigint"
          ? finalizedAt
          : BigInt(Number(finalizedAt ?? 0));
      return launched || finalizedAtBig > 0n;
    } catch {
      return launched;
    }
  }

  try {
    return m.graduationTarget > 0n && m.sold >= m.graduationTarget;
  } catch {
    return false;
  }
};

const UpDashboard = () => {
  const { fetchCampaigns, fetchCampaignSummary } = useLaunchpad();

  const [activeTab, setActiveTab] = useState<Tab>("up");
  const [loading, setLoading] = useState(true);

  const [upTokens, setUpTokens] = useState<Token[]>([]);
  const [higherTokens, setHigherTokens] = useState<Token[]>([]);
  const [moonTokens, setMoonTokens] = useState<Token[]>([]);
  const [graduatedTokens, setGraduatedTokens] = useState<Token[]>([]);

  const isMobile =
    typeof window !== "undefined" ? window.innerWidth < 768 : false;

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setLoading(true);

        const campaigns = (await fetchCampaigns()) ?? [];
        const results = await Promise.allSettled(
          campaigns.map((c) => fetchCampaignSummary(c))
        );

        if (cancelled) return;

        const nextUp: Token[] = [];
        const nextHigher: Token[] = [];
        const nextMoon: Token[] = [];
        const nextGraduated: Token[] = [];

        campaigns.forEach((c, idx) => {
          const r = results[idx];
          const summary = r.status === "fulfilled" ? r.value : null;
          const token = summary
            ? toTokenFromSummary(summary, idx + 1)
            : {
                id: typeof c.id === "number" ? c.id : idx + 1,
                image: c.logoURI || "/placeholder.svg",
                ticker: c.symbol,
                name: c.name,

                // Address-first routing (TokenDetails expects campaign address)
                campaignAddress: isAddress(String((c as any).campaign ?? ""))
                  ? String((c as any).campaign).trim()
                  : undefined,
                tokenAddress: isAddress(String((c as any).token ?? ""))
                  ? String((c as any).token).trim()
                  : undefined,

                holders: "",
                volume: "",
                marketCap: "",
                timeAgo: (c as any).timeAgo || formatTimeAgo(c.createdAt),
                hasWebsite: Boolean(c.website && c.website.length > 0),
                hasTwitter: Boolean(c.xAccount && c.xAccount.length > 0),
              };

          const metrics = summary?.metrics ?? null;
          if (isGraduatedFromMetrics(metrics)) {
            nextGraduated.push(token);
            return;
          }

          const tab = classifyTab(metrics);

          if (tab === "up") nextUp.push(token);
          else if (tab === "higher") nextHigher.push(token);
          else nextMoon.push(token);
        });

        setUpTokens(nextUp);
        setHigherTokens(nextHigher);
        setMoonTokens(nextMoon);
        setGraduatedTokens(nextGraduated);
      } catch (e) {
        console.error("[UpDashboard] Failed to load campaigns", e);
        if (!cancelled) {
          setUpTokens([]);
          setHigherTokens([]);
          setMoonTokens([]);
          setGraduatedTokens([]);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [fetchCampaigns, fetchCampaignSummary]);

  const sections = useMemo(() => {
    return {
      up: {
        icon: Sparkles,
        title: "up?",
        tokens: upTokens,
        subtitle: null as string | null,
      },
      higher: {
        icon: TrendingUp,
        title: "higher",
        tokens: higherTokens,
        subtitle: "Close to bonding",
      },
      moon: {
        icon: Target,
        title: "to the moon",
        tokens: moonTokens,
        subtitle: "Near graduation",
      },
    };
  }, [upTokens, higherTokens, moonTokens]);

  const renderSection = (type: Tab) => {
    const config = sections[type];
    const Icon = config.icon;

    return (
      <div className="bg-card/30 backdrop-blur-md rounded-2xl border border-border flex flex-col overflow-hidden h-full">
        <div className="flex items-center justify-between p-4 md:p-6 pb-4 shrink-0">
          <div className="flex items-center gap-3">
            <div className="bg-accent/20 p-2 md:p-3 rounded-xl">
              <Icon className="h-5 w-5 md:h-6 md:w-6 text-accent" />
            </div>
            <h2 className="text-xl md:text-2xl font-retro text-foreground">
              {config.title}
            </h2>
          </div>
          {config.subtitle && (
            <span className="text-xs md:text-sm font-retro text-muted-foreground">
              {config.subtitle}
            </span>
          )}
        </div>

        <div className="flex-1 overflow-y-auto px-4 md:px-6 pb-4 md:pb-6 space-y-3 scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
          {loading ? (
            <div className="text-center py-12">
              <p className="font-retro text-muted-foreground text-sm">
                Loading tokens...
              </p>
            </div>
          ) : config.tokens.length > 0 ? (
            config.tokens.map((token) => (
              <TokenCard key={token.id} token={token} />
            ))
          ) : (
            <div className="text-center py-12">
              <p className="font-retro text-muted-foreground text-sm">
                No tokens found
              </p>
            </div>
          )}
        </div>
      </div>
    );
  };

  const renderGraduatedRow = () => {
    // Keep the row visible on all layouts, but only render the container
    // when we have something to show (or we are still loading).
    if (!loading && graduatedTokens.length === 0) return null;

    return (
      <div className="bg-card/30 backdrop-blur-md rounded-2xl border border-border overflow-hidden shrink-0">
        <div className="flex items-center justify-between p-4 md:p-6 pb-4">
          <div className="flex items-center gap-3">
            <div className="bg-accent/20 p-2 md:p-3 rounded-xl">
              <Rocket className="h-5 w-5 md:h-6 md:w-6 text-accent" />
            </div>
            <h2 className="text-xl md:text-2xl font-retro text-foreground">graduated</h2>
          </div>
          <span className="text-xs md:text-sm font-retro text-muted-foreground">
            Trading on DEX
          </span>
        </div>

        <div className="px-4 md:px-6 pb-4 md:pb-6 overflow-x-auto scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
          {loading ? (
            <div className="py-6">
              <p className="font-retro text-muted-foreground text-sm">Loading tokens...</p>
            </div>
          ) : (
            <div className="flex gap-3">
              {graduatedTokens.map((token) => (
                <TokenCard key={token.id} token={token} className="min-w-[280px]" />
              ))}
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="fixed inset-0 pt-28 lg:pt-28 pl-0 lg:pl-72">
      <div className={`h-full ${isMobile ? "pb-20" : ""} p-4 md:p-6 flex flex-col gap-4`}>
        {renderGraduatedRow()}

        <div
          className={`flex-1 ${
            isMobile
              ? "flex"
              : "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3"
          } gap-4`}
        >
          {isMobile ? (
            <div className="flex-1">{renderSection(activeTab)}</div>
          ) : (
            <>
              {renderSection("up")}
              {renderSection("higher")}
              <div className="md:col-span-2 lg:col-span-1">
                {renderSection("moon")}
              </div>
            </>
          )}
        </div>
      </div>

      {isMobile && (
        <div className="fixed bottom-0 left-0 right-0 bg-card/95 backdrop-blur-md border-t border-border p-2 flex justify-around items-center z-50">
          <button
            onClick={() => setActiveTab("up")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "up"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <Sparkles className="h-5 w-5" />
            <span className="text-xs font-retro">up?</span>
          </button>

          <button
            onClick={() => setActiveTab("higher")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "higher"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <TrendingUp className="h-5 w-5" />
            <span className="text-xs font-retro">higher</span>
          </button>

          <button
            onClick={() => setActiveTab("moon")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "moon"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <Target className="h-5 w-5" />
            <span className="text-xs font-retro">to the moon</span>
          </button>
        </div>
      )}
    </div>
  );
};

export default UpDashboard;
</file>

<file path="frontend/src/pages/UpNow.tsx">
/**
 * UpNow Page
 * Displays three categories of campaigns.
 *
 * IMPORTANT:
 * - Uses the same data source as the carousel: useLaunchpad().fetchCampaigns()
 * - In live mode: returns on-chain/live campaigns
 */

import { useEffect, useMemo, useState } from "react";
import { Sparkles, TrendingUp, Target, Globe, Users, Rocket } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignMetrics, CampaignSummary } from "@/lib/launchpadClient";
import type { Token } from "@/types/token";

type Tab = "up" | "higher" | "moon";

const TokenCard = ({ token, className }: { token: Token; className?: string }) => {
  const navigate = useNavigate();

  return (
    <div
      className={`bg-card/40 backdrop-blur-sm rounded-xl p-3 md:p-4 border border-border hover:border-accent/50 transition-all cursor-pointer ${
        className ?? ""
      }`}
      onClick={() => token.campaignAddress && navigate(`/token/${token.campaignAddress.toLowerCase()}`)}
    >
      <div className="flex items-start gap-3">
        <img
          src={token.image}
          alt={token.ticker}
          className="w-12 h-12 md:w-14 md:h-14 rounded-full border-2 border-border object-cover"
        />

        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2 mb-2">
            <div className="min-w-0">
              <h3 className="font-retro text-foreground text-xs md:text-sm truncate">
                {token.ticker}
              </h3>
              <p className="font-retro text-muted-foreground text-xs truncate">
                {token.name}
              </p>
            </div>

            <div className="text-right shrink-0">
              <div className="flex items-center justify-end gap-1 text-xs font-retro text-muted-foreground">
                <Users className="h-3 w-3" />
                <span>{token.holders}</span>
              </div>
              <p className="text-xs font-retro text-accent mt-1">
                Vol {token.volume}
              </p>
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex gap-2">
              {token.hasWebsite && (
                <button
                  className="w-6 h-6 rounded-md border border-border bg-muted flex items-center justify-center hover:border-accent transition-colors"
                  onClick={(e) => e.stopPropagation()}
                >
                  <Globe className="h-3 w-3 text-muted-foreground" />
                </button>
              )}
              {token.hasTwitter && (
                <button
                  className="w-6 h-6 rounded-md border border-border bg-muted flex items-center justify-center hover:border-accent transition-colors"
                  onClick={(e) => e.stopPropagation()}
                >
                  <svg
                    className="h-3 w-3 text-muted-foreground"
                    fill="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
                  </svg>
                </button>
              )}
            </div>
            <p className="text-xs font-retro text-accent">MC {token.marketCap}</p>
          </div>

          <p className="text-[10px] font-retro text-muted-foreground mt-2">
            {token.timeAgo}
          </p>
        </div>
      </div>
    </div>
  );
};

const formatTimeAgo = (createdAt?: number): string => {
  if (!createdAt) return "";
  const now = Math.floor(Date.now() / 1000);
  const diff = Math.max(0, now - createdAt);
  if (diff < 60) return "now";
  const mins = Math.floor(diff / 60);
  if (mins < 60) return `${mins}m`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h`;
  const days = Math.floor(hours / 24);
  if (days < 7) return `${days}d`;
  const weeks = Math.floor(days / 7);
  return `${weeks}w`;
};

const toTokenFromSummary = (s: CampaignSummary, fallbackId: number): Token => {
  const c = s.campaign;
  const anyC = c as any;

  return {
    id: typeof c.id === "number" ? c.id : fallbackId,
    image: c.logoURI || "/placeholder.svg",
    ticker: c.symbol,
    name: c.name,
    holders: s.stats.holders ?? anyC.holders ?? "",
    volume: s.stats.volume ?? anyC.volume ?? "",
    marketCap: s.stats.marketCap ?? anyC.marketCap ?? "",
    timeAgo: anyC.timeAgo || formatTimeAgo(c.createdAt),
    hasWebsite: Boolean(c.website && c.website.length > 0),
    hasTwitter: Boolean(c.xAccount && c.xAccount.length > 0),
  };
};

const classifyTab = (m: CampaignMetrics | null): Tab => {
  // Live data currently doesn't have market-cap stages in the UI.
  // We classify by bonding progress (sold / graduationTarget)
  if (!m) return "up";

  try {
    if (m.graduationTarget <= 0n) return "up";
    const bps = (m.sold * 10_000n) / m.graduationTarget; // 0..10000

    if (bps < 3333n) return "up";
    if (bps < 6666n) return "higher";
    return "moon";
  } catch {
    return "up";
  }
};

const isGraduatedFromMetrics = (m: CampaignMetrics | null): boolean => {
  if (!m) return false;

  // Prefer explicit flags when available; otherwise fall back to sold >= target
  // so the UI works across older/newer deployments.
  const hasLaunchFlag = (m as any)?.launched !== undefined || (m as any)?.finalizedAt !== undefined;

  if (hasLaunchFlag) {
    const launched = Boolean((m as any)?.launched);
    const finalizedAt = (m as any)?.finalizedAt;

    try {
      const finalizedAtBig =
        typeof finalizedAt === "bigint"
          ? finalizedAt
          : BigInt(Number(finalizedAt ?? 0));
      return launched || finalizedAtBig > 0n;
    } catch {
      return launched;
    }
  }

  try {
    return m.graduationTarget > 0n && m.sold >= m.graduationTarget;
  } catch {
    return false;
  }
};

const UpNow = () => {
  const { fetchCampaigns, fetchCampaignSummary } = useLaunchpad();

  const [activeTab, setActiveTab] = useState<Tab>("up");
  const [loading, setLoading] = useState(true);

  const [upTokens, setUpTokens] = useState<Token[]>([]);
  const [higherTokens, setHigherTokens] = useState<Token[]>([]);
  const [moonTokens, setMoonTokens] = useState<Token[]>([]);
  const [graduatedTokens, setGraduatedTokens] = useState<Token[]>([]);

  const isMobile =
    typeof window !== "undefined" ? window.innerWidth < 768 : false;

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setLoading(true);

        const campaigns = (await fetchCampaigns()) ?? [];
        const results = await Promise.allSettled(
          campaigns.map((c) => fetchCampaignSummary(c))
        );

        if (cancelled) return;

        const nextUp: Token[] = [];
        const nextHigher: Token[] = [];
        const nextMoon: Token[] = [];
        const nextGraduated: Token[] = [];

        campaigns.forEach((c, idx) => {
          const r = results[idx];
          const summary = r.status === "fulfilled" ? r.value : null;
          const token = summary
            ? toTokenFromSummary(summary, idx + 1)
            : {
                id: typeof c.id === "number" ? c.id : idx + 1,
                image: c.logoURI || "/placeholder.svg",
                ticker: c.symbol,
                name: c.name,
                holders: "",
                volume: "",
                marketCap: "",
                timeAgo: (c as any).timeAgo || formatTimeAgo(c.createdAt),
                hasWebsite: Boolean(c.website && c.website.length > 0),
                hasTwitter: Boolean(c.xAccount && c.xAccount.length > 0),
              };

          const metrics = summary?.metrics ?? null;
          if (isGraduatedFromMetrics(metrics)) {
            nextGraduated.push(token);
            return;
          }

          const tab = classifyTab(metrics);

          if (tab === "up") nextUp.push(token);
          else if (tab === "higher") nextHigher.push(token);
          else nextMoon.push(token);
        });

        setUpTokens(nextUp);
        setHigherTokens(nextHigher);
        setMoonTokens(nextMoon);
        setGraduatedTokens(nextGraduated);
      } catch (e) {
        console.error("[UpNow] Failed to load campaigns", e);
        if (!cancelled) {
          setUpTokens([]);
          setHigherTokens([]);
          setMoonTokens([]);
          setGraduatedTokens([]);
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [fetchCampaigns, fetchCampaignSummary]);

  const sections = useMemo(() => {
    return {
      up: {
        icon: Sparkles,
        title: "up?",
        tokens: upTokens,
        subtitle: null as string | null,
      },
      higher: {
        icon: TrendingUp,
        title: "higher",
        tokens: higherTokens,
        subtitle: "Close to bonding",
      },
      moon: {
        icon: Target,
        title: "to the moon",
        tokens: moonTokens,
        subtitle: "Near graduation",
      },
    };
  }, [upTokens, higherTokens, moonTokens]);

  const renderSection = (type: Tab) => {
    const config = sections[type];
    const Icon = config.icon;

    return (
      <div className="bg-card/30 backdrop-blur-md rounded-2xl border border-border flex flex-col overflow-hidden h-full">
        <div className="flex items-center justify-between p-4 md:p-6 pb-4 shrink-0">
          <div className="flex items-center gap-3">
            <div className="bg-accent/20 p-2 md:p-3 rounded-xl">
              <Icon className="h-5 w-5 md:h-6 md:w-6 text-accent" />
            </div>
            <h2 className="text-xl md:text-2xl font-retro text-foreground">
              {config.title}
            </h2>
          </div>
          {config.subtitle && (
            <span className="text-xs md:text-sm font-retro text-muted-foreground">
              {config.subtitle}
            </span>
          )}
        </div>

        <div className="flex-1 overflow-y-auto px-4 md:px-6 pb-4 md:pb-6 space-y-3 scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
          {loading ? (
            <div className="text-center py-12">
              <p className="font-retro text-muted-foreground text-sm">
                Loading tokens...
              </p>
            </div>
          ) : config.tokens.length > 0 ? (
            config.tokens.map((token) => (
              <TokenCard key={token.id} token={token} />
            ))
          ) : (
            <div className="text-center py-12">
              <p className="font-retro text-muted-foreground text-sm">
                No tokens found
              </p>
            </div>
          )}
        </div>
      </div>
    );
  };

  const renderGraduatedRow = () => {
    // Keep the row visible on all layouts, but only render the container
    // when we have something to show (or we are still loading).
    if (!loading && graduatedTokens.length === 0) return null;

    return (
      <div className="bg-card/30 backdrop-blur-md rounded-2xl border border-border overflow-hidden shrink-0">
        <div className="flex items-center justify-between p-4 md:p-6 pb-4">
          <div className="flex items-center gap-3">
            <div className="bg-accent/20 p-2 md:p-3 rounded-xl">
              <Rocket className="h-5 w-5 md:h-6 md:w-6 text-accent" />
            </div>
            <h2 className="text-xl md:text-2xl font-retro text-foreground">graduated</h2>
          </div>
          <span className="text-xs md:text-sm font-retro text-muted-foreground">
            Trading on DEX
          </span>
        </div>

        <div className="px-4 md:px-6 pb-4 md:pb-6 overflow-x-auto scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
          {loading ? (
            <div className="py-6">
              <p className="font-retro text-muted-foreground text-sm">Loading tokens...</p>
            </div>
          ) : (
            <div className="flex gap-3">
              {graduatedTokens.map((token) => (
                <TokenCard key={token.id} token={token} className="min-w-[280px]" />
              ))}
            </div>
          )}
        </div>
      </div>
    );
  };

  return (
    <div className="fixed inset-0 pt-28 lg:pt-28 pl-0 lg:pl-72">
      <div className={`h-full ${isMobile ? "pb-20" : ""} p-4 md:p-6 flex flex-col gap-4`}>
        {renderGraduatedRow()}

        <div
          className={`flex-1 ${
            isMobile
              ? "flex"
              : "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3"
          } gap-4`}
        >
          {isMobile ? (
            <div className="flex-1">{renderSection(activeTab)}</div>
          ) : (
            <>
              {renderSection("up")}
              {renderSection("higher")}
              <div className="md:col-span-2 lg:col-span-1">
                {renderSection("moon")}
              </div>
            </>
          )}
        </div>
      </div>

      {isMobile && (
        <div className="fixed bottom-0 left-0 right-0 bg-card/95 backdrop-blur-md border-t border-border p-2 flex justify-around items-center z-50">
          <button
            onClick={() => setActiveTab("up")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "up"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <Sparkles className="h-5 w-5" />
            <span className="text-xs font-retro">up?</span>
          </button>

          <button
            onClick={() => setActiveTab("higher")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "higher"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <TrendingUp className="h-5 w-5" />
            <span className="text-xs font-retro">higher</span>
          </button>

          <button
            onClick={() => setActiveTab("moon")}
            className={`flex flex-col items-center gap-1 px-4 py-2 rounded-lg transition-all ${
              activeTab === "moon"
                ? "bg-accent/20 text-accent"
                : "text-muted-foreground"
            }`}
          >
            <Target className="h-5 w-5" />
            <span className="text-xs font-retro">to the moon</span>
          </button>
        </div>
      )}
    </div>
  );
};

export default UpNow;
</file>

<file path="frontend/src/types/search.ts">
export type TokenStatus = "bonding" | "graduated" | "unknown";

export interface TokenSearchResult {
  campaignAddress: string; // 0x...
  tokenAddress?: string; // 0x...
  name: string;
  symbol: string;
  status: TokenStatus;
  logoURI?: string;
}
</file>

<file path="frontend/src/types/token.ts">
/**
 * Token-related TypeScript interfaces and types
 */

export type TokenCategory = "meme" | "project";

export type ProcessingStatus = "queued" | "running" | "succeeded" | "failed";

export interface TokenFormData {
  name: string;
  ticker: string;
  description: string;
  category: TokenCategory;
  image: File | null;
  imagePreview: string;
  website: string;
  twitter: string;
  otherLink: string;
  showSocialLinks: boolean;
}

export interface Token {
  id: number;
  image: string;
  ticker: string;
  name: string;

  // Address-first routing
  campaignAddress?: string; // LaunchCampaign address
  tokenAddress?: string; // LaunchToken address (after deploy)
  holders: string;
  volume: string;
  marketCap: string;
  timeAgo: string;
  hasWebsite?: boolean;
  hasTwitter?: boolean;
}

export interface TokenMetrics {
  change: number;
  volume: number;
}

export interface TokenDetailsData {
  id: string;
  image: string;
  ticker: string;
  name: string;
  contractAddress: string;
  marketCap: number;
  marketCapChange: number;
  price: number;
  liquidity: number;
  holders: number;
  metrics: {
    "5m": TokenMetrics;
    "1h": TokenMetrics;
    "4h": TokenMetrics;
    "24h": TokenMetrics;
  };
  hasWebsite: boolean;
  hasTwitter: boolean;
  hasTelegram: boolean;
}

export interface Transaction {
  time: string;
  type: "buy" | "sell";
  amount: string;
  bnb: string;
  price: string;
  mcap: string; // formatted in BNB
  trader: string;
  tx: string;
}
export type TradeSide = "buy" | "sell";

export interface RawTradeEvent {
  campaignAddress: string;     // LaunchCampaign address
  txHash: string;
  blockNumber: number;
  logIndex: number;

  side: TradeSide;             // "buy" (TokensPurchased) or "sell" (TokensSold)
  trader: string;              // buyer or seller

  tokenAmount: bigint;         // amountOut (buy) or amountIn (sell)
  baseAmountWei: bigint;       // cost (buy) or payout (sell) in BNB (wei)

  timestamp: number;           // unix seconds from block.timestamp
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./pages/**/*.{ts,tsx}", "./components/**/*.{ts,tsx}", "./app/**/*.{ts,tsx}", "./src/**/*.{ts,tsx}"],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      fontFamily: {
        'retro': ['Pixeboy', 'monospace', 'sans-serif'],
      },
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      boxShadow: {
        'glow-primary': '0 0 20px hsl(var(--glow-primary) / 0.5)',
        'glow-accent': '0 0 30px hsl(var(--glow-accent) / 0.6)',
        'glow-success': '0 0 20px hsl(var(--glow-success) / 0.4)',
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
        "pulse-bounce": {
          "0%, 100%": {
            transform: "scale(1)",
            opacity: "0.8",
          },
          "50%": {
            transform: "scale(1.15)",
            opacity: "1",
          },
        },
        "flash": {
          "0%, 100%": {
            opacity: "0.1",
          },
          "50%": {
            opacity: "0.3",
          },
        },
        "glow-pulse": {
          "0%, 100%": {
            opacity: "0.3",
            transform: "scale(1)",
          },
          "50%": {
            opacity: "0.6",
            transform: "scale(1.1)",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "pulse-bounce": "pulse-bounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) infinite",
        "flash": "flash 0.8s ease-in-out infinite",
        "glow-pulse": "glow-pulse 1.2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": false,
    "noFallthroughCasesInSwitch": false,

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"]
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "noImplicitAny": false,
    "noUnusedParameters": false,
    "skipLibCheck": true,
    "allowJs": true,
    "noUnusedLocals": false,
    "strictNullChecks": false
  }
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vercel.json">
{
  "functions": {
    "api/**/*.js": {
      "includeFiles": "api/certs/**"
    }
  },
  "rewrites": [
    { "source": "/api/diagnostics-ui", "destination": "/api/diagnostics?ui=1" },
    { "source": "/api/(.*)", "destination": "/api/$1" },
    { "source": "/(.*)", "destination": "/index.html" }
  ]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";
import path from "path";
import { componentTagger } from "lovable-tagger";

// https://vitejs.dev/config/
export default defineConfig(({ mode }) => ({
  server: {
    host: "::",
    port: 8080,
  },
  plugins: [react(), mode === "development" && componentTagger()].filter(Boolean),
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
}));
</file>

<file path="hardhat.config.ts">
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "hardhat-gas-reporter";
import "solidity-coverage";
import * as dotenv from "dotenv";

dotenv.config();

function pk(): string[] {
  const key = process.env.DEPLOYER_PK;
  if (!key) return [];
  return [key.startsWith("0x") ? key : `0x${key}`];
}

const config: HardhatUserConfig = {
  networks: {
    hardhat: {
      // Your LaunchFactory bytecode exceeds the 24KB Spurious Dragon limit.
      // Hardhat defaults to enforcing the limit; for unit tests we disable it.
      allowUnlimitedContractSize: true,
    },

    // --- Added for deployments ---
    bscTestnet: {
  url: process.env.BSC_TESTNET_RPC || "",
  accounts: process.env.DEPLOYER_PK ? [process.env.DEPLOYER_PK.startsWith("0x") ? process.env.DEPLOYER_PK : `0x${process.env.DEPLOYER_PK}`] : [],
  chainId: 97
}
  },

  // --- Added for contract verification ---
  etherscan: {
    apiKey: {
      // hardhat-toolbox uses this key name for BNB Chain testnet verification
      bscTestnet: process.env.BSCSCAN_API_KEY || "",
    },
  },

  solidity: {
  version: "0.8.24",
  settings: {
    optimizer: { enabled: true, runs: 1 }, // low runs shrinks code size
    viaIR: true,
    metadata: { bytecodeHash: "none" } // removes metadata hash bytes
  },
},

  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts",
  },

  mocha: {
    timeout: 120_000,
  },

  gasReporter: {
    enabled: process.env.REPORT_GAS === "true",
    currency: "USD",
  },
};

export default config;
</file>

<file path="hardhat.deploy.config.ts">
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import * as dotenv from "dotenv";
dotenv.config();

const pk = process.env.DEPLOYER_PK
  ? [process.env.DEPLOYER_PK.startsWith("0x") ? process.env.DEPLOYER_PK : `0x${process.env.DEPLOYER_PK}`]
  : [];

const config: HardhatUserConfig = {
  networks: {
    bscTestnet: {
      url: process.env.BSC_TESTNET_RPC || "",
      accounts: pk,
      chainId: 97,
    },
  },
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: { enabled: true, runs: 1 },
      viaIR: true,
      metadata: {
        bytecodeHash: "none",
      },
    },
  },
  etherscan: {
    apiKey: { bscTestnet: process.env.BSCSCAN_API_KEY || "" },
  },
};

export default config;
</file>

<file path="package.json">
{
  "name": "launchit-bonding-curve-tests",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "compile": "hardhat compile",
    "test": "hardhat test",
    "coverage": "hardhat coverage",
    "gas": "REPORT_GAS=true hardhat test"
  },
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "hardhat": "^2.22.10",
    "hardhat-gas-reporter": "^1.0.10",
    "solidity-coverage": "^0.8.5",
    "typescript": "^5.4.5",
    "ts-node": "^10.9.2",
    "dotenv": "^16.4.5"
  },
  "dependencies": {
    "@openzeppelin/contracts": "^5.0.2"
  }
}
</file>

<file path="README.md">
# LaunchIt / Bonding-Curve Contracts  Fresh Hardhat Test Suite

## Quick start
```bash
npm i
npm test
```

Optional:
```bash
npm run coverage
npm run gas
```

## Notes
- Solidity compiler set to **0.8.24** (matches contracts).
- Includes a test-only helper contract `contracts/test/FactoryCaller.sol` to exercise `LaunchCampaign.buyExactTokensFor`.
</file>

<file path="realtime-indexer/.dockerignore">
node_modules
dist
.git
.env
npm-debug.log
</file>

<file path="realtime-indexer/Dockerfile">
FROM node:20-bookworm-slim

# Install CA certificates (critical for TLS trust)
RUN apt-get update \
  && apt-get install -y --no-install-recommends ca-certificates \
  && update-ca-certificates \
  && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install deps first (cache-friendly)
COPY package*.json ./
RUN npm ci

# Copy the rest of the service code (context is realtime-indexer/)
COPY . .

# Build TypeScript -> dist/
RUN npm run build

ENV NODE_ENV=production
EXPOSE 3000

CMD ["npm", "run", "start"]
</file>

<file path="realtime-indexer/nixpacks.toml">
[phases.setup]
nixPkgs = ["cacert"]
</file>

<file path="realtime-indexer/package.json">
{
  "name": "realtime-indexer",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "start": "node --enable-source-maps dist/server.js",
    "build": "tsc -p tsconfig.json",
    "cron:daily-repair": "node --enable-source-maps dist/jobs/dailyRepair.js"
  },
  "dependencies": {
    "ably": "^2.6.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "ethers": "^6.13.4",
    "express": "^4.19.2",
    "pg": "^8.13.0"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^22.10.2",
    "@types/pg": "^8.16.0",
    "tsx": "^4.19.2",
    "typescript": "^5.7.2"
  }
}
</file>

<file path="realtime-indexer/src/abis.ts">
export const LAUNCH_FACTORY_ABI = [
  // events
  "event CampaignCreated(uint256 indexed id,address indexed campaign,address indexed token,address creator,string name,string symbol)",

  // view helpers for robust campaign discovery (avoids missing events due to RPC log issues)
  "function campaignsCount() view returns (uint256)",
  "function getCampaign(uint256 id) view returns (tuple(address campaign,address token,address creator,string name,string symbol,string logoURI,string xAccount,string website,string extraLink,uint64 createdAt))"
];

export const LAUNCH_CAMPAIGN_ABI = [
  "event TokensPurchased(address indexed buyer,uint256 amountOut,uint256 cost)",
  "event TokensSold(address indexed seller,uint256 amountIn,uint256 payout)",
  "event CampaignFinalized(address indexed caller,uint256 liquidityTokens,uint256 liquidityBnb,uint256 protocolFee,uint256 creatorPayout)"
];

// UPVoteTreasury (paid upvote events)
export const UP_VOTE_TREASURY_ABI = [
  "event VoteCast(address indexed campaign,address indexed voter,address indexed asset,uint256 amountPaid,bytes32 meta)"
];
</file>

<file path="realtime-indexer/src/ably.ts">
import Ably from "ably";
import { ENV } from "./env.js";

export const ablyRest = new Ably.Rest({ key: ENV.ABLY_API_KEY });

export function tokenChannel(chainId: number, campaignAddress: string) {
  return `token:${chainId}:${campaignAddress.toLowerCase()}`;
}

export function leagueChannel(chainId: number) {
  return `league:${chainId}`;
}

export async function publishTrade(chainId: number, campaign: string, msg: any) {
  const ch = ablyRest.channels.get(tokenChannel(chainId, campaign));
  await ch.publish("trade", msg);
}

export async function publishCandle(chainId: number, campaign: string, msg: any) {
  const ch = ablyRest.channels.get(tokenChannel(chainId, campaign));
  await ch.publish("candle_upsert", msg);
}

export async function publishStats(chainId: number, campaign: string, msg: any) {
  const ch = ablyRest.channels.get(tokenChannel(chainId, campaign));
  await ch.publish("stats_patch", msg);
}

export async function publishLeague(chainId: number, event: string, msg: any) {
  const ch = ablyRest.channels.get(leagueChannel(chainId));
  await ch.publish(event, msg);
}
</file>

<file path="realtime-indexer/src/db.ts">
import { Pool } from "pg";
import { ENV } from "./env.js";

function dbHostFromUrl(dbUrl: string): string {
  const u = new URL(dbUrl);
  return u.hostname;
}

function dbPortFromUrl(dbUrl: string): number | null {
  const u = new URL(dbUrl);
  const p = u.port ? Number(u.port) : null;
  return Number.isFinite(p as number) ? (p as number) : null;
}

function loadCustomCaIfEnabled(): string | null {
  // Only use a custom CA if explicitly enabled.
  const enabled = String(process.env.PG_USE_CUSTOM_CA || "").trim() === "1";
  if (!enabled) return null;

  const b64 = process.env.PG_CA_CERT_B64;
  if (b64) {
    const pem = Buffer.from(b64, "base64").toString("utf8");
    if (!pem.includes("BEGIN CERTIFICATE")) {
      throw new Error("PG_CA_CERT_B64 does not decode to a PEM certificate");
    }
    return pem;
  }

  const pem = process.env.PG_CA_CERT;
  if (pem) return pem.includes("\\n") ? pem.replace(/\\n/g, "\n") : pem;

  return null;
}

const host = dbHostFromUrl(ENV.DATABASE_URL);
const port = dbPortFromUrl(ENV.DATABASE_URL);

// Keep this for local debugging only; do not set in production.
const disableSsl = String(process.env.PG_DISABLE_SSL || "").trim() === "1";

// Some serverless/container environments ship with a minimal CA bundle.
// If you hit SELF_SIGNED_CERT_IN_CHAIN when connecting to Supabase pooler,
// set PG_SSL_ALLOW_SELF_SIGNED=1 to keep TLS on but skip certificate verification.
const allowSelfSigned = String(process.env.PG_SSL_ALLOW_SELF_SIGNED || "").trim() === "1";

let customCa: string | null = null;
try {
  customCa = loadCustomCaIfEnabled();
} catch (e) {
  console.error("[db] Custom CA load error:", e);
  throw e; // fail fast; misconfigured CA should not silently degrade security
}

const ssl =
  disableSsl
    ? false
    : customCa
      ? { ca: customCa, rejectUnauthorized: true, servername: host }
      : allowSelfSigned
        ? { rejectUnauthorized: false, servername: host }
        : { rejectUnauthorized: true, servername: host };

// Pool size: keep small for Supabase pooler to avoid exhausting pool_size.
const poolMax = (() => {
  const raw = String(process.env.PG_POOL_MAX || "").trim();
  const n = raw ? Number(raw) : NaN;
  // Default 5 is safe for a single Railway instance.
  return Number.isFinite(n) && n > 0 ? Math.floor(n) : 5;
})();

// Supabase Transaction Pooler (port 6543) does not support PREPARE statements.
// Force pg "simple query" protocol to avoid prepared/extended protocol.
// Enable automatically if port == 6543, or override with PG_SIMPLE_PROTOCOL=1/0.
const forceSimpleProtocol = (() => {
  const override = String(process.env.PG_SIMPLE_PROTOCOL || "").trim();
  if (override === "1") return true;
  if (override === "0") return false;
  return port === 6543; // auto-enable for transaction pooler
})();

// Log connection mode once at boot for fast diagnosis.
console.log(
  `[db] host=${host}:${port ?? "?"} ssl=${disableSsl ? "off" : "on"} verify=${disableSsl ? "n/a" : allowSelfSigned ? "off" : "on"} ca=${
    customCa ? "custom" : "system"
  } poolMax=${poolMax} simple=${forceSimpleProtocol ? "on" : "off"}`
);

export const pool = new Pool({
  connectionString: ENV.DATABASE_URL,
  ssl,
  max: poolMax,
  idleTimeoutMillis: 30_000,
  connectionTimeoutMillis: 10_000,
});

// Force simple protocol globally for this pool (transaction pooler safe).
if (forceSimpleProtocol) {
  const origQuery: any = (pool as any).query.bind(pool);

  (pool as any).query = (...args: any[]) => {
    // query(text, values?)
    if (typeof args[0] === "string") {
      const text = args[0];
      const values = Array.isArray(args[1]) ? args[1] : undefined;

      return origQuery({
        text,
        values,
        simple: true, // <-- supported by pg runtime, not in TS types
      } as any);
    }

    // query({ text, values, ... })
    if (args[0] && typeof args[0] === "object" && typeof (args[0] as any).text === "string") {
      return origQuery({
        ...(args[0] as any),
        simple: true,
      } as any);
    }

    // fallback (callback signatures etc.)
    return origQuery.apply(pool, args);
  };
}


pool.on("error", (err) => {
  console.error("[db] pool error:", err);
});
</file>

<file path="realtime-indexer/src/env.ts">
import "dotenv/config";

function req(name: string): string {
  const v = process.env[name];
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

export const ENV = {
  DATABASE_URL: req("DATABASE_URL"),
  ABLY_API_KEY: req("ABLY_API_KEY"),

  BSC_RPC_HTTP_97: req("BSC_RPC_HTTP_97"),
  BSC_RPC_HTTP_56: process.env.BSC_RPC_HTTP_56 || "",

  FACTORY_ADDRESS_97: process.env.FACTORY_ADDRESS_97 || "",
  FACTORY_ADDRESS_56: process.env.FACTORY_ADDRESS_56 || "",

  // UPVoteTreasury addresses (optional; if not set, vote indexing is disabled for that chain)
  VOTE_TREASURY_ADDRESS_97: process.env.VOTE_TREASURY_ADDRESS_97 || "",
  VOTE_TREASURY_ADDRESS_56: process.env.VOTE_TREASURY_ADDRESS_56 || "",

  // Indexing window controls
  // Set FACTORY_START_BLOCK_97 to the factory deployment block (BSC testnet: 83444786 in your current deployment).
  FACTORY_START_BLOCK_97: Number(process.env.FACTORY_START_BLOCK_97 || 0),
  FACTORY_START_BLOCK_56: Number(process.env.FACTORY_START_BLOCK_56 || 0),

  // VoteTreasury start blocks (optional; if not set, fallback to latest - LOOKBACK)
  VOTE_TREASURY_START_BLOCK_97: Number(process.env.VOTE_TREASURY_START_BLOCK_97 || 0),
  VOTE_TREASURY_START_BLOCK_56: Number(process.env.VOTE_TREASURY_START_BLOCK_56 || 0),
  // If FACTORY_START_BLOCK_* is not set, we fallback to (latest - FACTORY_LOOKBACK_BLOCKS)
  FACTORY_LOOKBACK_BLOCKS: Number(process.env.FACTORY_LOOKBACK_BLOCKS || 250000),

  // Log scanning chunk sizes
  LOG_CHUNK_SIZE: Number(process.env.LOG_CHUNK_SIZE || "2000"),
  // When we need to split ranges due to public RPC limits, don't split below this span.
  MIN_LOG_CHUNK_SIZE: Number(process.env.MIN_LOG_CHUNK_SIZE || "250"),

  // Optional daily repair job settings
  REPAIR_LOOKBACK_BLOCKS: Number(process.env.REPAIR_LOOKBACK_BLOCKS || 20000),
  REPAIR_REWIND_BLOCKS: Number(process.env.REPAIR_REWIND_BLOCKS || 200),

  // Poll interval for the always-on indexer loop in server.ts
  // NOTE: Testnet UX benefits from lower latency; tune up for mainnet.
  INDEXER_INTERVAL_MS: Number(process.env.INDEXER_INTERVAL_MS || 5000),

  // Lower default confirmations for faster UI updates (especially on testnet).
  CONFIRMATIONS: Number(process.env.CONFIRMATIONS || "1"),

  // Optional telemetry (recommended). If not set, telemetry is disabled.
  TELEMETRY_INGEST_URL: process.env.TELEMETRY_INGEST_URL || "https://upmeme-telemetry-production.up.railway.app/ingest",
  TELEMETRY_TOKEN: process.env.TELEMETRY_TOKEN || "datraadjetochnooit1234!!",
  TELEMETRY_INTERVAL_MS: Number(process.env.TELEMETRY_INTERVAL_MS || "15000"),

  PORT: Number(process.env.PORT || "3000")
};
</file>

<file path="realtime-indexer/src/jobs/dailyRepair.ts">
import { runRepairOnce } from "../indexer.js";

// Designed to be run as a one-off process (e.g., Railway cron service).
// It rewinds recent cursor state and replays a bounded lookback window.

async function main() {
  await runRepairOnce();
}

main()
  .then(() => {
    // Ensure clean process exit for cron-style runs
    process.exit(0);
  })
  .catch((e) => {
    console.error("dailyRepair failed", e);
    process.exit(1);
  });
</file>

<file path="realtime-indexer/src/telemetry.ts">
import { ENV } from "./env.js";

export type TelemetrySnapshot = {
  service: string;
  ts: number;
  ok: boolean;
  // App-level
  rps_1m?: number;
  errors_1m?: number;
  // Indexer-level
  last_indexed_block?: number;
  head_block?: number;
  lag_blocks?: number;
  last_indexer_run_ms_ago?: number;
  last_indexer_error_ms_ago?: number;
  // Process
  mem_mb?: number;
};

function nowSec() {
  return Math.floor(Date.now() / 1000);
}

function memMb() {
  const rss = process.memoryUsage().rss;
  return Math.round((rss / 1024 / 1024) * 10) / 10;
}

async function postJson(url: string, token: string, payload: any) {
  const res = await fetch(url, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      "x-telemetry-token": token,
    },
    body: JSON.stringify(payload),
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`telemetry ingest failed: ${res.status} ${txt}`);
  }
}

/**
 * Starts a lightweight telemetry reporter.
 *
 * This MUST be safe during viral load:
 * - One small POST per interval
 * - No heavy DB queries (caller can decide what to include)
 */
export function startTelemetryReporter(getSnapshot: () => Promise<TelemetrySnapshot>) {
  const ingestUrl = (ENV.TELEMETRY_INGEST_URL || "").trim();
  const token = (ENV.TELEMETRY_TOKEN || "").trim();
  if (!ingestUrl || !token) return;

  const intervalMs = ENV.TELEMETRY_INTERVAL_MS;

  setInterval(async () => {
    try {
      const snap = await getSnapshot();
      // Ensure required fields
      const payload = {
        ...snap,
        ts: snap.ts || nowSec(),
        mem_mb: snap.mem_mb ?? memMb(),
      };
      await postJson(ingestUrl, token, payload);
    } catch (e) {
      // Do not crash the process if telemetry fails
      console.warn("telemetry reporter error", e);
    }
  }, intervalMs);
}
</file>

<file path="realtime-indexer/src/timeframes.ts">
export type TF = "5s" | "1m" | "5m" | "15m" | "1h";

export const TIMEFRAMES: TF[] = ["5s", "1m", "5m", "15m", "1h"];

const TF_SECONDS: Record<TF, number> = {
  "5s": 5,
  "1m": 60,
  "5m": 300,
  "15m": 900,
  "1h": 3600
};

export function bucketStart(tsSec: number, tf: TF): number {
  const s = TF_SECONDS[tf];
  return Math.floor(tsSec / s) * s;
}
</file>

<file path="realtime-indexer/SUPABASE_SCHEMA_FIX.sql">
-- UPMEME Supabase schema fix (League + profiles/comments)
-- Safe to run multiple times.

-- ---------------------------
-- campaigns
-- ---------------------------
ALTER TABLE public.campaigns
  ADD COLUMN IF NOT EXISTS logo_uri text,
  ADD COLUMN IF NOT EXISTS created_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS factory_address text,
  ADD COLUMN IF NOT EXISTS graduated_at_chain timestamptz,
  ADD COLUMN IF NOT EXISTS graduated_block bigint,
  ADD COLUMN IF NOT EXISTS fee_recipient_address text;


CREATE INDEX IF NOT EXISTS campaigns_chain_factory_idx
  ON public.campaigns(chain_id, factory_address);
CREATE INDEX IF NOT EXISTS campaigns_chain_created_block_idx
  ON public.campaigns(chain_id, created_block);

CREATE INDEX IF NOT EXISTS campaigns_chain_graduated_at_idx
  ON public.campaigns(chain_id, graduated_at_chain DESC);

-- ---------------------------
-- curve_trades: ensure log_index exists for stable UI keys
-- ---------------------------
ALTER TABLE public.curve_trades
  ADD COLUMN IF NOT EXISTS log_index integer;

CREATE INDEX IF NOT EXISTS curve_trades_chain_campaign_side_time_idx
  ON public.curve_trades(chain_id, campaign_address, side, block_time DESC);

-- ---------------------------
-- user_profiles
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.user_profiles (
  chain_id integer NOT NULL,
  address text NOT NULL,
  display_name text,
  avatar_url text,
  bio text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

-- Ensure expected columns exist (if table was created earlier with a different shape)
ALTER TABLE public.user_profiles
  ADD COLUMN IF NOT EXISTS display_name text,
  ADD COLUMN IF NOT EXISTS avatar_url text,
  ADD COLUMN IF NOT EXISTS bio text,
  ADD COLUMN IF NOT EXISTS created_at timestamptz,
  ADD COLUMN IF NOT EXISTS updated_at timestamptz;

-- ---------------------------
-- auth_nonces (used for profile/comment signatures)
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.auth_nonces (
  chain_id integer NOT NULL,
  address text NOT NULL,
  nonce text NOT NULL,
  expires_at timestamptz NOT NULL,
  used_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chain_id, address)
);

ALTER TABLE public.auth_nonces
  ADD COLUMN IF NOT EXISTS nonce text,
  ADD COLUMN IF NOT EXISTS expires_at timestamptz,
  ADD COLUMN IF NOT EXISTS used_at timestamptz,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

-- ---------------------------
-- token_comments
-- ---------------------------
CREATE TABLE IF NOT EXISTS public.token_comments (
  id bigserial PRIMARY KEY,
  chain_id integer NOT NULL,
  campaign_address text NOT NULL,
  token_address text,
  author_address text NOT NULL,
  body text NOT NULL,
  parent_id bigint,
  status integer NOT NULL DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

ALTER TABLE public.token_comments
  ADD COLUMN IF NOT EXISTS token_address text,
  ADD COLUMN IF NOT EXISTS parent_id bigint,
  ADD COLUMN IF NOT EXISTS status integer,
  ADD COLUMN IF NOT EXISTS created_at timestamptz;

CREATE INDEX IF NOT EXISTS token_comments_chain_campaign_id_idx
  ON public.token_comments(chain_id, campaign_address, id DESC);

-- Note: if you use RLS on these tables, ensure your server-side DB user (DATABASE_URL)
-- has permissions, or disable RLS for these tables (since Vercel/Railway access via Postgres).
</file>

<file path="realtime-indexer/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "sourceMap": true
  },
  "include": ["src"]
}
</file>

<file path="run-tests.mjs">
import "./test/factory.test.js";

console.log(" Hardhat runtime loaded, running tests...");
</file>

<file path="scripts/deploy-testnet.ts">
import { ethers } from "hardhat";

async function main() {
  const router = process.env.PANCAKE_V2_ROUTER!;
  const feeRecipient = process.env.FEE_RECIPIENT!;
  const protocolFeeBps = BigInt(process.env.PROTOCOL_FEE_BPS ?? "200");

  const [deployer] = await ethers.getSigners();
  console.log("Deployer:", deployer.address);
  console.log("Router:", router);

  const Factory = await ethers.getContractFactory("LaunchFactory");
  const factory = await Factory.deploy(router);
  await factory.waitForDeployment();

  const factoryAddr = await factory.getAddress();
  console.log("LaunchFactory deployed:", factoryAddr);

  // Update fee recipient if you dont want it to remain deployer
  if (feeRecipient.toLowerCase() !== deployer.address.toLowerCase()) {
    const tx = await factory.setFeeRecipient(feeRecipient);
    await tx.wait();
    console.log("FeeRecipient set:", feeRecipient);
  }

  // Optional: set protocol fee (constructor sets 200 already)
  if (protocolFeeBps !== 200n) {
    const tx = await factory.setProtocolFee(protocolFeeBps);
    await tx.wait();
    console.log("ProtocolFeeBps set:", protocolFeeBps.toString());
  }

  // Optional: setConfig if you want to override defaults
  // await (await factory.setConfig({ ... })).wait();

  console.log("Done.");
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
</file>

<file path="scripts/deploy.ts">
import { ethers } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deployer:", await deployer.getAddress());
  // Intentionally left minimal for test-focused repo.
}

main().catch((e) => {
  console.error(e);
  process.exitCode = 1;
});
</file>

<file path="scripts/deployAll.ts">
import fs from "fs";
import path from "path";
import { ethers, network } from "hardhat";

function mustEnv(name: string, fallback?: string): string {
  const v = (process.env[name] ?? fallback ?? "").trim();
  if (!v) throw new Error(`Missing env var ${name}`);
  return v;
}

function numEnv(name: string, fallback: number): number {
  const raw = (process.env[name] ?? "").trim();
  if (!raw) return fallback;
  const n = Number(raw);
  return Number.isFinite(n) ? n : fallback;
}

function writeDeployment(networkName: string, data: any) {
  const outDir = path.join(__dirname, "..", "deployments");
  fs.mkdirSync(outDir, { recursive: true });
  const file = path.join(outDir, `${networkName}.json`);
  fs.writeFileSync(file, JSON.stringify(data, null, 2));
  return file;
}

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log(`Network: ${network.name}`);
  console.log(`Deployer: ${deployer.address}`);

  const routerAddress = mustEnv("PANCAKE_ROUTER", process.env.ROUTER_ADDRESS);
  const treasurySafe = mustEnv("TREASURY_SAFE", process.env.FEE_RECIPIENT);
  const upgradeDelaySeconds = numEnv("UPGRADE_DELAY_SECONDS", 2 * 24 * 60 * 60);
  const protocolFeeBps = BigInt(numEnv("PROTOCOL_FEE_BPS", 200));

  console.log("Router:", routerAddress);
  console.log("Treasury Safe:", treasurySafe);
  console.log("Upgrade delay (seconds):", upgradeDelaySeconds);
  console.log("Protocol fee bps:", protocolFeeBps.toString());

  // 1) League Vault (custody) owned by Treasury Safe
  const Vault = await ethers.getContractFactory("TreasuryVault");
  const vault = await Vault.deploy(treasurySafe);
  await vault.waitForDeployment();
  const vaultAddr = await vault.getAddress();
  console.log("TreasuryVault:", vaultAddr);

  // 2) League Router (receiver) admin = Treasury Safe
  const Router = await ethers.getContractFactory("TreasuryRouter");
  const leagueRouter = await Router.deploy(treasurySafe, vaultAddr, upgradeDelaySeconds);
  await leagueRouter.waitForDeployment();
  const leagueRouterAddr = await leagueRouter.getAddress();
  console.log("TreasuryRouter (League Receiver):", leagueRouterAddr);

  // 3) Factory (dex router + leagueReceiver)
  const Factory = await ethers.getContractFactory("LaunchFactory");
  const factory = await Factory.deploy(routerAddress, leagueRouterAddr);
  await factory.waitForDeployment();
  const factoryAddr = await factory.getAddress();
  console.log("LaunchFactory:", factoryAddr);

  // 4) Route protocol fees (buy/sell + finalize) to Treasury Safe
  const tx1 = await factory.setFeeRecipient(treasurySafe);
  await tx1.wait();
  console.log("FeeRecipient set:", treasurySafe);

  // 5) Ensure protocol fee matches your config
  try {
    const current = await factory.protocolFeeBps();
    if (BigInt(current) !== protocolFeeBps) {
      const tx2 = await factory.setProtocolFee(protocolFeeBps);
      await tx2.wait();
      console.log("ProtocolFeeBps set:", protocolFeeBps.toString());
    }
  } catch (e) {
    console.warn("[deployAll] Could not set protocol fee (skipping):", (e as any)?.message ?? e);
  }

  // 6) UPVoteTreasury (League votes). Owner + feeReceiver are Treasury Safe.
  const UPVoteTreasury = await ethers.getContractFactory("UPVoteTreasury");
  const voteTreasury = await UPVoteTreasury.deploy(treasurySafe, treasurySafe);
  await voteTreasury.waitForDeployment();
  const voteTreasuryAddr = await voteTreasury.getAddress();
  console.log("UPVoteTreasury:", voteTreasuryAddr);

  const out = {
    network: network.name,
    chainId: Number((await ethers.provider.getNetwork()).chainId),
    deployer: deployer.address,
    router: routerAddress,
    treasurySafe,
    upgradeDelaySeconds,
    protocolFeeBps: protocolFeeBps.toString(),
    contracts: {
      TreasuryVault: vaultAddr,
      TreasuryRouter: leagueRouterAddr,
      LaunchFactory: factoryAddr,
      UPVoteTreasury: voteTreasuryAddr,
    },
  };

  const file = writeDeployment(network.name, out);
  console.log("\nSaved deployment:", file);

  console.log("\nFrontend env (Vite):");
  console.log(`VITE_FACTORY_ADDRESS_${out.chainId}=${factoryAddr}`);
  console.log(`VITE_VOTE_TREASURY_ADDRESS_${out.chainId}=${voteTreasuryAddr}`);
  console.log("\nLeague funds:");
  console.log("- Protocol fees -> Treasury Safe:", treasurySafe);
  console.log("- League slice -> TreasuryRouter -> TreasuryVault:", leagueRouterAddr, "->", vaultAddr);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
</file>

<file path="scripts/deployFactory.ts">
import { ethers, network } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log(`Network: ${network.name}`);
  console.log(`Deployer: ${await deployer.getAddress()}`);

  let routerAddress = (process.env.ROUTER_ADDRESS ?? "").trim();
  const deployMock = process.env.DEPLOY_MOCK_ROUTER === "true";

  if (!routerAddress && deployMock) {
    const wrapped = (process.env.MOCK_ROUTER_WRAPPED ?? deployer.address).trim();
    console.log(`Deploying MockRouter with wrapped token ${wrapped}...`);
    const MockRouter = await ethers.getContractFactory("MockRouter");
    const mockRouter = await MockRouter.deploy(deployer.address, wrapped);
    await mockRouter.waitForDeployment();
    routerAddress = await mockRouter.getAddress();
    console.log(`MockRouter deployed at ${routerAddress}`);
  }

  if (!routerAddress) {
    throw new Error(
      "Missing ROUTER_ADDRESS. Provide a Pancake router address or set DEPLOY_MOCK_ROUTER=true for local tests."
    );
  }

  console.log(`Deploying LaunchFactory with router ${routerAddress}...`);
  const LaunchFactory = await ethers.getContractFactory("LaunchFactory");
  const factory = await LaunchFactory.deploy(routerAddress);
  await factory.waitForDeployment();
  const factoryAddress = await factory.getAddress();
  console.log(`LaunchFactory deployed at ${factoryAddress}`);

  const feeRecipient = (process.env.FEE_RECIPIENT ?? "").trim();
  if (feeRecipient) {
    console.log(`Setting fee recipient to ${feeRecipient}...`);
    const tx = await factory.setFeeRecipient(feeRecipient);
    await tx.wait();
  }

  const protocolFeeBpsRaw = (process.env.PROTOCOL_FEE_BPS ?? "").trim();
  if (protocolFeeBpsRaw) {
    const feeValue = Number(protocolFeeBpsRaw);
    if (!Number.isFinite(feeValue) || feeValue < 0 || feeValue > 1000) {
      throw new Error("PROTOCOL_FEE_BPS must be between 0 and 1000.");
    }
    console.log(`Setting protocol fee to ${feeValue} bps...`);
    const tx = await factory.setProtocolFee(feeValue);
    await tx.wait();
  }

  console.log("Deployment complete. Export these addresses for the frontend:");
  console.log(`FACTORY_ADDRESS=${factoryAddress}`);
  if (deployMock) {
    console.log(`MOCK_ROUTER_ADDRESS=${routerAddress}`);
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
</file>

<file path="scripts/deployLeagueTreasury.ts">
import { ethers } from "hardhat";

/**
 * Safes (BSC testnet):
 * - Ops Safe:      0xd41B4185f9406312a1637CbD39A6c2038E46770d
 * - Treasury Safe: 0x20d71e7f04121C63A2664B19cB23b378d75B58C4
 *
 * For mainnet, set these to your production Safes (2-of-3) and install a Delay module on the Treasury Safe.
 */

const TREASURY_SAFE = "0x20d71e7f04121C63A2664B19cB23b378d75B58C4";

// Recommended: 48h on mainnet; you can shorten on testnet if you want faster iteration.
const UPGRADE_DELAY_SECONDS = 2 * 24 * 60 * 60;

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deployer:", deployer.address);

  const pancakeRouter = process.env.PANCAKE_ROUTER;
  if (!pancakeRouter) {
    throw new Error("Missing PANCAKE_ROUTER env var (PancakeSwap router address).");
  }

  // 1) Deploy Vault (custody) owned by Treasury Safe
  const Vault = await ethers.getContractFactory("TreasuryVault");
  const vault = await Vault.deploy(TREASURY_SAFE);
  await vault.waitForDeployment();
  const vaultAddr = await vault.getAddress();
  console.log("TreasuryVault:", vaultAddr);

  // 2) Deploy Router (immutable receiver) admin = Treasury Safe
  const Router = await ethers.getContractFactory("TreasuryRouter");
  const leagueRouter = await Router.deploy(TREASURY_SAFE, vaultAddr, UPGRADE_DELAY_SECONDS);
  await leagueRouter.waitForDeployment();
  const leagueRouterAddr = await leagueRouter.getAddress();
  console.log("TreasuryRouter (League Receiver):", leagueRouterAddr);

  // 3) Deploy Factory (dex router + leagueReceiver)
  const Factory = await ethers.getContractFactory("LaunchFactory");
  const factory = await Factory.deploy(pancakeRouter, leagueRouterAddr);
  await factory.waitForDeployment();
  const factoryAddr = await factory.getAddress();
  console.log("LaunchFactory:", factoryAddr);

  // 4) Route protocol fees (buy/sell + finalize) to Treasury Safe
  const tx = await factory.setFeeRecipient(TREASURY_SAFE);
  await tx.wait();
  console.log("FeeRecipient set to Treasury Safe:", TREASURY_SAFE);

  console.log("\nSummary:");
  console.log("- Protocol fees go to:", TREASURY_SAFE);
  console.log("- League 0.25% goes to:", leagueRouterAddr, "(auto-forward to vault)");
  console.log("- League vault:", vaultAddr);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
</file>

<file path="scripts/deployUPVoteTreasury.ts">
import { ethers } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();

  const feeReceiver = process.env.FEE_RECEIVER;
  if (!feeReceiver) throw new Error("Missing FEE_RECEIVER env var");

  const UPVoteTreasury = await ethers.getContractFactory("UPVoteTreasury");
  const treasury = await UPVoteTreasury.deploy(deployer.address, feeReceiver);
  await treasury.waitForDeployment();

  const addr = await treasury.getAddress();
  console.log("UPVoteTreasury deployed to:", addr);

  // Configure minimums (example values; set yours)
  // Native BNB min: 0.005 BNB
  await (await treasury.setAsset(ethers.ZeroAddress, true, ethers.parseEther("0.005"))).wait();

  // Optional: set ERC20 mins (addresses depend on network)
  // await (await treasury.setAsset(USDT_ADDR, true, ethers.parseUnits("2", 18))).wait();

  console.log("Configured assets.");
}

main().catch((e) => {
  console.error(e);
  process.exitCode = 1;
});
</file>

<file path="scripts/exportAbis.ts">
import fs from "fs";
import path from "path";
import { artifacts } from "hardhat";

async function main() {
  // Adjust if your folder layout differs
  const outDir = path.join(__dirname, "..", "frontend", "src", "abi");
  fs.mkdirSync(outDir, { recursive: true });

  const names = ["LaunchFactory", "LaunchCampaign", "LaunchToken"];

  for (const name of names) {
    const art = await artifacts.readArtifact(name);
    // Write minimal json with { abi: [...] } so your frontend can use `.abi`
    fs.writeFileSync(
      path.join(outDir, `${name}.json`),
      JSON.stringify({ abi: art.abi }, null, 2)
    );
    console.log(`Wrote ${name}.json`);
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
</file>

<file path="scripts/sync-abis.mjs">
import fs from "fs";
import path from "path";

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function copyAbi({ artifactPath, outPath, onlyAbi = true }) {
  const raw = fs.readFileSync(artifactPath, "utf8");
  const artifact = JSON.parse(raw);

  const payload = onlyAbi ? artifact.abi : artifact;

  ensureDir(path.dirname(outPath));
  fs.writeFileSync(outPath, JSON.stringify(payload, null, 2));
  console.log(` Wrote ${onlyAbi ? "ABI" : "artifact"}: ${outPath}`);
}

// ---- Configure paths here ----
// Hardhat artifact for LaunchCampaign:
const CAMPAIGN_ARTIFACT = path.join(
  process.cwd(),
  "artifacts",
  "contracts",
  "LaunchCampaign.sol",
  "LaunchCampaign.json"
);

// Where your frontend reads ABI from:
const FRONTEND_ABI_OUT = path.join(
  process.cwd(),
  "frontend",
  "src",
  "abi",
  "LaunchCampaign.json"
);

// Copy only the ABI array (smaller and faster for Vite)
copyAbi({
  artifactPath: CAMPAIGN_ARTIFACT,
  outPath: FRONTEND_ABI_OUT,
  onlyAbi: true,
});
</file>

<file path="test/backup/LaunchCampaign.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { deployCoreFixture } from "./fixtures/core";
import { quoteBuyExactTokens, quoteSellExactTokens, currentPrice as priceFn } from "./helpers/math";
import { getBalance } from "./helpers/balances";

async function createCampaignFixture() {
  const fx = await deployCoreFixture();
  const { factory, creator } = fx;

  const req = {
    name: "MyToken",
    symbol: "MYT",
    logoURI: "ipfs://logo",
    xAccount: "x",
    website: "w",
    extraLink: "e",
    basePrice: 0n,
    priceSlope: 0n,
    graduationTarget: 0n,
    lpReceiver: await fx.lpReceiver.getAddress(),
    initialBuyBnbWei: 0n
  };

  await factory.connect(creator).createCampaign(req as any);
  const info = await factory.getCampaign(0n);
  const campaign = await ethers.getContractAt("LaunchCampaign", info.campaign);
  const token = await ethers.getContractAt("LaunchToken", await campaign.token());
  return { ...fx, info, campaign, token, req };
}

describe("LaunchCampaign", function () {
  it("initial state / immutables / token minted to campaign", async () => {
    const { campaign, token } = await loadFixture(createCampaignFixture);

    expect(await campaign.launched()).to.eq(false);
    expect(await token.owner()).to.eq(await campaign.getAddress());

    const totalSupply = await campaign.totalSupply();
    expect(await token.balanceOf(await campaign.getAddress())).to.eq(totalSupply);
    expect(await token.tradingEnabled()).to.eq(false);
  });

  it("quoteBuyExactTokens / quoteSellExactTokens guard rails", async () => {
    const { campaign } = await loadFixture(createCampaignFixture);

    await expect(campaign.quoteBuyExactTokens(0n)).to.be.revertedWith("zero amount");
    await expect(campaign.quoteSellExactTokens(0n)).to.be.revertedWith("zero amount");
    await expect(campaign.quoteSellExactTokens(1n)).to.be.revertedWith("exceeds sold");

    const curveSupply = await campaign.curveSupply();
    await expect(campaign.quoteBuyExactTokens(curveSupply + 1n)).to.be.revertedWith("sold out");
  });

  it("currentPrice matches formula", async () => {
    const { campaign } = await loadFixture(createCampaignFixture);
    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();

    expect(await campaign.currentPrice()).to.eq(priceFn(base, slope, 0n));
  });

  it("buyExactTokens: transfers tokens, updates sold & counters, emits, sends fee, refunds overpay", async () => {
    const { campaign, token, alice, feeRecipient } = await loadFixture(createCampaignFixture);

    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();
    const feeBps = await campaign.protocolFeeBps();

    const amountOut = ethers.parseEther("10");
    const sold0 = await campaign.sold();
    const { costNoFee, fee, total } = quoteBuyExactTokens(BigInt(sold0), BigInt(amountOut), BigInt(base), BigInt(slope), BigInt(feeBps));

    const feeBefore = await getBalance(await feeRecipient.getAddress());
    const buyerBefore = await getBalance(await alice.getAddress());
    const campBefore = await getBalance(await campaign.getAddress());

    const tx = await campaign.connect(alice).buyExactTokens(amountOut, total, { value: total + ethers.parseEther("1") });
    await expect(tx).to.emit(campaign, "TokensPurchased").withArgs(await alice.getAddress(), amountOut, total);

    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut);
    expect(await campaign.sold()).to.eq(sold0 + amountOut);

    // counters
    expect(await campaign.totalBuyVolumeWei()).to.eq(costNoFee);
    expect(await campaign.buyersCount()).to.eq(1n);
    expect(await campaign.hasBought(await alice.getAddress())).to.eq(true);

    // fee recipient got fee
    const feeAfter = await getBalance(await feeRecipient.getAddress());
    expect(feeAfter - feeBefore).to.eq(fee);

    // campaign retains no-fee portion
    const campAfter = await getBalance(await campaign.getAddress());
    expect(campAfter - campBefore).to.eq(costNoFee);

    // buyer got refund of (msg.value - total); balance delta is affected by gas so we only assert it's <= total+gas
    const buyerAfter = await getBalance(await alice.getAddress());
    expect(buyerBefore - buyerAfter).to.be.gte(total); // paid at least total+gas
  });

  it("buyExactTokens: slippage & value checks", async () => {
    const { campaign, alice } = await loadFixture(createCampaignFixture);

    const amountOut = ethers.parseEther("1");
    const total = await campaign.quoteBuyExactTokens(amountOut);

    await expect(campaign.connect(alice).buyExactTokens(amountOut, total - 1n, { value: total }))
      .to.be.revertedWith("slippage");

    await expect(campaign.connect(alice).buyExactTokens(amountOut, total, { value: total - 1n }))
      .to.be.revertedWith("insufficient value");
  });

  it("sellExactTokens: transfers tokens back, pays out, updates sold & counters, emits, takes fee", async () => {
    const { campaign, token, alice, feeRecipient } = await loadFixture(createCampaignFixture);

    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();
    const feeBps = await campaign.protocolFeeBps();

    // buy first
    const amountOut = ethers.parseEther("10");
    const totalBuy = await campaign.quoteBuyExactTokens(amountOut);
    await campaign.connect(alice).buyExactTokens(amountOut, totalBuy, { value: totalBuy });

    // approve and sell half
    const amountIn = ethers.parseEther("4");
    await token.connect(alice).approve(await campaign.getAddress(), amountIn);

    const soldBefore = await campaign.sold();
    const { gross, fee, payout } = quoteSellExactTokens(BigInt(soldBefore), BigInt(amountIn), BigInt(base), BigInt(slope), BigInt(feeBps));

    const feeBefore = await getBalance(await feeRecipient.getAddress());
    const campBefore = await getBalance(await campaign.getAddress());

    const tx = await campaign.connect(alice).sellExactTokens(amountIn, payout);
    await expect(tx).to.emit(campaign, "TokensSold").withArgs(await alice.getAddress(), amountIn, payout);

    expect(await campaign.sold()).to.eq(soldBefore - amountIn);
    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut - amountIn);

    // fee recipient got fee
    const feeAfter = await getBalance(await feeRecipient.getAddress());
    expect(feeAfter - feeBefore).to.eq(fee);

    // campaign balance decreases by gross
    const campAfter = await getBalance(await campaign.getAddress());
    expect(campBefore - campAfter).to.eq(gross);

    expect(await campaign.totalSellVolumeWei()).to.eq(gross);
  });

  it("sellExactTokens: slippage protection", async () => {
    const { campaign, token, alice } = await loadFixture(createCampaignFixture);

    const amountOut = ethers.parseEther("5");
    const totalBuy = await campaign.quoteBuyExactTokens(amountOut);
    await campaign.connect(alice).buyExactTokens(amountOut, totalBuy, { value: totalBuy });

    const amountIn = ethers.parseEther("1");
    await token.connect(alice).approve(await campaign.getAddress(), amountIn);

    const minPayout = (await campaign.quoteSellExactTokens(amountIn)) + 1n;
    await expect(campaign.connect(alice).sellExactTokens(amountIn, minPayout)).to.be.revertedWith("slippage");
  });

  it("buyExactTokensFor can be exercised via FactoryCaller helper; onlyFactory enforced; recipient nonzero; refund goes to caller", async () => {
    const { creator, owner } = await deployCoreFixture();

    // Deploy a campaign directly with factory set to FactoryCaller (test-only)
    const Caller = await ethers.getContractFactory("FactoryCaller");
    const caller = await Caller.deploy();

    const Router = await ethers.getContractFactory("MockRouter");
    const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);

    const Campaign = await ethers.getContractFactory("LaunchCampaign");
    const params = {
      name: "T",
      symbol: "T",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      totalSupply: ethers.parseEther("1000"),
      curveBps: 5000,
      liquidityTokenBps: 4000,
      basePrice: 10n ** 12n,
      priceSlope: 10n ** 9n,
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000,
      protocolFeeBps: 200,
      router: await router.getAddress(),
      lpReceiver: await creator.getAddress(),
      feeRecipient: await owner.getAddress(),
      creator: await creator.getAddress(),
      factory: await caller.getAddress()
    };

    const impl = await Campaign.deploy();
await impl.waitForDeployment();

// Deploy an EIP-1167 minimal proxy clone of the implementation
const implAddr = await impl.getAddress();
const minimalProxyBytecode =
  "0x3d602d80600a3d3981f3363d3d373d3d3d363d73" +
  implAddr.slice(2).toLowerCase() +
  "5af43d82803e903d91602b57fd5bf3";
const tx = await creator.sendTransaction({ data: minimalProxyBytecode });
const receipt = await tx.wait();
const cloneAddr = receipt!.contractAddress;

const campaign = Campaign.attach(cloneAddr);
await campaign.initialize(params);

    // EOA cannot call onlyFactory
    await expect(
      campaign.connect(creator).buyExactTokensFor(await creator.getAddress(), ethers.parseEther("1"), 0n, { value: 0n })
    ).to.be.revertedWith("ONLY_FACTORY");

    const total = await campaign.quoteBuyExactTokens(ethers.parseEther("2"));

    await expect(
      caller.buyFor(await campaign.getAddress(), ethers.ZeroAddress, ethers.parseEther("2"), total, { value: total })
    ).to.be.revertedWith("zero recipient");

    // refund: send extra, should return to caller contract (msg.sender in campaign = caller)
    const extra = ethers.parseEther("1");
    await caller.buyFor(await campaign.getAddress(), await creator.getAddress(), ethers.parseEther("2"), total, { value: total + extra });

    // Caller should have received refund (held in contract balance)
    const balCaller = await ethers.provider.getBalance(await caller.getAddress());
    expect(balCaller).to.eq(extra);
  });


  it("edge-case: quote enforces curveSupply but buyExactTokens does not; overselling is possible", async () => {
    const { campaign, token, alice } = await loadFixture(createCampaignFixture);

    const curveSupply = await campaign.curveSupply();

    // quote blocks oversell
    await expect(campaign.quoteBuyExactTokens(curveSupply + 1n)).to.be.revertedWith("sold out");

    // buy path currently does not enforce this (sold can exceed curveSupply)
    const amountOut = curveSupply + 1n;
    const maxCost = (await campaign.quoteBuyExactTokens(curveSupply)) + ethers.parseEther("100"); // generous
    await expect(campaign.connect(alice).buyExactTokens(amountOut, maxCost, { value: maxCost })).to.not.be.reverted;

    expect(await campaign.sold()).to.eq(amountOut);
    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut);
  });

  it("edge-case: buyExactTokens / sellExactTokens accept zero amounts while quote functions reject them", async () => {
    const { campaign, token, alice } = await loadFixture(createCampaignFixture);

    // buy 0 succeeds (no-op)
    await expect(campaign.connect(alice).buyExactTokens(0n, 0n, { value: 0n })).to.not.be.reverted;

    // Need tokens to test sell 0 path: buy small amount first
    const amountOut = ethers.parseEther("1");
    const totalBuy = await campaign.quoteBuyExactTokens(amountOut);
    await campaign.connect(alice).buyExactTokens(amountOut, totalBuy, { value: totalBuy });

    await token.connect(alice).approve(await campaign.getAddress(), 0n);
    await expect(campaign.connect(alice).sellExactTokens(0n, 0n)).to.not.be.reverted;

    // quote paths reject zeros
    await expect(campaign.quoteBuyExactTokens(0n)).to.be.revertedWith("zero amount");
    await expect(campaign.quoteSellExactTokens(0n)).to.be.revertedWith("zero amount");
  });

  it("finalize: reverts unless threshold met; onlyOwner; marks launched; adds liquidity; burns unsold; transfers creatorReserve; pays creator; enables trading", async () => {
    const { campaign, token, creator, alice, feeRecipient, lpReceiver, router } = await loadFixture(createCampaignFixture);

    // onlyOwner
    await expect(campaign.connect(alice).finalize(0n, 0n))
      .to.be.revertedWithCustomError(campaign, "OwnableUnauthorizedAccount");

    await expect(campaign.connect(creator).finalize(0n, 0n)).to.be.revertedWith("threshold");

    // Meet finalize threshold robustly by selling out the curve
    // (With some parameter sets, graduationTarget may be unreachable given curveSupply and pricing.)
    const curveSupply = await campaign.curveSupply();
    const totalBuy = await campaign.quoteBuyExactTokens(curveSupply);
    await campaign.connect(alice).buyExactTokens(curveSupply, totalBuy, { value: totalBuy });

    expect(await campaign.sold()).to.eq(curveSupply);

    const ownerAddr = await creator.getAddress();
    const creatorBalBefore = await getBalance(ownerAddr);
    const feeBefore = await getBalance(await feeRecipient.getAddress());

    const tx = await campaign.connect(creator).finalize(0n, 0n);
    const receipt = await tx.wait();
    // Hardhat/Ethers can expose gas pricing differently across versions (effectiveGasPrice, gasPrice, maxFeePerGas).
    // For portability, bound the creator's gas spend rather than relying on a single receipt field.
    const gasUsed = BigInt((receipt!.gasUsed ?? 0n).toString());
    const maxFeePerGas = BigInt((((tx as any).maxFeePerGas ?? (tx as any).gasPrice ?? 0n)).toString());

    await expect(tx).to.emit(campaign, "CampaignFinalized");
    await expect(tx).to.emit(router, "LiquidityAdded");

    expect(await campaign.launched()).to.eq(true);
    expect(await token.tradingEnabled()).to.eq(true);

    // campaign should be drained of native balance after finalize
    expect(await getBalance(await campaign.getAddress())).to.eq(0n);

    // creator receives payout (native) and creatorReserve (tokens)
    // Read creatorPayout + protocolFee from the CampaignFinalized event for exact balance assertions
    const ev = receipt!.logs
      .map((l: any) => {
        try { return campaign.interface.parseLog(l); } catch { return null; }
      })
      .find((p: any) => p && p.name === "CampaignFinalized");

    expect(ev).to.not.eq(undefined);

    const protocolFee = BigInt(ev!.args.protocolFee.toString());
    const creatorPayout = BigInt(ev!.args.creatorPayout.toString());

    const creatorBalAfter = await getBalance(ownerAddr);
    // creatorBalBefore + creatorPayout - creatorBalAfter == gas spent by creator for finalize tx
    const spent = creatorBalBefore + creatorPayout - creatorBalAfter;
    expect(spent).to.be.gt(0n);
    if (maxFeePerGas !== 0n) {
      expect(spent).to.be.lte(gasUsed * maxFeePerGas);
    }

    const creatorReserve = await campaign.creatorReserve();
    expect(await token.balanceOf(ownerAddr)).to.be.gte(creatorReserve); // may also include tokens bought by creator in other tests

    // unsold curve tokens burned reduces totalSupply by (curveSupply - soldAtFinalize)
    const totalSupply = await campaign.totalSupply();
    const soldAtFinalize = await campaign.sold();
    const expectedBurn = curveSupply - soldAtFinalize;
    expect(await token.totalSupply()).to.eq(totalSupply - expectedBurn);

    // fee recipient should have received finalize protocol fee (plus any trade fees from buys/sells)
    const feeAfter = await getBalance(await feeRecipient.getAddress());
    expect(feeAfter - feeBefore).to.be.gte(protocolFee);
  });

  it("post-finalize: trading restriction lifted; buys/sells revert", async () => {
    const { campaign, token, creator, alice, bob } = await loadFixture(createCampaignFixture);

    // Sell out curve so finalize threshold is guaranteed.
    const curveSupply = await campaign.curveSupply();
    const totalBuy = await campaign.quoteBuyExactTokens(curveSupply);
    await campaign.connect(alice).buyExactTokens(curveSupply, totalBuy, { value: totalBuy });

    await campaign.connect(creator).finalize(0n, 0n);

    // After finalize, buy/sell entrypoints must revert on the launched guard.
    await expect(campaign.connect(alice).buyExactTokens(1n, 0n, { value: 0n }))
      .to.be.revertedWith("campaign launched");
    await expect(campaign.connect(alice).sellExactTokens(1n, 0n))
      .to.be.revertedWith("campaign launched");

    // transfers now allowed
    await token.connect(alice).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });
});
</file>

<file path="test/backup/LaunchFactory.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import { deployCoreFixture } from "./fixtures/core";
import { quoteBuyExactTokens } from "./helpers/math";

describe("LaunchFactory", function () {
  it("constructor requires router != 0 and sets defaults", async () => {
    const Factory = await ethers.getContractFactory("LaunchFactory");
    await expect(Factory.deploy(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      Factory,
      "RouterZero"
    );

    const Router = await ethers.getContractFactory("MockRouter");
    const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);
    const factory = await Factory.deploy(await router.getAddress());

    expect(await factory.router()).to.eq(await router.getAddress());
    expect((await factory.config()).totalSupply).to.be.gt(0n);
    expect(await factory.protocolFeeBps()).to.eq(200n);
  });

  it("quoteInitialBuyTotal: 0 tokens -> 0; override params respected", async () => {
    const { factory } = await deployCoreFixture();
    expect(await factory.quoteInitialBuyTotal(0n, 0n, 0n)).to.eq(0n);

    const base = 777n;
    const slope = 999n;
    const amount = ethers.parseEther("10");
    const quoted = await factory.quoteInitialBuyTotal(amount, base, slope);

    const { total } = quoteBuyExactTokens(0n, amount, base, slope, await factory.protocolFeeBps());
    expect(quoted).to.eq(total);
  });

  it("createCampaign: validates inputs, emits, persists CampaignInfo; refunds excess msg.value", async () => {
    const { factory, creator } = await deployCoreFixture();

    const bad = {
      name: "",
      symbol: "X",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: 0n,
    };

    await expect(factory.connect(creator).createCampaign(bad as any)).to.be.revertedWithCustomError(
      factory,
      "NameEmpty"
    );
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "" } as any)
    ).to.be.revertedWithCustomError(factory, "SymbolEmpty");
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "S", logoURI: "" } as any)
    ).to.be.revertedWithCustomError(factory, "LogoEmpty");

    const req = { ...bad, name: "MyToken", symbol: "MYT", logoURI: "ipfs://logo" };
    const tx = await factory.connect(creator).createCampaign(req as any, { value: ethers.parseEther("1") });

    await expect(tx).to.emit(factory, "CampaignCreated");

    expect(await factory.campaignsCount()).to.eq(1n);
    const info = await factory.getCampaign(0n);
    expect(info.creator).to.eq(await creator.getAddress());
    expect(info.name).to.eq("MyToken");
    expect(info.symbol).to.eq("MYT");
    expect(info.logoURI).to.eq("ipfs://logo");

    // getCampaignPage
    const page = await factory.getCampaignPage(0n, 10n);
    expect(page.length).to.eq(1);
    expect(page[0].campaign).to.eq(info.campaign);

    // bounds
    await expect(factory.getCampaign(1n)).to.be.revertedWithCustomError(factory, "OutOfBounds");
    await expect(factory.getCampaignPage(2n, 1n)).to.be.revertedWithCustomError(factory, "Offset");
  });

  it("createCampaign optional initialBuy: requires enough value; performs buy; refunds extra", async () => {
    const { factory, creator, feeRecipient } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei - 1n })
    ).to.be.revertedWithCustomError(factory, "InitBuyValue");

    const feeBefore = await ethers.provider.getBalance(await feeRecipient.getAddress());
    const tx = await factory
      .connect(creator)
      .createCampaign(req as any, { value: req.initialBuyBnbWei + ethers.parseEther("0.5") });
    const receipt = await tx.wait();

    const info = await factory.getCampaign(0n);
    const campaign = await ethers.getContractAt("LaunchCampaign", info.campaign);
    const token = await ethers.getContractAt("LaunchToken", await campaign.token());

    // Exact-BNB buy: token amount is determined by the curve, so just assert nonzero.
    expect(await campaign.sold()).to.be.gt(0n);
    expect(await token.balanceOf(await creator.getAddress())).to.be.gt(0n);

    // Fee recipient should have received the bonding-curve fee from the initial buy (not affected by creator gas)
    const feeAfter = await ethers.provider.getBalance(await feeRecipient.getAddress());
    expect(feeAfter).to.be.gt(feeBefore);

    // Campaign retains the no-fee portion of the buy (nonzero)
    expect(await ethers.provider.getBalance(info.campaign)).to.be.gt(0n);

    expect(receipt).to.not.eq(null);
  });

  it("createCampaign optional initialBuy: reverts when creator initial buy exceeds 1 BNB cap", async () => {
    const { factory, creator } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1.01"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei })
    ).to.be.revertedWithCustomError(factory, "InitBuyTooLarge");
  });

  it("owner-only setters with validation + events", async () => {
    const { factory, owner, alice } = await deployCoreFixture();

    await expect(factory.connect(alice).setRouter(await alice.getAddress())).to.be.revertedWithCustomError(
      factory,
      "OwnableUnauthorizedAccount"
    );

    await expect(factory.connect(owner).setRouter(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RouterZero"
    );
    await expect(factory.connect(owner).setFeeRecipient(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RecipientZero"
    );
    await expect(factory.connect(owner).setProtocolFee(1001n)).to.be.revertedWithCustomError(
      factory,
      "FeeTooHigh"
    );

    await expect(factory.connect(owner).setProtocolFee(123n)).to.emit(factory, "ProtocolFeeUpdated").withArgs(123n);
    expect(await factory.protocolFeeBps()).to.eq(123n);

    const newRouter = await (await ethers.getContractFactory("MockRouter")).deploy(
      ethers.ZeroAddress,
      ethers.ZeroAddress
    );
    await expect(factory.connect(owner).setRouter(await newRouter.getAddress()))
      .to.emit(factory, "RouterUpdated")
      .withArgs(await newRouter.getAddress());

    await expect(factory.connect(owner).setFeeRecipient(await alice.getAddress()))
      .to.emit(factory, "FeeRecipientUpdated")
      .withArgs(await alice.getAddress());

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 0n,
        curveBps: 5000n,
        liquidityTokenBps: 4000n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "SupplyZero");

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 1n,
        curveBps: 0n,
        liquidityTokenBps: 0n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "InvalidCurveBps");
  });
});
</file>

<file path="test/backup/LaunchToken.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("LaunchToken", function () {
  async function deploy() {
    const [owner, alice, bob] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("LaunchToken");
    const token = await Token.deploy("T", "T", ethers.parseEther("100"), await owner.getAddress());
    return { owner, alice, bob, token };
  }

  it("constructor sets cap and owner; rejects zero cap/owner", async () => {
    const [owner] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("LaunchToken");
    await expect(Token.deploy("T", "T", 0n, await owner.getAddress())).to.be.revertedWith("cap is zero");
    // OZ Ownable(owner_) reverts with a custom error before our own require() runs.
    await expect(Token.deploy("T", "T", 1n, ethers.ZeroAddress)).to.be.reverted;

    const token = await Token.deploy("T", "T", 123n, await owner.getAddress());
    expect(await token.cap()).to.eq(123n);
    expect(await token.owner()).to.eq(await owner.getAddress());
    expect(await token.tradingEnabled()).to.eq(false);
  });

  it("mint: onlyOwner, nonzero to, respects cap", async () => {
    const { owner, alice, token } = await deploy();
    await expect(token.connect(alice).mint(await alice.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");

    await expect(token.connect(owner).mint(ethers.ZeroAddress, 1n)).to.be.revertedWith("to zero");

    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));
    expect(await token.totalSupply()).to.eq(ethers.parseEther("10"));

    await expect(token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("100")))
      .to.be.revertedWith("cap exceeded");
  });

  it("burn: onlyOwner", async () => {
    const { owner, alice, token } = await deploy();
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));
    await expect(token.connect(alice).burn(await alice.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");

    await token.connect(owner).burn(await alice.getAddress(), ethers.parseEther("2"));
    expect(await token.balanceOf(await alice.getAddress())).to.eq(ethers.parseEther("8"));
  });

  it("trading restriction: before enableTrading, user->user transfers revert; campaign(owner) can move funds and pull via transferFrom", async () => {
    const { owner, alice, bob, token } = await deploy();

    // owner mints to alice (allowed: from==0)
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));

    // alice -> bob transfer blocked
    await expect(token.connect(alice).transfer(await bob.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "TradingNotEnabled");

    // alice approves owner (campaign), owner can move tokens even when 'from' is alice
    await token.connect(alice).approve(await owner.getAddress(), ethers.parseEther("2"));

    // owner pulls 1 token to itself (msg.sender==owner) allowed
    await token.connect(owner).transferFrom(await alice.getAddress(), await owner.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await owner.getAddress())).to.eq(ethers.parseEther("1"));

    // owner transfers from its own balance to bob (from==owner) allowed
    await token.connect(owner).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });

  it("after enableTrading, normal transfers work", async () => {
    const { owner, alice, bob, token } = await deploy();
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("3"));
    await token.connect(owner).enableTrading();
    await token.connect(alice).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });
});
</file>

<file path="test/backup/LpTimelock.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("LpTimelock", function () {
  it("constructor validations", async () => {
    const [deployer, beneficiary] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MockERC20");
    const token = await Token.deploy("LP", "LP", ethers.parseEther("100"), await deployer.getAddress());

    const Timelock = await ethers.getContractFactory("LpTimelock");
    const now = (await ethers.provider.getBlock("latest"))!.timestamp;

    await expect(Timelock.deploy(ethers.ZeroAddress, await beneficiary.getAddress(), now + 3600))
      .to.be.revertedWith("token=0");
    await expect(Timelock.deploy(await token.getAddress(), ethers.ZeroAddress, now + 3600))
      .to.be.revertedWith("beneficiary=0");
    await expect(Timelock.deploy(await token.getAddress(), await beneficiary.getAddress(), now))
      .to.be.revertedWith("releaseTime");
  });

  it("release: reverts before time; after time transfers all balance to beneficiary", async () => {
    const [deployer, beneficiary] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MockERC20");
    const token = await Token.deploy("LP", "LP", ethers.parseEther("100"), await deployer.getAddress());

    const Timelock = await ethers.getContractFactory("LpTimelock");
    const now = (await ethers.provider.getBlock("latest"))!.timestamp;
    const timelock = await Timelock.deploy(await token.getAddress(), await beneficiary.getAddress(), now + 3600);

    await expect(timelock.release()).to.be.revertedWith("not released");
    await expect(timelock.connect(beneficiary).release()).to.be.revertedWith("not released");

    // fund timelock
    await token.transfer(await timelock.getAddress(), ethers.parseEther("10"));

    // advance time
    await ethers.provider.send("evm_increaseTime", [3600]);
    await ethers.provider.send("evm_mine", []);

    await expect(timelock.release()).to.not.be.reverted; // any caller can trigger, but beneficiary receives

    expect(await token.balanceOf(await beneficiary.getAddress())).to.eq(ethers.parseEther("10"));
    expect(await token.balanceOf(await timelock.getAddress())).to.eq(0n);

    // second release: no tokens
    await expect(timelock.release()).to.be.revertedWith("no tokens");
  });
});
</file>

<file path="test/backup/UPVoteTreasury.test.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("UPVoteTreasury (forwarding)", function () {
  async function deploy() {
    const [owner, feeReceiver, alice, bob] = await ethers.getSigners();

    const Treasury = await ethers.getContractFactory("UPVoteTreasury");
    const treasury = await Treasury.deploy(owner.address, feeReceiver.address);
    await treasury.waitForDeployment();

    return { treasury, owner, feeReceiver, alice, bob };
  }

  it("deploys with feeReceiver and native enabled", async () => {
    const { treasury, feeReceiver } = await deploy();
    expect(await treasury.feeReceiver()).to.eq(feeReceiver.address);

    const cfg = await treasury.assetConfig(ethers.ZeroAddress);
    expect(cfg.enabled).to.eq(true);
  });

  it("only owner can setAsset / setFeeReceiver", async () => {
    const { treasury, alice } = await deploy();
    await expect(
      treasury.connect(alice).setAsset(ethers.ZeroAddress, true, 123n)
    ).to.be.revertedWith("NOT_OWNER");

    await expect(
      treasury.connect(alice).setFeeReceiver(alice.address)
    ).to.be.revertedWith("NOT_OWNER");
  });

  it("voteWithBNB reverts when below minAmount", async () => {
    const { treasury, owner, alice } = await deploy();

    await (await treasury.connect(owner).setAsset(
      ethers.ZeroAddress,
      true,
      ethers.parseEther("0.01")
    )).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(alice.address, ethers.ZeroHash, { value: ethers.parseEther("0.005") })
    ).to.be.revertedWith("AMOUNT_TOO_LOW");
  });

  it("voteWithBNB forwards to feeReceiver and emits event", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    await (await treasury.connect(owner).setAsset(
      ethers.ZeroAddress,
      true,
      ethers.parseEther("0.005")
    )).wait();

    const campaign = "0x0000000000000000000000000000000000001234";
    const value = ethers.parseEther("0.005");
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await ethers.provider.getBalance(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, meta, { value })
    )
      .to.emit(treasury, "VoteCast")
      .withArgs(campaign, alice.address, ethers.ZeroAddress, value, meta);

    const after = await ethers.provider.getBalance(feeReceiver.address);
    expect(after - before).to.eq(value);

    // contract balance should not accumulate (ignoring dust)
    const contractBal = await ethers.provider.getBalance(await treasury.getAddress());
    expect(contractBal).to.eq(0n);
  });

  it("voteWithToken pulls ERC20, forwards to feeReceiver, emits received amount", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    const Mock = await ethers.getContractFactory("MockERC20");
    // This repo's MockERC20 constructor is: (name, symbol, supply, to)
    const initialSupply = ethers.parseUnits("1000", 18);
    const usdt = await Mock.deploy("Tether", "USDT", initialSupply, alice.address);
    await usdt.waitForDeployment();

    // enable token with min 2
    await (await treasury
      .connect(owner)
      .setAsset(await usdt.getAddress(), true, ethers.parseUnits("2", 18))).wait();

    // approve
    await (await usdt
      .connect(alice)
      .approve(await treasury.getAddress(), ethers.parseUnits("3", 18))).wait();

    const campaign = "0x0000000000000000000000000000000000005678";
    const amount = ethers.parseUnits("3", 18);
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await usdt.balanceOf(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithToken(campaign, await usdt.getAddress(), amount, meta)
    )
      .to.emit(treasury, "VoteCast")
      // received == amount for normal ERC20
      .withArgs(campaign, alice.address, await usdt.getAddress(), amount, meta);

    const after = await usdt.balanceOf(feeReceiver.address);
    expect(after - before).to.eq(amount);

    // treasury should not hold tokens
    const held = await usdt.balanceOf(await treasury.getAddress());
    expect(held).to.eq(0n);
  });

  it("voteWithToken respects fee-on-transfer: minAmount enforced on received, and forwards received", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    const FeeToken = await ethers.getContractFactory("MockFeeOnTransferERC20");
    // 10% fee
    const feeToken = await FeeToken.deploy(1000);
    await feeToken.waitForDeployment();

    const tokenAddr = await feeToken.getAddress();

    // If we want min received = 90, set minAmount=90
    const minReceived = ethers.parseUnits("90", 18);
    await (await treasury.connect(owner).setAsset(tokenAddr, true, minReceived)).wait();

    // mint 200 to alice
    await (await feeToken.mint(alice.address, ethers.parseUnits("200", 18))).wait();

    // alice votes with 100; received by treasury will be 90
    const sendAmount = ethers.parseUnits("100", 18);
    await (await feeToken.connect(alice).approve(await treasury.getAddress(), sendAmount)).wait();

    const campaign = "0x0000000000000000000000000000000000009999";
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await feeToken.balanceOf(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithToken(campaign, tokenAddr, sendAmount, meta)
    )
      .to.emit(treasury, "VoteCast")
      .withArgs(campaign, alice.address, tokenAddr, minReceived, meta);

    const after = await feeToken.balanceOf(feeReceiver.address);
    // NOTE: fee-on-transfer tokens charge a fee on *each* transfer.
    // In this forwarding design:
    //   (1) Alice -> Treasury is taxed
    //   (2) Treasury -> feeReceiver is taxed again
    // The VoteCast event records what the Treasury received (minReceived),
    // but feeReceiver will receive less if the token taxes outgoing transfers.
    const feeBps = BigInt(await feeToken.feeBps());
    const expectedToFeeReceiver = (minReceived * (10_000n - feeBps)) / 10_000n;
    expect(after - before).to.eq(expectedToFeeReceiver);

    // treasury should not hold tokens
    const held = await feeToken.balanceOf(await treasury.getAddress());
    expect(held).to.eq(0n);
  });

  it("campaign allowlist can be enabled and enforced", async () => {
    const { treasury, owner, alice } = await deploy();

    const campaign = "0x000000000000000000000000000000000000ABCD";

    await (await treasury.connect(owner).setCampaignAllowlistEnabled(true)).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, ethers.ZeroHash, { value: 1n })
    ).to.be.revertedWith("CAMPAIGN_NOT_ALLOWED");

    await (await treasury.connect(owner).setCampaignAllowed(campaign, true)).wait();

    // enable tiny min
    await (await treasury.connect(owner).setAsset(ethers.ZeroAddress, true, 1n)).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, ethers.ZeroHash, { value: 1n })
    ).to.emit(treasury, "VoteCast");
  });

  it("direct BNB transfer to receive() does not emit VoteCast", async () => {
    const { treasury, alice } = await deploy();

    await expect(
      alice.sendTransaction({ to: await treasury.getAddress(), value: 123n })
    ).to.not.emit(treasury, "VoteCast");
  });
});
</file>

<file path="test/bondingCurveSale.test.js">
import { expect } from "chai";
import hre from "hardhat";

const { ethers } = await hre.network.connect();
const { parseEther } = ethers;

// Helper to build a sane InitParams object
function buildInitParams(tokenAddress, overrides = {}) {
  return {
    token: tokenAddress,
    tierSize: parseEther("1000"),          // 1000 tokens per tier
    startPrice: parseEther("0.0001"),      // 0.0001 BNB per token
    priceStep: parseEther("0.00001"),      // +0.00001 BNB per tier
    maxTiersPerTx: 10,
    platformFeeBps: 500,                   // 5%
    endTime: 0n,                           // no time limit
    hardCapBNB: 0n,                        // unlimited
    lpPercent: 7000,                       // 70% to LP
    router: overrides.router || overrides.owner || tokenAddress, // dummy non-zero
    treasury: overrides.treasury || overrides.owner,
    payout: overrides.payout || overrides.owner,
    mode: overrides.mode ?? 0,             // 0 = Mode.Minter
    ...overrides,
  };
}

describe("BondingCurveSale", function () {
  let owner, user, other;
  let token;
  let sale;

  beforeEach(async function () {
    [owner, user, other] = await ethers.getSigners();

    // Deploy TokenTemplate as the sale token
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    token = await TokenTemplate.deploy();
    await token.waitForDeployment();

    // Deploy BondingCurveSale implementation
    const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
    sale = await BondingCurveSale.deploy();
    await sale.waitForDeployment();
  });

  it("initializes sale with params and sets owner & paused", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    expect(await sale.token()).to.equal(tokenAddr);
    expect(await sale.tierSize()).to.equal(params.tierSize);
    expect(await sale.startPrice()).to.equal(params.startPrice);
    expect(await sale.maxTiersPerTx()).to.equal(params.maxTiersPerTx);
    expect(await sale.platformFeeBps()).to.equal(params.platformFeeBps);
    expect(await sale.lpPercent()).to.equal(params.lpPercent);
    expect(await sale.owner()).to.equal(owner.address);

    // Pausable: sale should start paused after initialize()
    expect(await sale.paused()).to.equal(true);
  });

  it("reverts if initialize() is called twice", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
    });

    await sale.connect(owner).initialize(params);

    let error;
    try {
      await sale.connect(owner).initialize(params);
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("Already initialized");
  });

  it("allows owner to run audit() in Minter mode and marks audited", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // TokenTemplate.decimals() returns 18, so audit should pass
    await sale.connect(owner).audit();

    expect(await sale.audited()).to.equal(true);
  });

  it("owner can buy in Minter mode, minting tokens and updating accounting", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // Grant MINTER_ROLE to the sale so internal mint() calls succeed
    const saleAddr = await sale.getAddress();
    await token.connect(owner).grantMinter(saleAddr);

    // Unpause sale before buying
    await sale.connect(owner).unpauseSale();

    const bnbIn = parseEther("1");
    const minTokensOut = 0n;
    const deadline = 0n;

    const tx = await sale
      .connect(owner)
      .buy(minTokensOut, deadline, { value: bnbIn });

    await tx.wait();

    const sold = await sale.sold();
    const raised = await sale.raised();
    const ownerBal = await token.balanceOf(owner.address);

    // Basic sanity checks
    expect(sold).to.be.gt(0n);
    expect(raised).to.equal(bnbIn);
    expect(ownerBal).to.be.gt(0n);
  });

  it("non-owner cannot buy while externalOk is false", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);
    await sale.connect(owner).unpauseSale();

    let error;
    try {
      await sale
        .connect(user)
        .buy(0n, 0n, { value: parseEther("0.1") });
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("External not OK");
  });

  it("unpauseSale can only be called by the owner", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // Non-owner call should revert
    let error;
    try {
      await sale.connect(user).unpauseSale();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");

    // Owner call should succeed
    await sale.connect(owner).unpauseSale();
    expect(await sale.paused()).to.equal(false);
  });

  it("quoteTokensOut returns non-zero tokens for a reasonable BNB input", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    const bnbIn = parseEther("1");
    const [tokensOut, bnbUsed, tiersCrossed] =
      await sale.quoteTokensOut(bnbIn);

    expect(tokensOut).to.be.gt(0n);
    expect(bnbUsed).to.be.gt(0n);
    expect(tiersCrossed).to.be.gte(0n);
  });
});
</file>

<file path="test/bondingCurveSale.test.js.disabled">
import { expect } from "chai";
import hre from "hardhat";

const { ethers } = await hre.network.connect();
const { parseEther } = ethers;

// Helper to build a sane InitParams object
function buildInitParams(tokenAddress, overrides = {}) {
  return {
    token: tokenAddress,
    tierSize: parseEther("1000"),          // 1000 tokens per tier
    startPrice: parseEther("0.0001"),      // 0.0001 BNB per token
    priceStep: parseEther("0.00001"),      // +0.00001 BNB per tier
    maxTiersPerTx: 10,
    platformFeeBps: 500,                   // 5%
    endTime: 0n,                           // no time limit
    hardCapBNB: 0n,                        // unlimited
    lpPercent: 7000,                       // 70% to LP
    router: overrides.router || overrides.owner || tokenAddress, // dummy non-zero
    treasury: overrides.treasury || overrides.owner,
    payout: overrides.payout || overrides.owner,
    mode: overrides.mode ?? 0,             // 0 = Mode.Minter
    ...overrides,
  };
}

describe("BondingCurveSale", function () {
  let owner, user, other;
  let token;
  let sale;

  beforeEach(async function () {
    [owner, user, other] = await ethers.getSigners();

    // Deploy TokenTemplate as the sale token
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    token = await TokenTemplate.deploy();
    await token.waitForDeployment();

    // Deploy BondingCurveSale implementation
    const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
    sale = await BondingCurveSale.deploy();
    await sale.waitForDeployment();
  });

  it("initializes sale with params and sets owner & paused", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    expect(await sale.token()).to.equal(tokenAddr);
    expect(await sale.tierSize()).to.equal(params.tierSize);
    expect(await sale.startPrice()).to.equal(params.startPrice);
    expect(await sale.maxTiersPerTx()).to.equal(params.maxTiersPerTx);
    expect(await sale.platformFeeBps()).to.equal(params.platformFeeBps);
    expect(await sale.lpPercent()).to.equal(params.lpPercent);
    expect(await sale.owner()).to.equal(owner.address);

    // Pausable: sale should start paused after initialize()
    expect(await sale.paused()).to.equal(true);
  });

  it("reverts if initialize() is called twice", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
    });

    await sale.connect(owner).initialize(params);

    let error;
    try {
      await sale.connect(owner).initialize(params);
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("Already initialized");
  });

  it("allows owner to run audit() in Minter mode and marks audited", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // TokenTemplate.decimals() returns 18, so audit should pass
    await sale.connect(owner).audit();

    expect(await sale.audited()).to.equal(true);
  });

  it("owner can buy in Minter mode, minting tokens and updating accounting", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // Grant MINTER_ROLE to the sale so internal mint() calls succeed
    const saleAddr = await sale.getAddress();
    await token.connect(owner).grantMinter(saleAddr);

    // Unpause sale before buying
    await sale.connect(owner).unpauseSale();

    const bnbIn = parseEther("1");
    const minTokensOut = 0n;
    const deadline = 0n;

    const tx = await sale
      .connect(owner)
      .buy(minTokensOut, deadline, { value: bnbIn });

    await tx.wait();

    const sold = await sale.sold();
    const raised = await sale.raised();
    const ownerBal = await token.balanceOf(owner.address);

    // Basic sanity checks
    expect(sold).to.be.gt(0n);
    expect(raised).to.equal(bnbIn);
    expect(ownerBal).to.be.gt(0n);
  });

  it("non-owner cannot buy while externalOk is false", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);
    await sale.connect(owner).unpauseSale();

    let error;
    try {
      await sale
        .connect(user)
        .buy(0n, 0n, { value: parseEther("0.1") });
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("External not OK");
  });

  it("unpauseSale can only be called by the owner", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    // Non-owner call should revert
    let error;
    try {
      await sale.connect(user).unpauseSale();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");

    // Owner call should succeed
    await sale.connect(owner).unpauseSale();
    expect(await sale.paused()).to.equal(false);
  });

  it("quoteTokensOut returns non-zero tokens for a reasonable BNB input", async function () {
    const tokenAddr = await token.getAddress();

    const params = buildInitParams(tokenAddr, {
      owner: owner.address,
      treasury: owner.address,
      payout: user.address,
      mode: 0, // Minter
    });

    await sale.connect(owner).initialize(params);

    const bnbIn = parseEther("1");
    const [tokensOut, bnbUsed, tiersCrossed] =
      await sale.quoteTokensOut(bnbIn);

    expect(tokensOut).to.be.gt(0n);
    expect(bnbUsed).to.be.gt(0n);
    expect(tiersCrossed).to.be.gte(0n);
  });
});
</file>

<file path="test/factory.test.js">
// test/factory.test.js
import { expect } from "chai";
import hre from "hardhat";
import { Interface } from "ethers";  // <-- get Interface from ethers package

const { ethers } = await hre.network.connect();

// -----------------------------------------------------------------------------
// Helpers (ethers v6)
// -----------------------------------------------------------------------------
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

const parseEther = (v) => ethers.parseEther(v);
const isAddress  = (v) => ethers.isAddress(v);

async function waitForDeployment(contract) {
  if (typeof contract.waitForDeployment === "function") {
    await contract.waitForDeployment(); // ethers v6
  } else if (typeof contract.deployed === "function") {
    await contract.deployed(); // ethers v5-style, just in case
  }
}

// -----------------------------------------------------------------------------
// Match BondingCurveSale.InitParams
// -----------------------------------------------------------------------------
function buildValidInitParams(context, overrides = {}) {
  const owner = context.owner;
  const user = context.user || owner;

  return {
    token: ZERO_ADDRESS,                        // Factory fills this for createLaunch
    tierSize: parseEther("1000"),              // 1000 tokens per tier
    startPrice: parseEther("0.0001"),          // 0.0001 BNB per token
    priceStep: parseEther("0.00001"),          // step per tier
    maxTiersPerTx: 10,
    platformFeeBps: 500,                       // 5% fee
    endTime: 0,                                // no end time
    hardCapBNB: parseEther("100"),             // or 0 for unlimited
    lpPercent: 7000,                           // 70% to LP
    router: context.router || owner.address,   // dummy router
    treasury: context.treasury || owner.address,
    payout: context.payout || user.address,
    mode: 0,                                   // Mode.Minter
    ...overrides,
  };
}

// -----------------------------------------------------------------------------
// TESTS
// -----------------------------------------------------------------------------
describe("Factory", function () {
  let owner, user, other;
  let tokenImpl, saleImpl, factory;

  beforeEach(async function () {
    [owner, user, other] = await ethers.getSigners();

    // Deploy TokenTemplate implementation
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    tokenImpl = await TokenTemplate.deploy();
    await waitForDeployment(tokenImpl);

    // Deploy BondingCurveSale implementation
    const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
    saleImpl = await BondingCurveSale.deploy();
    await waitForDeployment(saleImpl);

    // Deploy Factory
    const Factory = await ethers.getContractFactory("Factory");

    const tokenImplAddr =
      typeof tokenImpl.getAddress === "function"
        ? await tokenImpl.getAddress()
        : tokenImpl.address;

    const saleImplAddr =
      typeof saleImpl.getAddress === "function"
        ? await saleImpl.getAddress()
        : saleImpl.address;

    factory = await Factory.deploy(tokenImplAddr, saleImplAddr);
    await waitForDeployment(factory);
  });

  // ---------------------------------------------------------------------------
  // constructor
  // ---------------------------------------------------------------------------
  describe("constructor", function () {
    it("sets tokenImpl, saleImpl and owner correctly", async function () {
      const tokenImplAddr =
        typeof tokenImpl.getAddress === "function"
          ? await tokenImpl.getAddress()
          : tokenImpl.address;

      const saleImplAddr =
        typeof saleImpl.getAddress === "function"
          ? await saleImpl.getAddress()
          : saleImpl.address;

      expect(await factory.tokenImpl()).to.equal(tokenImplAddr);
      expect(await factory.saleImpl()).to.equal(saleImplAddr);
      expect(await factory.owner()).to.equal(owner.address);
    });

    it("reverts if tokenImpl is zero", async function () {
      const Factory = await ethers.getContractFactory("Factory");
      const saleImplAddr =
        typeof saleImpl.getAddress === "function"
          ? await saleImpl.getAddress()
          : saleImpl.address;

      let error;
      try {
        await Factory.deploy(ZERO_ADDRESS, saleImplAddr);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("impl zero");
    });

    it("reverts if saleImpl is zero", async function () {
      const Factory = await ethers.getContractFactory("Factory");
      const tokenImplAddr =
        typeof tokenImpl.getAddress === "function"
          ? await tokenImpl.getAddress()
          : tokenImpl.address;

      let error;
      try {
        await Factory.deploy(tokenImplAddr, ZERO_ADDRESS);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("impl zero");
    });
  });

  // ---------------------------------------------------------------------------
  // createLaunch
  // ---------------------------------------------------------------------------
  describe("createLaunch", function () {
    it("reverts if initParams.token is non-zero (Token specified)", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context, {
        token: user.address, // force non-zero to trigger require
      });

      let error;
      try {
        await factory.connect(user).createLaunch("MyToken", "MTK", params);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("Token specified");
    });

    it("creates token + sale clones, emits LaunchCreated and transfers sale ownership", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context);

      const tx = await factory
        .connect(user)
        .createLaunch("My Launch Token", "MLT", params);

      const receipt = await tx.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      let eventData = null;
      for (const log of receipt.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            eventData = parsed.args;
            break;
          }
        } catch {
          // ignore non-matching logs
        }
      }

      expect(eventData, "LaunchCreated event not found").to.not.equal(null);

      const launchId = eventData.launchId;
      const tokenAddr = eventData.token;
      const saleAddr = eventData.sale;
      const externalToken = eventData.externalToken;
      const creator = eventData.creator;

      expect(launchId.toString()).to.equal("1");
      expect(externalToken).to.equal(false);
      expect(creator).to.equal(user.address);
      expect(isAddress(tokenAddr)).to.equal(true);
      expect(isAddress(saleAddr)).to.equal(true);

      const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
      const sale = BondingCurveSale.attach(saleAddr);
      expect(await sale.owner()).to.equal(user.address);
    });

    it("increments launch id for each new launch", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params1 = buildValidInitParams(context);
      const params2 = buildValidInitParams(context);

      await (
        await factory.connect(user).createLaunch("TokenOne", "ONE", params1)
      ).wait();

      const tx2 = await factory
        .connect(other)
        .createLaunch("TokenTwo", "TWO", params2);
      const receipt2 = await tx2.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      const ids = [];
      for (const log of receipt2.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            ids.push(parsed.args.launchId.toString());
          }
        } catch {
          // ignore
        }
      }

      expect(ids).to.include("2");
    });
  });

  // ---------------------------------------------------------------------------
  // createExternalSale
  // ---------------------------------------------------------------------------
  describe("createExternalSale", function () {
    it("reverts if initParams.token is zero (Token not set)", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context, {
        token: ZERO_ADDRESS,
      });

      let error;
      try {
        await factory.connect(user).createExternalSale(params);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("Token not set");
    });

    it("creates a sale for an external token, emits LaunchCreated with externalToken = true and transfers ownership", async function () {
      const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
      const externalToken = await TokenTemplate.deploy();
      await waitForDeployment(externalToken);

      const externalTokenAddr =
        typeof externalToken.getAddress === "function"
          ? await externalToken.getAddress()
          : externalToken.address;

      const context = {
        owner,
        user,
        tokenImpl,
        saleImpl,
        externalToken: externalTokenAddr,
      };
      const params = buildValidInitParams(context, {
        token: externalTokenAddr,
      });

      const tx = await factory.connect(user).createExternalSale(params);
      const receipt = await tx.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      let eventData = null;
      for (const log of receipt.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            eventData = parsed.args;
            break;
          }
        } catch {
          // ignore
        }
      }

      expect(eventData, "LaunchCreated event not found").to.not.equal(null);

      const tokenAddr = eventData.token;
      const saleAddr = eventData.sale;
      const externalTokenFlag = eventData.externalToken;
      const creator = eventData.creator;

      expect(tokenAddr).to.equal(externalTokenAddr);
      expect(externalTokenFlag).to.equal(true);
      expect(creator).to.equal(user.address);

      const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
      const sale = BondingCurveSale.attach(saleAddr);
      expect(await sale.owner()).to.equal(user.address);
    });
  });
});
</file>

<file path="test/factory.test.js.disabled">
// test/factory.test.js
import { expect } from "chai";
import hre from "hardhat";
import { Interface } from "ethers";  // <-- get Interface from ethers package

const { ethers } = await hre.network.connect();

// -----------------------------------------------------------------------------
// Helpers (ethers v6)
// -----------------------------------------------------------------------------
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";

const parseEther = (v) => ethers.parseEther(v);
const isAddress  = (v) => ethers.isAddress(v);

async function waitForDeployment(contract) {
  if (typeof contract.waitForDeployment === "function") {
    await contract.waitForDeployment(); // ethers v6
  } else if (typeof contract.deployed === "function") {
    await contract.deployed(); // ethers v5-style, just in case
  }
}

// -----------------------------------------------------------------------------
// Match BondingCurveSale.InitParams
// -----------------------------------------------------------------------------
function buildValidInitParams(context, overrides = {}) {
  const owner = context.owner;
  const user = context.user || owner;

  return {
    token: ZERO_ADDRESS,                        // Factory fills this for createLaunch
    tierSize: parseEther("1000"),              // 1000 tokens per tier
    startPrice: parseEther("0.0001"),          // 0.0001 BNB per token
    priceStep: parseEther("0.00001"),          // step per tier
    maxTiersPerTx: 10,
    platformFeeBps: 500,                       // 5% fee
    endTime: 0,                                // no end time
    hardCapBNB: parseEther("100"),             // or 0 for unlimited
    lpPercent: 7000,                           // 70% to LP
    router: context.router || owner.address,   // dummy router
    treasury: context.treasury || owner.address,
    payout: context.payout || user.address,
    mode: 0,                                   // Mode.Minter
    ...overrides,
  };
}

// -----------------------------------------------------------------------------
// TESTS
// -----------------------------------------------------------------------------
describe("Factory", function () {
  let owner, user, other;
  let tokenImpl, saleImpl, factory;

  beforeEach(async function () {
    [owner, user, other] = await ethers.getSigners();

    // Deploy TokenTemplate implementation
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    tokenImpl = await TokenTemplate.deploy();
    await waitForDeployment(tokenImpl);

    // Deploy BondingCurveSale implementation
    const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
    saleImpl = await BondingCurveSale.deploy();
    await waitForDeployment(saleImpl);

    // Deploy Factory
    const Factory = await ethers.getContractFactory("Factory");

    const tokenImplAddr =
      typeof tokenImpl.getAddress === "function"
        ? await tokenImpl.getAddress()
        : tokenImpl.address;

    const saleImplAddr =
      typeof saleImpl.getAddress === "function"
        ? await saleImpl.getAddress()
        : saleImpl.address;

    factory = await Factory.deploy(tokenImplAddr, saleImplAddr);
    await waitForDeployment(factory);
  });

  // ---------------------------------------------------------------------------
  // constructor
  // ---------------------------------------------------------------------------
  describe("constructor", function () {
    it("sets tokenImpl, saleImpl and owner correctly", async function () {
      const tokenImplAddr =
        typeof tokenImpl.getAddress === "function"
          ? await tokenImpl.getAddress()
          : tokenImpl.address;

      const saleImplAddr =
        typeof saleImpl.getAddress === "function"
          ? await saleImpl.getAddress()
          : saleImpl.address;

      expect(await factory.tokenImpl()).to.equal(tokenImplAddr);
      expect(await factory.saleImpl()).to.equal(saleImplAddr);
      expect(await factory.owner()).to.equal(owner.address);
    });

    it("reverts if tokenImpl is zero", async function () {
      const Factory = await ethers.getContractFactory("Factory");
      const saleImplAddr =
        typeof saleImpl.getAddress === "function"
          ? await saleImpl.getAddress()
          : saleImpl.address;

      let error;
      try {
        await Factory.deploy(ZERO_ADDRESS, saleImplAddr);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("impl zero");
    });

    it("reverts if saleImpl is zero", async function () {
      const Factory = await ethers.getContractFactory("Factory");
      const tokenImplAddr =
        typeof tokenImpl.getAddress === "function"
          ? await tokenImpl.getAddress()
          : tokenImpl.address;

      let error;
      try {
        await Factory.deploy(tokenImplAddr, ZERO_ADDRESS);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("impl zero");
    });
  });

  // ---------------------------------------------------------------------------
  // createLaunch
  // ---------------------------------------------------------------------------
  describe("createLaunch", function () {
    it("reverts if initParams.token is non-zero (Token specified)", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context, {
        token: user.address, // force non-zero to trigger require
      });

      let error;
      try {
        await factory.connect(user).createLaunch("MyToken", "MTK", params);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("Token specified");
    });

    it("creates token + sale clones, emits LaunchCreated and transfers sale ownership", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context);

      const tx = await factory
        .connect(user)
        .createLaunch("My Launch Token", "MLT", params);

      const receipt = await tx.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      let eventData = null;
      for (const log of receipt.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            eventData = parsed.args;
            break;
          }
        } catch {
          // ignore non-matching logs
        }
      }

      expect(eventData, "LaunchCreated event not found").to.not.equal(null);

      const launchId = eventData.launchId;
      const tokenAddr = eventData.token;
      const saleAddr = eventData.sale;
      const externalToken = eventData.externalToken;
      const creator = eventData.creator;

      expect(launchId.toString()).to.equal("1");
      expect(externalToken).to.equal(false);
      expect(creator).to.equal(user.address);
      expect(isAddress(tokenAddr)).to.equal(true);
      expect(isAddress(saleAddr)).to.equal(true);

      const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
      const sale = BondingCurveSale.attach(saleAddr);
      expect(await sale.owner()).to.equal(user.address);
    });

    it("increments launch id for each new launch", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params1 = buildValidInitParams(context);
      const params2 = buildValidInitParams(context);

      await (
        await factory.connect(user).createLaunch("TokenOne", "ONE", params1)
      ).wait();

      const tx2 = await factory
        .connect(other)
        .createLaunch("TokenTwo", "TWO", params2);
      const receipt2 = await tx2.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      const ids = [];
      for (const log of receipt2.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            ids.push(parsed.args.launchId.toString());
          }
        } catch {
          // ignore
        }
      }

      expect(ids).to.include("2");
    });
  });

  // ---------------------------------------------------------------------------
  // createExternalSale
  // ---------------------------------------------------------------------------
  describe("createExternalSale", function () {
    it("reverts if initParams.token is zero (Token not set)", async function () {
      const context = { owner, user, tokenImpl, saleImpl };
      const params = buildValidInitParams(context, {
        token: ZERO_ADDRESS,
      });

      let error;
      try {
        await factory.connect(user).createExternalSale(params);
      } catch (e) {
        error = e;
      }

      expect(error).to.be.instanceOf(Error);
      expect(String(error.message)).to.include("Token not set");
    });

    it("creates a sale for an external token, emits LaunchCreated with externalToken = true and transfers ownership", async function () {
      const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
      const externalToken = await TokenTemplate.deploy();
      await waitForDeployment(externalToken);

      const externalTokenAddr =
        typeof externalToken.getAddress === "function"
          ? await externalToken.getAddress()
          : externalToken.address;

      const context = {
        owner,
        user,
        tokenImpl,
        saleImpl,
        externalToken: externalTokenAddr,
      };
      const params = buildValidInitParams(context, {
        token: externalTokenAddr,
      });

      const tx = await factory.connect(user).createExternalSale(params);
      const receipt = await tx.wait();

      const iface = new Interface([
        "event LaunchCreated(uint256 indexed launchId, address indexed token, address indexed sale, bool externalToken, address creator)",
      ]);

      let eventData = null;
      for (const log of receipt.logs) {
        try {
          const parsed = iface.parseLog(log);
          if (parsed.name === "LaunchCreated") {
            eventData = parsed.args;
            break;
          }
        } catch {
          // ignore
        }
      }

      expect(eventData, "LaunchCreated event not found").to.not.equal(null);

      const tokenAddr = eventData.token;
      const saleAddr = eventData.sale;
      const externalTokenFlag = eventData.externalToken;
      const creator = eventData.creator;

      expect(tokenAddr).to.equal(externalTokenAddr);
      expect(externalTokenFlag).to.equal(true);
      expect(creator).to.equal(user.address);

      const BondingCurveSale = await ethers.getContractFactory("BondingCurveSale");
      const sale = BondingCurveSale.attach(saleAddr);
      expect(await sale.owner()).to.equal(user.address);
    });
  });
});
</file>

<file path="test/fixtures/core.ts">
import { ethers } from "hardhat";

export type CoreFixture = {
  owner: any;
  creator: any;
  alice: any;
  bob: any;
  feeRecipient: any;
  lpReceiver: any;
  router: any;
  factory: any;
};

export async function deployCoreFixture(): Promise<CoreFixture> {
  const [owner, creator, alice, bob, feeRecipient, lpReceiver] = await ethers.getSigners();

  const Router = await ethers.getContractFactory("MockRouter");
  const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);

  const Factory = await ethers.getContractFactory("LaunchFactory");
  const factory = await Factory.deploy(await router.getAddress(), await lpReceiver.getAddress());

  // Make fee recipient explicit for assertions
  await factory.connect(owner).setFeeRecipient(await feeRecipient.getAddress());

  // Use small, test-friendly config
  await factory.connect(owner).setConfig({
    totalSupply: ethers.parseEther("1000"),      // 1000 tokens
    curveBps: 5000,                              // 50% curve
    liquidityTokenBps: 4000,                     // 40% LP
    basePrice: 10n ** 12n,                       // 0.000001 native per token (scaled)
    priceSlope: 10n ** 9n,                       // slope
    graduationTarget: ethers.parseEther("1"),    // 1 native target
    liquidityBps: 8000                           // 80% of raised (after finalize fee) to LP
  });

  return { owner, creator, alice, bob, feeRecipient, lpReceiver, router, factory };
}
</file>

<file path="test/helpers/balances.ts">
import { ethers } from "hardhat";

export async function getBalance(addr: string): Promise<bigint> {
  return await ethers.provider.getBalance(addr);
}

export async function getTxCost(txHash: string): Promise<bigint> {
  const r = await ethers.provider.getTransactionReceipt(txHash);
  if (!r) throw new Error("missing receipt");
  // effectiveGasPrice is present on EIP-1559 receipts
  const price = (r as any).effectiveGasPrice ?? (await ethers.provider.getTransaction(txHash))?.gasPrice;
  if (!price) throw new Error("missing gas price");
  return BigInt(r.gasUsed.toString()) * BigInt(price.toString());
}
</file>

<file path="test/helpers/math.ts">
import { BigNumberish } from "ethers";

const WAD = 10n ** 18n;
const MAX_BPS = 10_000n;

export function bn(x: BigNumberish): bigint {
  if (typeof x === "bigint") return x;
  if (typeof x === "number") return BigInt(x);
  if (typeof x === "string") return BigInt(x);
  // ethers BigNumber (v5) or bigint-like object
  // @ts-ignore
  if (x && typeof x.toString === "function") return BigInt(x.toString());
  throw new Error("Unsupported BigNumberish");
}

export function area(x: bigint, basePrice: bigint, priceSlope: bigint): bigint {
  // Matches LaunchCampaign._area:
  // linear = x*basePrice / 1e18
  // slopeTerm = priceSlope * x^2 / (2 * 1e36)
  const linear = (x * basePrice) / WAD;
  const square = x * x;
  const denom = 2n * WAD * WAD;
  const slopeTerm = (priceSlope * square) / denom;
  return linear + slopeTerm;
}

export function fee(amountWei: bigint, protocolFeeBps: bigint): bigint {
  if (protocolFeeBps === 0n) return 0n;
  return (amountWei * protocolFeeBps) / MAX_BPS;
}

export function quoteBuyExactTokens(
  sold: bigint,
  amountOut: bigint,
  basePrice: bigint,
  priceSlope: bigint,
  protocolFeeBps: bigint
): { costNoFee: bigint; fee: bigint; total: bigint } {
  const costNoFee = area(sold + amountOut, basePrice, priceSlope) - area(sold, basePrice, priceSlope);
  const f = fee(costNoFee, protocolFeeBps);
  return { costNoFee, fee: f, total: costNoFee + f };
}

export function quoteSellExactTokens(
  sold: bigint,
  amountIn: bigint,
  basePrice: bigint,
  priceSlope: bigint,
  protocolFeeBps: bigint
): { gross: bigint; fee: bigint; payout: bigint } {
  const gross = area(sold, basePrice, priceSlope) - area(sold - amountIn, basePrice, priceSlope);
  const f = fee(gross, protocolFeeBps);
  return { gross, fee: f, payout: gross - f };
}

export function currentPrice(basePrice: bigint, priceSlope: bigint, sold: bigint): bigint {
  // basePrice + priceSlope * sold / 1e18
  return basePrice + (priceSlope * sold) / WAD;
}
</file>

<file path="test/LaunchCampaign.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { deployCoreFixture } from "./fixtures/core";
import { quoteBuyExactTokens, quoteSellExactTokens, currentPrice as priceFn } from "./helpers/math";
import { getBalance } from "./helpers/balances";

async function createCampaignFixture() {
  const fx = await deployCoreFixture();
  const { factory, creator } = fx;

  const req = {
    name: "MyToken",
    symbol: "MYT",
    logoURI: "ipfs://logo",
    xAccount: "x",
    website: "w",
    extraLink: "e",
    basePrice: 0n,
    priceSlope: 0n,
    graduationTarget: 0n,
    lpReceiver: await fx.lpReceiver.getAddress(),
    initialBuyBnbWei: 0n
  };

  await factory.connect(creator).createCampaign(req as any);
  const info = await factory.getCampaign(0n);
  const campaign = await ethers.getContractAt("LaunchCampaign", info.campaign);
  const token = await ethers.getContractAt("LaunchToken", await campaign.token());
  return { ...fx, info, campaign, token, req };
}

describe("LaunchCampaign", function () {
  it("initial state / immutables / token minted to campaign", async () => {
    const { campaign, token } = await loadFixture(createCampaignFixture);

    expect(await campaign.launched()).to.eq(false);
    expect(await token.owner()).to.eq(await campaign.getAddress());

    const totalSupply = await campaign.totalSupply();
    expect(await token.balanceOf(await campaign.getAddress())).to.eq(totalSupply);
    expect(await token.tradingEnabled()).to.eq(false);
  });

  it("quoteBuyExactTokens / quoteSellExactTokens guard rails", async () => {
    const { campaign } = await loadFixture(createCampaignFixture);

    await expect(campaign.quoteBuyExactTokens(0n)).to.be.revertedWith("zero amount");
    await expect(campaign.quoteSellExactTokens(0n)).to.be.revertedWith("zero amount");
    await expect(campaign.quoteSellExactTokens(1n)).to.be.revertedWith("exceeds sold");

    const curveSupply = await campaign.curveSupply();
    await expect(campaign.quoteBuyExactTokens(curveSupply + 1n)).to.be.revertedWith("sold out");
  });

  it("currentPrice matches formula", async () => {
    const { campaign } = await loadFixture(createCampaignFixture);
    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();

    expect(await campaign.currentPrice()).to.eq(priceFn(base, slope, 0n));
  });

  it("buyExactTokens: transfers tokens, updates sold & counters, emits, sends fee, refunds overpay", async () => {
    const { campaign, token, alice, feeRecipient, lpReceiver } = await loadFixture(createCampaignFixture);

    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();
    const feeBps = await campaign.protocolFeeBps();

    const amountOut = ethers.parseEther("10");
    const sold0 = await campaign.sold();
    const { costNoFee, fee, total } = quoteBuyExactTokens(BigInt(sold0), BigInt(amountOut), BigInt(base), BigInt(slope), BigInt(feeBps));

    const feeBefore = await getBalance(await feeRecipient.getAddress());
    const leagueBefore = await getBalance(await lpReceiver.getAddress());
    const buyerBefore = await getBalance(await alice.getAddress());
    const campBefore = await getBalance(await campaign.getAddress());

    const tx = await campaign.connect(alice).buyExactTokens(amountOut, total, { value: total + ethers.parseEther("1") });
    await expect(tx).to.emit(campaign, "TokensPurchased").withArgs(await alice.getAddress(), amountOut, total);

    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut);
    expect(await campaign.sold()).to.eq(sold0 + amountOut);

    // counters
    expect(await campaign.totalBuyVolumeWei()).to.eq(costNoFee);
    expect(await campaign.buyersCount()).to.eq(1n);
    expect(await campaign.hasBought(await alice.getAddress())).to.eq(true);

    // fee split: protocolNet -> feeRecipient, league slice -> leagueReceiver (lpReceiver in this fixture)
    const leagueBps = await campaign.leagueFeeBps();
    let expectedLeagueFee = (costNoFee * BigInt(leagueBps)) / 10_000n;
    if (expectedLeagueFee > fee) expectedLeagueFee = fee; // must never exceed total fee
    const expectedProtocolNet = fee - expectedLeagueFee;

    const feeAfter = await getBalance(await feeRecipient.getAddress());
    const leagueAfter = await getBalance(await lpReceiver.getAddress());
    expect(feeAfter - feeBefore).to.eq(expectedProtocolNet);
    expect(leagueAfter - leagueBefore).to.eq(expectedLeagueFee);

    // campaign retains no-fee portion
    const campAfter = await getBalance(await campaign.getAddress());
    expect(campAfter - campBefore).to.eq(costNoFee);

    // buyer got refund of (msg.value - total); balance delta is affected by gas so we only assert it's <= total+gas
    const buyerAfter = await getBalance(await alice.getAddress());
    expect(buyerBefore - buyerAfter).to.be.gte(total); // paid at least total+gas
  });

  it("buyExactTokens: slippage & value checks", async () => {
    const { campaign, alice } = await loadFixture(createCampaignFixture);

    const amountOut = ethers.parseEther("1");
    const total = await campaign.quoteBuyExactTokens(amountOut);

    await expect(campaign.connect(alice).buyExactTokens(amountOut, total - 1n, { value: total }))
      .to.be.revertedWith("slippage");

    await expect(campaign.connect(alice).buyExactTokens(amountOut, total, { value: total - 1n }))
      .to.be.revertedWith("insufficient value");
  });

  it("sellExactTokens: transfers tokens back, pays out, updates sold & counters, emits, takes fee", async () => {
    const { campaign, token, alice, feeRecipient, lpReceiver } = await loadFixture(createCampaignFixture);

    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();
    const feeBps = await campaign.protocolFeeBps();

    // buy first
    const amountOut = ethers.parseEther("10");
    const totalBuy = await campaign.quoteBuyExactTokens(amountOut);
    await campaign.connect(alice).buyExactTokens(amountOut, totalBuy, { value: totalBuy });

    // approve and sell half
    const amountIn = ethers.parseEther("4");
    await token.connect(alice).approve(await campaign.getAddress(), amountIn);

    const soldBefore = await campaign.sold();
    const { gross, fee, payout } = quoteSellExactTokens(BigInt(soldBefore), BigInt(amountIn), BigInt(base), BigInt(slope), BigInt(feeBps));

    const feeBefore = await getBalance(await feeRecipient.getAddress());
    const leagueBefore = await getBalance(await lpReceiver.getAddress());
    const campBefore = await getBalance(await campaign.getAddress());

    const tx = await campaign.connect(alice).sellExactTokens(amountIn, payout);
    await expect(tx).to.emit(campaign, "TokensSold").withArgs(await alice.getAddress(), amountIn, payout);

    expect(await campaign.sold()).to.eq(soldBefore - amountIn);
    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut - amountIn);    // fee split: feeRecipient gets protocolNet, leagueReceiver gets leagueFee
    const leagueBps = await campaign.leagueFeeBps();

    const expectedLeagueFee = (gross * BigInt(leagueBps)) / 10_000n;
    const expectedProtocolNet = fee - expectedLeagueFee;

    const feeAfter = await getBalance(await feeRecipient.getAddress());
    const leagueAfter = await getBalance(await lpReceiver.getAddress());

    expect(feeAfter - feeBefore).to.eq(expectedProtocolNet);
    expect(leagueAfter - leagueBefore).to.eq(expectedLeagueFee);
// campaign balance decreases by gross
    const campAfter = await getBalance(await campaign.getAddress());
    expect(campBefore - campAfter).to.eq(gross);

    expect(await campaign.totalSellVolumeWei()).to.eq(gross);
  });

  it("sellExactTokens: slippage protection", async () => {
    const { campaign, token, alice } = await loadFixture(createCampaignFixture);

    const amountOut = ethers.parseEther("5");
    const totalBuy = await campaign.quoteBuyExactTokens(amountOut);
    await campaign.connect(alice).buyExactTokens(amountOut, totalBuy, { value: totalBuy });

    const amountIn = ethers.parseEther("1");
    await token.connect(alice).approve(await campaign.getAddress(), amountIn);

    const minPayout = (await campaign.quoteSellExactTokens(amountIn)) + 1n;
    await expect(campaign.connect(alice).sellExactTokens(amountIn, minPayout)).to.be.revertedWith("slippage");
  });

  it("buyExactTokensFor can be exercised via FactoryCaller helper; onlyFactory enforced; recipient nonzero; refund goes to caller", async () => {
    const { creator, owner } = await deployCoreFixture();

    // Deploy a campaign directly with factory set to FactoryCaller (test-only)
    const Caller = await ethers.getContractFactory("FactoryCaller");
    const caller = await Caller.deploy();

    const Router = await ethers.getContractFactory("MockRouter");
    const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);

    const Campaign = await ethers.getContractFactory("LaunchCampaign");
    const params = {
      name: "T",
      symbol: "T",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      totalSupply: ethers.parseEther("1000"),
      curveBps: 5000,
      liquidityTokenBps: 4000,
      basePrice: 10n ** 12n,
      priceSlope: 10n ** 9n,
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000,
      protocolFeeBps: 200,
      leagueFeeBps: 25,
      leagueReceiver: await owner.getAddress(),
      router: await router.getAddress(),
      lpReceiver: await creator.getAddress(),
      feeRecipient: await owner.getAddress(),
      creator: await creator.getAddress(),
      factory: await caller.getAddress()
    };

    const impl = await Campaign.deploy();
await impl.waitForDeployment();

// Deploy an EIP-1167 minimal proxy clone of the implementation
const implAddr = await impl.getAddress();
const minimalProxyBytecode =
  "0x3d602d80600a3d3981f3363d3d373d3d3d363d73" +
  implAddr.slice(2).toLowerCase() +
  "5af43d82803e903d91602b57fd5bf3";
const tx = await creator.sendTransaction({ data: minimalProxyBytecode });
const receipt = await tx.wait();
const cloneAddr = receipt!.contractAddress;

const campaign = Campaign.attach(cloneAddr);
await campaign.initialize(params);

    // EOA cannot call onlyFactory
    await expect(
      campaign.connect(creator).buyExactTokensFor(await creator.getAddress(), ethers.parseEther("1"), 0n, { value: 0n })
    ).to.be.revertedWith("ONLY_FACTORY");

    const total = await campaign.quoteBuyExactTokens(ethers.parseEther("2"));

    await expect(
      caller.buyFor(await campaign.getAddress(), ethers.ZeroAddress, ethers.parseEther("2"), total, { value: total })
    ).to.be.revertedWith("zero recipient");

    // refund: send extra, should return to caller contract (msg.sender in campaign = caller)
    const extra = ethers.parseEther("1");
    await caller.buyFor(await campaign.getAddress(), await creator.getAddress(), ethers.parseEther("2"), total, { value: total + extra });

    // Caller should have received refund (held in contract balance)
    const balCaller = await ethers.provider.getBalance(await caller.getAddress());
    expect(balCaller).to.eq(extra);
  });


  it("buyExactTokens enforces curveSupply cap (no oversell)", async () => {
    const { campaign, alice } = await loadFixture(createCampaignFixture);

    const curveSupply = await campaign.curveSupply();
    const amountOut = curveSupply + 1n;

    // generous maxCost; function should still revert on sold out
    const maxCost = (await campaign.quoteBuyExactTokens(curveSupply)) + ethers.parseEther("100");
    await expect(campaign.connect(alice).buyExactTokens(amountOut, maxCost, { value: maxCost }))
      .to.be.revertedWith("sold out");
  });

  it("buyExactTokens / sellExactTokens reject zero amounts (consistent with quote)", async () => {
    const { campaign, alice } = await loadFixture(createCampaignFixture);

    await expect(campaign.connect(alice).buyExactTokens(0n, 0n, { value: 0n }))
      .to.be.revertedWith("zero amount");

    await expect(campaign.connect(alice).sellExactTokens(0n, 0n))
      .to.be.revertedWith("zero amount");
  });

  it("fee receivers cannot DOS: feeRecipient revert escrows; leagueReceiver router forward failure doesn't revert", async () => {
    const { creator, owner, alice } = await deployCoreFixture();

    // feeRecipient that rejects native transfers
    const Reverting = await ethers.getContractFactory("RevertingReceiver");
    const feeRecipient = await Reverting.deploy();
    await feeRecipient.waitForDeployment();

    // vault that rejects native transfers, forcing the TreasuryRouter to emit ForwardFailed but not revert
    const vault = await Reverting.deploy();
    await vault.waitForDeployment();

    const TreasuryRouter = await ethers.getContractFactory("TreasuryRouter");
    const leagueReceiver = await TreasuryRouter.deploy(
      await owner.getAddress(),
      await vault.getAddress(),
      3600
    );
    await leagueReceiver.waitForDeployment();

    const Router = await ethers.getContractFactory("MockRouter");
    const dexRouter = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);
    await dexRouter.waitForDeployment();

    // Deploy campaign via clone so we can set feeRecipient/leagueReceiver explicitly
    const Campaign = await ethers.getContractFactory("LaunchCampaign");
    const impl = await Campaign.deploy();
    await impl.waitForDeployment();

    const implAddr = await impl.getAddress();
    const minimalProxyBytecode =
      "0x3d602d80600a3d3981f3363d3d373d3d3d363d73" +
      implAddr.slice(2).toLowerCase() +
      "5af43d82803e903d91602b57fd5bf3";
    const txClone = await creator.sendTransaction({ data: minimalProxyBytecode });
    const receipt = await txClone.wait();
    const cloneAddr = receipt!.contractAddress;

    const campaign = Campaign.attach(cloneAddr);
    const params = {
      name: "T",
      symbol: "T",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      totalSupply: ethers.parseEther("1000"),
      curveBps: 5000,
      liquidityTokenBps: 4000,
      basePrice: 10n ** 12n,
      priceSlope: 10n ** 9n,
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000,
      protocolFeeBps: 200,
      leagueFeeBps: 25,
      leagueReceiver: await leagueReceiver.getAddress(),
      router: await dexRouter.getAddress(),
      lpReceiver: await creator.getAddress(),
      feeRecipient: await feeRecipient.getAddress(),
      creator: await creator.getAddress(),
      factory: await creator.getAddress(),
    };
    await campaign.initialize(params);

    const token = await ethers.getContractAt("LaunchToken", await campaign.token());

    const base = await campaign.basePrice();
    const slope = await campaign.priceSlope();
    const feeBps = await campaign.protocolFeeBps();

    const amountOut = ethers.parseEther("10");
    const sold0 = await campaign.sold();

    const { costNoFee, fee, total } = quoteBuyExactTokens(
      BigInt(sold0),
      BigInt(amountOut),
      BigInt(base),
      BigInt(slope),
      BigInt(feeBps)
    );

    const leagueFee = (costNoFee * 25n) / 10_000n;
    const protocolNet = fee - leagueFee;

    const tx = await campaign.connect(alice).buyExactTokens(amountOut, total, { value: total });

    // Purchase succeeded even though feeRecipient rejects transfers
    expect(await token.balanceOf(await alice.getAddress())).to.eq(amountOut);

    // FeeRecipient portion escrowed
    await expect(tx).to.emit(campaign, "NativeEscrowed").withArgs(await feeRecipient.getAddress(), protocolNet);
    expect(await campaign.pendingNative(await feeRecipient.getAddress())).to.eq(protocolNet);

    // LeagueReceiver is the TreasuryRouter; forwarding fails but doesn't revert; router retains funds
    await expect(tx).to.emit(leagueReceiver, "ForwardFailed").withArgs(await vault.getAddress(), leagueFee);
    expect(await ethers.provider.getBalance(await leagueReceiver.getAddress())).to.eq(leagueFee);
  });

  it("finalize: reverts unless threshold met; onlyOwner; marks launched; adds liquidity; burns unsold; transfers creatorReserve; pays creator; enables trading", async () => {
    const { campaign, token, creator, alice, feeRecipient, lpReceiver, router } = await loadFixture(createCampaignFixture);

    // onlyOwner
    await expect(campaign.connect(alice).finalize(0n, 0n))
      .to.be.revertedWithCustomError(campaign, "OwnableUnauthorizedAccount");

    await expect(campaign.connect(creator).finalize(0n, 0n)).to.be.revertedWith("threshold");

    // Meet finalize threshold robustly by selling out the curve
    // (With some parameter sets, graduationTarget may be unreachable given curveSupply and pricing.)
    const curveSupply = await campaign.curveSupply();
    const totalBuy = await campaign.quoteBuyExactTokens(curveSupply);
    await campaign.connect(alice).buyExactTokens(curveSupply, totalBuy, { value: totalBuy });

    expect(await campaign.sold()).to.eq(curveSupply);

    const ownerAddr = await creator.getAddress();
    const creatorBalBefore = await getBalance(ownerAddr);
    const feeBefore = await getBalance(await feeRecipient.getAddress());
    const leagueBefore = await getBalance(await lpReceiver.getAddress());

    const tx = await campaign.connect(creator).finalize(0n, 0n);
    const receipt = await tx.wait();
    // Hardhat/Ethers can expose gas pricing differently across versions (effectiveGasPrice, gasPrice, maxFeePerGas).
    // For portability, bound the creator's gas spend rather than relying on a single receipt field.
    const gasUsed = BigInt((receipt!.gasUsed ?? 0n).toString());
    const maxFeePerGas = BigInt((((tx as any).maxFeePerGas ?? (tx as any).gasPrice ?? 0n)).toString());

    await expect(tx).to.emit(campaign, "CampaignFinalized");
    await expect(tx).to.emit(router, "LiquidityAdded");

    expect(await campaign.launched()).to.eq(true);
    expect(await token.tradingEnabled()).to.eq(true);

    // campaign should be drained of native balance after finalize
    expect(await getBalance(await campaign.getAddress())).to.eq(0n);

    // creator receives payout (native) and creatorReserve (tokens)
    // Read creatorPayout + protocolFee from the CampaignFinalized event for exact balance assertions
    const ev = receipt!.logs
      .map((l: any) => {
        try { return campaign.interface.parseLog(l); } catch { return null; }
      })
      .find((p: any) => p && p.name === "CampaignFinalized");

    expect(ev).to.not.eq(undefined);

    const protocolFee = BigInt(ev!.args.protocolFee.toString());
    const creatorPayout = BigInt(ev!.args.creatorPayout.toString());

    const creatorBalAfter = await getBalance(ownerAddr);
    // creatorBalBefore + creatorPayout - creatorBalAfter == gas spent by creator for finalize tx
    const spent = creatorBalBefore + creatorPayout - creatorBalAfter;
    expect(spent).to.be.gt(0n);
    if (maxFeePerGas !== 0n) {
      expect(spent).to.be.lte(gasUsed * maxFeePerGas);
    }

    const creatorReserve = await campaign.creatorReserve();
    expect(await token.balanceOf(ownerAddr)).to.be.gte(creatorReserve); // may also include tokens bought by creator in other tests

    // unsold curve tokens burned reduces totalSupply by (curveSupply - soldAtFinalize)
    const totalSupply = await campaign.totalSupply();
    const soldAtFinalize = await campaign.sold();
    const expectedBurn = curveSupply - soldAtFinalize;
    expect(await token.totalSupply()).to.eq(totalSupply - expectedBurn);

    // fee recipient should have received finalize protocol fee (plus any trade fees from buys/sells)
    const feeAfter = await getBalance(await feeRecipient.getAddress());
    expect(feeAfter - feeBefore).to.be.gte(protocolFee);
  });

  it("post-finalize: trading restriction lifted; buys/sells revert", async () => {
    const { campaign, token, creator, alice, bob } = await loadFixture(createCampaignFixture);

    // Sell out curve so finalize threshold is guaranteed.
    const curveSupply = await campaign.curveSupply();
    const totalBuy = await campaign.quoteBuyExactTokens(curveSupply);
    await campaign.connect(alice).buyExactTokens(curveSupply, totalBuy, { value: totalBuy });

    await campaign.connect(creator).finalize(0n, 0n);

    // After finalize, buy/sell entrypoints must revert on the launched guard.
    await expect(campaign.connect(alice).buyExactTokens(1n, 0n, { value: 0n }))
      .to.be.revertedWith("campaign launched");
    await expect(campaign.connect(alice).sellExactTokens(1n, 0n))
      .to.be.revertedWith("campaign launched");

    // transfers now allowed
    await token.connect(alice).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });
});
</file>

<file path="test/LaunchFactory.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import { deployCoreFixture } from "./fixtures/core";
import { quoteBuyExactTokens } from "./helpers/math";

describe("LaunchFactory", function () {
  
  
  it("constructor requires router != 0 and sets defaults", async () => {
    const Factory = await ethers.getContractFactory("LaunchFactory");
    const [deployer] = await ethers.getSigners();
    await expect(
  Factory.deploy(ethers.ZeroAddress, await deployer.getAddress())
).to.be.revertedWithCustomError(Factory, "RouterZero");

    const Router = await ethers.getContractFactory("MockRouter");
    const router = await Router.deploy(ethers.ZeroAddress, ethers.ZeroAddress);
    await expect(Factory.deploy(await router.getAddress(), ethers.ZeroAddress)).to.be.revertedWithCustomError(Factory, "RecipientZero");

    const factory = await Factory.deploy(await router.getAddress(), await deployer.getAddress());

    expect(await factory.router()).to.eq(await router.getAddress());
    expect((await factory.config()).totalSupply).to.be.gt(0n);
    expect(await factory.protocolFeeBps()).to.eq(200n);
  });

  it("quoteInitialBuyTotal: 0 tokens -> 0; override params respected", async () => {
    const { factory } = await deployCoreFixture();
    expect(await factory.quoteInitialBuyTotal(0n, 0n, 0n)).to.eq(0n);

    const base = 777n;
    const slope = 999n;
    const amount = ethers.parseEther("10");
    const quoted = await factory.quoteInitialBuyTotal(amount, base, slope);

    const { total } = quoteBuyExactTokens(0n, amount, base, slope, await factory.protocolFeeBps());
    expect(quoted).to.eq(total);
  });

  it("createCampaign: validates inputs, emits, persists CampaignInfo; refunds excess msg.value", async () => {
    const { factory, creator } = await deployCoreFixture();

    const bad = {
      name: "",
      symbol: "X",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: 0n,
    };

    await expect(factory.connect(creator).createCampaign(bad as any)).to.be.revertedWithCustomError(
      factory,
      "NameEmpty"
    );
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "" } as any)
    ).to.be.revertedWithCustomError(factory, "SymbolEmpty");
    await expect(
      factory.connect(creator).createCampaign({ ...bad, name: "N", symbol: "S", logoURI: "" } as any)
    ).to.be.revertedWithCustomError(factory, "LogoEmpty");

    const req = { ...bad, name: "MyToken", symbol: "MYT", logoURI: "ipfs://logo" };
    const tx = await factory.connect(creator).createCampaign(req as any, { value: ethers.parseEther("1") });

    await expect(tx).to.emit(factory, "CampaignCreated");

    expect(await factory.campaignsCount()).to.eq(1n);
    const info = await factory.getCampaign(0n);
    expect(info.creator).to.eq(await creator.getAddress());
    expect(info.name).to.eq("MyToken");
    expect(info.symbol).to.eq("MYT");
    expect(info.logoURI).to.eq("ipfs://logo");

    // getCampaignPage
    const page = await factory.getCampaignPage(0n, 10n);
    expect(page.length).to.eq(1);
    expect(page[0].campaign).to.eq(info.campaign);

    // bounds
    await expect(factory.getCampaign(1n)).to.be.revertedWithCustomError(factory, "OutOfBounds");
    await expect(factory.getCampaignPage(2n, 1n)).to.be.revertedWithCustomError(factory, "Offset");
  });

  it("createCampaign optional initialBuy: requires enough value; performs buy; refunds extra", async () => {
    const { factory, creator, feeRecipient } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei - 1n })
    ).to.be.revertedWithCustomError(factory, "InitBuyValue");

    const feeBefore = await ethers.provider.getBalance(await feeRecipient.getAddress());
    const tx = await factory
      .connect(creator)
      .createCampaign(req as any, { value: req.initialBuyBnbWei + ethers.parseEther("0.5") });
    const receipt = await tx.wait();

    const info = await factory.getCampaign(0n);
    const campaign = await ethers.getContractAt("LaunchCampaign", info.campaign);
    const token = await ethers.getContractAt("LaunchToken", await campaign.token());

    // Exact-BNB buy: token amount is determined by the curve, so just assert nonzero.
    expect(await campaign.sold()).to.be.gt(0n);
    expect(await token.balanceOf(await creator.getAddress())).to.be.gt(0n);

    // Fee recipient should have received the bonding-curve fee from the initial buy (not affected by creator gas)
    const feeAfter = await ethers.provider.getBalance(await feeRecipient.getAddress());
    expect(feeAfter).to.be.gt(feeBefore);

    // Campaign retains the no-fee portion of the buy (nonzero)
    expect(await ethers.provider.getBalance(info.campaign)).to.be.gt(0n);

    expect(receipt).to.not.eq(null);
  });

  it("createCampaign optional initialBuy: reverts when creator initial buy exceeds 1 BNB cap", async () => {
    const { factory, creator } = await deployCoreFixture();

    const req = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: ethers.parseEther("1.01"),
    };

    await expect(
      factory.connect(creator).createCampaign(req as any, { value: req.initialBuyBnbWei })
    ).to.be.revertedWithCustomError(factory, "InitBuyTooLarge");
  });

  it("owner-only setters with validation + events", async () => {
    const { factory, owner, alice } = await deployCoreFixture();

    await expect(factory.connect(alice).setRouter(await alice.getAddress())).to.be.revertedWithCustomError(
      factory,
      "OwnableUnauthorizedAccount"
    );

    await expect(factory.connect(owner).setRouter(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RouterZero"
    );
    await expect(factory.connect(owner).setFeeRecipient(ethers.ZeroAddress)).to.be.revertedWithCustomError(
      factory,
      "RecipientZero"
    );
    await expect(factory.connect(owner).setProtocolFee(1001n)).to.be.revertedWithCustomError(
      factory,
      "FeeTooHigh"
    );

    await expect(factory.connect(owner).setProtocolFee(24n)).to.be.revertedWithCustomError(
      factory,
      "FeeTooLowForLeague"
    );

    await expect(factory.connect(owner).setProtocolFee(123n)).to.emit(factory, "ProtocolFeeUpdated").withArgs(123n);
    expect(await factory.protocolFeeBps()).to.eq(123n);

    const newRouter = await (await ethers.getContractFactory("MockRouter")).deploy(
      ethers.ZeroAddress,
      ethers.ZeroAddress
    );
    await expect(factory.connect(owner).setRouter(await newRouter.getAddress()))
      .to.emit(factory, "RouterUpdated")
      .withArgs(await newRouter.getAddress());

    await expect(factory.connect(owner).setFeeRecipient(await alice.getAddress()))
      .to.emit(factory, "FeeRecipientUpdated")
      .withArgs(await alice.getAddress());

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 0n,
        curveBps: 5000n,
        liquidityTokenBps: 4000n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "SupplyZero");

    await expect(
      factory.connect(owner).setConfig({
        totalSupply: 1n,
        curveBps: 0n,
        liquidityTokenBps: 0n,
        basePrice: 1n,
        priceSlope: 1n,
        graduationTarget: 1n,
        liquidityBps: 8000n,
      })
    ).to.be.revertedWithCustomError(factory, "InvalidCurveBps");
  });

  it("createCampaign: rejects override params above bounds", async () => {
    const { factory, creator, owner } = await deployCoreFixture();

    const baseTooHigh = ethers.parseEther("1001");
    const targetTooHigh = ethers.parseEther("1000001");
    const slopeTooHigh = 10n ** 36n + 1n;

    const reqBase = {
      name: "MyToken",
      symbol: "MYT",
      logoURI: "ipfs://logo",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: baseTooHigh,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: ethers.ZeroAddress,
      initialBuyBnbWei: 0n,
    };

    await expect(factory.connect(creator).createCampaign(reqBase as any)).to.be.revertedWithCustomError(factory, "ParamTooHigh");

    await expect(factory.connect(creator).createCampaign({ ...reqBase, basePrice: 0n, priceSlope: slopeTooHigh } as any))
      .to.be.revertedWithCustomError(factory, "ParamTooHigh");

    await expect(factory.connect(creator).createCampaign({ ...reqBase, basePrice: 0n, priceSlope: 0n, graduationTarget: targetTooHigh } as any))
      .to.be.revertedWithCustomError(factory, "ParamTooHigh");
  });

});
</file>

<file path="test/Launchpad.ts">
import { expect } from "chai";
import { ethers } from "hardhat";
import type { LaunchFactory, LaunchCampaign, LaunchToken, MockRouter } from "../typechain-types";

describe("Launchpad end-to-end", function () {
  async function deployFactoryAndRouter() {
    const [deployer, creator, trader, other] = await ethers.getSigners();

    const MockRouter = await ethers.getContractFactory("MockRouter");
    const router = (await MockRouter.deploy(
      await deployer.getAddress(),
      await deployer.getAddress()
    )) as unknown as MockRouter;

    const LaunchFactory = await ethers.getContractFactory("LaunchFactory");
    const factory = (await LaunchFactory.deploy(await router.getAddress(), await deployer.getAddress())) as unknown as LaunchFactory;

    return { deployer, creator, trader, other, router, factory };
  }

  it("deploys factory with default config and creates a campaign with correct params", async () => {
    const { deployer, creator, router, factory } = await deployFactoryAndRouter();

    // Check default config
    const cfg = await factory.config();
    expect(cfg.totalSupply).to.equal(ethers.parseUnits("1000000000", 18));
    expect(cfg.curveBps).to.equal(8800n);
    expect(cfg.liquidityTokenBps).to.equal(1000n);

    // FIX: basePrice is 5e13 (0.00005 BNB)
    expect(cfg.basePrice).to.equal(50_000_000_000_000n);

    expect(cfg.priceSlope).to.equal(1_000_000_000n);
    expect(cfg.graduationTarget).to.equal(ethers.parseEther("50"));
    expect(cfg.liquidityBps).to.equal(8000n);

    // Build request overriding some params
    const request = {
      name: "Test Token",
      symbol: "TEST",
      logoURI: "ipfs://logo-hash",
      xAccount: "https://x.com/test",
      website: "https://example.com",
      extraLink: "https://t.me/test",
      // override base, slope, target
      basePrice: ethers.parseEther("0.0000005"),
      priceSlope: ethers.parseEther("0.0000000001"),
      graduationTarget: ethers.parseEther("0.5"),
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    const tx = await factory.connect(creator).createCampaign(request);
    await tx.wait();

    // One campaign created
    expect(await factory.campaignsCount()).to.equal(1n);

    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    // Basic metadata
    expect(info.creator).to.equal(creator.address);
    expect(info.name).to.equal(request.name);
    expect(info.symbol).to.equal(request.symbol);
    expect(info.logoURI).to.equal(request.logoURI);
    expect(info.website).to.equal(request.website);
    expect(info.xAccount).to.equal(request.xAccount);
    expect(info.extraLink).to.equal(request.extraLink);

    // Campaign invariants
    expect(await campaign.basePrice()).to.equal(request.basePrice);
    expect(await campaign.priceSlope()).to.equal(request.priceSlope);
    expect(await campaign.graduationTarget()).to.equal(request.graduationTarget);
    expect(await campaign.liquidityBps()).to.equal(cfg.liquidityBps);
    expect(await campaign.protocolFeeBps()).to.equal(await factory.protocolFeeBps());

    const totalSupply = await campaign.totalSupply();
    const curveSupply = await campaign.curveSupply();
    const liquiditySupply = await campaign.liquiditySupply();
    const creatorReserve = await campaign.creatorReserve();

    // Supply splits
    expect(totalSupply).to.equal(cfg.totalSupply);
    expect(curveSupply).to.equal((cfg.totalSupply * cfg.curveBps) / 10_000n);
    expect(liquiditySupply).to.equal((cfg.totalSupply * cfg.liquidityTokenBps) / 10_000n);
    expect(creatorReserve).to.equal(totalSupply - curveSupply - liquiditySupply);

    // Token was deployed and minted to campaign
    expect(await token.totalSupply()).to.equal(totalSupply);
    expect(await token.balanceOf(await campaign.getAddress())).to.equal(totalSupply);

    // Router and LP receiver configured
    expect(await campaign.router()).to.equal(await router.getAddress());
    expect(await campaign.lpReceiver()).to.equal(request.lpReceiver);
  });

  it("computes quotes, allows buys/sells, and updates price and sold correctly", async () => {
    const { creator, trader, router, factory } = await deployFactoryAndRouter();

    // Use a custom, smaller config for easier numbers
    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,
      liquidityTokenBps: 1000n,
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Quote Token",
      symbol: "QUO",
      logoURI: "ipfs://logo-quote",
      xAccount: "",
      website: "",
      extraLink: "",
      // leave these as 0 to use config defaults
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    // Initial price == basePrice
    const basePrice = await campaign.basePrice();
    const initialPrice = await campaign.currentPrice();
    expect(initialPrice).to.equal(basePrice);

    // quoteBuyExactTokens should revert on 0 amount
    await expect(campaign.quoteBuyExactTokens(0)).to.be.revertedWith("zero amount");

    const buyAmount = ethers.parseUnits("10", 18);
    const cost = await campaign.quoteBuyExactTokens(buyAmount);
    expect(cost).to.be.gt(0n);

    // Buy 10 tokens
    await expect(
      campaign.connect(trader).buyExactTokens(buyAmount, cost, { value: cost })
    )
      .to.emit(campaign, "TokensPurchased")
      .withArgs(trader.address, buyAmount, cost);

    expect(await token.balanceOf(trader.address)).to.equal(buyAmount);
    expect(await campaign.sold()).to.equal(buyAmount);

    // Price should have increased
    const newPrice = await campaign.currentPrice();
    expect(newPrice).to.be.gt(initialPrice);

    // quoteSellExactTokens reverts on invalid amounts
    await expect(campaign.quoteSellExactTokens(0)).to.be.revertedWith("zero amount");
    await expect(
      campaign.quoteSellExactTokens(buyAmount + 1n)
    ).to.be.revertedWith("exceeds sold");

    const sellAmount = ethers.parseUnits("4", 18);
    const payout = await campaign.quoteSellExactTokens(sellAmount);
    expect(payout).to.be.gt(0n);

    // Sell 4 tokens
    await token.connect(trader).approve(await campaign.getAddress(), sellAmount);
    await expect(
      campaign.connect(trader).sellExactTokens(sellAmount, 0)
    )
      .to.emit(campaign, "TokensSold")
      .withArgs(trader.address, sellAmount, payout);

    // sold reduced correctly
    expect(await campaign.sold()).to.equal(buyAmount - sellAmount);
  });
    it("fuzz: random buy/sell sequences preserve invariants on the curve", async () => {
    const { creator, trader, router, factory } = await deployFactoryAndRouter();

    // Small numbers to keep fuzz deterministic and cheap
    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,            // 800 tokens on curve
      liquidityTokenBps: 1000n,   // 100 tokens for LP
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("10"), // high enough so we won't accidentally hit it
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Fuzz Token",
      symbol: "FZZ",
      logoURI: "ipfs://logo-fuzz",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    const totalSupply = await campaign.totalSupply();
    const curveSupply = await campaign.curveSupply();

    // Initial sanity
    expect(await campaign.sold()).to.equal(0n);
    expect(await token.totalSupply()).to.equal(totalSupply);
    expect(await token.balanceOf(await campaign.getAddress())).to.equal(totalSupply);
    expect(await token.balanceOf(trader.address)).to.equal(0n);

    const iterations = 40; // enough to explore, not too slow

    for (let i = 0; i < iterations; i++) {
      const sold = await campaign.sold();
      const traderBal = await token.balanceOf(trader.address);
      const campaignAddr = await campaign.getAddress();
      const campaignBalTokens = await token.balanceOf(campaignAddr);

      // Invariant: before any operation
      expect(sold).to.be.gte(0n);
      expect(sold).to.be.lte(curveSupply);
      expect(campaignBalTokens + traderBal).to.equal(totalSupply);
      expect(sold).to.equal(traderBal); // only trader holds curve tokens

      // Decide action: bias slightly to buys so we don't drain all BNB
      const doBuy = Math.random() < 0.6;

      if (doBuy) {
        const remainingCurve = curveSupply - sold;
        if (remainingCurve === 0n) {
          // Can't buy any more, just skip this iteration
          continue;
        }

        // Choose random buy size between 1 and up to 20 tokens (but not more than remainingCurve)
        const rawTokens = BigInt(1 + Math.floor(Math.random() * 20));
        let amountTokens = ethers.parseUnits(rawTokens.toString(), 18);
        if (amountTokens > remainingCurve) {
          amountTokens = remainingCurve;
        }

        const cost = await campaign.quoteBuyExactTokens(amountTokens);
        // If cost is zero (can happen at tiny slope early), skip to avoid sending 0-value tx
        if (cost === 0n) continue;

        await campaign.connect(trader).buyExactTokens(amountTokens, cost, { value: cost });

      } else {
        // Sell path
        if (traderBal === 0n) {
          // Nothing to sell -> skip
          continue;
        }

        // Choose random sell size between 1 and up to 20 tokens (but not more than traderBal)
        const rawTokens = BigInt(1 + Math.floor(Math.random() * 20));
        let amountTokens = ethers.parseUnits(rawTokens.toString(), 18);
        if (amountTokens > traderBal) {
          amountTokens = traderBal;
        }

        const payout = await campaign.quoteSellExactTokens(amountTokens);
        if (payout === 0n) continue;

                await token.connect(trader).approve(campaignAddr, amountTokens);
        const tx = await campaign.connect(trader).sellExactTokens(amountTokens, 0);
        const receipt = await tx.wait();

        // Invariant: event payout equals quote (note: quote is NET-to-seller, campaign balance decreases by GROSS)
        const soldLog = receipt!.logs
          .map((l) => {
            try { return campaign.interface.parseLog(l as any); } catch { return null; }
          })
          .find((p) => p && p.name === "TokensSold");

        expect(soldLog, "TokensSold event").to.not.equal(undefined);
        const eventPayout = (soldLog as any).args.payout as bigint;
        expect(eventPayout).to.equal(payout);
      }

      // Re-check invariants after this operation
      const newSold = await campaign.sold();
      const newTraderBal = await token.balanceOf(trader.address);
      const newCampaignBalTokens = await token.balanceOf(await campaign.getAddress());
      const newTotalSupply = await token.totalSupply();

      expect(newSold).to.be.gte(0n);
      expect(newSold).to.be.lte(curveSupply);
      expect(newTotalSupply).to.equal(totalSupply); // no burns before finalize
      expect(newCampaignBalTokens + newTraderBal).to.equal(totalSupply);
      expect(newSold).to.equal(newTraderBal);
    }
  });

  it("enforces pre-launch lock: no user transfers or manual LP before finalize", async () => {
    const { creator, trader, other, router, factory } = await deployFactoryAndRouter();

    const request = {
      name: "Locked Token",
      symbol: "LOCK",
      logoURI: "ipfs://logo-locked",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: ethers.parseEther("0.0000005"),
      priceSlope: ethers.parseEther("0.0000000001"),
      graduationTarget: ethers.parseEther("0.5"),
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    // Trading is disabled initially
    expect(await token.tradingEnabled()).to.equal(false);

    // Trader buys some tokens
    const buyAmount = ethers.parseUnits("100000", 18);
    const cost = await campaign.quoteBuyExactTokens(buyAmount);
    await campaign.connect(trader).buyExactTokens(buyAmount, cost, { value: cost });

    // Direct transfer between users must fail
    const transferAmount = buyAmount / 10n;
    await expect(
      token.connect(trader).transfer(other.address, transferAmount)
    ).to.be.revertedWithCustomError(token, "TradingNotEnabled");

    // Attempt to add liquidity manually via router before finalize -> must fail
    const lpAmount = await token.balanceOf(trader.address);
    await token.connect(trader).approve(await router.getAddress(), lpAmount);

    await expect(
      router
        .connect(trader)
        .addLiquidityETH(
          await token.getAddress(),
          lpAmount,
          0n,
          0n,
          trader.address,
          Math.floor(Date.now() / 1000) + 3600,
          { value: ethers.parseEther("0.1") }
        )
    ).to.be.revertedWithCustomError(token, "TradingNotEnabled");
  });

  it("only the campaign owner can finalize, and finalize can only be called once", async () => {
    const { deployer, creator, trader, router, factory } = await deployFactoryAndRouter();

    // Small config to avoid huge ETH amounts
    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,
      liquidityTokenBps: 1000n,
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"), // 1 BNB target
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Finalize Token",
      symbol: "FIN",
      logoURI: "ipfs://logo-finalize",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    // Buy some tokens (but don't sell out)
    const buyAmount = ethers.parseUnits("10", 18);
    const cost = await campaign.quoteBuyExactTokens(buyAmount);
    await campaign.connect(trader).buyExactTokens(buyAmount, cost, { value: cost });

    // Top up BNB directly into campaign to reach graduation target
    const target = await campaign.graduationTarget();
    const currentBal = await ethers.provider.getBalance(await campaign.getAddress());
    const missing = target - currentBal;
    await deployer.sendTransaction({
      to: await campaign.getAddress(),
      value: missing,
    });

    // Non-owner cannot finalize (reverts because of access or because threshold not met  we only care it reverts)
    await expect(campaign.connect(trader).finalize(0, 0)).to.be.reverted;

    // Record balance before finalize for later checks
    const balanceBefore = await ethers.provider.getBalance(await campaign.getAddress());
    const liqBps = await campaign.liquidityBps();
    const protocolFeeBps = await factory.protocolFeeBps();
    const protocolFee = (balanceBefore * protocolFeeBps) / 10_000n;
    const remainingAfterFee = balanceBefore - protocolFee;
    const expectedLiquidityValue = (remainingAfterFee * liqBps) / 10_000n;

    // Owner (creator) can finalize, and router receives liquidity
    await expect(campaign.connect(creator).finalize(0, 0))
      .to.emit(campaign, "CampaignFinalized")
      .and.to.emit(router, "LiquidityAdded");

    // Launched and trading enabled
    expect(await campaign.launched()).to.equal(true);
    expect(await token.tradingEnabled()).to.equal(true);

    // Campaign contract should hold no ETH afterwards
    expect(await ethers.provider.getBalance(await campaign.getAddress())).to.equal(0n);

    // Router holds exactly the liquidity ETH
    expect(await ethers.provider.getBalance(await router.getAddress())).to.equal(
      expectedLiquidityValue
    );

    // Cannot finalize again
    await expect(campaign.connect(creator).finalize(0, 0)).to.be.revertedWith("finalized");
  });

  it("after finalize, tokens and LP are distributed correctly and trading is open", async () => {
    const { creator, trader, other, router, factory } = await deployFactoryAndRouter();

    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,
      liquidityTokenBps: 1000n,
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Distrib Token",
      symbol: "DST",
      logoURI: "ipfs://logo-distrib",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    const totalSupply = await campaign.totalSupply();
    const curveSupply = await campaign.curveSupply();
    const liquiditySupply = await campaign.liquiditySupply();
    const creatorReserve = await campaign.creatorReserve();

    // Trader buys some tokens (so sold > 0 but < curveSupply)
    const buyAmount = ethers.parseUnits("10", 18);
    const cost = await campaign.quoteBuyExactTokens(buyAmount);
    await campaign.connect(trader).buyExactTokens(buyAmount, cost, { value: cost });

    // Top up BNB to reach graduation target
    const target = await campaign.graduationTarget();
    const currentBal = await ethers.provider.getBalance(await campaign.getAddress());
    const missing = target - currentBal;
    await creator.sendTransaction({
      to: await campaign.getAddress(),
      value: missing,
    });

    // Finalize by owner
    await campaign.connect(creator).finalize(0, 0);

    // After finalize:
    // 1) Token trading enabled
    expect(await token.tradingEnabled()).to.equal(true);

    // 2) Campaign should hold no tokens
    expect(await token.balanceOf(await campaign.getAddress())).to.equal(0n);

    // 3) Router should hold exactly liquiditySupply tokens
    expect(await token.balanceOf(await router.getAddress())).to.equal(liquiditySupply);

    // 4) Creator should hold creatorReserve tokens
    expect(await token.balanceOf(creator.address)).to.equal(creatorReserve);

    // 5) Total supply should now be:
    //    original totalSupply - (unsold curve tokens)
    //    = liquiditySupply + creatorReserve + sold
    const sold = await campaign.sold();
    const expectedTotalSupply =
      totalSupply - (curveSupply - sold); // equivalent to liquiditySupply + creatorReserve + sold
    expect(await token.totalSupply()).to.equal(expectedTotalSupply);

    // 6) Trader can transfer tokens freely after launch
    const transferAmount = buyAmount / 2n;
    await token.connect(trader).transfer(other.address, transferAmount);
    expect(await token.balanceOf(other.address)).to.equal(transferAmount);

    // 7) Buys and sells via campaign are blocked after launch
    await expect(
      campaign
        .connect(trader)
        .buyExactTokens(ethers.parseUnits("1", 18), ethers.parseEther("1"), {
          value: ethers.parseEther("1"),
        })
    ).to.be.revertedWith("campaign launched");

    await token
      .connect(trader)
      .approve(await campaign.getAddress(), ethers.parseUnits("1", 18));
    await expect(
      campaign.connect(trader).sellExactTokens(ethers.parseUnits("1", 18), 0)
    ).to.be.revertedWith("campaign launched");
  });
    it("curve price discovery is consistent with the bonding integral and quotes", async () => {
    const { creator, trader, router, factory } = await deployFactoryAndRouter();

    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,
      liquidityTokenBps: 1000n,
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Curve Test Token",
      symbol: "CRV",
      logoURI: "ipfs://logo-curve",
      xAccount: "",
      website: "",
      extraLink: "",
      // use config defaults for curve params
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    const basePrice = await campaign.basePrice();
    const priceSlope = await campaign.priceSlope();
    const WAD = ethers.parseUnits("1", 18);


    const protocolFeeBps = await factory.protocolFeeBps();
    // JS version of _area(x)
    const area = (x: bigint) => {
      const linear = (x * basePrice) / WAD;
      const square = x * x;
      const slopeTerm = (priceSlope * square) / (2n * WAD * WAD);
      return linear + slopeTerm;
    };

    // Initially nothing sold
    expect(await campaign.sold()).to.equal(0n);

    // ---- First buy ----
    const amount1 = ethers.parseUnits("10", 18); // 10 tokens
    const quoted1 = await campaign.quoteBuyExactTokens(amount1);
    const base1 = area(amount1) - area(0n);
    const fee1 = (base1 * protocolFeeBps) / 10_000n;
    const expected1 = base1 + fee1;
    expect(quoted1).to.equal(expected1);

    await campaign.connect(trader).buyExactTokens(amount1, quoted1, { value: quoted1 });
    expect(await campaign.sold()).to.equal(amount1);

    // ---- Second buy ----
    const amount2 = ethers.parseUnits("5", 18); // 5 tokens
    const quoted2 = await campaign.quoteBuyExactTokens(amount2);
    const base2 = area(amount1 + amount2) - area(amount1);
    const fee2 = (base2 * protocolFeeBps) / 10_000n;
    const expected2 = base2 + fee2;
    expect(quoted2).to.equal(expected2);

    await campaign.connect(trader).buyExactTokens(amount2, quoted2, { value: quoted2 });

    const soldAfter = await campaign.sold();
    expect(soldAfter).to.equal(amount1 + amount2);

    // Spot price must match currentPrice formula
    const currentPrice = await campaign.currentPrice();
    const expectedPrice = basePrice + (priceSlope * soldAfter) / WAD;
    expect(currentPrice).to.equal(expectedPrice);

    // ---- Sell test ----
    const sellAmount = amount2; // sell back the second chunk
    const sellQuote = await campaign.quoteSellExactTokens(sellAmount);
    const grossSell = area(soldAfter) - area(soldAfter - sellAmount);
    const sellFee = (grossSell * protocolFeeBps) / 10_000n;
    const expectedSell = grossSell - sellFee;
    expect(sellQuote).to.equal(expectedSell);

    await token.connect(trader).approve(await campaign.getAddress(), sellAmount);

    await expect(
      campaign.connect(trader).sellExactTokens(sellAmount, 0)
    )
      .to.emit(campaign, "TokensSold")
      .withArgs(trader.address, sellAmount, sellQuote);
  });
      it("collects protocol fees correctly based on remaining balance after liquidity", async () => {
    const { creator, trader, router, factory } = await deployFactoryAndRouter();

    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,
      liquidityTokenBps: 1000n,
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"),
      liquidityBps: 8000n,
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Fee Token",
      symbol: "FEE",
      logoURI: "ipfs://logo-fee",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;

    const feeRecipientAddr = await factory.feeRecipient();
    const routerAddr = await router.getAddress();

    const routerBalanceBefore = await ethers.provider.getBalance(routerAddr);

    // Two buys into the curve
    const amount1 = ethers.parseUnits("10", 18);
    const cost1 = await campaign.quoteBuyExactTokens(amount1);
    await campaign.connect(trader).buyExactTokens(amount1, cost1, { value: cost1 });

    const amount2 = ethers.parseUnits("5", 18);
    const cost2 = await campaign.quoteBuyExactTokens(amount2);
    await campaign.connect(trader).buyExactTokens(amount2, cost2, { value: cost2 });

    const campaignAddr = await campaign.getAddress();
    const target = await campaign.graduationTarget();
    let campaignBalance = await ethers.provider.getBalance(campaignAddr);

    // Top up directly to hit graduationTarget if needed
    if (campaignBalance < target) {
      const missing = target - campaignBalance;
      await creator.sendTransaction({ to: campaignAddr, value: missing });
    }
    campaignBalance = await ethers.provider.getBalance(campaignAddr);
    const liquidityBps = await campaign.liquidityBps();
    const protocolFeeBps = await factory.protocolFeeBps();

    const balanceBefore = campaignBalance;
    const expectedProtocolFee = (balanceBefore * protocolFeeBps) / 10_000n;
    const remainingAfterFee = balanceBefore - expectedProtocolFee;
    const expectedLiquidityValue = (remainingAfterFee * liquidityBps) / 10_000n;
    const expectedCreatorPayout = remainingAfterFee - expectedLiquidityValue;
    // IMPORTANT: take feeRecipient baseline AFTER buys, so the delta measures finalize fee only
const feeRecipientBalanceBefore = await ethers.provider.getBalance(feeRecipientAddr);

    // Finalize: send LP to router, fee to feeRecipient, payout to creator
    const finalizeTx = await campaign.connect(creator).finalize(0, 0);
    const finalizeRc = await finalizeTx.wait();

    // Decode CampaignFinalized event (use indexes, not names)
    let parsed: any = null;
    for (const log of finalizeRc!.logs) {
      try {
        const p = campaign.interface.parseLog(log);
        if (p.name === "CampaignFinalized") {
          parsed = p;
          break;
        }
      } catch {
        // ignore logs from other contracts
      }
    }
    if (!parsed) {
      throw new Error("CampaignFinalized event not found");
    }

    // args: [caller, usedTokens, usedBnb, protocolFee, remainingBalance]
    const protocolFeeFromEvent = parsed.args[3] as bigint;
    const creatorPayoutFromEvent = parsed.args[4] as bigint;

    expect(protocolFeeFromEvent).to.equal(expectedProtocolFee);
    expect(creatorPayoutFromEvent).to.equal(expectedCreatorPayout);

    // Final balances: campaign empty, router & feeRecipient funded
    const routerBalanceAfter = await ethers.provider.getBalance(routerAddr);
    const feeRecipientBalanceAfter = await ethers.provider.getBalance(feeRecipientAddr);
    campaignBalance = await ethers.provider.getBalance(campaignAddr);

    expect(campaignBalance).to.equal(0n);
    expect(routerBalanceAfter - routerBalanceBefore).to.equal(expectedLiquidityValue);
    expect(feeRecipientBalanceAfter - feeRecipientBalanceBefore).to.equal(expectedProtocolFee);
  });
    it("full workflow: campaign creation, multi-user buys/sells, finalize and LP", async () => {
    const { router, factory } = await deployFactoryAndRouter();

    // We'll re-get some signers for clarity
    const [deployer, creator, alice, bob, carol] = await ethers.getSigners();

    // Use a small config so numbers stay manageable
    const newConfig = {
      totalSupply: ethers.parseUnits("1000", 18),
      curveBps: 8000n,            // 800 tokens for curve
      liquidityTokenBps: 1000n,   // 100 tokens for LP
      basePrice: ethers.parseEther("0.001"),
      priceSlope: ethers.parseEther("0.000001"),
      graduationTarget: ethers.parseEther("1"), // 1 BNB target
      liquidityBps: 8000n,        // 70% of BNB to LP
    };
    await factory.setConfig(newConfig);

    const request = {
      name: "Scenario Token",
      symbol: "SCN",
      logoURI: "ipfs://logo-scenario",
      xAccount: "",
      website: "",
      extraLink: "",
      basePrice: 0n,          // use config defaults
      priceSlope: 0n,
      graduationTarget: 0n,
      lpReceiver: creator.address,
      initialBuyBnbWei: 0n,
    };

    // 1. Creator launches a campaign via factory
    await factory.connect(creator).createCampaign(request);
    const info = await factory.getCampaign(0);
    const campaign = (await ethers.getContractAt("LaunchCampaign", info.campaign)) as unknown as LaunchCampaign;
    const token = (await ethers.getContractAt("LaunchToken", info.token)) as unknown as LaunchToken;

    const totalSupply = await campaign.totalSupply();
    const curveSupply = await campaign.curveSupply();
    const liquiditySupply = await campaign.liquiditySupply();
    const creatorReserve = await campaign.creatorReserve();

    // Initial invariants
    expect(await token.totalSupply()).to.equal(totalSupply);
    expect(await token.balanceOf(await campaign.getAddress())).to.equal(totalSupply);
    expect(await campaign.sold()).to.equal(0n);
    expect(totalSupply).to.equal(curveSupply + liquiditySupply + creatorReserve);

    // Helper functions for buys/sells in human units
    const buyTokens = async (user: any, rawAmount: number) => {
      const amount = ethers.parseUnits(rawAmount.toString(), 18);
      const cost = await campaign.quoteBuyExactTokens(amount);
      await campaign.connect(user).buyExactTokens(amount, cost, { value: cost });
      return { amount, cost };
    };

    const sellTokens = async (user: any, rawAmount: number) => {
      const amount = ethers.parseUnits(rawAmount.toString(), 18);
      const bal = await token.balanceOf(user.address);
      if (amount > bal) {
        // nothing to do
        return null;
      }
      const payout = await campaign.quoteSellExactTokens(amount);
      await token.connect(user).approve(await campaign.getAddress(), amount);
      await expect(campaign.connect(user).sellExactTokens(amount, 0))
        .to.emit(campaign, "TokensSold")
        .withArgs(user.address, amount, payout);
      return { amount, payout };
    };

    // 2. Multiple users buy into the curve
    await buyTokens(alice, 10); // Alice buys 10
    await buyTokens(bob, 20);   // Bob buys 20
    await buyTokens(carol, 5);  // Carol buys 5

    // Quick invariant: sold equals sum of all external balances
    const soldAfterBuys = await campaign.sold();
    const aliceBal1 = await token.balanceOf(alice.address);
    const bobBal1 = await token.balanceOf(bob.address);
    const carolBal1 = await token.balanceOf(carol.address);
    const sumBal1 = aliceBal1 + bobBal1 + carolBal1;

    expect(soldAfterBuys).to.equal(sumBal1);

    // And campaign holds the rest
    const campaignTokenBal1 = await token.balanceOf(await campaign.getAddress());
    expect(campaignTokenBal1 + sumBal1).to.equal(totalSupply);

    // 3. Some sells happen (profit-taking, rebalancing)
    await sellTokens(alice, 3); // Alice sells 3 (keeps 7)
    await sellTokens(bob, 5);   // Bob sells 5 (keeps 15)

    const soldAfterTrades = await campaign.sold();
    const aliceBal2 = await token.balanceOf(alice.address);
    const bobBal2 = await token.balanceOf(bob.address);
    const carolBal2 = await token.balanceOf(carol.address);
    const sumBal2 = aliceBal2 + bobBal2 + carolBal2;

    // Invariants still hold
    expect(soldAfterTrades).to.equal(sumBal2);
    const campaignTokenBal2 = await token.balanceOf(await campaign.getAddress());
    expect(campaignTokenBal2 + sumBal2).to.equal(totalSupply);
    expect(soldAfterTrades).to.be.lte(curveSupply);

    // 4. Reach graduation target (simulate more activity / external funding)
    const target = await campaign.graduationTarget();
    const campaignAddr = await campaign.getAddress();
    let campaignEthBal = await ethers.provider.getBalance(campaignAddr);
    if (campaignEthBal < target) {
      const missing = target - campaignEthBal;
      await deployer.sendTransaction({ to: campaignAddr, value: missing });
      campaignEthBal = await ethers.provider.getBalance(campaignAddr);
    }
    expect(campaignEthBal).to.be.gte(target);

    // 5. Only creator can finalize; and this will add LP via router
    await expect(
      campaign.connect(alice).finalize(0, 0)
    ).to.be.reverted; // non-owner

    await expect(
      campaign.connect(creator).finalize(0, 0)
    )
      .to.emit(campaign, "CampaignFinalized")
      .and.to.emit(router, "LiquidityAdded");

    // 6. Post-finalize state: launched, trading enabled
    expect(await campaign.launched()).to.equal(true);
    expect(await token.tradingEnabled()).to.equal(true);

    // Campaign should hold no tokens
    expect(await token.balanceOf(campaignAddr)).to.equal(0n);

    // Router should hold exactly liquiditySupply tokens
    expect(await token.balanceOf(await router.getAddress())).to.equal(liquiditySupply);

    // Creator should hold creatorReserve
    expect(await token.balanceOf(creator.address)).to.equal(creatorReserve);

    // Total supply = liquiditySupply + creatorReserve + sold (unsold curve burned)
    const soldFinal = await campaign.sold();
    const expectedTotalSupply =
      totalSupply - (curveSupply - soldFinal); // == liquiditySupply + creatorReserve + soldFinal
    expect(await token.totalSupply()).to.equal(expectedTotalSupply);

    // 7. Post-launch user-to-user transfers (simulating trading on an AMM)
    const transferAmount = ethers.parseUnits("2", 18);
    await token.connect(alice).transfer(bob.address, transferAmount);
    const aliceFinal = await token.balanceOf(alice.address);
    const bobFinal = await token.balanceOf(bob.address);
    expect(aliceFinal + bobFinal + (await token.balanceOf(carol.address)) + creatorReserve + liquiditySupply)
      .to.equal(await token.totalSupply());
  });
});
</file>

<file path="test/LaunchToken.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("LaunchToken", function () {
  async function deploy() {
    const [owner, alice, bob] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("LaunchToken");
    const token = await Token.deploy("T", "T", ethers.parseEther("100"), await owner.getAddress());
    return { owner, alice, bob, token };
  }

  it("constructor sets cap and owner; rejects zero cap/owner", async () => {
    const [owner] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("LaunchToken");
    await expect(Token.deploy("T", "T", 0n, await owner.getAddress())).to.be.revertedWith("cap is zero");
    // OZ Ownable(owner_) reverts with a custom error before our own require() runs.
    await expect(Token.deploy("T", "T", 1n, ethers.ZeroAddress)).to.be.reverted;

    const token = await Token.deploy("T", "T", 123n, await owner.getAddress());
    expect(await token.cap()).to.eq(123n);
    expect(await token.owner()).to.eq(await owner.getAddress());
    expect(await token.tradingEnabled()).to.eq(false);
  });

  it("mint: onlyOwner, nonzero to, respects cap", async () => {
    const { owner, alice, token } = await deploy();
    await expect(token.connect(alice).mint(await alice.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");

    await expect(token.connect(owner).mint(ethers.ZeroAddress, 1n)).to.be.revertedWith("to zero");

    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));
    expect(await token.totalSupply()).to.eq(ethers.parseEther("10"));

    await expect(token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("100")))
      .to.be.revertedWith("cap exceeded");
  });

  it("burn: onlyOwner", async () => {
    const { owner, alice, token } = await deploy();
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));
    await expect(token.connect(alice).burn(await alice.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");

    await token.connect(owner).burn(await alice.getAddress(), ethers.parseEther("2"));
    expect(await token.balanceOf(await alice.getAddress())).to.eq(ethers.parseEther("8"));
  });

  it("trading restriction: before enableTrading, user->user transfers revert; campaign(owner) can move funds and pull via transferFrom", async () => {
    const { owner, alice, bob, token } = await deploy();

    // owner mints to alice (allowed: from==0)
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("10"));

    // alice -> bob transfer blocked
    await expect(token.connect(alice).transfer(await bob.getAddress(), 1n))
      .to.be.revertedWithCustomError(token, "TradingNotEnabled");

    // alice approves owner (campaign), owner can move tokens even when 'from' is alice
    await token.connect(alice).approve(await owner.getAddress(), ethers.parseEther("2"));

    // owner pulls 1 token to itself (msg.sender==owner) allowed
    await token.connect(owner).transferFrom(await alice.getAddress(), await owner.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await owner.getAddress())).to.eq(ethers.parseEther("1"));

    // owner transfers from its own balance to bob (from==owner) allowed
    await token.connect(owner).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });

  it("after enableTrading, normal transfers work", async () => {
    const { owner, alice, bob, token } = await deploy();
    await token.connect(owner).mint(await alice.getAddress(), ethers.parseEther("3"));
    await token.connect(owner).enableTrading();
    await token.connect(alice).transfer(await bob.getAddress(), ethers.parseEther("1"));
    expect(await token.balanceOf(await bob.getAddress())).to.eq(ethers.parseEther("1"));
  });
});
</file>

<file path="test/LpTimelock.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("LpTimelock", function () {
  it("constructor validations", async () => {
    const [deployer, beneficiary] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MockERC20");
    const token = await Token.deploy("LP", "LP", ethers.parseEther("100"), await deployer.getAddress());

    const Timelock = await ethers.getContractFactory("LpTimelock");
    const now = (await ethers.provider.getBlock("latest"))!.timestamp;

    await expect(Timelock.deploy(ethers.ZeroAddress, await beneficiary.getAddress(), now + 3600))
      .to.be.revertedWith("token=0");
    await expect(Timelock.deploy(await token.getAddress(), ethers.ZeroAddress, now + 3600))
      .to.be.revertedWith("beneficiary=0");
    await expect(Timelock.deploy(await token.getAddress(), await beneficiary.getAddress(), now))
      .to.be.revertedWith("releaseTime");
  });

  it("release: reverts before time; after time transfers all balance to beneficiary", async () => {
    const [deployer, beneficiary] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("MockERC20");
    const token = await Token.deploy("LP", "LP", ethers.parseEther("100"), await deployer.getAddress());

    const Timelock = await ethers.getContractFactory("LpTimelock");
    const now = (await ethers.provider.getBlock("latest"))!.timestamp;
    const timelock = await Timelock.deploy(await token.getAddress(), await beneficiary.getAddress(), now + 3600);

    await expect(timelock.release()).to.be.revertedWith("not released");
    await expect(timelock.connect(beneficiary).release()).to.be.revertedWith("not released");

    // fund timelock
    await token.transfer(await timelock.getAddress(), ethers.parseEther("10"));

    // advance time
    await ethers.provider.send("evm_increaseTime", [3600]);
    await ethers.provider.send("evm_mine", []);

    await expect(timelock.release()).to.not.be.reverted; // any caller can trigger, but beneficiary receives

    expect(await token.balanceOf(await beneficiary.getAddress())).to.eq(ethers.parseEther("10"));
    expect(await token.balanceOf(await timelock.getAddress())).to.eq(0n);

    // second release: no tokens
    await expect(timelock.release()).to.be.revertedWith("no tokens");
  });
});
</file>

<file path="test/lpTimelock.test.js">
import { expect } from "chai";
import hre from "hardhat";

const { ethers } = await hre.network.connect();
const { parseEther } = ethers;

//  Helper to jump time using ethers.provider
async function setNextBlockTimestamp(timestamp) {
  await ethers.provider.send("evm_setNextBlockTimestamp", [timestamp]);
  await ethers.provider.send("evm_mine", []);
}

describe("LpTimelock", function () {
  let owner, beneficiary, other;
  let token;
  let LpTimelock;

  beforeEach(async function () {
    [owner, beneficiary, other] = await ethers.getSigners();

    // Use your TokenTemplate as the ERC20
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    token = await TokenTemplate.deploy();
    await token.waitForDeployment();

    // Initialize token so it behaves like in the other tests
    await token
      .connect(owner)
      .initialize("LP Token", "LPT", owner.address);

    LpTimelock = await ethers.getContractFactory("LpTimelock");
  });

  it("sets token, beneficiary and releaseTime in constructor", async function () {
    const tokenAddr = await token.getAddress();

    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600; // 1 hour from now

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    expect(await timelock.token()).to.equal(tokenAddr);
    expect(await timelock.beneficiary()).to.equal(beneficiary.address);
    expect(await timelock.releaseTime()).to.equal(releaseTime);
  });

  it("reverts if releaseTime is not strictly in the future", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;

    let errorEqual;
    try {
      await LpTimelock.deploy(tokenAddr, beneficiary.address, now);
    } catch (e) {
      errorEqual = e;
    }
    expect(errorEqual).to.be.an("Error");
    expect(String(errorEqual.message)).to.include("Release before now");

    let errorPast;
    try {
      await LpTimelock.deploy(tokenAddr, beneficiary.address, now - 1);
    } catch (e) {
      errorPast = e;
    }
    expect(errorPast).to.be.an("Error");
    expect(String(errorPast.message)).to.include("Release before now");
  });

  it("reverts release() before releaseTime", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    let error;
    try {
      await timelock.connect(beneficiary).release();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("Not released");
  });

  it("reverts release() after time if no tokens locked", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    // move just past releaseTime
    await setNextBlockTimestamp(releaseTime + 1);

    let error;
    try {
      await timelock.connect(beneficiary).release();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("No tokens");
  });

  it("releases full balance to beneficiary after releaseTime", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    const timelockAddr = await timelock.getAddress();
    const amount = parseEther("1000");

    // owner has MINTER_ROLE by default from initialize()
    await token.connect(owner).mint(owner.address, amount);

    // send LP tokens to the timelock
    await token.connect(owner).transfer(timelockAddr, amount);

    const beforeBeneficiary = await token.balanceOf(beneficiary.address);
    const beforeLock = await token.balanceOf(timelockAddr);

    expect(beforeLock).to.equal(amount);

    // move time past releaseTime
    await setNextBlockTimestamp(releaseTime + 1);

    // release tokens
    const tx = await timelock.connect(beneficiary).release();
    await tx.wait();

    const afterBeneficiary = await token.balanceOf(beneficiary.address);
    const afterLock = await token.balanceOf(timelockAddr);

    expect(afterLock).to.equal(0n);
    expect(afterBeneficiary - beforeBeneficiary).to.equal(amount);
  });
});
</file>

<file path="test/lpTimelock.test.js.disabled">
import { expect } from "chai";
import hre from "hardhat";

const { ethers } = await hre.network.connect();
const { parseEther } = ethers;

//  Helper to jump time using ethers.provider
async function setNextBlockTimestamp(timestamp) {
  await ethers.provider.send("evm_setNextBlockTimestamp", [timestamp]);
  await ethers.provider.send("evm_mine", []);
}

describe("LpTimelock", function () {
  let owner, beneficiary, other;
  let token;
  let LpTimelock;

  beforeEach(async function () {
    [owner, beneficiary, other] = await ethers.getSigners();

    // Use your TokenTemplate as the ERC20
    const TokenTemplate = await ethers.getContractFactory("TokenTemplate");
    token = await TokenTemplate.deploy();
    await token.waitForDeployment();

    // Initialize token so it behaves like in the other tests
    await token
      .connect(owner)
      .initialize("LP Token", "LPT", owner.address);

    LpTimelock = await ethers.getContractFactory("LpTimelock");
  });

  it("sets token, beneficiary and releaseTime in constructor", async function () {
    const tokenAddr = await token.getAddress();

    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600; // 1 hour from now

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    expect(await timelock.token()).to.equal(tokenAddr);
    expect(await timelock.beneficiary()).to.equal(beneficiary.address);
    expect(await timelock.releaseTime()).to.equal(releaseTime);
  });

  it("reverts if releaseTime is not strictly in the future", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;

    let errorEqual;
    try {
      await LpTimelock.deploy(tokenAddr, beneficiary.address, now);
    } catch (e) {
      errorEqual = e;
    }
    expect(errorEqual).to.be.an("Error");
    expect(String(errorEqual.message)).to.include("Release before now");

    let errorPast;
    try {
      await LpTimelock.deploy(tokenAddr, beneficiary.address, now - 1);
    } catch (e) {
      errorPast = e;
    }
    expect(errorPast).to.be.an("Error");
    expect(String(errorPast.message)).to.include("Release before now");
  });

  it("reverts release() before releaseTime", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    let error;
    try {
      await timelock.connect(beneficiary).release();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("Not released");
  });

  it("reverts release() after time if no tokens locked", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    // move just past releaseTime
    await setNextBlockTimestamp(releaseTime + 1);

    let error;
    try {
      await timelock.connect(beneficiary).release();
    } catch (e) {
      error = e;
    }

    expect(error).to.be.an("Error");
    expect(String(error.message)).to.include("No tokens");
  });

  it("releases full balance to beneficiary after releaseTime", async function () {
    const tokenAddr = await token.getAddress();
    const latest = await ethers.provider.getBlock("latest");
    const now = latest.timestamp;
    const releaseTime = now + 3600;

    const timelock = await LpTimelock.deploy(
      tokenAddr,
      beneficiary.address,
      releaseTime
    );
    await timelock.waitForDeployment();

    const timelockAddr = await timelock.getAddress();
    const amount = parseEther("1000");

    // owner has MINTER_ROLE by default from initialize()
    await token.connect(owner).mint(owner.address, amount);

    // send LP tokens to the timelock
    await token.connect(owner).transfer(timelockAddr, amount);

    const beforeBeneficiary = await token.balanceOf(beneficiary.address);
    const beforeLock = await token.balanceOf(timelockAddr);

    expect(beforeLock).to.equal(amount);

    // move time past releaseTime
    await setNextBlockTimestamp(releaseTime + 1);

    // release tokens
    const tx = await timelock.connect(beneficiary).release();
    await tx.wait();

    const afterBeneficiary = await token.balanceOf(beneficiary.address);
    const afterLock = await token.balanceOf(timelockAddr);

    expect(afterLock).to.equal(0n);
    expect(afterBeneficiary - beforeBeneficiary).to.equal(amount);
  });
});
</file>

<file path="test/tokenTemplate.test.js">
import { expect } from "chai";
import hre from "hardhat";
import { Interface } from "ethers";  // <-- get Interface from ethers package

const { ethers } = await hre.network.connect();

// same helper style as factory test
async function waitForDeployment(contract) {
  if (typeof contract.waitForDeployment === "function") {
    await contract.waitForDeployment(); // ethers v6
  } else if (typeof contract.deployed === "function") {
    await contract.deployed(); // ethers v5
  }
}

describe("TokenTemplate", function () {
  let owner, alice, bob;
  let TokenTemplate;
  let token;

  beforeEach(async function () {
    [owner, alice, bob] = await ethers.getSigners();

    TokenTemplate = await ethers.getContractFactory("TokenTemplate");

    //  OLD (causes invalid overrides):
    // token = await TokenTemplate.deploy(owner.address);

    //  NEW: no constructor args, matches the compiled contract ABI
    token = await TokenTemplate.deploy();

    await waitForDeployment(token);
  });

  it("sets the initial owner correctly (if constructor sets it)", async function () {
    // If your TokenTemplate constructor uses Ownable(msg.sender),
    // this will pass. If you still plan to set owner in initialize(),
    // you might need to adjust this expectation later.
    expect(await token.owner()).to.equal(owner.address);
  });

  it("initializes name, symbol and owner", async function () {
    await token.initialize("MyToken", "MTK", owner.address);

    expect(await token.name()).to.equal("MyToken");
    expect(await token.symbol()).to.equal("MTK");
    expect(await token.owner()).to.equal(owner.address);
  });

  it("reverts if initialize() is called twice", async function () {
    await token.initialize("AAA", "AAA", owner.address);

    await expect(
      token.initialize("BBB", "BBB", owner.address)
    ).to.be.revertedWith("Already initialized");
  });

  it("owner can grant minter role", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(alice.address);

    // no isMinter() in the contract, so we rely on AccessControl.hasRole
    const minterRole = await token.MINTER_ROLE();
    expect(await token.hasRole(minterRole, alice.address)).to.equal(true);
  });

  it("non-owner cannot grant minter role", async function () {
    await token.initialize("T", "T", owner.address);

    await expect(
      token.connect(alice).grantMinter(bob.address)
    ).to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");
  });

  it("minter can mint tokens", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(owner.address);

    await token.mint(bob.address, 123);
    expect(await token.balanceOf(bob.address)).to.equal(123);
  });

  it("non-minter cannot mint", async function () {
    await token.initialize("T", "T", owner.address);

    await expect(
      token.connect(alice).mint(bob.address, 500)
    ).to.be.revertedWith("Not minter");
  });

  it("holder can burn their tokens", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(owner.address);

    await token.mint(owner.address, 1000);
    await token.burn(400);

    expect(await token.balanceOf(owner.address)).to.equal(600);
  });
});
</file>

<file path="test/tokenTemplate.test.js.disabled">
import { expect } from "chai";
import hre from "hardhat";
import { Interface } from "ethers";  // <-- get Interface from ethers package

const { ethers } = await hre.network.connect();

// same helper style as factory test
async function waitForDeployment(contract) {
  if (typeof contract.waitForDeployment === "function") {
    await contract.waitForDeployment(); // ethers v6
  } else if (typeof contract.deployed === "function") {
    await contract.deployed(); // ethers v5
  }
}

describe("TokenTemplate", function () {
  let owner, alice, bob;
  let TokenTemplate;
  let token;

  beforeEach(async function () {
    [owner, alice, bob] = await ethers.getSigners();

    TokenTemplate = await ethers.getContractFactory("TokenTemplate");

    //  OLD (causes invalid overrides):
    // token = await TokenTemplate.deploy(owner.address);

    //  NEW: no constructor args, matches the compiled contract ABI
    token = await TokenTemplate.deploy();

    await waitForDeployment(token);
  });

  it("sets the initial owner correctly (if constructor sets it)", async function () {
    // If your TokenTemplate constructor uses Ownable(msg.sender),
    // this will pass. If you still plan to set owner in initialize(),
    // you might need to adjust this expectation later.
    expect(await token.owner()).to.equal(owner.address);
  });

  it("initializes name, symbol and owner", async function () {
    await token.initialize("MyToken", "MTK", owner.address);

    expect(await token.name()).to.equal("MyToken");
    expect(await token.symbol()).to.equal("MTK");
    expect(await token.owner()).to.equal(owner.address);
  });

  it("reverts if initialize() is called twice", async function () {
    await token.initialize("AAA", "AAA", owner.address);

    await expect(
      token.initialize("BBB", "BBB", owner.address)
    ).to.be.revertedWith("Already initialized");
  });

  it("owner can grant minter role", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(alice.address);

    // no isMinter() in the contract, so we rely on AccessControl.hasRole
    const minterRole = await token.MINTER_ROLE();
    expect(await token.hasRole(minterRole, alice.address)).to.equal(true);
  });

  it("non-owner cannot grant minter role", async function () {
    await token.initialize("T", "T", owner.address);

    await expect(
      token.connect(alice).grantMinter(bob.address)
    ).to.be.revertedWithCustomError(token, "OwnableUnauthorizedAccount");
  });

  it("minter can mint tokens", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(owner.address);

    await token.mint(bob.address, 123);
    expect(await token.balanceOf(bob.address)).to.equal(123);
  });

  it("non-minter cannot mint", async function () {
    await token.initialize("T", "T", owner.address);

    await expect(
      token.connect(alice).mint(bob.address, 500)
    ).to.be.revertedWith("Not minter");
  });

  it("holder can burn their tokens", async function () {
    await token.initialize("T", "T", owner.address);
    await token.grantMinter(owner.address);

    await token.mint(owner.address, 1000);
    await token.burn(400);

    expect(await token.balanceOf(owner.address)).to.equal(600);
  });
});
</file>

<file path="test/TreasuryRouter.spec.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

// TreasuryRouter is used as a League fee receiver. These tests ensure
// forwarding failures never revert and funds are retained safely.

describe("TreasuryRouter", function () {
  it("receive(): forwarding failure emits ForwardFailed and retains funds", async () => {
    const [admin, sender] = await ethers.getSigners();

    const Reverting = await ethers.getContractFactory("RevertingReceiver");
    const badVault = await Reverting.deploy();
    await badVault.waitForDeployment();

    const Router = await ethers.getContractFactory("TreasuryRouter");
    const router = await Router.deploy(await admin.getAddress(), await badVault.getAddress(), 3600);
    await router.waitForDeployment();

    const amount = ethers.parseEther("0.123");

    await expect(sender.sendTransaction({ to: await router.getAddress(), value: amount }))
      .to.emit(router, "ForwardFailed")
      .withArgs(await badVault.getAddress(), amount);

    expect(await ethers.provider.getBalance(await router.getAddress())).to.eq(amount);
  });

  it("forwardingPaused prevents forwarding attempts", async () => {
    const [admin, sender] = await ethers.getSigners();

    const Reverting = await ethers.getContractFactory("RevertingReceiver");
    const badVault = await Reverting.deploy();
    await badVault.waitForDeployment();

    const Router = await ethers.getContractFactory("TreasuryRouter");
    const router = await Router.deploy(await admin.getAddress(), await badVault.getAddress(), 3600);
    await router.waitForDeployment();

    await (await router.connect(admin).setForwardingPaused(true)).wait();

    const amount = 123n;
    // When paused, receive should not emit ForwardFailed/Forwarded and should simply accept funds.
    await expect(sender.sendTransaction({ to: await router.getAddress(), value: amount }))
      .to.not.emit(router, "ForwardFailed");

    expect(await ethers.provider.getBalance(await router.getAddress())).to.eq(amount);
  });
});
</file>

<file path="test/UPVoteTreasury.test.ts">
import { expect } from "chai";
import { ethers } from "hardhat";

describe("UPVoteTreasury (forwarding)", function () {
  async function deploy() {
    const [owner, feeReceiver, alice, bob] = await ethers.getSigners();

    const Treasury = await ethers.getContractFactory("UPVoteTreasury");
    const treasury = await Treasury.deploy(owner.address, feeReceiver.address);
    await treasury.waitForDeployment();

    return { treasury, owner, feeReceiver, alice, bob };
  }

  it("deploys with feeReceiver and native enabled", async () => {
    const { treasury, feeReceiver } = await deploy();
    expect(await treasury.feeReceiver()).to.eq(feeReceiver.address);

    const cfg = await treasury.assetConfig(ethers.ZeroAddress);
    expect(cfg.enabled).to.eq(true);
  });

  it("only owner can setAsset / setFeeReceiver", async () => {
    const { treasury, alice } = await deploy();
    await expect(
      treasury.connect(alice).setAsset(ethers.ZeroAddress, true, 123n)
    ).to.be.revertedWith("NOT_OWNER");

    await expect(
      treasury.connect(alice).setFeeReceiver(alice.address)
    ).to.be.revertedWith("NOT_OWNER");
  });

  it("voteWithBNB reverts when below minAmount", async () => {
    const { treasury, owner, alice } = await deploy();

    await (await treasury.connect(owner).setAsset(
      ethers.ZeroAddress,
      true,
      ethers.parseEther("0.01")
    )).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(alice.address, ethers.ZeroHash, { value: ethers.parseEther("0.005") })
    ).to.be.revertedWith("AMOUNT_TOO_LOW");
  });

  it("voteWithBNB forwards to feeReceiver and emits event", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    await (await treasury.connect(owner).setAsset(
      ethers.ZeroAddress,
      true,
      ethers.parseEther("0.005")
    )).wait();

    const campaign = "0x0000000000000000000000000000000000001234";
    const value = ethers.parseEther("0.005");
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await ethers.provider.getBalance(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, meta, { value })
    )
      .to.emit(treasury, "VoteCast")
      .withArgs(campaign, alice.address, ethers.ZeroAddress, value, meta);

    const after = await ethers.provider.getBalance(feeReceiver.address);
    expect(after - before).to.eq(value);

    // contract balance should not accumulate (ignoring dust)
    const contractBal = await ethers.provider.getBalance(await treasury.getAddress());
    expect(contractBal).to.eq(0n);
  });

  it("voteWithToken pulls ERC20, forwards to feeReceiver, emits received amount", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    const Mock = await ethers.getContractFactory("MockERC20");
    // This repo's MockERC20 constructor is: (name, symbol, supply, to)
    const initialSupply = ethers.parseUnits("1000", 18);
    const usdt = await Mock.deploy("Tether", "USDT", initialSupply, alice.address);
    await usdt.waitForDeployment();

    // enable token with min 2
    await (await treasury
      .connect(owner)
      .setAsset(await usdt.getAddress(), true, ethers.parseUnits("2", 18))).wait();

    // approve
    await (await usdt
      .connect(alice)
      .approve(await treasury.getAddress(), ethers.parseUnits("3", 18))).wait();

    const campaign = "0x0000000000000000000000000000000000005678";
    const amount = ethers.parseUnits("3", 18);
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await usdt.balanceOf(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithToken(campaign, await usdt.getAddress(), amount, meta)
    )
      .to.emit(treasury, "VoteCast")
      // received == amount for normal ERC20
      .withArgs(campaign, alice.address, await usdt.getAddress(), amount, meta);

    const after = await usdt.balanceOf(feeReceiver.address);
    expect(after - before).to.eq(amount);

    // treasury should not hold tokens
    const held = await usdt.balanceOf(await treasury.getAddress());
    expect(held).to.eq(0n);
  });

  it("voteWithToken respects fee-on-transfer: minAmount enforced on received, and forwards received", async () => {
    const { treasury, owner, alice, feeReceiver } = await deploy();

    const FeeToken = await ethers.getContractFactory("MockFeeOnTransferERC20");
    // 10% fee
    const feeToken = await FeeToken.deploy(1000);
    await feeToken.waitForDeployment();

    const tokenAddr = await feeToken.getAddress();

    // If we want min received = 90, set minAmount=90
    const minReceived = ethers.parseUnits("90", 18);
    await (await treasury.connect(owner).setAsset(tokenAddr, true, minReceived)).wait();

    // mint 200 to alice
    await (await feeToken.mint(alice.address, ethers.parseUnits("200", 18))).wait();

    // alice votes with 100; received by treasury will be 90
    const sendAmount = ethers.parseUnits("100", 18);
    await (await feeToken.connect(alice).approve(await treasury.getAddress(), sendAmount)).wait();

    const campaign = "0x0000000000000000000000000000000000009999";
    const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));

    const before = await feeToken.balanceOf(feeReceiver.address);

    await expect(
      treasury.connect(alice).voteWithToken(campaign, tokenAddr, sendAmount, meta)
    )
      .to.emit(treasury, "VoteCast")
      .withArgs(campaign, alice.address, tokenAddr, minReceived, meta);

    const after = await feeToken.balanceOf(feeReceiver.address);
    // NOTE: fee-on-transfer tokens charge a fee on *each* transfer.
    // In this forwarding design:
    //   (1) Alice -> Treasury is taxed
    //   (2) Treasury -> feeReceiver is taxed again
    // The VoteCast event records what the Treasury received (minReceived),
    // but feeReceiver will receive less if the token taxes outgoing transfers.
    const feeBps = BigInt(await feeToken.feeBps());
    const expectedToFeeReceiver = (minReceived * (10_000n - feeBps)) / 10_000n;
    expect(after - before).to.eq(expectedToFeeReceiver);

    // treasury should not hold tokens
    const held = await feeToken.balanceOf(await treasury.getAddress());
    expect(held).to.eq(0n);
  });

  it("campaign allowlist can be enabled and enforced", async () => {
    const { treasury, owner, alice } = await deploy();

    const campaign = "0x000000000000000000000000000000000000ABCD";

    await (await treasury.connect(owner).setCampaignAllowlistEnabled(true)).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, ethers.ZeroHash, { value: 1n })
    ).to.be.revertedWith("CAMPAIGN_NOT_ALLOWED");

    await (await treasury.connect(owner).setCampaignAllowed(campaign, true)).wait();

    // enable tiny min
    await (await treasury.connect(owner).setAsset(ethers.ZeroAddress, true, 1n)).wait();

    await expect(
      treasury.connect(alice).voteWithBNB(campaign, ethers.ZeroHash, { value: 1n })
    ).to.emit(treasury, "VoteCast");
  });

  it("direct BNB transfer to receive() does not emit VoteCast", async () => {
    const { treasury, alice } = await deploy();

    await expect(
      alice.sendTransaction({ to: await treasury.getAddress(), value: 123n })
    ).to.not.emit(treasury, "VoteCast");
  });
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "outDir": "dist",
    "types": ["node", "mocha"]
  },
  "include": ["./hardhat.config.ts", "./test/**/*.ts", "./scripts/**/*.ts"]
}
</file>

<file path="typechain-types/@openzeppelin/contracts/access/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { Ownable } from "./Ownable";
</file>

<file path="typechain-types/@openzeppelin/contracts/access/Ownable.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export interface OwnableInterface extends Interface {
  getFunction(
    nameOrSignature: "owner" | "renounceOwnership" | "transferOwnership"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;

  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Ownable extends BaseContract {
  connect(runner?: ContractRunner | null): Ownable;
  waitForDeployment(): Promise<this>;

  interface: OwnableInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  owner: TypedContractMethod<[], [string], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;

  filters: {
    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/@openzeppelin/contracts/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as access from "./access";
export type { access };
import type * as interfaces from "./interfaces";
export type { interfaces };
import type * as proxy from "./proxy";
export type { proxy };
import type * as token from "./token";
export type { token };
import type * as utils from "./utils";
export type { utils };
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../../common";

export interface IERC1155ErrorsInterface extends Interface {}

export interface IERC1155Errors extends BaseContract {
  connect(runner?: ContractRunner | null): IERC1155Errors;
  waitForDeployment(): Promise<this>;

  interface: IERC1155ErrorsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../../common";

export interface IERC20ErrorsInterface extends Interface {}

export interface IERC20Errors extends BaseContract {
  connect(runner?: ContractRunner | null): IERC20Errors;
  waitForDeployment(): Promise<this>;

  interface: IERC20ErrorsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../../common";

export interface IERC721ErrorsInterface extends Interface {}

export interface IERC721Errors extends BaseContract {
  connect(runner?: ContractRunner | null): IERC721Errors;
  waitForDeployment(): Promise<this>;

  interface: IERC721ErrorsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IERC1155Errors } from "./IERC1155Errors";
export type { IERC20Errors } from "./IERC20Errors";
export type { IERC721Errors } from "./IERC721Errors";
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/IERC1363.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export interface IERC1363Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "approveAndCall(address,uint256)"
      | "approveAndCall(address,uint256,bytes)"
      | "balanceOf"
      | "supportsInterface"
      | "totalSupply"
      | "transfer"
      | "transferAndCall(address,uint256)"
      | "transferAndCall(address,uint256,bytes)"
      | "transferFrom"
      | "transferFromAndCall(address,address,uint256,bytes)"
      | "transferFromAndCall(address,address,uint256)"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAndCall(address,uint256)",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveAndCall(address,uint256,bytes)",
    values: [AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAndCall(address,uint256)",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAndCall(address,uint256,bytes)",
    values: [AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromAndCall(address,address,uint256,bytes)",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFromAndCall(address,address,uint256)",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approveAndCall(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveAndCall(address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferAndCall(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAndCall(address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromAndCall(address,address,uint256,bytes)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferFromAndCall(address,address,uint256)",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IERC1363 extends BaseContract {
  connect(runner?: ContractRunner | null): IERC1363;
  waitForDeployment(): Promise<this>;

  interface: IERC1363Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  "approveAndCall(address,uint256)": TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  "approveAndCall(address,uint256,bytes)": TypedContractMethod<
    [spender: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  "transferAndCall(address,uint256)": TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  "transferAndCall(address,uint256,bytes)": TypedContractMethod<
    [to: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  "transferFromAndCall(address,address,uint256,bytes)": TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;

  "transferFromAndCall(address,address,uint256)": TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveAndCall(address,uint256)"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "approveAndCall(address,uint256,bytes)"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferAndCall(address,uint256)"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferAndCall(address,uint256,bytes)"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFromAndCall(address,address,uint256,bytes)"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish, data: BytesLike],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFromAndCall(address,address,uint256)"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/@openzeppelin/contracts/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as draftIerc6093Sol from "./draft-IERC6093.sol";
export type { draftIerc6093Sol };
export type { IERC1363 } from "./IERC1363";
</file>

<file path="typechain-types/@openzeppelin/contracts/proxy/Clones.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../common";

export interface ClonesInterface extends Interface {}

export interface Clones extends BaseContract {
  connect(runner?: ContractRunner | null): Clones;
  waitForDeployment(): Promise<this>;

  interface: ClonesInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/proxy/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { Clones } from "./Clones";
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/ERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface ERC20Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "decimals"
      | "name"
      | "symbol"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface ERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): ERC20;
  waitForDeployment(): Promise<this>;

  interface: ERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  name: TypedContractMethod<[], [string], "view">;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../../common";

export interface IERC20MetadataInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "decimals"
      | "name"
      | "symbol"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IERC20Metadata extends BaseContract {
  connect(runner?: ContractRunner | null): IERC20Metadata;
  waitForDeployment(): Promise<this>;

  interface: IERC20MetadataInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  name: TypedContractMethod<[], [string], "view">;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/extensions/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IERC20Metadata } from "./IERC20Metadata";
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/IERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface IERC20Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): IERC20;
  waitForDeployment(): Promise<this>;

  interface: IERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as extensions from "./extensions";
export type { extensions };
import type * as utils from "./utils";
export type { utils };
export type { ERC20 } from "./ERC20";
export type { IERC20 } from "./IERC20";
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/utils/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { SafeERC20 } from "./SafeERC20";
</file>

<file path="typechain-types/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../../../common";

export interface SafeERC20Interface extends Interface {}

export interface SafeERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): SafeERC20;
  waitForDeployment(): Promise<this>;

  interface: SafeERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/token/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as erc20 from "./ERC20";
export type { erc20 };
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/Create2.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../common";

export interface Create2Interface extends Interface {}

export interface Create2 extends BaseContract {
  connect(runner?: ContractRunner | null): Create2;
  waitForDeployment(): Promise<this>;

  interface: Create2Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/Errors.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../common";

export interface ErrorsInterface extends Interface {}

export interface Errors extends BaseContract {
  connect(runner?: ContractRunner | null): Errors;
  waitForDeployment(): Promise<this>;

  interface: ErrorsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as introspection from "./introspection";
export type { introspection };
import type * as math from "./math";
export type { math };
export type { Create2 } from "./Create2";
export type { Errors } from "./Errors";
export type { ReentrancyGuard } from "./ReentrancyGuard";
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/introspection/IERC165.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface IERC165Interface extends Interface {
  getFunction(nameOrSignature: "supportsInterface"): FunctionFragment;

  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
}

export interface IERC165 extends BaseContract {
  connect(runner?: ContractRunner | null): IERC165;
  waitForDeployment(): Promise<this>;

  interface: IERC165Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  supportsInterface: TypedContractMethod<
    [interfaceId: BytesLike],
    [boolean],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/introspection/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IERC165 } from "./IERC165";
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/math/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { SafeCast } from "./SafeCast";
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/math/SafeCast.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../../common";

export interface SafeCastInterface extends Interface {}

export interface SafeCast extends BaseContract {
  connect(runner?: ContractRunner | null): SafeCast;
  waitForDeployment(): Promise<this>;

  interface: SafeCastInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/contracts/utils/ReentrancyGuard.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../../common";

export interface ReentrancyGuardInterface extends Interface {}

export interface ReentrancyGuard extends BaseContract {
  connect(runner?: ContractRunner | null): ReentrancyGuard;
  waitForDeployment(): Promise<this>;

  interface: ReentrancyGuardInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/@openzeppelin/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as contracts from "./contracts";
export type { contracts };
</file>

<file path="typechain-types/common.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  FunctionFragment,
  Typed,
  EventFragment,
  ContractTransaction,
  ContractTransactionResponse,
  DeferredTopicFilter,
  EventLog,
  TransactionRequest,
  LogDescription,
} from "ethers";

export interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent>
  extends DeferredTopicFilter {}

export interface TypedContractEvent<
  InputTuple extends Array<any> = any,
  OutputTuple extends Array<any> = any,
  OutputObject = any
> {
  (...args: Partial<InputTuple>): TypedDeferredTopicFilter<
    TypedContractEvent<InputTuple, OutputTuple, OutputObject>
  >;
  name: string;
  fragment: EventFragment;
  getFragment(...args: Partial<InputTuple>): EventFragment;
}

type __TypechainAOutputTuple<T> = T extends TypedContractEvent<
  infer _U,
  infer W
>
  ? W
  : never;
type __TypechainOutputObject<T> = T extends TypedContractEvent<
  infer _U,
  infer _W,
  infer V
>
  ? V
  : never;

export interface TypedEventLog<TCEvent extends TypedContractEvent>
  extends Omit<EventLog, "args"> {
  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;
}

export interface TypedLogDescription<TCEvent extends TypedContractEvent>
  extends Omit<LogDescription, "args"> {
  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;
}

export type TypedListener<TCEvent extends TypedContractEvent> = (
  ...listenerArg: [
    ...__TypechainAOutputTuple<TCEvent>,
    TypedEventLog<TCEvent>,
    ...undefined[]
  ]
) => void;

export type MinEthersFactory<C, ARGS> = {
  deploy(...a: ARGS[]): Promise<C>;
};

export type GetContractTypeFromFactory<F> = F extends MinEthersFactory<
  infer C,
  any
>
  ? C
  : never;
export type GetARGsTypeFromFactory<F> = F extends MinEthersFactory<any, any>
  ? Parameters<F["deploy"]>
  : never;

export type StateMutability = "nonpayable" | "payable" | "view";

export type BaseOverrides = Omit<TransactionRequest, "to" | "data">;
export type NonPayableOverrides = Omit<
  BaseOverrides,
  "value" | "blockTag" | "enableCcipRead"
>;
export type PayableOverrides = Omit<
  BaseOverrides,
  "blockTag" | "enableCcipRead"
>;
export type ViewOverrides = Omit<TransactionRequest, "to" | "data">;
export type Overrides<S extends StateMutability> = S extends "nonpayable"
  ? NonPayableOverrides
  : S extends "payable"
  ? PayableOverrides
  : ViewOverrides;

export type PostfixOverrides<A extends Array<any>, S extends StateMutability> =
  | A
  | [...A, Overrides<S>];
export type ContractMethodArgs<
  A extends Array<any>,
  S extends StateMutability
> = PostfixOverrides<{ [I in keyof A]-?: A[I] | Typed }, S>;

export type DefaultReturnType<R> = R extends Array<any> ? R[0] : R;

// export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {
export interface TypedContractMethod<
  A extends Array<any> = Array<any>,
  R = any,
  S extends StateMutability = "payable"
> {
  (...args: ContractMethodArgs<A, S>): S extends "view"
    ? Promise<DefaultReturnType<R>>
    : Promise<ContractTransactionResponse>;

  name: string;

  fragment: FunctionFragment;

  getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment;

  populateTransaction(
    ...args: ContractMethodArgs<A, S>
  ): Promise<ContractTransaction>;
  staticCall(
    ...args: ContractMethodArgs<A, "view">
  ): Promise<DefaultReturnType<R>>;
  send(...args: ContractMethodArgs<A, S>): Promise<ContractTransactionResponse>;
  estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>;
  staticCallResult(...args: ContractMethodArgs<A, "view">): Promise<R>;
}
</file>

<file path="typechain-types/contracts/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as upVoteTreasurySol from "./UPVoteTreasury.sol";
export type { upVoteTreasurySol };
import type * as interfaces from "./interfaces";
export type { interfaces };
import type * as mocks from "./mocks";
export type { mocks };
import type * as test from "./test";
export type { test };
import type * as token from "./token";
export type { token };
export type { ITreasuryVault } from "./ITreasuryVault";
export type { LaunchCampaign } from "./LaunchCampaign";
export type { LaunchFactory } from "./LaunchFactory";
export type { LpTimelock } from "./LpTimelock";
export type { TreasuryRouter } from "./TreasuryRouter";
export type { TreasuryVault } from "./TreasuryVault";
</file>

<file path="typechain-types/contracts/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IPancakeRouter02 } from "./IPancakeRouter02";
</file>

<file path="typechain-types/contracts/interfaces/IPancakeRouter02.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface IPancakeRouter02Interface extends Interface {
  getFunction(
    nameOrSignature: "WETH" | "addLiquidityETH" | "factory"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "addLiquidityETH",
    values: [
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      AddressLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;

  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addLiquidityETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
}

export interface IPancakeRouter02 extends BaseContract {
  connect(runner?: ContractRunner | null): IPancakeRouter02;
  waitForDeployment(): Promise<this>;

  interface: IPancakeRouter02Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  WETH: TypedContractMethod<[], [string], "view">;

  addLiquidityETH: TypedContractMethod<
    [
      token: AddressLike,
      amountTokenDesired: BigNumberish,
      amountTokenMin: BigNumberish,
      amountETHMin: BigNumberish,
      to: AddressLike,
      deadline: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        amountToken: bigint;
        amountETH: bigint;
        liquidity: bigint;
      }
    ],
    "payable"
  >;

  factory: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "WETH"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "addLiquidityETH"
  ): TypedContractMethod<
    [
      token: AddressLike,
      amountTokenDesired: BigNumberish,
      amountTokenMin: BigNumberish,
      amountETHMin: BigNumberish,
      to: AddressLike,
      deadline: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        amountToken: bigint;
        amountETH: bigint;
        liquidity: bigint;
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "factory"
  ): TypedContractMethod<[], [string], "view">;

  filters: {};
}
</file>

<file path="typechain-types/contracts/ITreasuryVault.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../common";

export interface ITreasuryVaultInterface extends Interface {}

export interface ITreasuryVault extends BaseContract {
  connect(runner?: ContractRunner | null): ITreasuryVault;
  waitForDeployment(): Promise<this>;

  interface: ITreasuryVaultInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/contracts/LaunchCampaign.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace LaunchCampaign {
  export type InitParamsStruct = {
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    totalSupply: BigNumberish;
    curveBps: BigNumberish;
    liquidityTokenBps: BigNumberish;
    basePrice: BigNumberish;
    priceSlope: BigNumberish;
    graduationTarget: BigNumberish;
    liquidityBps: BigNumberish;
    protocolFeeBps: BigNumberish;
    leagueFeeBps: BigNumberish;
    leagueReceiver: AddressLike;
    router: AddressLike;
    lpReceiver: AddressLike;
    feeRecipient: AddressLike;
    creator: AddressLike;
    factory: AddressLike;
  };

  export type InitParamsStructOutput = [
    name: string,
    symbol: string,
    logoURI: string,
    xAccount: string,
    website: string,
    extraLink: string,
    totalSupply: bigint,
    curveBps: bigint,
    liquidityTokenBps: bigint,
    basePrice: bigint,
    priceSlope: bigint,
    graduationTarget: bigint,
    liquidityBps: bigint,
    protocolFeeBps: bigint,
    leagueFeeBps: bigint,
    leagueReceiver: string,
    router: string,
    lpReceiver: string,
    feeRecipient: string,
    creator: string,
    factory: string
  ] & {
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    totalSupply: bigint;
    curveBps: bigint;
    liquidityTokenBps: bigint;
    basePrice: bigint;
    priceSlope: bigint;
    graduationTarget: bigint;
    liquidityBps: bigint;
    protocolFeeBps: bigint;
    leagueFeeBps: bigint;
    leagueReceiver: string;
    router: string;
    lpReceiver: string;
    feeRecipient: string;
    creator: string;
    factory: string;
  };
}

export interface LaunchCampaignInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "basePrice"
      | "buyExactBnb"
      | "buyExactBnbFor"
      | "buyExactTokens"
      | "buyExactTokensFor"
      | "buyersCount"
      | "claimPendingNative"
      | "creatorReserve"
      | "currentPrice"
      | "curveSupply"
      | "extraLink"
      | "factory"
      | "feeRecipient"
      | "finalize"
      | "finalizedAt"
      | "graduationTarget"
      | "hasBought"
      | "initialize"
      | "launched"
      | "leagueFeeBps"
      | "leagueReceiver"
      | "liquidityBps"
      | "liquiditySupply"
      | "logoURI"
      | "lpReceiver"
      | "owner"
      | "pendingNative"
      | "priceSlope"
      | "protocolFeeBps"
      | "quoteBuyExactBnb"
      | "quoteBuyExactTokens"
      | "quoteSellExactTokens"
      | "renounceOwnership"
      | "router"
      | "sellExactTokens"
      | "sold"
      | "token"
      | "totalBuyVolumeWei"
      | "totalSellVolumeWei"
      | "totalSupply"
      | "transferOwnership"
      | "website"
      | "xAccount"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "CampaignFinalized"
      | "NativeClaimed"
      | "NativeEscrowed"
      | "OwnershipTransferred"
      | "TokensPurchased"
      | "TokensSold"
  ): EventFragment;

  encodeFunctionData(functionFragment: "basePrice", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "buyExactBnb",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyExactBnbFor",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyExactTokens",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyExactTokensFor",
    values: [AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "buyersCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimPendingNative",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creatorReserve",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "curveSupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "extraLink", values?: undefined): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "feeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "finalize",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizedAt",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "graduationTarget",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "hasBought",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [LaunchCampaign.InitParamsStruct]
  ): string;
  encodeFunctionData(functionFragment: "launched", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "leagueFeeBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "leagueReceiver",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquiditySupply",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "logoURI", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "lpReceiver",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingNative",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "priceSlope",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "protocolFeeBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "quoteBuyExactBnb",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "quoteBuyExactTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "quoteSellExactTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "router", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sellExactTokens",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "sold", values?: undefined): string;
  encodeFunctionData(functionFragment: "token", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalBuyVolumeWei",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalSellVolumeWei",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "website", values?: undefined): string;
  encodeFunctionData(functionFragment: "xAccount", values?: undefined): string;

  decodeFunctionResult(functionFragment: "basePrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "buyExactBnb",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyExactBnbFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyExactTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyExactTokensFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "buyersCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimPendingNative",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "creatorReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "curveSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "extraLink", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finalize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalizedAt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "graduationTarget",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasBought", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "launched", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "leagueFeeBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "leagueReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidityBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquiditySupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "logoURI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "lpReceiver", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingNative",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "priceSlope", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "quoteBuyExactBnb",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "quoteBuyExactTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "quoteSellExactTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "router", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellExactTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sold", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalBuyVolumeWei",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSellVolumeWei",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "website", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "xAccount", data: BytesLike): Result;
}

export namespace CampaignFinalizedEvent {
  export type InputTuple = [
    caller: AddressLike,
    liquidityTokens: BigNumberish,
    liquidityBnb: BigNumberish,
    protocolFee: BigNumberish,
    creatorPayout: BigNumberish
  ];
  export type OutputTuple = [
    caller: string,
    liquidityTokens: bigint,
    liquidityBnb: bigint,
    protocolFee: bigint,
    creatorPayout: bigint
  ];
  export interface OutputObject {
    caller: string;
    liquidityTokens: bigint;
    liquidityBnb: bigint;
    protocolFee: bigint;
    creatorPayout: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NativeClaimedEvent {
  export type InputTuple = [beneficiary: AddressLike, amount: BigNumberish];
  export type OutputTuple = [beneficiary: string, amount: bigint];
  export interface OutputObject {
    beneficiary: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NativeEscrowedEvent {
  export type InputTuple = [beneficiary: AddressLike, amount: BigNumberish];
  export type OutputTuple = [beneficiary: string, amount: bigint];
  export interface OutputObject {
    beneficiary: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokensPurchasedEvent {
  export type InputTuple = [
    buyer: AddressLike,
    amountOut: BigNumberish,
    cost: BigNumberish
  ];
  export type OutputTuple = [buyer: string, amountOut: bigint, cost: bigint];
  export interface OutputObject {
    buyer: string;
    amountOut: bigint;
    cost: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokensSoldEvent {
  export type InputTuple = [
    seller: AddressLike,
    amountIn: BigNumberish,
    payout: BigNumberish
  ];
  export type OutputTuple = [seller: string, amountIn: bigint, payout: bigint];
  export interface OutputObject {
    seller: string;
    amountIn: bigint;
    payout: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface LaunchCampaign extends BaseContract {
  connect(runner?: ContractRunner | null): LaunchCampaign;
  waitForDeployment(): Promise<this>;

  interface: LaunchCampaignInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  basePrice: TypedContractMethod<[], [bigint], "view">;

  buyExactBnb: TypedContractMethod<
    [minTokensOut: BigNumberish],
    [[bigint, bigint] & { tokensOut: bigint; totalSpent: bigint }],
    "payable"
  >;

  buyExactBnbFor: TypedContractMethod<
    [recipient: AddressLike, minTokensOut: BigNumberish],
    [[bigint, bigint] & { tokensOut: bigint; totalSpent: bigint }],
    "payable"
  >;

  buyExactTokens: TypedContractMethod<
    [amountOut: BigNumberish, maxCost: BigNumberish],
    [bigint],
    "payable"
  >;

  buyExactTokensFor: TypedContractMethod<
    [recipient: AddressLike, amountOut: BigNumberish, maxCost: BigNumberish],
    [bigint],
    "payable"
  >;

  buyersCount: TypedContractMethod<[], [bigint], "view">;

  claimPendingNative: TypedContractMethod<[], [bigint], "nonpayable">;

  creatorReserve: TypedContractMethod<[], [bigint], "view">;

  currentPrice: TypedContractMethod<[], [bigint], "view">;

  curveSupply: TypedContractMethod<[], [bigint], "view">;

  extraLink: TypedContractMethod<[], [string], "view">;

  factory: TypedContractMethod<[], [string], "view">;

  feeRecipient: TypedContractMethod<[], [string], "view">;

  finalize: TypedContractMethod<
    [minTokens: BigNumberish, minBnb: BigNumberish],
    [[bigint, bigint] & { usedTokens: bigint; usedBnb: bigint }],
    "nonpayable"
  >;

  finalizedAt: TypedContractMethod<[], [bigint], "view">;

  graduationTarget: TypedContractMethod<[], [bigint], "view">;

  hasBought: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  initialize: TypedContractMethod<
    [params: LaunchCampaign.InitParamsStruct],
    [void],
    "nonpayable"
  >;

  launched: TypedContractMethod<[], [boolean], "view">;

  leagueFeeBps: TypedContractMethod<[], [bigint], "view">;

  leagueReceiver: TypedContractMethod<[], [string], "view">;

  liquidityBps: TypedContractMethod<[], [bigint], "view">;

  liquiditySupply: TypedContractMethod<[], [bigint], "view">;

  logoURI: TypedContractMethod<[], [string], "view">;

  lpReceiver: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  pendingNative: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  priceSlope: TypedContractMethod<[], [bigint], "view">;

  protocolFeeBps: TypedContractMethod<[], [bigint], "view">;

  quoteBuyExactBnb: TypedContractMethod<
    [totalInWei: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        tokensOut: bigint;
        totalCostWei: bigint;
        feeWei: bigint;
      }
    ],
    "view"
  >;

  quoteBuyExactTokens: TypedContractMethod<
    [amountOut: BigNumberish],
    [bigint],
    "view"
  >;

  quoteSellExactTokens: TypedContractMethod<
    [amountIn: BigNumberish],
    [bigint],
    "view"
  >;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  router: TypedContractMethod<[], [string], "view">;

  sellExactTokens: TypedContractMethod<
    [amountIn: BigNumberish, minPayout: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  sold: TypedContractMethod<[], [bigint], "view">;

  token: TypedContractMethod<[], [string], "view">;

  totalBuyVolumeWei: TypedContractMethod<[], [bigint], "view">;

  totalSellVolumeWei: TypedContractMethod<[], [bigint], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  website: TypedContractMethod<[], [string], "view">;

  xAccount: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "basePrice"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "buyExactBnb"
  ): TypedContractMethod<
    [minTokensOut: BigNumberish],
    [[bigint, bigint] & { tokensOut: bigint; totalSpent: bigint }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyExactBnbFor"
  ): TypedContractMethod<
    [recipient: AddressLike, minTokensOut: BigNumberish],
    [[bigint, bigint] & { tokensOut: bigint; totalSpent: bigint }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyExactTokens"
  ): TypedContractMethod<
    [amountOut: BigNumberish, maxCost: BigNumberish],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyExactTokensFor"
  ): TypedContractMethod<
    [recipient: AddressLike, amountOut: BigNumberish, maxCost: BigNumberish],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "buyersCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "claimPendingNative"
  ): TypedContractMethod<[], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "creatorReserve"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "currentPrice"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "curveSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "extraLink"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "factory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "feeRecipient"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "finalize"
  ): TypedContractMethod<
    [minTokens: BigNumberish, minBnb: BigNumberish],
    [[bigint, bigint] & { usedTokens: bigint; usedBnb: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "finalizedAt"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "graduationTarget"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "hasBought"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "initialize"
  ): TypedContractMethod<
    [params: LaunchCampaign.InitParamsStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "launched"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "leagueFeeBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "leagueReceiver"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "liquidityBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "liquiditySupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "logoURI"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "lpReceiver"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "pendingNative"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "priceSlope"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "protocolFeeBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "quoteBuyExactBnb"
  ): TypedContractMethod<
    [totalInWei: BigNumberish],
    [
      [bigint, bigint, bigint] & {
        tokensOut: bigint;
        totalCostWei: bigint;
        feeWei: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "quoteBuyExactTokens"
  ): TypedContractMethod<[amountOut: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "quoteSellExactTokens"
  ): TypedContractMethod<[amountIn: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "router"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "sellExactTokens"
  ): TypedContractMethod<
    [amountIn: BigNumberish, minPayout: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "sold"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "token"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalBuyVolumeWei"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalSellVolumeWei"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "website"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "xAccount"
  ): TypedContractMethod<[], [string], "view">;

  getEvent(
    key: "CampaignFinalized"
  ): TypedContractEvent<
    CampaignFinalizedEvent.InputTuple,
    CampaignFinalizedEvent.OutputTuple,
    CampaignFinalizedEvent.OutputObject
  >;
  getEvent(
    key: "NativeClaimed"
  ): TypedContractEvent<
    NativeClaimedEvent.InputTuple,
    NativeClaimedEvent.OutputTuple,
    NativeClaimedEvent.OutputObject
  >;
  getEvent(
    key: "NativeEscrowed"
  ): TypedContractEvent<
    NativeEscrowedEvent.InputTuple,
    NativeEscrowedEvent.OutputTuple,
    NativeEscrowedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "TokensPurchased"
  ): TypedContractEvent<
    TokensPurchasedEvent.InputTuple,
    TokensPurchasedEvent.OutputTuple,
    TokensPurchasedEvent.OutputObject
  >;
  getEvent(
    key: "TokensSold"
  ): TypedContractEvent<
    TokensSoldEvent.InputTuple,
    TokensSoldEvent.OutputTuple,
    TokensSoldEvent.OutputObject
  >;

  filters: {
    "CampaignFinalized(address,uint256,uint256,uint256,uint256)": TypedContractEvent<
      CampaignFinalizedEvent.InputTuple,
      CampaignFinalizedEvent.OutputTuple,
      CampaignFinalizedEvent.OutputObject
    >;
    CampaignFinalized: TypedContractEvent<
      CampaignFinalizedEvent.InputTuple,
      CampaignFinalizedEvent.OutputTuple,
      CampaignFinalizedEvent.OutputObject
    >;

    "NativeClaimed(address,uint256)": TypedContractEvent<
      NativeClaimedEvent.InputTuple,
      NativeClaimedEvent.OutputTuple,
      NativeClaimedEvent.OutputObject
    >;
    NativeClaimed: TypedContractEvent<
      NativeClaimedEvent.InputTuple,
      NativeClaimedEvent.OutputTuple,
      NativeClaimedEvent.OutputObject
    >;

    "NativeEscrowed(address,uint256)": TypedContractEvent<
      NativeEscrowedEvent.InputTuple,
      NativeEscrowedEvent.OutputTuple,
      NativeEscrowedEvent.OutputObject
    >;
    NativeEscrowed: TypedContractEvent<
      NativeEscrowedEvent.InputTuple,
      NativeEscrowedEvent.OutputTuple,
      NativeEscrowedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "TokensPurchased(address,uint256,uint256)": TypedContractEvent<
      TokensPurchasedEvent.InputTuple,
      TokensPurchasedEvent.OutputTuple,
      TokensPurchasedEvent.OutputObject
    >;
    TokensPurchased: TypedContractEvent<
      TokensPurchasedEvent.InputTuple,
      TokensPurchasedEvent.OutputTuple,
      TokensPurchasedEvent.OutputObject
    >;

    "TokensSold(address,uint256,uint256)": TypedContractEvent<
      TokensSoldEvent.InputTuple,
      TokensSoldEvent.OutputTuple,
      TokensSoldEvent.OutputObject
    >;
    TokensSold: TypedContractEvent<
      TokensSoldEvent.InputTuple,
      TokensSoldEvent.OutputTuple,
      TokensSoldEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/LaunchFactory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace LaunchFactory {
  export type LaunchConfigStruct = {
    totalSupply: BigNumberish;
    curveBps: BigNumberish;
    liquidityTokenBps: BigNumberish;
    basePrice: BigNumberish;
    priceSlope: BigNumberish;
    graduationTarget: BigNumberish;
    liquidityBps: BigNumberish;
  };

  export type LaunchConfigStructOutput = [
    totalSupply: bigint,
    curveBps: bigint,
    liquidityTokenBps: bigint,
    basePrice: bigint,
    priceSlope: bigint,
    graduationTarget: bigint,
    liquidityBps: bigint
  ] & {
    totalSupply: bigint;
    curveBps: bigint;
    liquidityTokenBps: bigint;
    basePrice: bigint;
    priceSlope: bigint;
    graduationTarget: bigint;
    liquidityBps: bigint;
  };

  export type CampaignRequestStruct = {
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    basePrice: BigNumberish;
    priceSlope: BigNumberish;
    graduationTarget: BigNumberish;
    lpReceiver: AddressLike;
    initialBuyBnbWei: BigNumberish;
  };

  export type CampaignRequestStructOutput = [
    name: string,
    symbol: string,
    logoURI: string,
    xAccount: string,
    website: string,
    extraLink: string,
    basePrice: bigint,
    priceSlope: bigint,
    graduationTarget: bigint,
    lpReceiver: string,
    initialBuyBnbWei: bigint
  ] & {
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    basePrice: bigint;
    priceSlope: bigint;
    graduationTarget: bigint;
    lpReceiver: string;
    initialBuyBnbWei: bigint;
  };

  export type CampaignInfoStruct = {
    campaign: AddressLike;
    token: AddressLike;
    creator: AddressLike;
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    createdAt: BigNumberish;
  };

  export type CampaignInfoStructOutput = [
    campaign: string,
    token: string,
    creator: string,
    name: string,
    symbol: string,
    logoURI: string,
    xAccount: string,
    website: string,
    extraLink: string,
    createdAt: bigint
  ] & {
    campaign: string;
    token: string;
    creator: string;
    name: string;
    symbol: string;
    logoURI: string;
    xAccount: string;
    website: string;
    extraLink: string;
    createdAt: bigint;
  };
}

export interface LaunchFactoryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "LEAGUE_FEE_BPS"
      | "MAX_BASE_PRICE"
      | "MAX_GRADUATION_TARGET"
      | "MAX_PRICE_SLOPE"
      | "campaignImplementation"
      | "campaignsCount"
      | "config"
      | "createCampaign"
      | "feeRecipient"
      | "getCampaign"
      | "getCampaignPage"
      | "leagueReceiver"
      | "owner"
      | "protocolFeeBps"
      | "quoteInitialBuyTotal"
      | "renounceOwnership"
      | "router"
      | "setConfig"
      | "setFeeRecipient"
      | "setProtocolFee"
      | "setRouter"
      | "transferOwnership"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "CampaignCreated"
      | "ConfigUpdated"
      | "FeeRecipientUpdated"
      | "OwnershipTransferred"
      | "ProtocolFeeUpdated"
      | "RouterUpdated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "LEAGUE_FEE_BPS",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_BASE_PRICE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_GRADUATION_TARGET",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "MAX_PRICE_SLOPE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "campaignImplementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "campaignsCount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "config", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "createCampaign",
    values: [LaunchFactory.CampaignRequestStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "feeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCampaign",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCampaignPage",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "leagueReceiver",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "protocolFeeBps",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "quoteInitialBuyTotal",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "router", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setConfig",
    values: [LaunchFactory.LaunchConfigStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeRecipient",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setProtocolFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setRouter",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(
    functionFragment: "LEAGUE_FEE_BPS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_BASE_PRICE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_GRADUATION_TARGET",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "MAX_PRICE_SLOPE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "campaignImplementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "campaignsCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createCampaign",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCampaign",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCampaignPage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "leagueReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "protocolFeeBps",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "quoteInitialBuyTotal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "router", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setConfig", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFeeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setProtocolFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setRouter", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
}

export namespace CampaignCreatedEvent {
  export type InputTuple = [
    id: BigNumberish,
    campaign: AddressLike,
    token: AddressLike,
    creator: AddressLike,
    name: string,
    symbol: string
  ];
  export type OutputTuple = [
    id: bigint,
    campaign: string,
    token: string,
    creator: string,
    name: string,
    symbol: string
  ];
  export interface OutputObject {
    id: bigint;
    campaign: string;
    token: string;
    creator: string;
    name: string;
    symbol: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ConfigUpdatedEvent {
  export type InputTuple = [newConfig: LaunchFactory.LaunchConfigStruct];
  export type OutputTuple = [newConfig: LaunchFactory.LaunchConfigStructOutput];
  export interface OutputObject {
    newConfig: LaunchFactory.LaunchConfigStructOutput;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeeRecipientUpdatedEvent {
  export type InputTuple = [newRecipient: AddressLike];
  export type OutputTuple = [newRecipient: string];
  export interface OutputObject {
    newRecipient: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ProtocolFeeUpdatedEvent {
  export type InputTuple = [newFeeBps: BigNumberish];
  export type OutputTuple = [newFeeBps: bigint];
  export interface OutputObject {
    newFeeBps: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RouterUpdatedEvent {
  export type InputTuple = [newRouter: AddressLike];
  export type OutputTuple = [newRouter: string];
  export interface OutputObject {
    newRouter: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface LaunchFactory extends BaseContract {
  connect(runner?: ContractRunner | null): LaunchFactory;
  waitForDeployment(): Promise<this>;

  interface: LaunchFactoryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  LEAGUE_FEE_BPS: TypedContractMethod<[], [bigint], "view">;

  MAX_BASE_PRICE: TypedContractMethod<[], [bigint], "view">;

  MAX_GRADUATION_TARGET: TypedContractMethod<[], [bigint], "view">;

  MAX_PRICE_SLOPE: TypedContractMethod<[], [bigint], "view">;

  campaignImplementation: TypedContractMethod<[], [string], "view">;

  campaignsCount: TypedContractMethod<[], [bigint], "view">;

  config: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        totalSupply: bigint;
        curveBps: bigint;
        liquidityTokenBps: bigint;
        basePrice: bigint;
        priceSlope: bigint;
        graduationTarget: bigint;
        liquidityBps: bigint;
      }
    ],
    "view"
  >;

  createCampaign: TypedContractMethod<
    [req: LaunchFactory.CampaignRequestStruct],
    [[string, string] & { campaignAddr: string; tokenAddr: string }],
    "payable"
  >;

  feeRecipient: TypedContractMethod<[], [string], "view">;

  getCampaign: TypedContractMethod<
    [id: BigNumberish],
    [LaunchFactory.CampaignInfoStructOutput],
    "view"
  >;

  getCampaignPage: TypedContractMethod<
    [offset: BigNumberish, limit: BigNumberish],
    [LaunchFactory.CampaignInfoStructOutput[]],
    "view"
  >;

  leagueReceiver: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  protocolFeeBps: TypedContractMethod<[], [bigint], "view">;

  quoteInitialBuyTotal: TypedContractMethod<
    [
      initialBuyTokens: BigNumberish,
      basePriceOverride: BigNumberish,
      priceSlopeOverride: BigNumberish
    ],
    [bigint],
    "view"
  >;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  router: TypedContractMethod<[], [string], "view">;

  setConfig: TypedContractMethod<
    [newConfig: LaunchFactory.LaunchConfigStruct],
    [void],
    "nonpayable"
  >;

  setFeeRecipient: TypedContractMethod<
    [newRecipient: AddressLike],
    [void],
    "nonpayable"
  >;

  setProtocolFee: TypedContractMethod<
    [newProtocolFeeBps: BigNumberish],
    [void],
    "nonpayable"
  >;

  setRouter: TypedContractMethod<
    [newRouter: AddressLike],
    [void],
    "nonpayable"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "LEAGUE_FEE_BPS"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_BASE_PRICE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_GRADUATION_TARGET"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "MAX_PRICE_SLOPE"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "campaignImplementation"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "campaignsCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "config"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint] & {
        totalSupply: bigint;
        curveBps: bigint;
        liquidityTokenBps: bigint;
        basePrice: bigint;
        priceSlope: bigint;
        graduationTarget: bigint;
        liquidityBps: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "createCampaign"
  ): TypedContractMethod<
    [req: LaunchFactory.CampaignRequestStruct],
    [[string, string] & { campaignAddr: string; tokenAddr: string }],
    "payable"
  >;
  getFunction(
    nameOrSignature: "feeRecipient"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getCampaign"
  ): TypedContractMethod<
    [id: BigNumberish],
    [LaunchFactory.CampaignInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCampaignPage"
  ): TypedContractMethod<
    [offset: BigNumberish, limit: BigNumberish],
    [LaunchFactory.CampaignInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "leagueReceiver"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "protocolFeeBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "quoteInitialBuyTotal"
  ): TypedContractMethod<
    [
      initialBuyTokens: BigNumberish,
      basePriceOverride: BigNumberish,
      priceSlopeOverride: BigNumberish
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "router"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "setConfig"
  ): TypedContractMethod<
    [newConfig: LaunchFactory.LaunchConfigStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setFeeRecipient"
  ): TypedContractMethod<[newRecipient: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setProtocolFee"
  ): TypedContractMethod<
    [newProtocolFeeBps: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setRouter"
  ): TypedContractMethod<[newRouter: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "CampaignCreated"
  ): TypedContractEvent<
    CampaignCreatedEvent.InputTuple,
    CampaignCreatedEvent.OutputTuple,
    CampaignCreatedEvent.OutputObject
  >;
  getEvent(
    key: "ConfigUpdated"
  ): TypedContractEvent<
    ConfigUpdatedEvent.InputTuple,
    ConfigUpdatedEvent.OutputTuple,
    ConfigUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "FeeRecipientUpdated"
  ): TypedContractEvent<
    FeeRecipientUpdatedEvent.InputTuple,
    FeeRecipientUpdatedEvent.OutputTuple,
    FeeRecipientUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "ProtocolFeeUpdated"
  ): TypedContractEvent<
    ProtocolFeeUpdatedEvent.InputTuple,
    ProtocolFeeUpdatedEvent.OutputTuple,
    ProtocolFeeUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "RouterUpdated"
  ): TypedContractEvent<
    RouterUpdatedEvent.InputTuple,
    RouterUpdatedEvent.OutputTuple,
    RouterUpdatedEvent.OutputObject
  >;

  filters: {
    "CampaignCreated(uint256,address,address,address,string,string)": TypedContractEvent<
      CampaignCreatedEvent.InputTuple,
      CampaignCreatedEvent.OutputTuple,
      CampaignCreatedEvent.OutputObject
    >;
    CampaignCreated: TypedContractEvent<
      CampaignCreatedEvent.InputTuple,
      CampaignCreatedEvent.OutputTuple,
      CampaignCreatedEvent.OutputObject
    >;

    "ConfigUpdated(tuple)": TypedContractEvent<
      ConfigUpdatedEvent.InputTuple,
      ConfigUpdatedEvent.OutputTuple,
      ConfigUpdatedEvent.OutputObject
    >;
    ConfigUpdated: TypedContractEvent<
      ConfigUpdatedEvent.InputTuple,
      ConfigUpdatedEvent.OutputTuple,
      ConfigUpdatedEvent.OutputObject
    >;

    "FeeRecipientUpdated(address)": TypedContractEvent<
      FeeRecipientUpdatedEvent.InputTuple,
      FeeRecipientUpdatedEvent.OutputTuple,
      FeeRecipientUpdatedEvent.OutputObject
    >;
    FeeRecipientUpdated: TypedContractEvent<
      FeeRecipientUpdatedEvent.InputTuple,
      FeeRecipientUpdatedEvent.OutputTuple,
      FeeRecipientUpdatedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "ProtocolFeeUpdated(uint256)": TypedContractEvent<
      ProtocolFeeUpdatedEvent.InputTuple,
      ProtocolFeeUpdatedEvent.OutputTuple,
      ProtocolFeeUpdatedEvent.OutputObject
    >;
    ProtocolFeeUpdated: TypedContractEvent<
      ProtocolFeeUpdatedEvent.InputTuple,
      ProtocolFeeUpdatedEvent.OutputTuple,
      ProtocolFeeUpdatedEvent.OutputObject
    >;

    "RouterUpdated(address)": TypedContractEvent<
      RouterUpdatedEvent.InputTuple,
      RouterUpdatedEvent.OutputTuple,
      RouterUpdatedEvent.OutputObject
    >;
    RouterUpdated: TypedContractEvent<
      RouterUpdatedEvent.InputTuple,
      RouterUpdatedEvent.OutputTuple,
      RouterUpdatedEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/LpTimelock.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface LpTimelockInterface extends Interface {
  getFunction(
    nameOrSignature: "beneficiary" | "release" | "releaseTime" | "token"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "beneficiary",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "release", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "releaseTime",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "token", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "beneficiary",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "release", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "releaseTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "token", data: BytesLike): Result;
}

export interface LpTimelock extends BaseContract {
  connect(runner?: ContractRunner | null): LpTimelock;
  waitForDeployment(): Promise<this>;

  interface: LpTimelockInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  beneficiary: TypedContractMethod<[], [string], "view">;

  release: TypedContractMethod<[], [void], "nonpayable">;

  releaseTime: TypedContractMethod<[], [bigint], "view">;

  token: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "beneficiary"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "release"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "releaseTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "token"
  ): TypedContractMethod<[], [string], "view">;

  filters: {};
}
</file>

<file path="typechain-types/contracts/mocks/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { MockERC20 } from "./MockERC20";
export type { MockFeeOnTransferERC20 } from "./MockFeeOnTransferERC20";
export type { MockRouter } from "./MockRouter";
export type { RevertingReceiver } from "./RevertingReceiver";
</file>

<file path="typechain-types/contracts/mocks/MockERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface MockERC20Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "decimals"
      | "name"
      | "symbol"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MockERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): MockERC20;
  waitForDeployment(): Promise<this>;

  interface: MockERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  name: TypedContractMethod<[], [string], "view">;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/mocks/MockFeeOnTransferERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface MockFeeOnTransferERC20Interface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "decimals"
      | "feeBps"
      | "mint"
      | "name"
      | "symbol"
      | "totalSupply"
      | "transfer"
      | "transferFrom"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Approval" | "Transfer"): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(functionFragment: "feeBps", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "feeBps", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MockFeeOnTransferERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): MockFeeOnTransferERC20;
  waitForDeployment(): Promise<this>;

  interface: MockFeeOnTransferERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  feeBps: TypedContractMethod<[], [bigint], "view">;

  mint: TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  name: TypedContractMethod<[], [string], "view">;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "feeBps"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, amount: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/mocks/MockRouter.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface MockRouterInterface extends Interface {
  getFunction(
    nameOrSignature: "WETH" | "addLiquidityETH" | "factory"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "LiquidityAdded"): EventFragment;

  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "addLiquidityETH",
    values: [
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      AddressLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;

  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addLiquidityETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
}

export namespace LiquidityAddedEvent {
  export type InputTuple = [
    token: AddressLike,
    amountToken: BigNumberish,
    amountETH: BigNumberish,
    to: AddressLike
  ];
  export type OutputTuple = [
    token: string,
    amountToken: bigint,
    amountETH: bigint,
    to: string
  ];
  export interface OutputObject {
    token: string;
    amountToken: bigint;
    amountETH: bigint;
    to: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface MockRouter extends BaseContract {
  connect(runner?: ContractRunner | null): MockRouter;
  waitForDeployment(): Promise<this>;

  interface: MockRouterInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  WETH: TypedContractMethod<[], [string], "view">;

  addLiquidityETH: TypedContractMethod<
    [
      token: AddressLike,
      amountTokenDesired: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      to: AddressLike,
      arg5: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        amountToken: bigint;
        amountETH: bigint;
        liquidity: bigint;
      }
    ],
    "payable"
  >;

  factory: TypedContractMethod<[], [string], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "WETH"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "addLiquidityETH"
  ): TypedContractMethod<
    [
      token: AddressLike,
      amountTokenDesired: BigNumberish,
      arg2: BigNumberish,
      arg3: BigNumberish,
      to: AddressLike,
      arg5: BigNumberish
    ],
    [
      [bigint, bigint, bigint] & {
        amountToken: bigint;
        amountETH: bigint;
        liquidity: bigint;
      }
    ],
    "payable"
  >;
  getFunction(
    nameOrSignature: "factory"
  ): TypedContractMethod<[], [string], "view">;

  getEvent(
    key: "LiquidityAdded"
  ): TypedContractEvent<
    LiquidityAddedEvent.InputTuple,
    LiquidityAddedEvent.OutputTuple,
    LiquidityAddedEvent.OutputObject
  >;

  filters: {
    "LiquidityAdded(address,uint256,uint256,address)": TypedContractEvent<
      LiquidityAddedEvent.InputTuple,
      LiquidityAddedEvent.OutputTuple,
      LiquidityAddedEvent.OutputObject
    >;
    LiquidityAdded: TypedContractEvent<
      LiquidityAddedEvent.InputTuple,
      LiquidityAddedEvent.OutputTuple,
      LiquidityAddedEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/mocks/RevertingReceiver.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  FunctionFragment,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
} from "../../common";

export interface RevertingReceiverInterface extends Interface {}

export interface RevertingReceiver extends BaseContract {
  connect(runner?: ContractRunner | null): RevertingReceiver;
  waitForDeployment(): Promise<this>;

  interface: RevertingReceiverInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  filters: {};
}
</file>

<file path="typechain-types/contracts/test/FactoryCaller.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface FactoryCallerInterface extends Interface {
  getFunction(nameOrSignature: "buyFor"): FunctionFragment;

  encodeFunctionData(
    functionFragment: "buyFor",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "buyFor", data: BytesLike): Result;
}

export interface FactoryCaller extends BaseContract {
  connect(runner?: ContractRunner | null): FactoryCaller;
  waitForDeployment(): Promise<this>;

  interface: FactoryCallerInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  buyFor: TypedContractMethod<
    [
      campaign: AddressLike,
      recipient: AddressLike,
      amountOut: BigNumberish,
      maxCost: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "buyFor"
  ): TypedContractMethod<
    [
      campaign: AddressLike,
      recipient: AddressLike,
      amountOut: BigNumberish,
      maxCost: BigNumberish
    ],
    [bigint],
    "payable"
  >;

  filters: {};
}
</file>

<file path="typechain-types/contracts/test/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { FactoryCaller } from "./FactoryCaller";
</file>

<file path="typechain-types/contracts/token/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { LaunchToken } from "./LaunchToken";
</file>

<file path="typechain-types/contracts/token/LaunchToken.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface LaunchTokenInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "allowance"
      | "approve"
      | "balanceOf"
      | "burn"
      | "cap"
      | "decimals"
      | "enableTrading"
      | "mint"
      | "name"
      | "owner"
      | "renounceOwnership"
      | "symbol"
      | "totalSupply"
      | "tradingEnabled"
      | "transfer"
      | "transferFrom"
      | "transferOwnership"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic: "Approval" | "OwnershipTransferred" | "Transfer"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "allowance",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "approve",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "burn",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "cap", values?: undefined): string;
  encodeFunctionData(functionFragment: "decimals", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "enableTrading",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "name", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalSupply",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tradingEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "allowance", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cap", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "decimals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "enableTrading",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalSupply",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
}

export namespace ApprovalEvent {
  export type InputTuple = [
    owner: AddressLike,
    spender: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [owner: string, spender: string, value: bigint];
  export interface OutputObject {
    owner: string;
    spender: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TransferEvent {
  export type InputTuple = [
    from: AddressLike,
    to: AddressLike,
    value: BigNumberish
  ];
  export type OutputTuple = [from: string, to: string, value: bigint];
  export interface OutputObject {
    from: string;
    to: string;
    value: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface LaunchToken extends BaseContract {
  connect(runner?: ContractRunner | null): LaunchToken;
  waitForDeployment(): Promise<this>;

  interface: LaunchTokenInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allowance: TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;

  approve: TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  burn: TypedContractMethod<
    [from: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  cap: TypedContractMethod<[], [bigint], "view">;

  decimals: TypedContractMethod<[], [bigint], "view">;

  enableTrading: TypedContractMethod<[], [void], "nonpayable">;

  mint: TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  name: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;

  symbol: TypedContractMethod<[], [string], "view">;

  totalSupply: TypedContractMethod<[], [bigint], "view">;

  tradingEnabled: TypedContractMethod<[], [boolean], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allowance"
  ): TypedContractMethod<
    [owner: AddressLike, spender: AddressLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<
    [spender: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "burn"
  ): TypedContractMethod<
    [from: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "cap"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "decimals"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "enableTrading"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "renounceOwnership"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "symbol"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalSupply"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "tradingEnabled"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "Approval"
  ): TypedContractEvent<
    ApprovalEvent.InputTuple,
    ApprovalEvent.OutputTuple,
    ApprovalEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "Transfer"
  ): TypedContractEvent<
    TransferEvent.InputTuple,
    TransferEvent.OutputTuple,
    TransferEvent.OutputObject
  >;

  filters: {
    "Approval(address,address,uint256)": TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;
    Approval: TypedContractEvent<
      ApprovalEvent.InputTuple,
      ApprovalEvent.OutputTuple,
      ApprovalEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "Transfer(address,address,uint256)": TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
    Transfer: TypedContractEvent<
      TransferEvent.InputTuple,
      TransferEvent.OutputTuple,
      TransferEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/TreasuryRouter.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface TreasuryRouterInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "acceptVault"
      | "activeVault"
      | "admin"
      | "forward"
      | "forwardingPaused"
      | "pendingSince"
      | "pendingVault"
      | "proposeVault"
      | "setForwardingPaused"
      | "upgradeDelay"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ForwardFailed"
      | "Forwarded"
      | "ForwardingPaused"
      | "VaultActivated"
      | "VaultProposed"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "acceptVault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activeVault",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "admin", values?: undefined): string;
  encodeFunctionData(functionFragment: "forward", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "forwardingPaused",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingSince",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingVault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposeVault",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setForwardingPaused",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeDelay",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activeVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forwardingPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingSince",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setForwardingPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeDelay",
    data: BytesLike
  ): Result;
}

export namespace ForwardFailedEvent {
  export type InputTuple = [vault: AddressLike, amount: BigNumberish];
  export type OutputTuple = [vault: string, amount: bigint];
  export interface OutputObject {
    vault: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ForwardedEvent {
  export type InputTuple = [vault: AddressLike, amount: BigNumberish];
  export type OutputTuple = [vault: string, amount: bigint];
  export interface OutputObject {
    vault: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ForwardingPausedEvent {
  export type InputTuple = [paused: boolean];
  export type OutputTuple = [paused: boolean];
  export interface OutputObject {
    paused: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VaultActivatedEvent {
  export type InputTuple = [oldVault: AddressLike, newVault: AddressLike];
  export type OutputTuple = [oldVault: string, newVault: string];
  export interface OutputObject {
    oldVault: string;
    newVault: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VaultProposedEvent {
  export type InputTuple = [newVault: AddressLike, executeAfter: BigNumberish];
  export type OutputTuple = [newVault: string, executeAfter: bigint];
  export interface OutputObject {
    newVault: string;
    executeAfter: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface TreasuryRouter extends BaseContract {
  connect(runner?: ContractRunner | null): TreasuryRouter;
  waitForDeployment(): Promise<this>;

  interface: TreasuryRouterInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  acceptVault: TypedContractMethod<[], [void], "nonpayable">;

  activeVault: TypedContractMethod<[], [string], "view">;

  admin: TypedContractMethod<[], [string], "view">;

  forward: TypedContractMethod<[], [void], "nonpayable">;

  forwardingPaused: TypedContractMethod<[], [boolean], "view">;

  pendingSince: TypedContractMethod<[], [bigint], "view">;

  pendingVault: TypedContractMethod<[], [string], "view">;

  proposeVault: TypedContractMethod<
    [newVault: AddressLike],
    [void],
    "nonpayable"
  >;

  setForwardingPaused: TypedContractMethod<
    [paused: boolean],
    [void],
    "nonpayable"
  >;

  upgradeDelay: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "acceptVault"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "activeVault"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "admin"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "forward"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "forwardingPaused"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "pendingSince"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "pendingVault"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "proposeVault"
  ): TypedContractMethod<[newVault: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setForwardingPaused"
  ): TypedContractMethod<[paused: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "upgradeDelay"
  ): TypedContractMethod<[], [bigint], "view">;

  getEvent(
    key: "ForwardFailed"
  ): TypedContractEvent<
    ForwardFailedEvent.InputTuple,
    ForwardFailedEvent.OutputTuple,
    ForwardFailedEvent.OutputObject
  >;
  getEvent(
    key: "Forwarded"
  ): TypedContractEvent<
    ForwardedEvent.InputTuple,
    ForwardedEvent.OutputTuple,
    ForwardedEvent.OutputObject
  >;
  getEvent(
    key: "ForwardingPaused"
  ): TypedContractEvent<
    ForwardingPausedEvent.InputTuple,
    ForwardingPausedEvent.OutputTuple,
    ForwardingPausedEvent.OutputObject
  >;
  getEvent(
    key: "VaultActivated"
  ): TypedContractEvent<
    VaultActivatedEvent.InputTuple,
    VaultActivatedEvent.OutputTuple,
    VaultActivatedEvent.OutputObject
  >;
  getEvent(
    key: "VaultProposed"
  ): TypedContractEvent<
    VaultProposedEvent.InputTuple,
    VaultProposedEvent.OutputTuple,
    VaultProposedEvent.OutputObject
  >;

  filters: {
    "ForwardFailed(address,uint256)": TypedContractEvent<
      ForwardFailedEvent.InputTuple,
      ForwardFailedEvent.OutputTuple,
      ForwardFailedEvent.OutputObject
    >;
    ForwardFailed: TypedContractEvent<
      ForwardFailedEvent.InputTuple,
      ForwardFailedEvent.OutputTuple,
      ForwardFailedEvent.OutputObject
    >;

    "Forwarded(address,uint256)": TypedContractEvent<
      ForwardedEvent.InputTuple,
      ForwardedEvent.OutputTuple,
      ForwardedEvent.OutputObject
    >;
    Forwarded: TypedContractEvent<
      ForwardedEvent.InputTuple,
      ForwardedEvent.OutputTuple,
      ForwardedEvent.OutputObject
    >;

    "ForwardingPaused(bool)": TypedContractEvent<
      ForwardingPausedEvent.InputTuple,
      ForwardingPausedEvent.OutputTuple,
      ForwardingPausedEvent.OutputObject
    >;
    ForwardingPaused: TypedContractEvent<
      ForwardingPausedEvent.InputTuple,
      ForwardingPausedEvent.OutputTuple,
      ForwardingPausedEvent.OutputObject
    >;

    "VaultActivated(address,address)": TypedContractEvent<
      VaultActivatedEvent.InputTuple,
      VaultActivatedEvent.OutputTuple,
      VaultActivatedEvent.OutputObject
    >;
    VaultActivated: TypedContractEvent<
      VaultActivatedEvent.InputTuple,
      VaultActivatedEvent.OutputTuple,
      VaultActivatedEvent.OutputObject
    >;

    "VaultProposed(address,uint64)": TypedContractEvent<
      VaultProposedEvent.InputTuple,
      VaultProposedEvent.OutputTuple,
      VaultProposedEvent.OutputObject
    >;
    VaultProposed: TypedContractEvent<
      VaultProposedEvent.InputTuple,
      VaultProposedEvent.OutputTuple,
      VaultProposedEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/TreasuryVault.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface TreasuryVaultInterface extends Interface {
  getFunction(nameOrSignature: "multisig" | "withdraw"): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;

  encodeFunctionData(functionFragment: "multisig", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "multisig", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
}

export namespace WithdrawEvent {
  export type InputTuple = [to: AddressLike, amount: BigNumberish];
  export type OutputTuple = [to: string, amount: bigint];
  export interface OutputObject {
    to: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface TreasuryVault extends BaseContract {
  connect(runner?: ContractRunner | null): TreasuryVault;
  waitForDeployment(): Promise<this>;

  interface: TreasuryVaultInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  multisig: TypedContractMethod<[], [string], "view">;

  withdraw: TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "multisig"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "withdraw"
  ): TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "Withdraw"
  ): TypedContractEvent<
    WithdrawEvent.InputTuple,
    WithdrawEvent.OutputTuple,
    WithdrawEvent.OutputObject
  >;

  filters: {
    "Withdraw(address,uint256)": TypedContractEvent<
      WithdrawEvent.InputTuple,
      WithdrawEvent.OutputTuple,
      WithdrawEvent.OutputObject
    >;
    Withdraw: TypedContractEvent<
      WithdrawEvent.InputTuple,
      WithdrawEvent.OutputTuple,
      WithdrawEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/UPVoteTreasury.sol/IERC20.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface IERC20Interface extends Interface {
  getFunction(
    nameOrSignature: "balanceOf" | "transfer" | "transferFrom"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferFrom",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferFrom",
    data: BytesLike
  ): Result;
}

export interface IERC20 extends BaseContract {
  connect(runner?: ContractRunner | null): IERC20;
  waitForDeployment(): Promise<this>;

  interface: IERC20Interface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  balanceOf: TypedContractMethod<[account: AddressLike], [bigint], "view">;

  transfer: TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  transferFrom: TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[account: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "transfer"
  ): TypedContractMethod<
    [to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "transferFrom"
  ): TypedContractMethod<
    [from: AddressLike, to: AddressLike, value: BigNumberish],
    [boolean],
    "nonpayable"
  >;

  filters: {};
}
</file>

<file path="typechain-types/contracts/UPVoteTreasury.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IERC20 } from "./IERC20";
export type { Ownable } from "./Ownable";
export type { UPVoteTreasury } from "./UPVoteTreasury";
</file>

<file path="typechain-types/contracts/UPVoteTreasury.sol/Ownable.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface OwnableInterface extends Interface {
  getFunction(nameOrSignature: "owner" | "transferOwnership"): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;

  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Ownable extends BaseContract {
  connect(runner?: ContractRunner | null): Ownable;
  waitForDeployment(): Promise<this>;

  interface: OwnableInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  owner: TypedContractMethod<[], [string], "view">;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;

  filters: {
    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/contracts/UPVoteTreasury.sol/UPVoteTreasury.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface UPVoteTreasuryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "NATIVE"
      | "assetConfig"
      | "campaignAllowed"
      | "campaignAllowlistEnabled"
      | "feeReceiver"
      | "owner"
      | "rescueBNB"
      | "rescueToken"
      | "setAsset"
      | "setCampaignAllowed"
      | "setCampaignAllowlistEnabled"
      | "setFeeReceiver"
      | "transferOwnership"
      | "voteWithBNB"
      | "voteWithToken"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AssetConfigured"
      | "CampaignAllowed"
      | "CampaignAllowlistToggled"
      | "FeeReceiverUpdated"
      | "OwnershipTransferred"
      | "Rescue"
      | "VoteCast"
  ): EventFragment;

  encodeFunctionData(functionFragment: "NATIVE", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "assetConfig",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "campaignAllowed",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "campaignAllowlistEnabled",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "feeReceiver",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rescueBNB",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rescueToken",
    values: [AddressLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAsset",
    values: [AddressLike, boolean, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setCampaignAllowed",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setCampaignAllowlistEnabled",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeReceiver",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "voteWithBNB",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "voteWithToken",
    values: [AddressLike, AddressLike, BigNumberish, BytesLike]
  ): string;

  decodeFunctionResult(functionFragment: "NATIVE", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "assetConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "campaignAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "campaignAllowlistEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "rescueBNB", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rescueToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setAsset", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCampaignAllowed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setCampaignAllowlistEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeReceiver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "voteWithBNB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "voteWithToken",
    data: BytesLike
  ): Result;
}

export namespace AssetConfiguredEvent {
  export type InputTuple = [
    asset: AddressLike,
    enabled: boolean,
    minAmount: BigNumberish
  ];
  export type OutputTuple = [
    asset: string,
    enabled: boolean,
    minAmount: bigint
  ];
  export interface OutputObject {
    asset: string;
    enabled: boolean;
    minAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CampaignAllowedEvent {
  export type InputTuple = [campaign: AddressLike, allowed: boolean];
  export type OutputTuple = [campaign: string, allowed: boolean];
  export interface OutputObject {
    campaign: string;
    allowed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace CampaignAllowlistToggledEvent {
  export type InputTuple = [enabled: boolean];
  export type OutputTuple = [enabled: boolean];
  export interface OutputObject {
    enabled: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace FeeReceiverUpdatedEvent {
  export type InputTuple = [
    previousReceiver: AddressLike,
    newReceiver: AddressLike
  ];
  export type OutputTuple = [previousReceiver: string, newReceiver: string];
  export interface OutputObject {
    previousReceiver: string;
    newReceiver: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RescueEvent {
  export type InputTuple = [
    asset: AddressLike,
    to: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [asset: string, to: string, amount: bigint];
  export interface OutputObject {
    asset: string;
    to: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace VoteCastEvent {
  export type InputTuple = [
    campaign: AddressLike,
    voter: AddressLike,
    asset: AddressLike,
    amountPaid: BigNumberish,
    meta: BytesLike
  ];
  export type OutputTuple = [
    campaign: string,
    voter: string,
    asset: string,
    amountPaid: bigint,
    meta: string
  ];
  export interface OutputObject {
    campaign: string;
    voter: string;
    asset: string;
    amountPaid: bigint;
    meta: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface UPVoteTreasury extends BaseContract {
  connect(runner?: ContractRunner | null): UPVoteTreasury;
  waitForDeployment(): Promise<this>;

  interface: UPVoteTreasuryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  NATIVE: TypedContractMethod<[], [string], "view">;

  assetConfig: TypedContractMethod<
    [arg0: AddressLike],
    [[boolean, bigint] & { enabled: boolean; minAmount: bigint }],
    "view"
  >;

  campaignAllowed: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  campaignAllowlistEnabled: TypedContractMethod<[], [boolean], "view">;

  feeReceiver: TypedContractMethod<[], [string], "view">;

  owner: TypedContractMethod<[], [string], "view">;

  rescueBNB: TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  rescueToken: TypedContractMethod<
    [token: AddressLike, to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;

  setAsset: TypedContractMethod<
    [asset: AddressLike, enabled: boolean, minAmount: BigNumberish],
    [void],
    "nonpayable"
  >;

  setCampaignAllowed: TypedContractMethod<
    [campaign: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;

  setCampaignAllowlistEnabled: TypedContractMethod<
    [enabled: boolean],
    [void],
    "nonpayable"
  >;

  setFeeReceiver: TypedContractMethod<
    [newFeeReceiver: AddressLike],
    [void],
    "nonpayable"
  >;

  transferOwnership: TypedContractMethod<
    [newOwner: AddressLike],
    [void],
    "nonpayable"
  >;

  voteWithBNB: TypedContractMethod<
    [campaign: AddressLike, meta: BytesLike],
    [void],
    "payable"
  >;

  voteWithToken: TypedContractMethod<
    [
      campaign: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      meta: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "NATIVE"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "assetConfig"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[boolean, bigint] & { enabled: boolean; minAmount: bigint }],
    "view"
  >;
  getFunction(
    nameOrSignature: "campaignAllowed"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "campaignAllowlistEnabled"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "feeReceiver"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "rescueBNB"
  ): TypedContractMethod<
    [to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "rescueToken"
  ): TypedContractMethod<
    [token: AddressLike, to: AddressLike, amount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setAsset"
  ): TypedContractMethod<
    [asset: AddressLike, enabled: boolean, minAmount: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setCampaignAllowed"
  ): TypedContractMethod<
    [campaign: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setCampaignAllowlistEnabled"
  ): TypedContractMethod<[enabled: boolean], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setFeeReceiver"
  ): TypedContractMethod<[newFeeReceiver: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferOwnership"
  ): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "voteWithBNB"
  ): TypedContractMethod<
    [campaign: AddressLike, meta: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "voteWithToken"
  ): TypedContractMethod<
    [
      campaign: AddressLike,
      token: AddressLike,
      amount: BigNumberish,
      meta: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "AssetConfigured"
  ): TypedContractEvent<
    AssetConfiguredEvent.InputTuple,
    AssetConfiguredEvent.OutputTuple,
    AssetConfiguredEvent.OutputObject
  >;
  getEvent(
    key: "CampaignAllowed"
  ): TypedContractEvent<
    CampaignAllowedEvent.InputTuple,
    CampaignAllowedEvent.OutputTuple,
    CampaignAllowedEvent.OutputObject
  >;
  getEvent(
    key: "CampaignAllowlistToggled"
  ): TypedContractEvent<
    CampaignAllowlistToggledEvent.InputTuple,
    CampaignAllowlistToggledEvent.OutputTuple,
    CampaignAllowlistToggledEvent.OutputObject
  >;
  getEvent(
    key: "FeeReceiverUpdated"
  ): TypedContractEvent<
    FeeReceiverUpdatedEvent.InputTuple,
    FeeReceiverUpdatedEvent.OutputTuple,
    FeeReceiverUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "OwnershipTransferred"
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "Rescue"
  ): TypedContractEvent<
    RescueEvent.InputTuple,
    RescueEvent.OutputTuple,
    RescueEvent.OutputObject
  >;
  getEvent(
    key: "VoteCast"
  ): TypedContractEvent<
    VoteCastEvent.InputTuple,
    VoteCastEvent.OutputTuple,
    VoteCastEvent.OutputObject
  >;

  filters: {
    "AssetConfigured(address,bool,uint256)": TypedContractEvent<
      AssetConfiguredEvent.InputTuple,
      AssetConfiguredEvent.OutputTuple,
      AssetConfiguredEvent.OutputObject
    >;
    AssetConfigured: TypedContractEvent<
      AssetConfiguredEvent.InputTuple,
      AssetConfiguredEvent.OutputTuple,
      AssetConfiguredEvent.OutputObject
    >;

    "CampaignAllowed(address,bool)": TypedContractEvent<
      CampaignAllowedEvent.InputTuple,
      CampaignAllowedEvent.OutputTuple,
      CampaignAllowedEvent.OutputObject
    >;
    CampaignAllowed: TypedContractEvent<
      CampaignAllowedEvent.InputTuple,
      CampaignAllowedEvent.OutputTuple,
      CampaignAllowedEvent.OutputObject
    >;

    "CampaignAllowlistToggled(bool)": TypedContractEvent<
      CampaignAllowlistToggledEvent.InputTuple,
      CampaignAllowlistToggledEvent.OutputTuple,
      CampaignAllowlistToggledEvent.OutputObject
    >;
    CampaignAllowlistToggled: TypedContractEvent<
      CampaignAllowlistToggledEvent.InputTuple,
      CampaignAllowlistToggledEvent.OutputTuple,
      CampaignAllowlistToggledEvent.OutputObject
    >;

    "FeeReceiverUpdated(address,address)": TypedContractEvent<
      FeeReceiverUpdatedEvent.InputTuple,
      FeeReceiverUpdatedEvent.OutputTuple,
      FeeReceiverUpdatedEvent.OutputObject
    >;
    FeeReceiverUpdated: TypedContractEvent<
      FeeReceiverUpdatedEvent.InputTuple,
      FeeReceiverUpdatedEvent.OutputTuple,
      FeeReceiverUpdatedEvent.OutputObject
    >;

    "OwnershipTransferred(address,address)": TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    "Rescue(address,address,uint256)": TypedContractEvent<
      RescueEvent.InputTuple,
      RescueEvent.OutputTuple,
      RescueEvent.OutputObject
    >;
    Rescue: TypedContractEvent<
      RescueEvent.InputTuple,
      RescueEvent.OutputTuple,
      RescueEvent.OutputObject
    >;

    "VoteCast(address,address,address,uint256,bytes32)": TypedContractEvent<
      VoteCastEvent.InputTuple,
      VoteCastEvent.OutputTuple,
      VoteCastEvent.OutputObject
    >;
    VoteCast: TypedContractEvent<
      VoteCastEvent.InputTuple,
      VoteCastEvent.OutputTuple,
      VoteCastEvent.OutputObject
    >;
  };
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/access/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { Ownable__factory } from "./Ownable__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/access/Ownable__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  Ownable,
  OwnableInterface,
} from "../../../../@openzeppelin/contracts/access/Ownable";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "OwnableInvalidOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class Ownable__factory {
  static readonly abi = _abi;
  static createInterface(): OwnableInterface {
    return new Interface(_abi) as OwnableInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): Ownable {
    return new Contract(address, _abi, runner) as unknown as Ownable;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as access from "./access";
export * as interfaces from "./interfaces";
export * as proxy from "./proxy";
export * as token from "./token";
export * as utils from "./utils";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC1155Errors,
  IERC1155ErrorsInterface,
} from "../../../../../@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "ERC1155InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC1155InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "idsLength",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "valuesLength",
        type: "uint256",
      },
    ],
    name: "ERC1155InvalidArrayLength",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address",
      },
    ],
    name: "ERC1155InvalidOperator",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC1155InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC1155InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "ERC1155MissingApprovalForAll",
    type: "error",
  },
] as const;

export class IERC1155Errors__factory {
  static readonly abi = _abi;
  static createInterface(): IERC1155ErrorsInterface {
    return new Interface(_abi) as IERC1155ErrorsInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): IERC1155Errors {
    return new Contract(address, _abi, runner) as unknown as IERC1155Errors;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC20Errors,
  IERC20ErrorsInterface,
} from "../../../../../@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientAllowance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC20InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC20InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSpender",
    type: "error",
  },
] as const;

export class IERC20Errors__factory {
  static readonly abi = _abi;
  static createInterface(): IERC20ErrorsInterface {
    return new Interface(_abi) as IERC20ErrorsInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): IERC20Errors {
    return new Contract(address, _abi, runner) as unknown as IERC20Errors;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC721Errors,
  IERC721ErrorsInterface,
} from "../../../../../@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "ERC721IncorrectOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "ERC721InsufficientApproval",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC721InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address",
      },
    ],
    name: "ERC721InvalidOperator",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "ERC721InvalidOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC721InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC721InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "ERC721NonexistentToken",
    type: "error",
  },
] as const;

export class IERC721Errors__factory {
  static readonly abi = _abi;
  static createInterface(): IERC721ErrorsInterface {
    return new Interface(_abi) as IERC721ErrorsInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): IERC721Errors {
    return new Contract(address, _abi, runner) as unknown as IERC721Errors;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IERC1155Errors__factory } from "./IERC1155Errors__factory";
export { IERC20Errors__factory } from "./IERC20Errors__factory";
export { IERC721Errors__factory } from "./IERC721Errors__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/IERC1363__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC1363,
  IERC1363Interface,
} from "../../../../@openzeppelin/contracts/interfaces/IERC1363";

const _abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approveAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes",
      },
    ],
    name: "approveAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4",
      },
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes",
      },
    ],
    name: "transferAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes",
      },
    ],
    name: "transferFromAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFromAndCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class IERC1363__factory {
  static readonly abi = _abi;
  static createInterface(): IERC1363Interface {
    return new Interface(_abi) as IERC1363Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): IERC1363 {
    return new Contract(address, _abi, runner) as unknown as IERC1363;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as draftIerc6093Sol from "./draft-IERC6093.sol";
export { IERC1363__factory } from "./IERC1363__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/proxy/Clones__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../../common";
import type {
  Clones,
  ClonesInterface,
} from "../../../../@openzeppelin/contracts/proxy/Clones";

const _abi = [
  {
    inputs: [],
    name: "CloneArgumentsTooLong",
    type: "error",
  },
] as const;

const _bytecode =
  "0x6080806040523460175760119081601d823930815050f35b600080fdfe600080fdfea164736f6c6343000818000a";

type ClonesConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: ClonesConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class Clones__factory extends ContractFactory {
  constructor(...args: ClonesConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      Clones & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): Clones__factory {
    return super.connect(runner) as Clones__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): ClonesInterface {
    return new Interface(_abi) as ClonesInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): Clones {
    return new Contract(address, _abi, runner) as unknown as Clones;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/proxy/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { Clones__factory } from "./Clones__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/ERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  ERC20,
  ERC20Interface,
} from "../../../../../@openzeppelin/contracts/token/ERC20/ERC20";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientAllowance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC20InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC20InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSpender",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class ERC20__factory {
  static readonly abi = _abi;
  static createInterface(): ERC20Interface {
    return new Interface(_abi) as ERC20Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): ERC20 {
    return new Contract(address, _abi, runner) as unknown as ERC20;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC20Metadata,
  IERC20MetadataInterface,
} from "../../../../../../@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata";

const _abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class IERC20Metadata__factory {
  static readonly abi = _abi;
  static createInterface(): IERC20MetadataInterface {
    return new Interface(_abi) as IERC20MetadataInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): IERC20Metadata {
    return new Contract(address, _abi, runner) as unknown as IERC20Metadata;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/extensions/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IERC20Metadata__factory } from "./IERC20Metadata__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/IERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC20,
  IERC20Interface,
} from "../../../../../@openzeppelin/contracts/token/ERC20/IERC20";

const _abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class IERC20__factory {
  static readonly abi = _abi;
  static createInterface(): IERC20Interface {
    return new Interface(_abi) as IERC20Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): IERC20 {
    return new Contract(address, _abi, runner) as unknown as IERC20;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as extensions from "./extensions";
export * as utils from "./utils";
export { ERC20__factory } from "./ERC20__factory";
export { IERC20__factory } from "./IERC20__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/utils/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { SafeERC20__factory } from "./SafeERC20__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/ERC20/utils/SafeERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../../../../common";
import type {
  SafeERC20,
  SafeERC20Interface,
} from "../../../../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "currentAllowance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "requestedDecrease",
        type: "uint256",
      },
    ],
    name: "SafeERC20FailedDecreaseAllowance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "SafeERC20FailedOperation",
    type: "error",
  },
] as const;

const _bytecode =
  "0x6080806040523460175760119081601d823930815050f35b600080fdfe600080fdfea164736f6c6343000818000a";

type SafeERC20ConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: SafeERC20ConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class SafeERC20__factory extends ContractFactory {
  constructor(...args: SafeERC20ConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      SafeERC20 & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): SafeERC20__factory {
    return super.connect(runner) as SafeERC20__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): SafeERC20Interface {
    return new Interface(_abi) as SafeERC20Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): SafeERC20 {
    return new Contract(address, _abi, runner) as unknown as SafeERC20;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/token/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as erc20 from "./ERC20";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/Create2__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../../common";
import type {
  Create2,
  Create2Interface,
} from "../../../../@openzeppelin/contracts/utils/Create2";

const _abi = [
  {
    inputs: [],
    name: "Create2EmptyBytecode",
    type: "error",
  },
] as const;

const _bytecode =
  "0x6080806040523460175760119081601d823930815050f35b600080fdfe600080fdfea164736f6c6343000818000a";

type Create2ConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: Create2ConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class Create2__factory extends ContractFactory {
  constructor(...args: Create2ConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      Create2 & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): Create2__factory {
    return super.connect(runner) as Create2__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): Create2Interface {
    return new Interface(_abi) as Create2Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): Create2 {
    return new Contract(address, _abi, runner) as unknown as Create2;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/Errors__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../../common";
import type {
  Errors,
  ErrorsInterface,
} from "../../../../@openzeppelin/contracts/utils/Errors";

const _abi = [
  {
    inputs: [],
    name: "FailedCall",
    type: "error",
  },
  {
    inputs: [],
    name: "FailedDeployment",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "MissingPrecompile",
    type: "error",
  },
] as const;

const _bytecode =
  "0x6080806040523460175760119081601d823930815050f35b600080fdfe600080fdfea164736f6c6343000818000a";

type ErrorsConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: ErrorsConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class Errors__factory extends ContractFactory {
  constructor(...args: ErrorsConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      Errors & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): Errors__factory {
    return super.connect(runner) as Errors__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): ErrorsInterface {
    return new Interface(_abi) as ErrorsInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): Errors {
    return new Contract(address, _abi, runner) as unknown as Errors;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as introspection from "./introspection";
export * as math from "./math";
export { Create2__factory } from "./Create2__factory";
export { Errors__factory } from "./Errors__factory";
export { ReentrancyGuard__factory } from "./ReentrancyGuard__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/introspection/IERC165__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC165,
  IERC165Interface,
} from "../../../../../@openzeppelin/contracts/utils/introspection/IERC165";

const _abi = [
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4",
      },
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const;

export class IERC165__factory {
  static readonly abi = _abi;
  static createInterface(): IERC165Interface {
    return new Interface(_abi) as IERC165Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): IERC165 {
    return new Contract(address, _abi, runner) as unknown as IERC165;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/introspection/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IERC165__factory } from "./IERC165__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/math/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { SafeCast__factory } from "./SafeCast__factory";
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/math/SafeCast__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../../../common";
import type {
  SafeCast,
  SafeCastInterface,
} from "../../../../../@openzeppelin/contracts/utils/math/SafeCast";

const _abi = [
  {
    inputs: [
      {
        internalType: "uint8",
        name: "bits",
        type: "uint8",
      },
      {
        internalType: "int256",
        name: "value",
        type: "int256",
      },
    ],
    name: "SafeCastOverflowedIntDowncast",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "int256",
        name: "value",
        type: "int256",
      },
    ],
    name: "SafeCastOverflowedIntToUint",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint8",
        name: "bits",
        type: "uint8",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "SafeCastOverflowedUintDowncast",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "SafeCastOverflowedUintToInt",
    type: "error",
  },
] as const;

const _bytecode =
  "0x6080806040523460175760119081601d823930815050f35b600080fdfe600080fdfea164736f6c6343000818000a";

type SafeCastConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: SafeCastConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class SafeCast__factory extends ContractFactory {
  constructor(...args: SafeCastConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      SafeCast & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): SafeCast__factory {
    return super.connect(runner) as SafeCast__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): SafeCastInterface {
    return new Interface(_abi) as SafeCastInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): SafeCast {
    return new Contract(address, _abi, runner) as unknown as SafeCast;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/contracts/utils/ReentrancyGuard__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  ReentrancyGuard,
  ReentrancyGuardInterface,
} from "../../../../@openzeppelin/contracts/utils/ReentrancyGuard";

const _abi = [
  {
    inputs: [],
    name: "ReentrancyGuardReentrantCall",
    type: "error",
  },
] as const;

export class ReentrancyGuard__factory {
  static readonly abi = _abi;
  static createInterface(): ReentrancyGuardInterface {
    return new Interface(_abi) as ReentrancyGuardInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): ReentrancyGuard {
    return new Contract(address, _abi, runner) as unknown as ReentrancyGuard;
  }
}
</file>

<file path="typechain-types/factories/@openzeppelin/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as contracts from "./contracts";
</file>

<file path="typechain-types/factories/contracts/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as upVoteTreasurySol from "./UPVoteTreasury.sol";
export * as interfaces from "./interfaces";
export * as mocks from "./mocks";
export * as test from "./test";
export * as token from "./token";
export { ITreasuryVault__factory } from "./ITreasuryVault__factory";
export { LaunchCampaign__factory } from "./LaunchCampaign__factory";
export { LaunchFactory__factory } from "./LaunchFactory__factory";
export { LpTimelock__factory } from "./LpTimelock__factory";
export { TreasuryRouter__factory } from "./TreasuryRouter__factory";
export { TreasuryVault__factory } from "./TreasuryVault__factory";
</file>

<file path="typechain-types/factories/contracts/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IPancakeRouter02__factory } from "./IPancakeRouter02__factory";
</file>

<file path="typechain-types/factories/contracts/interfaces/IPancakeRouter02__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IPancakeRouter02,
  IPancakeRouter02Interface,
} from "../../../contracts/interfaces/IPancakeRouter02";

const _abi = [
  {
    inputs: [],
    name: "WETH",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amountTokenDesired",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amountTokenMin",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amountETHMin",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256",
      },
    ],
    name: "addLiquidityETH",
    outputs: [
      {
        internalType: "uint256",
        name: "amountToken",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amountETH",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "liquidity",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const;

export class IPancakeRouter02__factory {
  static readonly abi = _abi;
  static createInterface(): IPancakeRouter02Interface {
    return new Interface(_abi) as IPancakeRouter02Interface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): IPancakeRouter02 {
    return new Contract(address, _abi, runner) as unknown as IPancakeRouter02;
  }
}
</file>

<file path="typechain-types/factories/contracts/ITreasuryVault__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  ITreasuryVault,
  ITreasuryVaultInterface,
} from "../../contracts/ITreasuryVault";

const _abi = [
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

export class ITreasuryVault__factory {
  static readonly abi = _abi;
  static createInterface(): ITreasuryVaultInterface {
    return new Interface(_abi) as ITreasuryVaultInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): ITreasuryVault {
    return new Contract(address, _abi, runner) as unknown as ITreasuryVault;
  }
}
</file>

<file path="typechain-types/factories/contracts/LaunchCampaign__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../common";
import type {
  LaunchCampaign,
  LaunchCampaignInterface,
} from "../../contracts/LaunchCampaign";

const _abi = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "OwnableInvalidOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error",
  },
  {
    inputs: [],
    name: "ReentrancyGuardReentrantCall",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
    ],
    name: "SafeERC20FailedOperation",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "caller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityTokens",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "liquidityBnb",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "protocolFee",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "creatorPayout",
        type: "uint256",
      },
    ],
    name: "CampaignFinalized",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beneficiary",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NativeClaimed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beneficiary",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NativeEscrowed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "buyer",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountOut",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "cost",
        type: "uint256",
      },
    ],
    name: "TokensPurchased",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountIn",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    name: "TokensSold",
    type: "event",
  },
  {
    inputs: [],
    name: "basePrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minTokensOut",
        type: "uint256",
      },
    ],
    name: "buyExactBnb",
    outputs: [
      {
        internalType: "uint256",
        name: "tokensOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "totalSpent",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "minTokensOut",
        type: "uint256",
      },
    ],
    name: "buyExactBnbFor",
    outputs: [
      {
        internalType: "uint256",
        name: "tokensOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "totalSpent",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256",
      },
    ],
    name: "buyExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "cost",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "recipient",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256",
      },
    ],
    name: "buyExactTokensFor",
    outputs: [
      {
        internalType: "uint256",
        name: "total",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    name: "buyersCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "claimPendingNative",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "creatorReserve",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "currentPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "curveSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "extraLink",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "minTokens",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "minBnb",
        type: "uint256",
      },
    ],
    name: "finalize",
    outputs: [
      {
        internalType: "uint256",
        name: "usedTokens",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "usedBnb",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "finalizedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "graduationTarget",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "hasBought",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string",
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string",
          },
          {
            internalType: "string",
            name: "logoURI",
            type: "string",
          },
          {
            internalType: "string",
            name: "xAccount",
            type: "string",
          },
          {
            internalType: "string",
            name: "website",
            type: "string",
          },
          {
            internalType: "string",
            name: "extraLink",
            type: "string",
          },
          {
            internalType: "uint256",
            name: "totalSupply",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "curveBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityTokenBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "basePrice",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "priceSlope",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "graduationTarget",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "protocolFeeBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "leagueFeeBps",
            type: "uint256",
          },
          {
            internalType: "address",
            name: "leagueReceiver",
            type: "address",
          },
          {
            internalType: "address",
            name: "router",
            type: "address",
          },
          {
            internalType: "address",
            name: "lpReceiver",
            type: "address",
          },
          {
            internalType: "address",
            name: "feeRecipient",
            type: "address",
          },
          {
            internalType: "address",
            name: "creator",
            type: "address",
          },
          {
            internalType: "address",
            name: "factory",
            type: "address",
          },
        ],
        internalType: "struct LaunchCampaign.InitParams",
        name: "params",
        type: "tuple",
      },
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "launched",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "leagueFeeBps",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "leagueReceiver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "liquidityBps",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "liquiditySupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "logoURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "lpReceiver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "pendingNative",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "priceSlope",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "protocolFeeBps",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "totalInWei",
        type: "uint256",
      },
    ],
    name: "quoteBuyExactBnb",
    outputs: [
      {
        internalType: "uint256",
        name: "tokensOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "totalCostWei",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "feeWei",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256",
      },
    ],
    name: "quoteBuyExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256",
      },
    ],
    name: "quoteSellExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "router",
    outputs: [
      {
        internalType: "contract IPancakeRouter02",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "amountIn",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "minPayout",
        type: "uint256",
      },
    ],
    name: "sellExactTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "payout",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "sold",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "contract LaunchToken",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalBuyVolumeWei",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSellVolumeWei",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "website",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "xAccount",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x6080806040523461006b576001600081815581546001600160a01b031981168317835582916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a360ff19601f541617601f5561421c90816100718239f35b600080fdfe60808060405260043610156200001f575b5036156200001d57600080fd5b005b600090813560e01c90816302c7e7af14620028be5750806318160ddd146200289e5780631dd9e2df14620027a75780631f0c57fc146200277c5780632138a4c0146200275c57806335659fb8146200273c578063365d57a4146200271c578063366ad25014620026b75780633794f6be14620024df578063381562c214620024bf57806346904840146200249457806354354629146200247457806354e42f7e146200245457806360068dd8146200241157806365161831146200224a5780636700e332146200221f5780636915712d14620020485780636bb38b281462001f88578063715018a61462001f385780638091f3bf1462001f1357806386f2ece01462001ef357806389f2f0851462001ed35780638da5cb5b1462001ea85780639d1b464a1462001e7b5780639e6ea74d1462001c7e578063a4b20f131462001c5e578063af7695451462001bef578063b6013cef146200164c578063b915d4be1462001616578063ba49a08c14620015f6578063beb0a4161462001559578063bec92898146200151c578063c45a015514620014f1578063c59f5eed14620006fe578063c7876ea414620006de578063c9f62af214620006be578063cd1fc09f146200069e578063dd1a2a391462000601578063ed33da2714620003bd578063f20f3d9014620002e3578063f2fde38b1462000284578063f887ea4014620002595763fc0c546a0362000010573462000256578060031936011262000256576002546040516001600160a01b039091168152602090f35b80fd5b503462000256578060031936011262000256576004546040516001600160a01b039091168152602090f35b5034620002565760203660031901126200025657620002a2620028f8565b620002ac62002fe2565b6001600160a01b03811615620002ca57620002c7906200300f565b80f35b604051631e4fbdf760e01b815260048101839052602490fd5b50346200025657806003193601126200025657604051600b546000826200030a8362002924565b91828252602093600190856001821691826000146200039b57505060011462000357575b506200033d9250038362002991565b62000353604051928284938452830190620029b5565b0390f35b849150600b60005281600020906000915b858310620003825750506200033d9350820101856200032e565b8054838901850152879450869390920191810162000368565b60ff1916858201526200033d95151560051b85010192508791506200032e9050565b5060603660031901126200025657620003d5620028f8565b6005546001600160a01b039060243590620003f4908316331462002c6f565b620003fe62002e28565b818316916200040f83151562002cab565b6200042060ff601854161562002b30565b6200042d82151562002a95565b620004776017546200044f62000444858362002ba9565b601454101562002bb7565b620004706200046962000463868462002ba9565b62003153565b9162003153565b9062002b0c565b620004828162002e4c565b6200048e818362002ba9565b956200049f60443588111562002b71565b620004ad8734101562002bef565b620004bb83601a5462002ba9565b601a55858852601d60205260408820805460ff811615620005ba575b50509360019593600080516020620041f083398151915293604093620005178460209c99620005098260175462002ba9565b601755856003541662002fb5565b62000559575b50508634116200053c575b81519081528688820152a255604051908152f35b620005536200054c883462002b0c565b3362002f62565b62000528565b620005649062002e71565b915080151580620005ac575b62000595575b5080156200051d576200058d916007541662002ee6565b38806200051d565b620005a590836006541662002ee6565b3862000576565b508260065416151562000570565b60019060ff1916179055601c5460018101809111620005ed57601c5583600080516020620041f0833981519152620004d7565b634e487b7160e01b89526011600452602489fd5b50346200025657806003193601126200025657604051600d54600082620006288362002924565b91828252602093600190856001821691826000146200039b5750506001146200065a57506200033d9250038362002991565b849150600d60005281600020906000915b858310620006855750506200033d9350820101856200032e565b805483890185015287945086939092019181016200066b565b503462000256578060031936011262000256576020600854604051908152f35b503462000256578060031936011262000256576020601154604051908152f35b503462000256578060031936011262000256576020600e54604051908152f35b503462000256576003199060203683011262000256576001600160401b036004351162000256576102a080926004353603011262000256576040519182016001600160401b03811183821017620014db576040526004803501356001600160401b038111620014d7576200077a90600436918135010162002a13565b8252600435602401356001600160401b038111620014d757620007a590600436918135010162002a13565b6020830190815290600435604401356001600160401b038111620014d757620007d690600436918135010162002a13565b6040840152600435606401356001600160401b038111620014d7576200080490600436918135010162002a13565b6060840152600435608401356001600160401b038111620014d7576200083290600436918135010162002a13565b608084015260043560a401356001600160401b038111620014d7576200086090600436918135010162002a13565b60a084015260043560c481013560c085015260e481013560e08501526101048101356101008501526101248101356101208501526101448101356101408501526101648101356101608501526101848101356101808501526101a48101356101a08501526101c48101356101c0850152620008df906101e4016200290f565b6101e0840152620008f6610204600435016200290f565b6102008401526200090d610224600435016200290f565b61022084015262000924610244600435016200290f565b6102408401526200093b610264600435016200290f565b61026084015262000952610284600435016200290f565b610280840152601f5460ff8116620014a45760ff1916600117601f5560c0830151156200146e5760e0830151801515908162001461575b50156200143057612710620009a960e08501516101008601519062002ba9565b11620013f85761012083015115620013c6576101408301511562001394576102008301516001600160a01b03161562001361576102608301516001600160a01b0316156200132d5761271061018084015111620012f8576127106101a084015111620012c4576101c08301516101a0840151106200128d576101e08301516001600160a01b031615620012515760408301515115620012215761026083015162000a5c906001600160a01b03166200300f565b604083015180519093906001600160401b03811162000f5d5762000a82600a5462002924565b601f8111620011ce575b506020601f821160011462001155578394958293949262001149575b50508160011b916000199060031b1c191617600a555b606081015180519093906001600160401b038111620011355762000ae4600b5462002924565b601f8111620010e2575b506020601f82116001146200106957849582939495926200105d575b50508160011b916000199060031b1c191617600b555b608082015180519093906001600160401b038111620010495762000b46600c5462002924565b601f811162000ff6575b506020601f821160011462000f7d578293949582939262000f71575b50508160011b916000199060031b1c191617600c555b60a083015180519093906001600160401b03811162000f5d5762000ba8600d5462002924565b601f811162000f0a575b506020601f821160011462000e91578394958293949262000e85575b50508160011b916000199060031b1c191617600d555b610120810151600e55610140810151600f556101608101516010556101808101516011556101a0810151601255610280810151600580546001600160a01b03199081166001600160a01b03938416179091556102408301516006805483169184169190911790556101e0830151600780549092169083161790556101c0820151600855610220820151168062000e7f57506102608101516001600160a01b03165b600980546001600160a01b039283166001600160a01b0319918216179091556102008301516004805491909316911617905560c0810151601381905560e082015162000d119162000d17916127109162000ce0919062002ce9565b048060145561271062000cfe60c08601516101008701519062002ce9565b049283918260155560c086015162002b0c565b62002b0c565b6016551562000e49578051925160c082015160405190949091610f6a80840192906001600160401b0384118585101762000e355786979262000d6f86959362000d7e93620031e68839608085526080850190620029b5565b908382036020850152620029b5565b916040820152606030910152039083f0801562000e2657600280546001600160a01b03198082166001600160a01b0390941693841790925560038054909216908516909217918217905560c0919091015190803b1562000e31576040516340c10f1960e01b8152918391839182908490829062000e0090306004840162002cfd565b03925af1801562000e265762000e135750f35b62000e1e9062002961565b620002565780f35b6040513d84823e3d90fd5b5050fd5b634e487b7160e01b87526041600452602487fd5b60405162461bcd60e51b815260206004820152600e60248201526d6c6971756964697479207a65726f60901b6044820152606490fd5b62000c85565b01519050388062000bce565b600d84526000805160206200419083398151915290845b601f198416811062000ef1575060019394959683601f1981161062000ed7575b505050811b01600d5562000be4565b015160001960f88460031b161c1916905538808062000ec8565b9091602060018192858b01518155019301910162000ea8565b600d845260008051602062004190833981519152601f830160051c81016020841062000f55575b601f830160051c8201811062000f4957505062000bb2565b85815560010162000f31565b508062000f31565b634e487b7160e01b83526041600452602483fd5b01519050388062000b6c565b600c83526000805160206200415083398151915290835b601f198416811062000fdd575060019394959683601f1981161062000fc3575b505050811b01600c5562000b82565b015160001960f88460031b161c1916905538808062000fb4565b9091602060018192858b01518155019301910162000f94565b600c835260008051602062004150833981519152601f830160051c81016020841062001041575b601f830160051c820181106200103557505062000b50565b8481556001016200101d565b50806200101d565b634e487b7160e01b82526041600452602482fd5b01519050388062000b0a565b600b8552600080516020620041d083398151915290855b601f1984168110620010c9575060019394959683601f19811610620010af575b505050811b01600b5562000b20565b015160001960f88460031b161c19169055388080620010a0565b9091602060018192858b01518155019301910162001080565b600b8552600080516020620041d0833981519152601f830160051c8101602084106200112d575b601f830160051c820181106200112157505062000aee565b86815560010162001109565b508062001109565b634e487b7160e01b84526041600452602484fd5b01519050388062000aa8565b600a84526000805160206200417083398151915290845b601f1984168110620011b5575060019394959683601f198116106200119b575b505050811b01600a5562000abe565b015160001960f88460031b161c191690553880806200118c565b9091602060018192858b0151815501930191016200116c565b600a845260008051602062004170833981519152601f830160051c81016020841062001219575b601f830160051c820181106200120d57505062000a8c565b858155600101620011f5565b5080620011f5565b60405162461bcd60e51b81526020600482015260086024820152676c6f676f2075726960c01b6044820152606490fd5b60405162461bcd60e51b81526020600482015260146024820152736c6561677565207265636569766572207a65726f60601b6044820152606490fd5b60405162461bcd60e51b815260206004820152600f60248201526e1b195859dd594f9c1c9bdd1bd8dbdb608a1b6044820152606490fd5b60405162461bcd60e51b815260206004820152600c60248201526b70726f746f636f6c2062707360a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600d60248201526c6c69717569646974792062707360981b6044820152606490fd5b60405162461bcd60e51b815260206004820152600c60248201526b63726561746f72207a65726f60a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600b60248201526a726f75746572207a65726f60a81b6044820152606490fd5b60405162461bcd60e51b815260206004820152600a602482015269736c6f7065207a65726f60b01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600a6024820152697072696365207a65726f60b01b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f706f7274696f6e206f766572666c6f7760801b6044820152606490fd5b60405162461bcd60e51b815260206004820152600960248201526863757276652062707360b81b6044820152606490fd5b6127109150103862000989565b60405162461bcd60e51b815260206004820152600e60248201526d696e76616c696420737570706c7960901b6044820152606490fd5b60405162461bcd60e51b815260206004820152600b60248201526a1a5b9a5d1a585b1a5e995960aa1b6044820152606490fd5b5080fd5b634e487b7160e01b600052604160045260246000fd5b503462000256578060031936011262000256576005546040516001600160a01b039091168152602090f35b50346200025657602036600319011262000256576020906040906001600160a01b0362001548620028f8565b168152601e83522054604051908152f35b50346200025657806003193601126200025657604051600c54600082620015808362002924565b91828252602093600190856001821691826000146200039b575050600114620015b257506200033d9250038362002991565b849150600c60005281600020906000915b858310620015dd5750506200033d9350820101856200032e565b80548389018501528794508693909201918101620015c3565b503462000256578060031936011262000256576020601c54604051908152f35b503462000256576020366003190112620002565760606200163960043562002d18565b9060405192835260208301526040820152f35b503462000256576200165e36620028dc565b6200166862002fe2565b6200167262002e28565b829183916018549160ff831662001bbe5760175460145414801562001bb1575b1562001b80576001620016bc9360ff19161760185542601955476127109384916012549062002ce9565b04928315158062001b6b575b62001b4c575b620016dd476011549062002ce9565b0490601554918215158062001b42575b62001893575b5050505083620017096014546017549062002b0c565b806200181b575b505060165480620017f5575b504780620017d6575b60025485906001600160a01b0316803b15620014d75781906004604051809481936322a3148f60e21b83525af18015620017cb57620017af575b50936001916040958651918683528560208401528783015260608201527fd286a958d004cd376acc3762fff407f0dd9bf991995fc81a26ff88081f2b7d1b60803392a25582519182526020820152f35b620017bb869162002961565b620017c757386200175f565b8480fd5b6040513d88823e3d90fd5b600154620017ef9082906001600160a01b031662002f62565b62001725565b6003546001546200181492916001600160a01b03918216911662002fb5565b386200171c565b6002546001600160a01b031690813b156200188f5782916200185591604051948580948193632770a7eb60e21b8352306004840162002cfd565b03925af1801562001884576200186e575b849062001710565b6200187c9094919462002961565b923862001866565b6040513d87823e3d90fd5b8280fd5b60035460045460405163095ea7b360e01b6020820152959850939650919390926001600160a01b039081169216620018e482620018d589866024840162002cfd565b03601f19810184528362002991565b602089835182850182855af189513d8262001b23575b50501562001ae6575b50506004546002546009546001600160a01b03918216949350918116911642610708810110620005ed5791606094939160c493604051998a96879563f305d71960e01b875260048701528a6024870152604486015260648501526084840152610708420160a48401525af1801562001adb578493859162001a98575b5060035460045460405163095ea7b360e01b60208083019182526001600160a01b039384166024840181905260448085018c905284529597958995909416918a90620019cb8562002975565b84519082855af189513d8262001a79575b50501562001a2f575b505050808211620019f9575b8080620016f3565b60035460015462001a27936001600160a01b0392831693929091169162001a209162002b0c565b9162002fb5565b3880620019f1565b62001a6a62001a70936040519063095ea7b360e01b602083015260248201528a60448201526044815262001a638162002975565b8262003179565b62003179565b388080620019e5565b90915062001a8f5750803b15155b3880620019dc565b60011462001a87565b9350506060833d60601162001ad2575b8162001ab76060938362002991565b8101031262001ace5760208351930151386200197f565b8380fd5b3d915062001aa8565b6040513d86823e3d90fd5b62001a6a62001b1a936040519063095ea7b360e01b602083015260248201528a60448201526044815262001a638162002975565b38808062001903565b90915062001b395750803b15155b3880620018fa565b60011462001b31565b50801515620016ed565b60065462001b659085906001600160a01b031662002ee6565b620016ce565b506006546001600160a01b03161515620016c8565b60405162461bcd60e51b81526020600482015260096024820152681d1a1c995cda1bdb1960ba1b6044820152606490fd5b5047601054111562001692565b60405162461bcd60e51b8152602060048201526009602482015268199a5b985b1a5e995960ba1b6044820152606490fd5b5034620002565760203660031901126200025657602062001c5662001c4460043562001c1d81151562002a95565b6200047062000469620004636017549362001c3d62000444828762002ba9565b8462002ba9565b62001c4f8162002e4c565b9062002ba9565b604051908152f35b503462000256578060031936011262000256576020601054604051908152f35b506040366003190112620002565762001c96620028f8565b6005546001600160a01b039062001cb1908216331462002c6f565b62001cbb62002e28565b80821662001ccb81151562002cab565b62001cdc60ff601854161562002b30565b62001ce73462002d18565b5092909362001cf885151562002a95565b62001d0860243586101562002b71565b62001d3360175462001d1f62000444888362002ba9565b620004706200046962000463898462002ba9565b9062001d3f8262002e4c565b9062001d5962001d50838562002ba9565b96871462002c31565b62001d6783601a5462002ba9565b601a55848852601d60205260408820805460ff81161562001e54575b505091604097939162001da28860019795620005098260175462002ba9565b62001df3575b505083341162001ddd575b600080516020620041f0833981519152868051878152866020820152a25582519182526020820152f35b62001ded6200054c853462002b0c565b62001db3565b62001dfe9062002e71565b91508015158062001e46575b62001e2f575b50801562001da85762001e27916007541662002ee6565b388062001da8565b62001e3f90836006541662002ee6565b3862001e10565b508260065416151562001e0a565b60019060ff1916179055601c5460018101809111620005ed57601c558162001da262001d83565b50346200025657806003193601126200025657602062001c56600e5462001c4f600f546017549062003047565b503462000256578060031936011262000256576001546040516001600160a01b039091168152602090f35b503462000256578060031936011262000256576020601b54604051908152f35b503462000256578060031936011262000256576020601a54604051908152f35b50346200025657806003193601126200025657602060ff601854166040519015158152f35b5034620002565780600319360112620002565762001f5562002fe2565b600180546001600160a01b0319811690915581906001600160a01b0316600080516020620041b08339815191528280a380f35b50346200025657806003193601126200025657604051908082600a549162001fb08362002924565b92838352602094600191866001821691826000146200202457505060011462001fe4575b50506200033d9250038362002991565b90859250600a82528282205b8583106200200b5750506200033d9350820101388062001fd4565b8054838901850152879450869390920191810162001ff0565b92509350506200033d94915060ff191682840152151560051b820101388062001fd4565b50602036600319011262000256576200206062002e28565b6200207160ff601854161562002b30565b6200207c3462002d18565b506200208a82151562002a95565b6200209a60043583101562002b71565b620020b16017546200044f62000444858362002ba9565b620020bc8162002e4c565b90620020d6620020cd838362002ba9565b93841462002c31565b620020e481601a5462002ba9565b601a55338552601d60205260408520805460ff811615620021e6575b505093600191604095620021178660175462002ba9565b601755838060a01b0391620021328733856003541662002fb5565b62002185575b50508234116200216f575b8451848152836020820152600080516020620041f0833981519152863392a25582519182526020820152f35b6200217f6200054c843462002b0c565b62002143565b620021909062002e71565b915080151580620021d8575b620021c1575b5080156200213857620021b9916007541662002ee6565b388062002138565b620021d190836006541662002ee6565b38620021a2565b50826006541615156200219c565b60019060ff1916179055601c54600181018091116200220b57601c5581604062002100565b634e487b7160e01b86526011600452602486fd5b503462000256578060031936011262000256576007546040516001600160a01b039091168152602090f35b506200225636620028dc565b906200226162002e28565b6200227260ff601854161562002b30565b6200227f81151562002a95565b620022aa6017546200229662000444848362002ba9565b620004706200046962000463858462002ba9565b620022b58162002e4c565b90620022d0620022c6838362002ba9565b9485111562002b71565b620022de8434101562002bef565b620022ec81601a5462002ba9565b601a55338552601d60205260408520805460ff811615620023ec575b50509160209491600193620023208360175462002ba9565b601755848060a01b03916200233b8433856003541662002fb5565b6200238b575b505083341162002375575b6040519081528385820152600080516020620041f083398151915260403392a255604051908152f35b620023856200054c853462002b0c565b6200234c565b620023969062002e71565b915080151580620023de575b620023c7575b5080156200234157620023bf916007541662002ee6565b388062002341565b620023d790836006541662002ee6565b38620023a8565b5082600654161515620023a2565b60019060ff1916179055601c54600181018091116200220b57601c5581600162002308565b503462000256576020366003190112620002565760209060ff906040906001600160a01b0362002440620028f8565b168152601d84522054166040519015158152f35b503462000256578060031936011262000256576020600f54604051908152f35b503462000256578060031936011262000256576020601654604051908152f35b503462000256578060031936011262000256576006546040516001600160a01b039091168152602090f35b503462000256578060031936011262000256576020601554604051908152f35b50346200025657620024f136620028dc565b90620024fc62002e28565b6200250d60ff601854161562002b30565b6200251a81151562002a95565b6017546200252b8183111562002ad0565b6200254a6200253a8262003153565b6200047062000463858562002b0c565b9062002576836200255b8462002e4c565b9262000d116200256c858762002b0c565b9788101562002b71565b6017556003546040516323b872dd60e01b6020820152336024820152306044820152606480820186905281526001600160a01b039291831660a082016001600160401b03811183821017620026a35792620025e260209996936001989693620025fe9660405262003179565b6200263b575b50620025f5863362002f62565b601b5462002ba9565b601b5560405190815283858201527f2dcf9433d75db0d8b1c172641f85e319ffe4ad22e108a95d1847ceb906e5195d60403392a255604051908152f35b620026468262002e71565b91508015158062002695575b6200267e575b508062002667575b50620025e8565b62002676916007541662002ee6565b388062002660565b6200268e90836006541662002ee6565b3862002658565b508260065416151562002652565b634e487b7160e01b89526041600452602489fd5b5034620002565760203660031901126200025657602062001c5662002711600435620026e581151562002a95565b620004706200046360175492620026ff8482111562002ad0565b6200270a8462003153565b9362002b0c565b620004708162002e4c565b503462000256578060031936011262000256576020601954604051908152f35b503462000256578060031936011262000256576020601254604051908152f35b503462000256578060031936011262000256576020601454604051908152f35b503462000256578060031936011262000256576009546040516001600160a01b039091168152602090f35b50346200025657806003193601126200025657620027c462002e28565b338152602090601e825260408120549081156200286c57338152601e83528060408120558080808085335af1620027fa62002a60565b501562002838576001906040518381527f7b3fcf6b642a0d537ec94e3e3554737ca883871bc8a5ea348d8ee3a9b9d9656c853392a255604051908152f35b60405162461bcd60e51b815260048101849052600c60248201526b18db185a5b4819985a5b195960a21b6044820152606490fd5b60405162461bcd60e51b815260048101849052600a6024820152696e6f2070656e64696e6760b01b6044820152606490fd5b503462000256578060031936011262000256576020601354604051908152f35b905034620014d75781600319360112620014d7576020906017548152f35b6040906003190112620028f3576004359060243590565b600080fd5b600435906001600160a01b0382168203620028f357565b35906001600160a01b0382168203620028f357565b90600182811c9216801562002956575b60208310146200294057565b634e487b7160e01b600052602260045260246000fd5b91607f169162002934565b6001600160401b038111620014db57604052565b608081019081106001600160401b03821117620014db57604052565b601f909101601f19168101906001600160401b03821190821017620014db57604052565b919082519283825260005b848110620029e2575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201620029c0565b6001600160401b038111620014db57601f01601f191660200190565b81601f82011215620028f35780359062002a2d82620029f7565b9262002a3d604051948562002991565b82845260208383010111620028f357816000926020809301838601378301015290565b3d1562002a90573d9062002a7482620029f7565b9162002a84604051938462002991565b82523d6000602084013e565b606090565b1562002a9d57565b60405162461bcd60e51b815260206004820152600b60248201526a1e995c9bc8185b5bdd5b9d60aa1b6044820152606490fd5b1562002ad857565b60405162461bcd60e51b815260206004820152600c60248201526b195e18d959591cc81cdbdb1960a21b6044820152606490fd5b9190820391821162002b1a57565b634e487b7160e01b600052601160045260246000fd5b1562002b3857565b60405162461bcd60e51b815260206004820152601160248201527018d85b5c185a59db881b185d5b98da1959607a1b6044820152606490fd5b1562002b7957565b60405162461bcd60e51b8152602060048201526008602482015267736c69707061676560c01b6044820152606490fd5b9190820180921162002b1a57565b1562002bbf57565b60405162461bcd60e51b81526020600482015260086024820152671cdbdb19081bdd5d60c21b6044820152606490fd5b1562002bf757565b60405162461bcd60e51b8152602060048201526012602482015271696e73756666696369656e742076616c756560701b6044820152606490fd5b1562002c3957565b60405162461bcd60e51b815260206004820152600e60248201526d0e2eadee8ca40dad2e6dac2e8c6d60931b6044820152606490fd5b1562002c7757565b60405162461bcd60e51b815260206004820152600c60248201526b4f4e4c595f464143544f525960a01b6044820152606490fd5b1562002cb357565b60405162461bcd60e51b815260206004820152600e60248201526d1e995c9bc81c9958da5c1a595b9d60921b6044820152606490fd5b8181029291811591840414171562002b1a57565b6001600160a01b039091168152602081019190915260400190565b90811562002e1e5760ff6018541662002e1e5760145462002d3d601754809262002b0c565b92831562002e1257600093905b81851062002d9b575050821562002d9057806200047062000469620004638662002d749562002ba9565b9062002d8c62002d848362002e4c565b809362002ba9565b9190565b506000915081908190565b909362002da9858262002ba9565b600180820180921162002b1a571c908262002ddc62001c4462002dd162000463868962002ba9565b620004708862003153565b1162002dec5750935b9062002d4a565b945060001981019081111562002de557634e487b7160e01b600052601160045260246000fd5b50600092508291829150565b6000915081908190565b60026000541462002e3a576002600055565b604051633ee5aeb560e01b8152600490fd5b60125490811562002e6a576127109162002e669162002ce9565b0490565b5050600090565b9062002e7d8262002e4c565b91821562002d905762002e97612710916008549062002ce9565b600754919004906001600160a01b031615801562002edd575b62002ed55782811162002ecd575b62002eca818462002b0c565b91565b508162002ebe565b508190600090565b50801562002eb0565b811562002f5e576001600160a01b03169060008080808085875af162002f0b62002a60565b501562002f1757505050565b7f1196ff9c61f6c4d265bb9529d5aa6afceea1fc7646a5c406fcc1dcb61941db15916040828560209452601e84522062002f5382825462002ba9565b9055604051908152a2565b5050565b600080809381935af162002f7562002a60565b501562002f7e57565b60405162461bcd60e51b815260206004820152600f60248201526e1d1c985b9cd9995c8819985a5b1959608a1b6044820152606490fd5b62001a6a62002fe09392620018d560405194859263a9059cbb60e01b60208501526024840162002cfd565b565b6001546001600160a01b0316330362002ff757565b60405163118cdaa760e01b8152336004820152602490fd5b600180546001600160a01b039283166001600160a01b031982168117909255909116600080516020620041b0833981519152600080a3565b9060001981830981830291828083109203918083039214620030bf57670de0b6b3a76400009082821115620030ac577faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac10669940990828211900360ee1b910360121c170290565b634e487b7160005260116020526024601cfd5b5050670de0b6b3a764000091500490565b90600019818309818302918280831092039180830392146200313b576a0c097ce7bc90715b34b9f160251b9082821115620030ac577f356317ffa45f828d2a41175b2aed3a20e7fdd4a4e46cc11944d93b01be7b1711940990828211900360db1b910360251c170290565b50506a0c097ce7bc90715b34b9f160251b9004919050565b620031769062001c4f6200316a600e548362003047565b918002600f54620030d0565b90565b906000602091828151910182855af115620031d9576000513d620031cf57506001600160a01b0381163b155b620031ad5750565b604051635274afe760e01b81526001600160a01b039091166004820152602490fd5b60011415620031a5565b6040513d6000823e3d90fdfe60a060405234620003de5762000f6a803803806200001d81620003e3565b9283398101608082820312620003de5781516001600160401b039190828111620003de57816200004f91850162000409565b6020918285015190848211620003de576200006c91860162000409565b90606060408601519501519060018060a01b0394858316809303620003de578151818111620002de576003908154906001948583811c93168015620003d3575b89841014620003bd578190601f9384811162000367575b5089908483116001146200030057600092620002f4575b505060001982851b1c191690851b1782555b8551928311620002de5760049586548581811c91168015620002d3575b89821014620002be5782811162000273575b50879184116001146200020857938394918492600095620001fc575b50501b92600019911b1c19161782555b8015620001e457600580546001600160a01b03198116831790915560405194167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a38315620001b75783608052604051610aee90816200047c823960805181818161052001526105f30152f35b62461bcd60e51b8352820152600b60248201526a636170206973207a65726f60a81b604482015260649150fd5b604051631e4fbdf760e01b8152600081840152602490fd5b01519350388062000137565b9190601f198416928760005284896000209460005b8b898383106200025b575050501062000240575b50505050811b01825562000147565b01519060f884600019921b161c191690553880808062000231565b8686015189559097019694850194889350016200021d565b87600052886000208380870160051c8201928b8810620002b4575b0160051c019086905b828110620002a75750506200011b565b6000815501869062000297565b925081926200028e565b602288634e487b7160e01b6000525260246000fd5b90607f169062000109565b634e487b7160e01b600052604160045260246000fd5b015190503880620000da565b90879350601f19831691866000528b6000209260005b8d82821062000350575050841162000337575b505050811b018255620000ec565b015160001983871b60f8161c1916905538808062000329565b8385015186558b9790950194938401930162000316565b90915084600052896000208480850160051c8201928c8610620003b3575b918991869594930160051c01915b828110620003a3575050620000c3565b6000815585945089910162000393565b9250819262000385565b634e487b7160e01b600052602260045260246000fd5b92607f1692620000ac565b600080fd5b6040519190601f01601f191682016001600160401b03811183821017620002de57604052565b919080601f84011215620003de5782516001600160401b038111620002de576020906200043f601f8201601f19168301620003e3565b92818452828287010111620003de5760005b8181106200046757508260009394955001015290565b85810183015184820184015282016200045156fe6080604081815260048036101561001557600080fd5b600092833560e01c90816306fdde03146107df57508063095ea7b31461073657806318160ddd1461071757806323b872dd14610632578063313ce56714610616578063355274ea146105db57806340c10f19146104d95780634ada218b146104b257806370a082311461047b578063715018a6146104305780638a8c523c146103fe5780638da5cb5b146103d557806395d89b41146102d15780639dc29fac146101d6578063a9059cbb146101a5578063dd62ed3e146101585763f2fde38b146100de57600080fd5b34610154576020366003190112610154576100f7610901565b90610100610a75565b6001600160a01b0391821692831561013e575050600580546001600160a01b03198116841790915516600080516020610aa28339815191528380a380f35b51631e4fbdf760e01b8152908101849052602490fd5b8280fd5b5050346101a157806003193601126101a15780602092610176610901565b61017e61091c565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b5050346101a157806003193601126101a1576020906101cf6101c5610901565b6024359033610973565b5160018152f35b508290346101a157826003193601126101a1576101f1610901565b90602435906101fe610a75565b6001600160a01b03838116939084156102ba5760055460ff8160a01c1615610288575b5050838552846020528585205491838310610269575050818495600080516020610ac2833981519152936020938688528785520381872055816002540360025551908152a380f35b6102848484895194859463391434e360e21b86528501610955565b0390fd5b168085141590816102af575b506102a0578680610221565b5084516312f1f92360e01b8152fd5b905033141587610294565b8651634b637e8f60e11b8152808401879052602490fd5b509190346101a157816003193601126101a15780519082845460018160011c90600183169283156103cb575b60209384841081146103b85783885290811561039c5750600114610364575b505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b0390f35b634e487b7160e01b815260418552602490fd5b919250868652828620918387935b838510610388575050505083010138808061031c565b805488860183015293019284908201610372565b60ff1916878501525050151560051b840101905038808061031c565b634e487b7160e01b895260228a52602489fd5b91607f16916102fd565b5050346101a157816003193601126101a15760055490516001600160a01b039091168152602090f35b833461042d578060031936011261042d57610417610a75565b6005805460ff60a01b1916600160a01b17905580f35b80fd5b833461042d578060031936011261042d57610449610a75565b600580546001600160a01b0319811690915581906001600160a01b0316600080516020610aa28339815191528280a380f35b5050346101a15760203660031901126101a15760209181906001600160a01b036104a3610901565b16815280845220549051908152f35b5050346101a157816003193601126101a15760209060ff60055460a01c1690519015158152f35b5090346101545780600319360112610154576104f3610901565b9060243591610500610a75565b6001600160a01b03169283156105af576002549061051e8483610932565b7f00000000000000000000000000000000000000000000000000000000000000001061057d575082600080516020610ac2833981519152926105638795602094610932565b60025585855284835280852082815401905551908152a380f35b606490602084519162461bcd60e51b8352820152600c60248201526b18d85c08195e18d95959195960a21b6044820152fd5b6020606492519162461bcd60e51b83528201526007602482015266746f207a65726f60c81b6044820152fd5b5050346101a157816003193601126101a157602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5050346101a157816003193601126101a1576020905160128152f35b50823461042d57606036600319011261042d5761064d610901565b61065561091c565b916044359360018060a01b038316808352600160205286832033845260205286832054916000198310610691575b6020886101cf898989610973565b8683106106f95781156106e25733156106cb575082526001602090815286832033845281529186902090859003905582906101cf87610683565b8751634a1406b160e11b8152908101849052602490fd5b875163e602df0560e01b8152908101849052602490fd5b9050610284868851938493637dc7a0d960e11b855233908501610955565b5050346101a157816003193601126101a1576020906002549051908152f35b503461015457816003193601126101545761074f610901565b6024359033156107c8576001600160a01b03169182156107b157508083602095338152600187528181208582528752205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b8351634a1406b160e11b8152908101859052602490fd5b835163e602df0560e01b8152808401869052602490fd5b84915083346101545782600319360112610154578260035460018160011c90600183169283156108ae575b60209384841081146103b857838852908115610892575060011461085957505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b91925060038652828620918387935b83851061087e575050505083010185808061031c565b805488860183015293019284908201610868565b60ff1916878501525050151560051b840101905085808061031c565b91607f169161080a565b6020808252825181830181905290939260005b8281106108ed57505060409293506000838284010152601f8019910116010190565b8181018601518482016040015285016108cb565b600435906001600160a01b038216820361091757565b600080fd5b602435906001600160a01b038216820361091757565b9190820180921161093f57565b634e487b7160e01b600052601160045260246000fd5b604091949392606082019560018060a01b0316825260208201520152565b6001600160a01b0392838216929091908315610a5c578416938415610a435760055460ff8160a01c1615610a0e575b5050600090838252816020526040822054908382106109f157509160408282600080516020610ac2833981519152958760209652828652038282205586815220818154019055604051908152a3565b6102848460405193849363391434e360e21b855260048501610955565b16808414159081610a38575b50610a265738806109a2565b6040516312f1f92360e01b8152600490fd5b905033141538610a1a565b60405163ec442f0560e01b815260006004820152602490fd5b604051634b637e8f60e11b815260006004820152602490fd5b6005546001600160a01b03163303610a8957565b60405163118cdaa760e01b8152336004820152602490fdfe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa164736f6c6343000818000adf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c7c65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2a8d7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb58be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e00175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db98fafebcaf9d154343dad25669bfa277f4fbacd7ac6b0c4fed522580e040a0f33a164736f6c6343000818000a";

type LaunchCampaignConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: LaunchCampaignConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class LaunchCampaign__factory extends ContractFactory {
  constructor(...args: LaunchCampaignConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      LaunchCampaign & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): LaunchCampaign__factory {
    return super.connect(runner) as LaunchCampaign__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): LaunchCampaignInterface {
    return new Interface(_abi) as LaunchCampaignInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): LaunchCampaign {
    return new Contract(address, _abi, runner) as unknown as LaunchCampaign;
  }
}
</file>

<file path="typechain-types/factories/contracts/LaunchFactory__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../common";
import type {
  LaunchFactory,
  LaunchFactoryInterface,
} from "../../contracts/LaunchFactory";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "router_",
        type: "address",
      },
      {
        internalType: "address",
        name: "leagueReceiver_",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "FailedDeployment",
    type: "error",
  },
  {
    inputs: [],
    name: "FeeTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "FeeTooLowForLeague",
    type: "error",
  },
  {
    inputs: [],
    name: "InitBuyTooLarge",
    type: "error",
  },
  {
    inputs: [],
    name: "InitBuyValue",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "InsufficientBalance",
    type: "error",
  },
  {
    inputs: [],
    name: "InvalidCurveBps",
    type: "error",
  },
  {
    inputs: [],
    name: "LiquidityBps",
    type: "error",
  },
  {
    inputs: [],
    name: "LogoEmpty",
    type: "error",
  },
  {
    inputs: [],
    name: "NameEmpty",
    type: "error",
  },
  {
    inputs: [],
    name: "Offset",
    type: "error",
  },
  {
    inputs: [],
    name: "OutOfBounds",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "OwnableInvalidOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error",
  },
  {
    inputs: [],
    name: "ParamTooHigh",
    type: "error",
  },
  {
    inputs: [],
    name: "PriceZero",
    type: "error",
  },
  {
    inputs: [],
    name: "RecipientZero",
    type: "error",
  },
  {
    inputs: [],
    name: "RefundFail",
    type: "error",
  },
  {
    inputs: [],
    name: "RouterZero",
    type: "error",
  },
  {
    inputs: [],
    name: "SlopeZero",
    type: "error",
  },
  {
    inputs: [],
    name: "SupplyZero",
    type: "error",
  },
  {
    inputs: [],
    name: "SymbolEmpty",
    type: "error",
  },
  {
    inputs: [],
    name: "TargetZero",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "creator",
        type: "address",
      },
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string",
      },
      {
        indexed: false,
        internalType: "string",
        name: "symbol",
        type: "string",
      },
    ],
    name: "CampaignCreated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "totalSupply",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "curveBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityTokenBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "basePrice",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "priceSlope",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "graduationTarget",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityBps",
            type: "uint256",
          },
        ],
        indexed: false,
        internalType: "struct LaunchFactory.LaunchConfig",
        name: "newConfig",
        type: "tuple",
      },
    ],
    name: "ConfigUpdated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRecipient",
        type: "address",
      },
    ],
    name: "FeeRecipientUpdated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "newFeeBps",
        type: "uint256",
      },
    ],
    name: "ProtocolFeeUpdated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRouter",
        type: "address",
      },
    ],
    name: "RouterUpdated",
    type: "event",
  },
  {
    inputs: [],
    name: "LEAGUE_FEE_BPS",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "MAX_BASE_PRICE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "MAX_GRADUATION_TARGET",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "MAX_PRICE_SLOPE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "campaignImplementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "campaignsCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "config",
    outputs: [
      {
        internalType: "uint256",
        name: "totalSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "curveBps",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "liquidityTokenBps",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "basePrice",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "priceSlope",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "graduationTarget",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "liquidityBps",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "string",
            name: "name",
            type: "string",
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string",
          },
          {
            internalType: "string",
            name: "logoURI",
            type: "string",
          },
          {
            internalType: "string",
            name: "xAccount",
            type: "string",
          },
          {
            internalType: "string",
            name: "website",
            type: "string",
          },
          {
            internalType: "string",
            name: "extraLink",
            type: "string",
          },
          {
            internalType: "uint256",
            name: "basePrice",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "priceSlope",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "graduationTarget",
            type: "uint256",
          },
          {
            internalType: "address",
            name: "lpReceiver",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "initialBuyBnbWei",
            type: "uint256",
          },
        ],
        internalType: "struct LaunchFactory.CampaignRequest",
        name: "req",
        type: "tuple",
      },
    ],
    name: "createCampaign",
    outputs: [
      {
        internalType: "address",
        name: "campaignAddr",
        type: "address",
      },
      {
        internalType: "address",
        name: "tokenAddr",
        type: "address",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "getCampaign",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "campaign",
            type: "address",
          },
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "address",
            name: "creator",
            type: "address",
          },
          {
            internalType: "string",
            name: "name",
            type: "string",
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string",
          },
          {
            internalType: "string",
            name: "logoURI",
            type: "string",
          },
          {
            internalType: "string",
            name: "xAccount",
            type: "string",
          },
          {
            internalType: "string",
            name: "website",
            type: "string",
          },
          {
            internalType: "string",
            name: "extraLink",
            type: "string",
          },
          {
            internalType: "uint64",
            name: "createdAt",
            type: "uint64",
          },
        ],
        internalType: "struct LaunchFactory.CampaignInfo",
        name: "",
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "offset",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "limit",
        type: "uint256",
      },
    ],
    name: "getCampaignPage",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "campaign",
            type: "address",
          },
          {
            internalType: "address",
            name: "token",
            type: "address",
          },
          {
            internalType: "address",
            name: "creator",
            type: "address",
          },
          {
            internalType: "string",
            name: "name",
            type: "string",
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string",
          },
          {
            internalType: "string",
            name: "logoURI",
            type: "string",
          },
          {
            internalType: "string",
            name: "xAccount",
            type: "string",
          },
          {
            internalType: "string",
            name: "website",
            type: "string",
          },
          {
            internalType: "string",
            name: "extraLink",
            type: "string",
          },
          {
            internalType: "uint64",
            name: "createdAt",
            type: "uint64",
          },
        ],
        internalType: "struct LaunchFactory.CampaignInfo[]",
        name: "page",
        type: "tuple[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "leagueReceiver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "protocolFeeBps",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "initialBuyTokens",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "basePriceOverride",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "priceSlopeOverride",
        type: "uint256",
      },
    ],
    name: "quoteInitialBuyTotal",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "router",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "uint256",
            name: "totalSupply",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "curveBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityTokenBps",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "basePrice",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "priceSlope",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "graduationTarget",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "liquidityBps",
            type: "uint256",
          },
        ],
        internalType: "struct LaunchFactory.LaunchConfig",
        name: "newConfig",
        type: "tuple",
      },
    ],
    name: "setConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newRecipient",
        type: "address",
      },
    ],
    name: "setFeeRecipient",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "newProtocolFeeBps",
        type: "uint256",
      },
    ],
    name: "setProtocolFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newRouter",
        type: "address",
      },
    ],
    name: "setRouter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x60a034620002105762006626906001600160401b03601f38849003908101601f19168301908282118483101762000215578084916040968794855283398101031262000210576200005e602062000056846200022b565b93016200022b565b903315620001f857600080546001600160a01b0319808216339081178455875191966001600160a01b03969495949387929083167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08880a316908115620001e9575084821615620001d85785600a541617600a55608052845160e0810181811083821117620001c4579060c09187526b033b2e3c9fd0803ce80000008082526122608060208401526103e8808a850152652d79883d200091826060860152633b9aca00938460808701526802b5e3af16b1880000958660a0820152611f4097889101526001556002556003556004556005556006556007553384600854161760085560c860095584519061428d8083019183831090831117620001c457908291620023998339039082f0908115620001b957501690600b541617600b555161215890816200024182396080518181816103f801526118be0152f35b8451903d90823e3d90fd5b634e487b7160e01b84526041600452602484fd5b8651633d9eb1db60e01b8152600490fd5b631ef88b9960e21b8152600490fd5b8351631e4fbdf760e01b815260006004820152602490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b0382168203620002105756fe610200604052600436101561001c575b361561001a57600080fd5b005b60006101e0526101e0513560e01c8063228d452a14611a6e5780632b6c075b146119e957806335659fb8146119c957806344c89b65146119a9578063469048401461197e5780635598f8cc1461191857806362a6e065146118ed5780636700e332146118a65780636caffb81146116c7578063715018a614611677578063787dce3d146115f057806379502c551461159d5780638da5cb5b14611570578063967d112c146115525780639914fb9a1461152b578063c0d78655146114a4578063d6e172961461147e578063db1d03da14611452578063e74b981b146113cb578063f2fde38b14611348578063f887ea401461131d5763fc51ff4c0361000f57600319602036820112610c47576001600160401b0360043511610c47576101609060043536030112610c4757610155600480350180612041565b90501561130b57610170602460043501600435600401612041565b9050156112f95761018b604460043501600435600401612041565b9050156112e75760c460043501351515806112cf575b6112865760e460043501351515806112b2575b611286576101046004350135151580611298575b611286576101da600480350180612041565b61010052610160526101f6602460043501600435600401612041565b6101a05261020e604460043501600435600401612041565b610225606460049493943501600435600401612041565b93909261023c608460043501600435600401612041565b9261025160a460043501600435600401612041565b9190926001549560025497600354996101e0515060c4600435013515600014611279576004549b5b6101e05160805260043560e4013561126a576005546080525b6101e05160c052600435610104013561125a5760065460c0525b600754610120526009546101c052600a546001600160a01b039081166101805260043561012401906102dd82612078565b6101e0516101405216611248575033610140525b6008546001600160a01b031660e05260405160a08190526001600160401b036102a08201908111911117610d5957610369610385966103779461035b6103939c6102a060a0510160405261034c3661010051610160516120a7565b60a051526101a05136916120a7565b602060a051015236916120a7565b604060a051015236916120a7565b606060a051015236916120a7565b608060a051015236916120a7565b60a08051015260c060a051015260e060a051015261010060a051015261012060a051015260805161014060a051015260c05161016060a05101526101205161018060a05101526101c0516101a060a051015260196101c060a051015260018060a01b037f0000000000000000000000000000000000000000000000000000000000000000166101e060a05101526101805161020060a051015260018060a01b03610140511661022060a051015260e05161024060a05101523361026060a05101523061028060a05101526e5af43d82803e903d91602b57fd5bf3600b54763d602d80600a3d3981f3363d3d373d3d3d363d7300000062ffffff8260881c16176101e0515260018060781b03199060781b161760205260018060a01b03603760096101e051f016801561123657803b15610c475760405163c59f5eed60e01b8152602060048201526105766104f760a051516102a060248501526102c4840190611a9a565b61056061054a61053461051e602060a05101519460231995868983030160448a0152611a9a565b604060a051015185888303016064890152611a9a565b606060a051015184878303016084880152611a9a565b608060a0510151838683030160a4870152611a9a565b9060a080510151908483030160c4850152611a9a565b60a0805160c0015160e4840152805160e0015161010484015280516101000151610124840152805161012001516101448401528051610140015161016484015280516101600151610184840152805161018001516101a484015280516101a001516101c484015280516101c001516101e484015280516101e0908101516001600160a01b03908116610204860152825161020001518116610224860152825161022001518116610244860152825161024001518116610264860152825161026001518116610284860152915161028001519091166102a4840152519082908190038183865af18015610c565761121f575b50604051637e062a3560e11b815290602082600481845afa918215610c56576101e051926111db575b50816106a0600480350180612041565b906106b360048035602481019101612041565b906106c660048035604481019101612041565b906106d960048035606481019101612041565b919092600435608401600435600401906106f291612041565b95909660043560a4016004356004019061070b91612041565b99909a8d6040519d8e9161071e83611c6c565b82526001600160a01b03166020909101523360408e0152610741913691906120a7565b60608c01523690610751926120a7565b60808a01523690610761926120a7565b60a08801523690610771926120a7565b60c08601523690610781926120a7565b60e08401523690610791926120a7565b610100820152426001600160401b0316610120820152600c54600160401b811015610d59578060016107c69201600c55611d30565b6111bf57815181546001600160a01b039182166001600160a01b03199182161783556020840151600184018054918416918316919091179055604084015160028401805491909316911617905560608201518051906001600160401b038211610d595781906108386003850154611d79565b601f8111611166575b506020906001601f8411146110ee576101e051926110e3575b50508160011b916000199060031b1c19161760038201555b60808201518051906001600160401b038211610d595781906108976004850154611d79565b601f811161108a575b506020906001601f841114611012576101e05192611007575b50508160011b916000199060031b1c19161760048201555b60a08201518051906001600160401b038211610d595781906108f66005850154611d79565b601f8111610fae575b506020906001601f841114610f36576101e05192610f2b575b50508160011b916000199060031b1c19161760058201555b60c08201518051906001600160401b038211610d595781906109556006850154611d79565b601f8111610ed2575b506020906001601f841114610e5a576101e05192610e4f575b50508160011b916000199060031b1c19161760068201555b60e08201518051906001600160401b038211610d595781906109b46007850154611d79565b601f8111610df6575b506020906001601f841114610d7e576101e05192610d73575b50508160011b916000199060031b1c19161760078201555b6101008201518051906001600160401b038211610d5957610a126008840154611d79565b601f8111610d0c575b506020906001601f841114610c9357918091600994936101e05192610c88575b50508160011b916000199060031b1c19161760088201555b61012090920151910180546001600160401b0319166001600160401b03929092169190911790556101e051600435610144013580610bc2575b50803411610b5d575b50600c54600019810192908311610b4357604092610b2b9083907ffdb1476ee472ae4c88dd3d31e0289bf3aede684aae57fae4d32c92e7585911ef610ade600480350180612041565b610af2602460043501600435600401612041565b610b118b989298519485943386526060602087015260608601916120de565b8381038c8501526001600160a01b038a16989091906120de565b0390a482519182526001600160a01b03166020820152f35b634e487b7160e01b6101e05152601160045260246101e051fd5b6101e05190819081908190610b729034611d23565b335af13d15610bbd573d610b858161208c565b90610b936040519283611c9e565b81526101e0513d916020013e5b15610bab5738610a95565b6040516305610ec560e01b8152600490fd5b610ba0565b9050670de0b6b3a76400008111610c7657803410610c645760408051639e6ea74d60e01b81523360048201526101e05160248201529182906044908290865af1908115610c56576101e05191610c1a575b5038610a8c565b90506040813d604011610c4e575b81610c3560409383611c9e565b81010312610c47576020015138610c13565b6101e05180fd5b3d9150610c28565b6040513d6101e051823e3d90fd5b604051633b56ac4f60e01b8152600490fd5b60405163049428d560e11b8152600490fd5b015190503880610a3b565b90600884016101e0515260206101e05120916101e0515b601f1985168110610cf4575091839160019360099695601f19811610610cdb575b505050811b016008820155610a53565b015160001960f88460031b161c19169055388080610ccb565b91926020600181928685015181550194019201610caa565b600884016101e0515260206101e05120601f840160051c810160208510610d52575b601f830160051c82018110610d44575050610a1b565b6101e0518155600101610d2e565b5080610d2e565b634e487b7160e01b6101e05152604160045260246101e051fd5b0151905038806109d6565b9250600784016101e0515260206101e05120906101e051935b601f1984168510610ddb576001945083601f19811610610dc2575b505050811b0160078201556109ee565b015160001960f88460031b161c19169055388080610db2565b81810151835560209485019460019093019290910190610d97565b909150600784016101e0515260206101e05120601f840160051c810160208510610e48575b90849392915b601f830160051c82018110610e375750506109bd565b6101e0518155859450600101610e21565b5080610e1b565b015190503880610977565b9250600684016101e0515260206101e05120906101e051935b601f1984168510610eb7576001945083601f19811610610e9e575b505050811b01600682015561098f565b015160001960f88460031b161c19169055388080610e8e565b81810151835560209485019460019093019290910190610e73565b909150600684016101e0515260206101e05120601f840160051c810160208510610f24575b90849392915b601f830160051c82018110610f1357505061095e565b6101e0518155859450600101610efd565b5080610ef7565b015190503880610918565b9250600584016101e0515260206101e05120906101e051935b601f1984168510610f93576001945083601f19811610610f7a575b505050811b016005820155610930565b015160001960f88460031b161c19169055388080610f6a565b81810151835560209485019460019093019290910190610f4f565b909150600584016101e0515260206101e05120601f840160051c810160208510611000575b90849392915b601f830160051c82018110610fef5750506108ff565b6101e0518155859450600101610fd9565b5080610fd3565b0151905038806108b9565b9250600484016101e0515260206101e05120906101e051935b601f198416851061106f576001945083601f19811610611056575b505050811b0160048201556108d1565b015160001960f88460031b161c19169055388080611046565b8181015183556020948501946001909301929091019061102b565b909150600484016101e0515260206101e05120601f840160051c8101602085106110dc575b90849392915b601f830160051c820181106110cb5750506108a0565b6101e05181558594506001016110b5565b50806110af565b01519050388061085a565b9250600384016101e0515260206101e05120906101e051935b601f198416851061114b576001945083601f19811610611132575b505050811b016003820155610872565b015160001960f88460031b161c19169055388080611122565b81810151835560209485019460019093019290910190611107565b909150600384016101e0515260206101e05120601f840160051c8101602085106111b8575b90849392915b601f830160051c820181106111a7575050610841565b6101e0518155859450600101611191565b508061118b565b634e487b7160e01b6101e051526101e05160045260246101e051fd5b9091506020813d602011611217575b816111f760209383611c9e565b81010312610c4757516001600160a01b0381168103610c47579038610690565b3d91506111ea565b6001600160401b038111610d595760405238610667565b60405163b06ebf3d60e01b8152600490fd5b61125190612078565b610140526102f1565b610104600435013560c0526102ac565b60e46004350135608052610292565b60c460043501359b610279565b6040516372bda9b160e11b8152600490fd5b5069d3c21bcecceda10000006101046004350135116101c8565b506a0c097ce7bc90715b34b9f160241b60043560e40135116101b4565b50683635c9adc5dea0000060c46004350135116101a1565b604051631b43d34f60e21b8152600490fd5b604051631790aef760e31b8152600490fd5b604051631ff3ed9d60e01b8152600490fd5b34610c47576101e051366003190112610c4757600a546040516001600160a01b039091168152602090f35b34610c47576020366003190112610c47576004356001600160a01b0381811691829003610c47576113776120ff565b81156113b0576101e05180546001600160a01b0319811684178255919091169060008051602061212c8339815191529080a36101e05180f35b604051631e4fbdf760e01b81526101e0516004820152602490fd5b34610c47576020366003190112610c47576004356001600160a01b03811690819003610c47576113f96120ff565b801561144057600880546001600160a01b031916821790556101e0517f7a7b5a0a132f9e0581eb8527f66eae9ee89c2a3e79d4ac7e41a1f1f4d48a7fc29080a26101e05180f35b604051633d9eb1db60e01b8152600490fd5b34610c47576101e051366003190112610c47576040516a0c097ce7bc90715b34b9f160241b8152602090f35b34610c47576101e051366003190112610c47576020604051683635c9adc5dea000008152f35b34610c47576020366003190112610c47576004356001600160a01b03811690819003610c47576114d26120ff565b801561151957600a80546001600160a01b031916821790556101e0517f7aed1d3e8155a07ccf395e44ea3109a0e2d6c9b29bbbe9f142d9790596f4dc809080a26101e05180f35b604051631ef88b9960e21b8152600490fd5b34610c47576101e051366003190112610c4757602060405169d3c21bcecceda10000008152f35b34610c47576101e051366003190112610c4757602060405160198152f35b34610c47576101e051366003190112610c47576101e051546040516001600160a01b039091168152602090f35b34610c47576101e051366003190112610c475760e0600154600254600354600454600554906006549260075494604051968752602087015260408601526060850152608084015260a083015260c0820152f35b34610c47576020366003190112610c475760043561160c6120ff565b6103e881116116655760198110611653576020817fd10d75876659a287a59a6ccfa2e3fff42f84d94b542837acd30bc184d562de4092600955604051908152a16101e05180f35b6040516306fc103f60e41b8152600490fd5b60405163cd4e616760e01b8152600490fd5b34610c47576101e051366003190112610c47576116926120ff565b6101e05180546001600160a01b0319811682556001600160a01b031660008051602061212c8339815191528280a36101e05180f35b34610c475760e0366003190112610c47576116e06120ff565b60405160e081016001600160401b03811182821017610d595760405260043580825260243590602083019282845260443593604082018581526064356060840192818452608435926080860184815260a4359560a088019287845260c060c4359901948986528a156118945751801515918261187c575b50501561186a5780511561185857683635c9adc5dea000009051116112865780511561184657516a0c097ce7bc90715b34b9f160241b10611286578051156118345769d3c21bcecceda100000090511161128657612710905111611822577f7c4abc5e661f62070299968a3a9a482d60903a066b120d28cc5512eec5ee38f29660e09686600155806002558160035582600455836005558460065585600755604051968752602087015260408601526060850152608084015260a083015260c0820152a16101e05180f35b604051630cc8afa560e31b8152600490fd5b6040516301c7164760e41b8152600490fd5b6040516382a62b8560e01b8152600490fd5b604051637294708f60e11b8152600490fd5b60405163d2de546160e01b8152600490fd5b51612710925061188b91611bc5565b11158c80611757565b604051639fbba64f60e01b8152600490fd5b34610c47576101e051366003190112610c47576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b34610c47576101e051366003190112610c4757600b546040516001600160a01b039091168152602090f35b34610c47576020366003190112610c4757600435611934611cd8565b50600c5481101561196c5761195461194e61196892611d30565b50611e58565b604051918291602083526020830190611ada565b0390f35b604051632d0483c560e21b8152600490fd5b34610c47576101e051366003190112610c47576008546040516001600160a01b039091168152602090f35b34610c47576101e051366003190112610c47576020600c54604051908152f35b34610c47576101e051366003190112610c47576020600954604051908152f35b34610c47576040366003190112610c4757611a08602435600435611f0b565b60405160209160208201926020835281518094526040830193602060408260051b8601019301916101e051955b828710611a425785850386f35b909192938280611a5e600193603f198a82030186528851611ada565b9601920196019592919092611a35565b34610c47576060366003190112610c47576020611a92604435602435600435611bd2565b604051908152f35b919082519283825260005b848110611ac6575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201611aa5565b90611b84611b70611b5e611b4c611b3a611b2861014060018060a01b03808a511689528060208b01511660208a015260408a01511660408901526060890151908060608a0152880190611a9a565b60808801518782036080890152611a9a565b60a087015186820360a0880152611a9a565b60c086015185820360c0870152611a9a565b60e085015184820360e0860152611a9a565b610100808501519084830390850152611a9a565b610120928301516001600160401b0316919092015290565b81810292918115918404141715611baf57565b634e487b7160e01b600052601160045260246000fd5b91908201809211611baf57565b8015611c6457611c3c92611c2d928015611c5a57905b828115611c3f57611c06670de0b6b3a764000091611c269394611b9c565b0492611c21816a0c097ce7bc90715b34b9f160251b94611b9c565b611b9c565b0490611bc5565b612710611c2660095483611b9c565b90565b611c269150611c06670de0b6b3a76400009160055494611b9c565b5060045490611be8565b505050600090565b61014081019081106001600160401b03821117611c8857604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017611c8857604052565b6001600160401b038111611c885760051b60200190565b60405190611ce582611c6c565b600061012083828152826020820152826040820152606080808301528060808301528060a08301528060c08301528060e08301526101008201520152565b91908203918211611baf57565b600c54811015611d4f57600c600052600a602060002091020190600090565b634e487b7160e01b600052603260045260246000fd5b8051821015611d4f5760209160051b010190565b90600182811c92168015611da9575b6020831014611d9357565b634e487b7160e01b600052602260045260246000fd5b91607f1691611d88565b90604051918260008254611dc681611d79565b90818452602094600191600181169081600014611e365750600114611df7575b505050611df592500383611c9e565b565b600090815285812095935091905b818310611e1e575050611df59350820101388080611de6565b85548884018501529485019487945091830191611e05565b92505050611df594925060ff191682840152151560051b820101388080611de6565b90604051611e6581611c6c565b82546001600160a01b039081168252600184015481166020830152600284015416604082015291829061012090611e9e60038201611db3565b6060840152611eaf60048201611db3565b6080840152611ec060058201611db3565b60a0840152611ed160068201611db3565b60c0840152611ee260078201611db3565b60e0840152611ef360088201611db3565b610100840152600901546001600160401b0316910152565b9190600c549081158081159182612038575b15612026579061201e575b611ff657611f369084611bc5565b90808211611fee575b5082600091818111600014611fe757611f589250611d23565b611f6181611cc1565b611f6e6040519182611c9e565b818152601f19611f7d83611cc1565b0160005b818110611fd0575050809360005b838110611f9c5750505050565b80611fb461194e611faf60019486611bc5565b611d30565b611fbe8286611d65565b52611fc98185611d65565b5001611f8f565b602090611fdb611cd8565b82828601015201611f81565b5050611f58565b905038611f3f565b5050604051909150602081016001600160401b03811182821017611c88576040526000815290565b508015611f28565b604051632930eba560e11b8152600490fd5b50838610611f1d565b903590601e198136030182121561207357018035906001600160401b0382116120735760200191813603831361207357565b600080fd5b356001600160a01b03811681036120735790565b6001600160401b038111611c8857601f01601f191660200190565b9291926120b38261208c565b916120c16040519384611c9e565b829481845281830111612073578281602093846000960137010152565b908060209392818452848401376000828201840152601f01601f1916010190565b6000546001600160a01b0316330361211357565b60405163118cdaa760e01b8152336004820152602490fdfe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0a164736f6c6343000818000a6080806040523461006b576001600081815581546001600160a01b031981168317835582916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a360ff19601f541617601f5561421c90816100718239f35b600080fdfe60808060405260043610156200001f575b5036156200001d57600080fd5b005b600090813560e01c90816302c7e7af14620028be5750806318160ddd146200289e5780631dd9e2df14620027a75780631f0c57fc146200277c5780632138a4c0146200275c57806335659fb8146200273c578063365d57a4146200271c578063366ad25014620026b75780633794f6be14620024df578063381562c214620024bf57806346904840146200249457806354354629146200247457806354e42f7e146200245457806360068dd8146200241157806365161831146200224a5780636700e332146200221f5780636915712d14620020485780636bb38b281462001f88578063715018a61462001f385780638091f3bf1462001f1357806386f2ece01462001ef357806389f2f0851462001ed35780638da5cb5b1462001ea85780639d1b464a1462001e7b5780639e6ea74d1462001c7e578063a4b20f131462001c5e578063af7695451462001bef578063b6013cef146200164c578063b915d4be1462001616578063ba49a08c14620015f6578063beb0a4161462001559578063bec92898146200151c578063c45a015514620014f1578063c59f5eed14620006fe578063c7876ea414620006de578063c9f62af214620006be578063cd1fc09f146200069e578063dd1a2a391462000601578063ed33da2714620003bd578063f20f3d9014620002e3578063f2fde38b1462000284578063f887ea4014620002595763fc0c546a0362000010573462000256578060031936011262000256576002546040516001600160a01b039091168152602090f35b80fd5b503462000256578060031936011262000256576004546040516001600160a01b039091168152602090f35b5034620002565760203660031901126200025657620002a2620028f8565b620002ac62002fe2565b6001600160a01b03811615620002ca57620002c7906200300f565b80f35b604051631e4fbdf760e01b815260048101839052602490fd5b50346200025657806003193601126200025657604051600b546000826200030a8362002924565b91828252602093600190856001821691826000146200039b57505060011462000357575b506200033d9250038362002991565b62000353604051928284938452830190620029b5565b0390f35b849150600b60005281600020906000915b858310620003825750506200033d9350820101856200032e565b8054838901850152879450869390920191810162000368565b60ff1916858201526200033d95151560051b85010192508791506200032e9050565b5060603660031901126200025657620003d5620028f8565b6005546001600160a01b039060243590620003f4908316331462002c6f565b620003fe62002e28565b818316916200040f83151562002cab565b6200042060ff601854161562002b30565b6200042d82151562002a95565b620004776017546200044f62000444858362002ba9565b601454101562002bb7565b620004706200046962000463868462002ba9565b62003153565b9162003153565b9062002b0c565b620004828162002e4c565b6200048e818362002ba9565b956200049f60443588111562002b71565b620004ad8734101562002bef565b620004bb83601a5462002ba9565b601a55858852601d60205260408820805460ff811615620005ba575b50509360019593600080516020620041f083398151915293604093620005178460209c99620005098260175462002ba9565b601755856003541662002fb5565b62000559575b50508634116200053c575b81519081528688820152a255604051908152f35b620005536200054c883462002b0c565b3362002f62565b62000528565b620005649062002e71565b915080151580620005ac575b62000595575b5080156200051d576200058d916007541662002ee6565b38806200051d565b620005a590836006541662002ee6565b3862000576565b508260065416151562000570565b60019060ff1916179055601c5460018101809111620005ed57601c5583600080516020620041f0833981519152620004d7565b634e487b7160e01b89526011600452602489fd5b50346200025657806003193601126200025657604051600d54600082620006288362002924565b91828252602093600190856001821691826000146200039b5750506001146200065a57506200033d9250038362002991565b849150600d60005281600020906000915b858310620006855750506200033d9350820101856200032e565b805483890185015287945086939092019181016200066b565b503462000256578060031936011262000256576020600854604051908152f35b503462000256578060031936011262000256576020601154604051908152f35b503462000256578060031936011262000256576020600e54604051908152f35b503462000256576003199060203683011262000256576001600160401b036004351162000256576102a080926004353603011262000256576040519182016001600160401b03811183821017620014db576040526004803501356001600160401b038111620014d7576200077a90600436918135010162002a13565b8252600435602401356001600160401b038111620014d757620007a590600436918135010162002a13565b6020830190815290600435604401356001600160401b038111620014d757620007d690600436918135010162002a13565b6040840152600435606401356001600160401b038111620014d7576200080490600436918135010162002a13565b6060840152600435608401356001600160401b038111620014d7576200083290600436918135010162002a13565b608084015260043560a401356001600160401b038111620014d7576200086090600436918135010162002a13565b60a084015260043560c481013560c085015260e481013560e08501526101048101356101008501526101248101356101208501526101448101356101408501526101648101356101608501526101848101356101808501526101a48101356101a08501526101c48101356101c0850152620008df906101e4016200290f565b6101e0840152620008f6610204600435016200290f565b6102008401526200090d610224600435016200290f565b61022084015262000924610244600435016200290f565b6102408401526200093b610264600435016200290f565b61026084015262000952610284600435016200290f565b610280840152601f5460ff8116620014a45760ff1916600117601f5560c0830151156200146e5760e0830151801515908162001461575b50156200143057612710620009a960e08501516101008601519062002ba9565b11620013f85761012083015115620013c6576101408301511562001394576102008301516001600160a01b03161562001361576102608301516001600160a01b0316156200132d5761271061018084015111620012f8576127106101a084015111620012c4576101c08301516101a0840151106200128d576101e08301516001600160a01b031615620012515760408301515115620012215761026083015162000a5c906001600160a01b03166200300f565b604083015180519093906001600160401b03811162000f5d5762000a82600a5462002924565b601f8111620011ce575b506020601f821160011462001155578394958293949262001149575b50508160011b916000199060031b1c191617600a555b606081015180519093906001600160401b038111620011355762000ae4600b5462002924565b601f8111620010e2575b506020601f82116001146200106957849582939495926200105d575b50508160011b916000199060031b1c191617600b555b608082015180519093906001600160401b038111620010495762000b46600c5462002924565b601f811162000ff6575b506020601f821160011462000f7d578293949582939262000f71575b50508160011b916000199060031b1c191617600c555b60a083015180519093906001600160401b03811162000f5d5762000ba8600d5462002924565b601f811162000f0a575b506020601f821160011462000e91578394958293949262000e85575b50508160011b916000199060031b1c191617600d555b610120810151600e55610140810151600f556101608101516010556101808101516011556101a0810151601255610280810151600580546001600160a01b03199081166001600160a01b03938416179091556102408301516006805483169184169190911790556101e0830151600780549092169083161790556101c0820151600855610220820151168062000e7f57506102608101516001600160a01b03165b600980546001600160a01b039283166001600160a01b0319918216179091556102008301516004805491909316911617905560c0810151601381905560e082015162000d119162000d17916127109162000ce0919062002ce9565b048060145561271062000cfe60c08601516101008701519062002ce9565b049283918260155560c086015162002b0c565b62002b0c565b6016551562000e49578051925160c082015160405190949091610f6a80840192906001600160401b0384118585101762000e355786979262000d6f86959362000d7e93620031e68839608085526080850190620029b5565b908382036020850152620029b5565b916040820152606030910152039083f0801562000e2657600280546001600160a01b03198082166001600160a01b0390941693841790925560038054909216908516909217918217905560c0919091015190803b1562000e31576040516340c10f1960e01b8152918391839182908490829062000e0090306004840162002cfd565b03925af1801562000e265762000e135750f35b62000e1e9062002961565b620002565780f35b6040513d84823e3d90fd5b5050fd5b634e487b7160e01b87526041600452602487fd5b60405162461bcd60e51b815260206004820152600e60248201526d6c6971756964697479207a65726f60901b6044820152606490fd5b62000c85565b01519050388062000bce565b600d84526000805160206200419083398151915290845b601f198416811062000ef1575060019394959683601f1981161062000ed7575b505050811b01600d5562000be4565b015160001960f88460031b161c1916905538808062000ec8565b9091602060018192858b01518155019301910162000ea8565b600d845260008051602062004190833981519152601f830160051c81016020841062000f55575b601f830160051c8201811062000f4957505062000bb2565b85815560010162000f31565b508062000f31565b634e487b7160e01b83526041600452602483fd5b01519050388062000b6c565b600c83526000805160206200415083398151915290835b601f198416811062000fdd575060019394959683601f1981161062000fc3575b505050811b01600c5562000b82565b015160001960f88460031b161c1916905538808062000fb4565b9091602060018192858b01518155019301910162000f94565b600c835260008051602062004150833981519152601f830160051c81016020841062001041575b601f830160051c820181106200103557505062000b50565b8481556001016200101d565b50806200101d565b634e487b7160e01b82526041600452602482fd5b01519050388062000b0a565b600b8552600080516020620041d083398151915290855b601f1984168110620010c9575060019394959683601f19811610620010af575b505050811b01600b5562000b20565b015160001960f88460031b161c19169055388080620010a0565b9091602060018192858b01518155019301910162001080565b600b8552600080516020620041d0833981519152601f830160051c8101602084106200112d575b601f830160051c820181106200112157505062000aee565b86815560010162001109565b508062001109565b634e487b7160e01b84526041600452602484fd5b01519050388062000aa8565b600a84526000805160206200417083398151915290845b601f1984168110620011b5575060019394959683601f198116106200119b575b505050811b01600a5562000abe565b015160001960f88460031b161c191690553880806200118c565b9091602060018192858b0151815501930191016200116c565b600a845260008051602062004170833981519152601f830160051c81016020841062001219575b601f830160051c820181106200120d57505062000a8c565b858155600101620011f5565b5080620011f5565b60405162461bcd60e51b81526020600482015260086024820152676c6f676f2075726960c01b6044820152606490fd5b60405162461bcd60e51b81526020600482015260146024820152736c6561677565207265636569766572207a65726f60601b6044820152606490fd5b60405162461bcd60e51b815260206004820152600f60248201526e1b195859dd594f9c1c9bdd1bd8dbdb608a1b6044820152606490fd5b60405162461bcd60e51b815260206004820152600c60248201526b70726f746f636f6c2062707360a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600d60248201526c6c69717569646974792062707360981b6044820152606490fd5b60405162461bcd60e51b815260206004820152600c60248201526b63726561746f72207a65726f60a01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600b60248201526a726f75746572207a65726f60a81b6044820152606490fd5b60405162461bcd60e51b815260206004820152600a602482015269736c6f7065207a65726f60b01b6044820152606490fd5b60405162461bcd60e51b815260206004820152600a6024820152697072696365207a65726f60b01b6044820152606490fd5b60405162461bcd60e51b815260206004820152601060248201526f706f7274696f6e206f766572666c6f7760801b6044820152606490fd5b60405162461bcd60e51b815260206004820152600960248201526863757276652062707360b81b6044820152606490fd5b6127109150103862000989565b60405162461bcd60e51b815260206004820152600e60248201526d696e76616c696420737570706c7960901b6044820152606490fd5b60405162461bcd60e51b815260206004820152600b60248201526a1a5b9a5d1a585b1a5e995960aa1b6044820152606490fd5b5080fd5b634e487b7160e01b600052604160045260246000fd5b503462000256578060031936011262000256576005546040516001600160a01b039091168152602090f35b50346200025657602036600319011262000256576020906040906001600160a01b0362001548620028f8565b168152601e83522054604051908152f35b50346200025657806003193601126200025657604051600c54600082620015808362002924565b91828252602093600190856001821691826000146200039b575050600114620015b257506200033d9250038362002991565b849150600c60005281600020906000915b858310620015dd5750506200033d9350820101856200032e565b80548389018501528794508693909201918101620015c3565b503462000256578060031936011262000256576020601c54604051908152f35b503462000256576020366003190112620002565760606200163960043562002d18565b9060405192835260208301526040820152f35b503462000256576200165e36620028dc565b6200166862002fe2565b6200167262002e28565b829183916018549160ff831662001bbe5760175460145414801562001bb1575b1562001b80576001620016bc9360ff19161760185542601955476127109384916012549062002ce9565b04928315158062001b6b575b62001b4c575b620016dd476011549062002ce9565b0490601554918215158062001b42575b62001893575b5050505083620017096014546017549062002b0c565b806200181b575b505060165480620017f5575b504780620017d6575b60025485906001600160a01b0316803b15620014d75781906004604051809481936322a3148f60e21b83525af18015620017cb57620017af575b50936001916040958651918683528560208401528783015260608201527fd286a958d004cd376acc3762fff407f0dd9bf991995fc81a26ff88081f2b7d1b60803392a25582519182526020820152f35b620017bb869162002961565b620017c757386200175f565b8480fd5b6040513d88823e3d90fd5b600154620017ef9082906001600160a01b031662002f62565b62001725565b6003546001546200181492916001600160a01b03918216911662002fb5565b386200171c565b6002546001600160a01b031690813b156200188f5782916200185591604051948580948193632770a7eb60e21b8352306004840162002cfd565b03925af1801562001884576200186e575b849062001710565b6200187c9094919462002961565b923862001866565b6040513d87823e3d90fd5b8280fd5b60035460045460405163095ea7b360e01b6020820152959850939650919390926001600160a01b039081169216620018e482620018d589866024840162002cfd565b03601f19810184528362002991565b602089835182850182855af189513d8262001b23575b50501562001ae6575b50506004546002546009546001600160a01b03918216949350918116911642610708810110620005ed5791606094939160c493604051998a96879563f305d71960e01b875260048701528a6024870152604486015260648501526084840152610708420160a48401525af1801562001adb578493859162001a98575b5060035460045460405163095ea7b360e01b60208083019182526001600160a01b039384166024840181905260448085018c905284529597958995909416918a90620019cb8562002975565b84519082855af189513d8262001a79575b50501562001a2f575b505050808211620019f9575b8080620016f3565b60035460015462001a27936001600160a01b0392831693929091169162001a209162002b0c565b9162002fb5565b3880620019f1565b62001a6a62001a70936040519063095ea7b360e01b602083015260248201528a60448201526044815262001a638162002975565b8262003179565b62003179565b388080620019e5565b90915062001a8f5750803b15155b3880620019dc565b60011462001a87565b9350506060833d60601162001ad2575b8162001ab76060938362002991565b8101031262001ace5760208351930151386200197f565b8380fd5b3d915062001aa8565b6040513d86823e3d90fd5b62001a6a62001b1a936040519063095ea7b360e01b602083015260248201528a60448201526044815262001a638162002975565b38808062001903565b90915062001b395750803b15155b3880620018fa565b60011462001b31565b50801515620016ed565b60065462001b659085906001600160a01b031662002ee6565b620016ce565b506006546001600160a01b03161515620016c8565b60405162461bcd60e51b81526020600482015260096024820152681d1a1c995cda1bdb1960ba1b6044820152606490fd5b5047601054111562001692565b60405162461bcd60e51b8152602060048201526009602482015268199a5b985b1a5e995960ba1b6044820152606490fd5b5034620002565760203660031901126200025657602062001c5662001c4460043562001c1d81151562002a95565b6200047062000469620004636017549362001c3d62000444828762002ba9565b8462002ba9565b62001c4f8162002e4c565b9062002ba9565b604051908152f35b503462000256578060031936011262000256576020601054604051908152f35b506040366003190112620002565762001c96620028f8565b6005546001600160a01b039062001cb1908216331462002c6f565b62001cbb62002e28565b80821662001ccb81151562002cab565b62001cdc60ff601854161562002b30565b62001ce73462002d18565b5092909362001cf885151562002a95565b62001d0860243586101562002b71565b62001d3360175462001d1f62000444888362002ba9565b620004706200046962000463898462002ba9565b9062001d3f8262002e4c565b9062001d5962001d50838562002ba9565b96871462002c31565b62001d6783601a5462002ba9565b601a55848852601d60205260408820805460ff81161562001e54575b505091604097939162001da28860019795620005098260175462002ba9565b62001df3575b505083341162001ddd575b600080516020620041f0833981519152868051878152866020820152a25582519182526020820152f35b62001ded6200054c853462002b0c565b62001db3565b62001dfe9062002e71565b91508015158062001e46575b62001e2f575b50801562001da85762001e27916007541662002ee6565b388062001da8565b62001e3f90836006541662002ee6565b3862001e10565b508260065416151562001e0a565b60019060ff1916179055601c5460018101809111620005ed57601c558162001da262001d83565b50346200025657806003193601126200025657602062001c56600e5462001c4f600f546017549062003047565b503462000256578060031936011262000256576001546040516001600160a01b039091168152602090f35b503462000256578060031936011262000256576020601b54604051908152f35b503462000256578060031936011262000256576020601a54604051908152f35b50346200025657806003193601126200025657602060ff601854166040519015158152f35b5034620002565780600319360112620002565762001f5562002fe2565b600180546001600160a01b0319811690915581906001600160a01b0316600080516020620041b08339815191528280a380f35b50346200025657806003193601126200025657604051908082600a549162001fb08362002924565b92838352602094600191866001821691826000146200202457505060011462001fe4575b50506200033d9250038362002991565b90859250600a82528282205b8583106200200b5750506200033d9350820101388062001fd4565b8054838901850152879450869390920191810162001ff0565b92509350506200033d94915060ff191682840152151560051b820101388062001fd4565b50602036600319011262000256576200206062002e28565b6200207160ff601854161562002b30565b6200207c3462002d18565b506200208a82151562002a95565b6200209a60043583101562002b71565b620020b16017546200044f62000444858362002ba9565b620020bc8162002e4c565b90620020d6620020cd838362002ba9565b93841462002c31565b620020e481601a5462002ba9565b601a55338552601d60205260408520805460ff811615620021e6575b505093600191604095620021178660175462002ba9565b601755838060a01b0391620021328733856003541662002fb5565b62002185575b50508234116200216f575b8451848152836020820152600080516020620041f0833981519152863392a25582519182526020820152f35b6200217f6200054c843462002b0c565b62002143565b620021909062002e71565b915080151580620021d8575b620021c1575b5080156200213857620021b9916007541662002ee6565b388062002138565b620021d190836006541662002ee6565b38620021a2565b50826006541615156200219c565b60019060ff1916179055601c54600181018091116200220b57601c5581604062002100565b634e487b7160e01b86526011600452602486fd5b503462000256578060031936011262000256576007546040516001600160a01b039091168152602090f35b506200225636620028dc565b906200226162002e28565b6200227260ff601854161562002b30565b6200227f81151562002a95565b620022aa6017546200229662000444848362002ba9565b620004706200046962000463858462002ba9565b620022b58162002e4c565b90620022d0620022c6838362002ba9565b9485111562002b71565b620022de8434101562002bef565b620022ec81601a5462002ba9565b601a55338552601d60205260408520805460ff811615620023ec575b50509160209491600193620023208360175462002ba9565b601755848060a01b03916200233b8433856003541662002fb5565b6200238b575b505083341162002375575b6040519081528385820152600080516020620041f083398151915260403392a255604051908152f35b620023856200054c853462002b0c565b6200234c565b620023969062002e71565b915080151580620023de575b620023c7575b5080156200234157620023bf916007541662002ee6565b388062002341565b620023d790836006541662002ee6565b38620023a8565b5082600654161515620023a2565b60019060ff1916179055601c54600181018091116200220b57601c5581600162002308565b503462000256576020366003190112620002565760209060ff906040906001600160a01b0362002440620028f8565b168152601d84522054166040519015158152f35b503462000256578060031936011262000256576020600f54604051908152f35b503462000256578060031936011262000256576020601654604051908152f35b503462000256578060031936011262000256576006546040516001600160a01b039091168152602090f35b503462000256578060031936011262000256576020601554604051908152f35b50346200025657620024f136620028dc565b90620024fc62002e28565b6200250d60ff601854161562002b30565b6200251a81151562002a95565b6017546200252b8183111562002ad0565b6200254a6200253a8262003153565b6200047062000463858562002b0c565b9062002576836200255b8462002e4c565b9262000d116200256c858762002b0c565b9788101562002b71565b6017556003546040516323b872dd60e01b6020820152336024820152306044820152606480820186905281526001600160a01b039291831660a082016001600160401b03811183821017620026a35792620025e260209996936001989693620025fe9660405262003179565b6200263b575b50620025f5863362002f62565b601b5462002ba9565b601b5560405190815283858201527f2dcf9433d75db0d8b1c172641f85e319ffe4ad22e108a95d1847ceb906e5195d60403392a255604051908152f35b620026468262002e71565b91508015158062002695575b6200267e575b508062002667575b50620025e8565b62002676916007541662002ee6565b388062002660565b6200268e90836006541662002ee6565b3862002658565b508260065416151562002652565b634e487b7160e01b89526041600452602489fd5b5034620002565760203660031901126200025657602062001c5662002711600435620026e581151562002a95565b620004706200046360175492620026ff8482111562002ad0565b6200270a8462003153565b9362002b0c565b620004708162002e4c565b503462000256578060031936011262000256576020601954604051908152f35b503462000256578060031936011262000256576020601254604051908152f35b503462000256578060031936011262000256576020601454604051908152f35b503462000256578060031936011262000256576009546040516001600160a01b039091168152602090f35b50346200025657806003193601126200025657620027c462002e28565b338152602090601e825260408120549081156200286c57338152601e83528060408120558080808085335af1620027fa62002a60565b501562002838576001906040518381527f7b3fcf6b642a0d537ec94e3e3554737ca883871bc8a5ea348d8ee3a9b9d9656c853392a255604051908152f35b60405162461bcd60e51b815260048101849052600c60248201526b18db185a5b4819985a5b195960a21b6044820152606490fd5b60405162461bcd60e51b815260048101849052600a6024820152696e6f2070656e64696e6760b01b6044820152606490fd5b503462000256578060031936011262000256576020601354604051908152f35b905034620014d75781600319360112620014d7576020906017548152f35b6040906003190112620028f3576004359060243590565b600080fd5b600435906001600160a01b0382168203620028f357565b35906001600160a01b0382168203620028f357565b90600182811c9216801562002956575b60208310146200294057565b634e487b7160e01b600052602260045260246000fd5b91607f169162002934565b6001600160401b038111620014db57604052565b608081019081106001600160401b03821117620014db57604052565b601f909101601f19168101906001600160401b03821190821017620014db57604052565b919082519283825260005b848110620029e2575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201620029c0565b6001600160401b038111620014db57601f01601f191660200190565b81601f82011215620028f35780359062002a2d82620029f7565b9262002a3d604051948562002991565b82845260208383010111620028f357816000926020809301838601378301015290565b3d1562002a90573d9062002a7482620029f7565b9162002a84604051938462002991565b82523d6000602084013e565b606090565b1562002a9d57565b60405162461bcd60e51b815260206004820152600b60248201526a1e995c9bc8185b5bdd5b9d60aa1b6044820152606490fd5b1562002ad857565b60405162461bcd60e51b815260206004820152600c60248201526b195e18d959591cc81cdbdb1960a21b6044820152606490fd5b9190820391821162002b1a57565b634e487b7160e01b600052601160045260246000fd5b1562002b3857565b60405162461bcd60e51b815260206004820152601160248201527018d85b5c185a59db881b185d5b98da1959607a1b6044820152606490fd5b1562002b7957565b60405162461bcd60e51b8152602060048201526008602482015267736c69707061676560c01b6044820152606490fd5b9190820180921162002b1a57565b1562002bbf57565b60405162461bcd60e51b81526020600482015260086024820152671cdbdb19081bdd5d60c21b6044820152606490fd5b1562002bf757565b60405162461bcd60e51b8152602060048201526012602482015271696e73756666696369656e742076616c756560701b6044820152606490fd5b1562002c3957565b60405162461bcd60e51b815260206004820152600e60248201526d0e2eadee8ca40dad2e6dac2e8c6d60931b6044820152606490fd5b1562002c7757565b60405162461bcd60e51b815260206004820152600c60248201526b4f4e4c595f464143544f525960a01b6044820152606490fd5b1562002cb357565b60405162461bcd60e51b815260206004820152600e60248201526d1e995c9bc81c9958da5c1a595b9d60921b6044820152606490fd5b8181029291811591840414171562002b1a57565b6001600160a01b039091168152602081019190915260400190565b90811562002e1e5760ff6018541662002e1e5760145462002d3d601754809262002b0c565b92831562002e1257600093905b81851062002d9b575050821562002d9057806200047062000469620004638662002d749562002ba9565b9062002d8c62002d848362002e4c565b809362002ba9565b9190565b506000915081908190565b909362002da9858262002ba9565b600180820180921162002b1a571c908262002ddc62001c4462002dd162000463868962002ba9565b620004708862003153565b1162002dec5750935b9062002d4a565b945060001981019081111562002de557634e487b7160e01b600052601160045260246000fd5b50600092508291829150565b6000915081908190565b60026000541462002e3a576002600055565b604051633ee5aeb560e01b8152600490fd5b60125490811562002e6a576127109162002e669162002ce9565b0490565b5050600090565b9062002e7d8262002e4c565b91821562002d905762002e97612710916008549062002ce9565b600754919004906001600160a01b031615801562002edd575b62002ed55782811162002ecd575b62002eca818462002b0c565b91565b508162002ebe565b508190600090565b50801562002eb0565b811562002f5e576001600160a01b03169060008080808085875af162002f0b62002a60565b501562002f1757505050565b7f1196ff9c61f6c4d265bb9529d5aa6afceea1fc7646a5c406fcc1dcb61941db15916040828560209452601e84522062002f5382825462002ba9565b9055604051908152a2565b5050565b600080809381935af162002f7562002a60565b501562002f7e57565b60405162461bcd60e51b815260206004820152600f60248201526e1d1c985b9cd9995c8819985a5b1959608a1b6044820152606490fd5b62001a6a62002fe09392620018d560405194859263a9059cbb60e01b60208501526024840162002cfd565b565b6001546001600160a01b0316330362002ff757565b60405163118cdaa760e01b8152336004820152602490fd5b600180546001600160a01b039283166001600160a01b031982168117909255909116600080516020620041b0833981519152600080a3565b9060001981830981830291828083109203918083039214620030bf57670de0b6b3a76400009082821115620030ac577faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac10669940990828211900360ee1b910360121c170290565b634e487b7160005260116020526024601cfd5b5050670de0b6b3a764000091500490565b90600019818309818302918280831092039180830392146200313b576a0c097ce7bc90715b34b9f160251b9082821115620030ac577f356317ffa45f828d2a41175b2aed3a20e7fdd4a4e46cc11944d93b01be7b1711940990828211900360db1b910360251c170290565b50506a0c097ce7bc90715b34b9f160251b9004919050565b620031769062001c4f6200316a600e548362003047565b918002600f54620030d0565b90565b906000602091828151910182855af115620031d9576000513d620031cf57506001600160a01b0381163b155b620031ad5750565b604051635274afe760e01b81526001600160a01b039091166004820152602490fd5b60011415620031a5565b6040513d6000823e3d90fdfe60a060405234620003de5762000f6a803803806200001d81620003e3565b9283398101608082820312620003de5781516001600160401b039190828111620003de57816200004f91850162000409565b6020918285015190848211620003de576200006c91860162000409565b90606060408601519501519060018060a01b0394858316809303620003de578151818111620002de576003908154906001948583811c93168015620003d3575b89841014620003bd578190601f9384811162000367575b5089908483116001146200030057600092620002f4575b505060001982851b1c191690851b1782555b8551928311620002de5760049586548581811c91168015620002d3575b89821014620002be5782811162000273575b50879184116001146200020857938394918492600095620001fc575b50501b92600019911b1c19161782555b8015620001e457600580546001600160a01b03198116831790915560405194167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a38315620001b75783608052604051610aee90816200047c823960805181818161052001526105f30152f35b62461bcd60e51b8352820152600b60248201526a636170206973207a65726f60a81b604482015260649150fd5b604051631e4fbdf760e01b8152600081840152602490fd5b01519350388062000137565b9190601f198416928760005284896000209460005b8b898383106200025b575050501062000240575b50505050811b01825562000147565b01519060f884600019921b161c191690553880808062000231565b8686015189559097019694850194889350016200021d565b87600052886000208380870160051c8201928b8810620002b4575b0160051c019086905b828110620002a75750506200011b565b6000815501869062000297565b925081926200028e565b602288634e487b7160e01b6000525260246000fd5b90607f169062000109565b634e487b7160e01b600052604160045260246000fd5b015190503880620000da565b90879350601f19831691866000528b6000209260005b8d82821062000350575050841162000337575b505050811b018255620000ec565b015160001983871b60f8161c1916905538808062000329565b8385015186558b9790950194938401930162000316565b90915084600052896000208480850160051c8201928c8610620003b3575b918991869594930160051c01915b828110620003a3575050620000c3565b6000815585945089910162000393565b9250819262000385565b634e487b7160e01b600052602260045260246000fd5b92607f1692620000ac565b600080fd5b6040519190601f01601f191682016001600160401b03811183821017620002de57604052565b919080601f84011215620003de5782516001600160401b038111620002de576020906200043f601f8201601f19168301620003e3565b92818452828287010111620003de5760005b8181106200046757508260009394955001015290565b85810183015184820184015282016200045156fe6080604081815260048036101561001557600080fd5b600092833560e01c90816306fdde03146107df57508063095ea7b31461073657806318160ddd1461071757806323b872dd14610632578063313ce56714610616578063355274ea146105db57806340c10f19146104d95780634ada218b146104b257806370a082311461047b578063715018a6146104305780638a8c523c146103fe5780638da5cb5b146103d557806395d89b41146102d15780639dc29fac146101d6578063a9059cbb146101a5578063dd62ed3e146101585763f2fde38b146100de57600080fd5b34610154576020366003190112610154576100f7610901565b90610100610a75565b6001600160a01b0391821692831561013e575050600580546001600160a01b03198116841790915516600080516020610aa28339815191528380a380f35b51631e4fbdf760e01b8152908101849052602490fd5b8280fd5b5050346101a157806003193601126101a15780602092610176610901565b61017e61091c565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b5050346101a157806003193601126101a1576020906101cf6101c5610901565b6024359033610973565b5160018152f35b508290346101a157826003193601126101a1576101f1610901565b90602435906101fe610a75565b6001600160a01b03838116939084156102ba5760055460ff8160a01c1615610288575b5050838552846020528585205491838310610269575050818495600080516020610ac2833981519152936020938688528785520381872055816002540360025551908152a380f35b6102848484895194859463391434e360e21b86528501610955565b0390fd5b168085141590816102af575b506102a0578680610221565b5084516312f1f92360e01b8152fd5b905033141587610294565b8651634b637e8f60e11b8152808401879052602490fd5b509190346101a157816003193601126101a15780519082845460018160011c90600183169283156103cb575b60209384841081146103b85783885290811561039c5750600114610364575b505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b0390f35b634e487b7160e01b815260418552602490fd5b919250868652828620918387935b838510610388575050505083010138808061031c565b805488860183015293019284908201610372565b60ff1916878501525050151560051b840101905038808061031c565b634e487b7160e01b895260228a52602489fd5b91607f16916102fd565b5050346101a157816003193601126101a15760055490516001600160a01b039091168152602090f35b833461042d578060031936011261042d57610417610a75565b6005805460ff60a01b1916600160a01b17905580f35b80fd5b833461042d578060031936011261042d57610449610a75565b600580546001600160a01b0319811690915581906001600160a01b0316600080516020610aa28339815191528280a380f35b5050346101a15760203660031901126101a15760209181906001600160a01b036104a3610901565b16815280845220549051908152f35b5050346101a157816003193601126101a15760209060ff60055460a01c1690519015158152f35b5090346101545780600319360112610154576104f3610901565b9060243591610500610a75565b6001600160a01b03169283156105af576002549061051e8483610932565b7f00000000000000000000000000000000000000000000000000000000000000001061057d575082600080516020610ac2833981519152926105638795602094610932565b60025585855284835280852082815401905551908152a380f35b606490602084519162461bcd60e51b8352820152600c60248201526b18d85c08195e18d95959195960a21b6044820152fd5b6020606492519162461bcd60e51b83528201526007602482015266746f207a65726f60c81b6044820152fd5b5050346101a157816003193601126101a157602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5050346101a157816003193601126101a1576020905160128152f35b50823461042d57606036600319011261042d5761064d610901565b61065561091c565b916044359360018060a01b038316808352600160205286832033845260205286832054916000198310610691575b6020886101cf898989610973565b8683106106f95781156106e25733156106cb575082526001602090815286832033845281529186902090859003905582906101cf87610683565b8751634a1406b160e11b8152908101849052602490fd5b875163e602df0560e01b8152908101849052602490fd5b9050610284868851938493637dc7a0d960e11b855233908501610955565b5050346101a157816003193601126101a1576020906002549051908152f35b503461015457816003193601126101545761074f610901565b6024359033156107c8576001600160a01b03169182156107b157508083602095338152600187528181208582528752205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b8351634a1406b160e11b8152908101859052602490fd5b835163e602df0560e01b8152808401869052602490fd5b84915083346101545782600319360112610154578260035460018160011c90600183169283156108ae575b60209384841081146103b857838852908115610892575060011461085957505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b91925060038652828620918387935b83851061087e575050505083010185808061031c565b805488860183015293019284908201610868565b60ff1916878501525050151560051b840101905085808061031c565b91607f169161080a565b6020808252825181830181905290939260005b8281106108ed57505060409293506000838284010152601f8019910116010190565b8181018601518482016040015285016108cb565b600435906001600160a01b038216820361091757565b600080fd5b602435906001600160a01b038216820361091757565b9190820180921161093f57565b634e487b7160e01b600052601160045260246000fd5b604091949392606082019560018060a01b0316825260208201520152565b6001600160a01b0392838216929091908315610a5c578416938415610a435760055460ff8160a01c1615610a0e575b5050600090838252816020526040822054908382106109f157509160408282600080516020610ac2833981519152958760209652828652038282205586815220818154019055604051908152a3565b6102848460405193849363391434e360e21b855260048501610955565b16808414159081610a38575b50610a265738806109a2565b6040516312f1f92360e01b8152600490fd5b905033141538610a1a565b60405163ec442f0560e01b815260006004820152602490fd5b604051634b637e8f60e11b815260006004820152602490fd5b6005546001600160a01b03163303610a8957565b60405163118cdaa760e01b8152336004820152602490fdfe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa164736f6c6343000818000adf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c7c65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2a8d7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb58be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e00175b7a638427703f0dbe7bb9bbf987a2551717b34e79f33b5b1008d1fa01db98fafebcaf9d154343dad25669bfa277f4fbacd7ac6b0c4fed522580e040a0f33a164736f6c6343000818000a";

type LaunchFactoryConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: LaunchFactoryConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class LaunchFactory__factory extends ContractFactory {
  constructor(...args: LaunchFactoryConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    router_: AddressLike,
    leagueReceiver_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      router_,
      leagueReceiver_,
      overrides || {}
    );
  }
  override deploy(
    router_: AddressLike,
    leagueReceiver_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(router_, leagueReceiver_, overrides || {}) as Promise<
      LaunchFactory & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): LaunchFactory__factory {
    return super.connect(runner) as LaunchFactory__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): LaunchFactoryInterface {
    return new Interface(_abi) as LaunchFactoryInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): LaunchFactory {
    return new Contract(address, _abi, runner) as unknown as LaunchFactory;
  }
}
</file>

<file path="typechain-types/factories/contracts/LpTimelock__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  BigNumberish,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../common";
import type {
  LpTimelock,
  LpTimelockInterface,
} from "../../contracts/LpTimelock";

const _abi = [
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "token_",
        type: "address",
      },
      {
        internalType: "address",
        name: "beneficiary_",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "releaseTime_",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [],
    name: "beneficiary",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "release",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "releaseTime",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const;

const _bytecode =
  "0x60e03461015757601f6104db38819003918201601f191683019291906001600160401b0384118385101761015c5781606092849260409687528339810103126101575780516001600160a01b03808216929091908382036101575760208101519283169081840361015757850151931561012957156100f557428311156100c35760805260a05260c05251610368908161017382396080518181816064015261012a015260a05181818161018301526102f3015260c05181818160ae015260e60152f35b835162461bcd60e51b815260206004820152600b60248201526a72656c6561736554696d6560a81b6044820152606490fd5b835162461bcd60e51b815260206004820152600d60248201526c062656e65666963696172793d3609c1b6044820152606490fd5b845162461bcd60e51b81526020600482015260076024820152660746f6b656e3d360cc1b6044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe608060408181526004918236101561001657600080fd5b600092833560e01c91826338af3eed146102df5750816386d1a69f146100d157508063b91d4001146100975763fc0c546a1461005157600080fd5b34610093578160031936011261009357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b5034610093578160031936011261009357602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b919050346102db57826003193601126102db577f000000000000000000000000000000000000000000000000000000000000000042106102a95780516370a0823160e01b81523083820152602091906001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811691908482602481865afa91821561029f57879261026c575b50811561023d579060448592888651958694859363a9059cbb60e01b85527f0000000000000000000000000000000000000000000000000000000000000000168b85015260248401525af19081156102335785916101f9575b50156101c6578380f35b5162461bcd60e51b815291820152600f60248201526e1d1c985b9cd9995c8819985a5b1959608a1b604482015260649150fd5b90508281813d831161022c575b6102108183610322565b810103126102285751801515810361022857386101bc565b8480fd5b503d610206565b82513d87823e3d90fd5b835162461bcd60e51b815280870186905260096024820152686e6f20746f6b656e7360b81b6044820152606490fd5b9091508481813d8311610298575b6102848183610322565b8101031261029457519038610163565b8680fd5b503d61027a565b84513d89823e3d90fd5b906020606492519162461bcd60e51b8352820152600c60248201526b1b9bdd081c995b19585cd95960a21b6044820152fd5b8280fd5b8490346100935781600319360112610093577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b601f909101601f19168101906001600160401b0382119082101761034557604052565b634e487b7160e01b600052604160045260246000fdfea164736f6c6343000818000a";

type LpTimelockConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: LpTimelockConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class LpTimelock__factory extends ContractFactory {
  constructor(...args: LpTimelockConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    token_: AddressLike,
    beneficiary_: AddressLike,
    releaseTime_: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      token_,
      beneficiary_,
      releaseTime_,
      overrides || {}
    );
  }
  override deploy(
    token_: AddressLike,
    beneficiary_: AddressLike,
    releaseTime_: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(
      token_,
      beneficiary_,
      releaseTime_,
      overrides || {}
    ) as Promise<
      LpTimelock & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): LpTimelock__factory {
    return super.connect(runner) as LpTimelock__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): LpTimelockInterface {
    return new Interface(_abi) as LpTimelockInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): LpTimelock {
    return new Contract(address, _abi, runner) as unknown as LpTimelock;
  }
}
</file>

<file path="typechain-types/factories/contracts/mocks/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { MockERC20__factory } from "./MockERC20__factory";
export { MockFeeOnTransferERC20__factory } from "./MockFeeOnTransferERC20__factory";
export { MockRouter__factory } from "./MockRouter__factory";
export { RevertingReceiver__factory } from "./RevertingReceiver__factory";
</file>

<file path="typechain-types/factories/contracts/mocks/MockERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  BigNumberish,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  MockERC20,
  MockERC20Interface,
} from "../../../contracts/mocks/MockERC20";

const _abi = [
  {
    inputs: [
      {
        internalType: "string",
        name: "name_",
        type: "string",
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "supply",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientAllowance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC20InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC20InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSpender",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

const _bytecode =
  "0x60406080815234620003b55762000a90803803806200001e81620003ba565b9283398101608082820312620003b55781516001600160401b039290838111620003b5578262000050918301620003e0565b6020928383015190858211620003b5576200006d918401620003e0565b906060868401519301519460018060a01b038616809603620003b5578151818111620002b5576003908154906001948583811c93168015620003aa575b8984101462000394578190601f938481116200033e575b508990848311600114620002d757600092620002cb575b505060001982851b1c191690851b1782555b8451928311620002b55760049485548581811c91168015620002aa575b8982101462000295578281116200024a575b5087918411600114620001df57938394918492600095620001d3575b50501b92600019911b1c19161781555b8315620001bc5760025490828201809211620001a7575060025560008381528083528481208054830190558451918252917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a35161063d9081620004538239f35b601190634e487b7160e01b6000525260246000fd5b602490600086519163ec442f0560e01b8352820152fd5b01519350388062000135565b9190601f198416928660005284896000209460005b8b8983831062000232575050501062000217575b50505050811b01815562000145565b01519060f884600019921b161c191690553880808062000208565b868601518955909701969485019488935001620001f4565b86600052886000208380870160051c8201928b88106200028b575b0160051c019086905b8281106200027e57505062000119565b600081550186906200026e565b9250819262000265565b602287634e487b7160e01b6000525260246000fd5b90607f169062000107565b634e487b7160e01b600052604160045260246000fd5b015190503880620000d8565b90879350601f19831691866000528b6000209260005b8d8282106200032757505084116200030e575b505050811b018255620000ea565b015160001983871b60f8161c1916905538808062000300565b8385015186558b97909501949384019301620002ed565b90915084600052896000208480850160051c8201928c86106200038a575b918991869594930160051c01915b8281106200037a575050620000c1565b600081558594508991016200036a565b925081926200035c565b634e487b7160e01b600052602260045260246000fd5b92607f1692620000aa565b600080fd5b6040519190601f01601f191682016001600160401b03811183821017620002b557604052565b919080601f84011215620003b55782516001600160401b038111620002b55760209062000416601f8201601f19168301620003ba565b92818452828287010111620003b55760005b8181106200043e57508260009394955001015290565b85810183015184820184015282016200042856fe608060408181526004918236101561001657600080fd5b600092833560e01c91826306fdde031461041357508163095ea7b31461036557816318160ddd1461034657816323b872dd14610259578163313ce5671461023d57816370a082311461020657816395d89b411461010357508063a9059cbb146100d35763dd62ed3e1461008857600080fd5b346100cf57806003193601126100cf57806020926100a4610518565b6100ac610533565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b50346100cf57806003193601126100cf576020906100fc6100f2610518565b6024359033610567565b5160018152f35b8383346100cf57816003193601126100cf5780519082845460018160011c90600183169283156101fc575b60209384841081146101e9578388529081156101cd5750600114610195575b505050829003601f01601f19168201926001600160401b03841183851017610182575082918261017e9252826104cf565b0390f35b634e487b7160e01b815260418552602490fd5b919250868652828620918387935b8385106101b9575050505083010185808061014d565b8054888601830152930192849082016101a3565b60ff1916878501525050151560051b840101905085808061014d565b634e487b7160e01b895260228a52602489fd5b91607f169161012e565b5050346100cf5760203660031901126100cf5760209181906001600160a01b0361022e610518565b16815280845220549051908152f35b5050346100cf57816003193601126100cf576020905160128152f35b9050823461034357606036600319011261034357610275610518565b61027d610533565b916044359360018060a01b0383168083526001602052868320338452602052868320549160001983106102b9575b6020886100fc898989610567565b86831061032157811561030a5733156102f3575082526001602090815286832033845281529186902090859003905582906100fc876102ab565b8751634a1406b160e11b8152908101849052602490fd5b875163e602df0560e01b8152908101849052602490fd5b905061033f868851938493637dc7a0d960e11b855233908501610549565b0390fd5b80fd5b5050346100cf57816003193601126100cf576020906002549051908152f35b90503461040f578160031936011261040f5761037f610518565b6024359033156103f8576001600160a01b03169182156103e157508083602095338152600187528181208582528752205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b8351634a1406b160e11b8152908101859052602490fd5b835163e602df0560e01b8152808401869052602490fd5b8280fd5b8490843461040f578260031936011261040f578260035460018160011c90600183169283156104c5575b60209384841081146101e9578388529081156101cd575060011461048c57505050829003601f01601f19168201926001600160401b03841183851017610182575082918261017e9252826104cf565b91925060038652828620918387935b8385106104b1575050505083010185808061014d565b80548886018301529301928490820161049b565b91607f169161043d565b6020808252825181830181905290939260005b82811061050457505060409293506000838284010152601f8019910116010190565b8181018601518482016040015285016104e2565b600435906001600160a01b038216820361052e57565b600080fd5b602435906001600160a01b038216820361052e57565b604091949392606082019560018060a01b0316825260208201520152565b916001600160a01b0380841692831561061757169283156105fe57600090838252816020526040822054908382106105e1575091604082827fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef958760209652828652038282205586815220818154019055604051908152a3565b61033f8460405193849363391434e360e21b855260048501610549565b60405163ec442f0560e01b815260006004820152602490fd5b604051634b637e8f60e11b815260006004820152602490fdfea164736f6c6343000818000a";

type MockERC20ConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: MockERC20ConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class MockERC20__factory extends ContractFactory {
  constructor(...args: MockERC20ConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    name_: string,
    symbol_: string,
    supply: BigNumberish,
    to: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      name_,
      symbol_,
      supply,
      to,
      overrides || {}
    );
  }
  override deploy(
    name_: string,
    symbol_: string,
    supply: BigNumberish,
    to: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(name_, symbol_, supply, to, overrides || {}) as Promise<
      MockERC20 & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): MockERC20__factory {
    return super.connect(runner) as MockERC20__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): MockERC20Interface {
    return new Interface(_abi) as MockERC20Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): MockERC20 {
    return new Contract(address, _abi, runner) as unknown as MockERC20;
  }
}
</file>

<file path="typechain-types/factories/contracts/mocks/MockFeeOnTransferERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  BigNumberish,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  MockFeeOnTransferERC20,
  MockFeeOnTransferERC20Interface,
} from "../../../contracts/mocks/MockFeeOnTransferERC20";

const _abi = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_feeBps",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "feeBps",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

const _bytecode =
  "0x60803461013e57601f61086538819003918201601f19168301916001600160401b038311848410176101435780849260209460405283398101031261013e5751600061004b8154610159565b601f8111610114575b506010672332b2aa37b5b2b760c11b018155600190610074600154610159565b90601f82116100ea575b505060066246454560e81b01600155506002805460ff191660121790556107d081116100b6576004556040516106d190816101948239f35b60405162461bcd60e51b815260206004820152600c60248201526b0cccaca40e8dede40d0d2ced60a31b6044820152606490fd5b60018152601f60208220920160051c8201915b82811061010a575061007e565b81815583016100fd565b818052601f60208320910160051c8101905b8181106101335750610054565b828155600101610126565b600080fd5b634e487b7160e01b600052604160045260246000fd5b90600182811c92168015610189575b602083101461017357565b634e487b7160e01b600052602260045260246000fd5b91607f169161016856fe608060408181526004918236101561001657600080fd5b600092833560e01c91826306fdde031461043757508163095ea7b3146103c657816318160ddd146103a757816323b872dd1461030157816324a9d853146102df578163313ce567146102bd57816340c10f191461025657816370a082311461021e57816395d89b411461011957508063a9059cbb146100e95763dd62ed3e1461009e57600080fd5b346100e557806003193601126100e557806020926100ba61053a565b6100c2610555565b6001600160a01b0391821683526006865283832091168252845220549051908152f35b5080fd5b50346100e557806003193601126100e55760209061011261010861053a565b602435903361059b565b5160018152f35b8383346100e557816003193601126100e5578051908260018054908160011c9060018316928315610214575b6020938484108114610201578388529081156101e557506001146101ac575b505050829003601f01601f19168201926001600160401b0384118385101761019957508291826101959252826104f1565b0390f35b634e487b7160e01b815260418552602490fd5b91925060018652828620918387935b8385106101d15750505050830101858080610164565b8054888601830152930192849082016101bb565b60ff1916878501525050151560051b8401019050858080610164565b634e487b7160e01b895260228a52602489fd5b91607f1691610145565b5050346100e55760203660031901126100e55760209181906001600160a01b0361024661053a565b1681526005845220549051908152f35b5050346100e557806003193601126100e557816000805160206106a5833981519152602061028261053a565b6024359060018060a01b031694858552600583528085206102a483825461058e565b90556102b28260035461058e565b60035551908152a380f35b5050346100e557816003193601126100e55760209060ff600254169051908152f35b9050346102fd57826003193601126102fd5760209250549051908152f35b8280fd5b919050346102fd5760603660031901126102fd5761031d61053a565b610325610555565b6044359160018060a01b0381168087526020956006875285882033895287528588205490858210610378575094809697610362866101129861056b565b928152600689528181203382528952205561059b565b865162461bcd60e51b81529081018890526009602482015268414c4c4f57414e434560b81b6044820152606490fd5b5050346100e557816003193601126100e5576020906003549051908152f35b5050346100e557806003193601126100e557602091816103e461053a565b91602435918291338152600687528181209460018060a01b0316948582528752205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b849084346102fd57826003193601126102fd5782835460018160011c90600183169283156104e7575b6020938484108114610201578388529081156101e557506001146104af57505050829003601f01601f19168201926001600160401b0384118385101761019957508291826101959252826104f1565b919250858052828620918387935b8385106104d35750505050830101858080610164565b8054888601830152930192849082016104bd565b91607f1691610460565b6020808252825181830181905290939260005b82811061052657505060409293506000838284010152601f8019910116010190565b818101860151848201604001528501610504565b600435906001600160a01b038216820361055057565b600080fd5b602435906001600160a01b038216820361055057565b9190820391821161057857565b634e487b7160e01b600052601160045260246000fd5b9190820180921161057857565b92919260018060a01b03809116906000948286526020916005835260409082828920541061067a57600454808402908482041484151715610666579480969798916127106000805160206106a58339815191529704986105fb8a8761056b565b958385526005885261061186862091825461056b565b905516978883526005865283832061062a86825461058e565b9055858161063e575b5050505051908152a3565b87918480526005825285852061065582825461058e565b90558551908152a338858185610633565b634e487b7160e01b89526011600452602489fd5b815162461bcd60e51b815260048101859052600360248201526210905360ea1b6044820152606490fdfeddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa164736f6c6343000818000a";

type MockFeeOnTransferERC20ConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: MockFeeOnTransferERC20ConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class MockFeeOnTransferERC20__factory extends ContractFactory {
  constructor(...args: MockFeeOnTransferERC20ConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    _feeBps: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(_feeBps, overrides || {});
  }
  override deploy(
    _feeBps: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(_feeBps, overrides || {}) as Promise<
      MockFeeOnTransferERC20 & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(
    runner: ContractRunner | null
  ): MockFeeOnTransferERC20__factory {
    return super.connect(runner) as MockFeeOnTransferERC20__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): MockFeeOnTransferERC20Interface {
    return new Interface(_abi) as MockFeeOnTransferERC20Interface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): MockFeeOnTransferERC20 {
    return new Contract(
      address,
      _abi,
      runner
    ) as unknown as MockFeeOnTransferERC20;
  }
}
</file>

<file path="typechain-types/factories/contracts/mocks/MockRouter__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  MockRouter,
  MockRouterInterface,
} from "../../../contracts/mocks/MockRouter";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "factory_",
        type: "address",
      },
      {
        internalType: "address",
        name: "wrapped_",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountToken",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountETH",
        type: "uint256",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
    ],
    name: "LiquidityAdded",
    type: "event",
  },
  {
    inputs: [],
    name: "WETH",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amountTokenDesired",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    name: "addLiquidityETH",
    outputs: [
      {
        internalType: "uint256",
        name: "amountToken",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amountETH",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "liquidity",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const;

const _bytecode =
  "0x60c03461007a57601f6102c738819003918201601f19168301916001600160401b0383118484101761007f57808492604094855283398101031261007a57610052602061004b83610095565b9201610095565b9060805260a05260405161021d90816100aa82396080518161019e015260a051816101e10152f35b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b038216820361007a5756fe60806040818152600436101561001457600080fd5b600091823560e01c908163ad5c4648146101cd57508063c45a01551461018a5763f305d7191461004357600080fd5b60c0366003190112610186576001600160a01b03906004358281169190829003610182576024359260843590811680910361017e5781516323b872dd60e01b8152336004820152306024820152604481018590526020919082816064818a895af180156101745761010f575b50348501938486116100fb57606096507f3c69701a61c79a92ef9692903aaa0068bce8771361ecb09547391e4fb4df85378480518881523486820152a381519384523490840152820152f35b634e487b7160e01b87526011600452602487fd5b823d841161016d575b601f8101601f191682016001600160401b03811183821017610159578491839187528101031261015557518015150361015157386100af565b8580fd5b8680fd5b634e487b7160e01b89526041600452602489fd5b503d610118565b84513d89823e3d90fd5b8480fd5b8380fd5b5080fd5b5034610186578160031936011261018657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b8390346101865781600319360112610186577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f3fea164736f6c6343000818000a";

type MockRouterConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: MockRouterConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class MockRouter__factory extends ContractFactory {
  constructor(...args: MockRouterConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    factory_: AddressLike,
    wrapped_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(factory_, wrapped_, overrides || {});
  }
  override deploy(
    factory_: AddressLike,
    wrapped_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(factory_, wrapped_, overrides || {}) as Promise<
      MockRouter & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): MockRouter__factory {
    return super.connect(runner) as MockRouter__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): MockRouterInterface {
    return new Interface(_abi) as MockRouterInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): MockRouter {
    return new Contract(address, _abi, runner) as unknown as MockRouter;
  }
}
</file>

<file path="typechain-types/factories/contracts/mocks/RevertingReceiver__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  RevertingReceiver,
  RevertingReceiverInterface,
} from "../../../contracts/mocks/RevertingReceiver";

const _abi = [
  {
    stateMutability: "payable",
    type: "fallback",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x608080604052346014576079908161001a8239f35b600080fdfe6080806040523615603d5760405162461bcd60e51b815260206004820152600b60248201526a4e4f5f46414c4c4241434b60a81b6044820152606490fd5b62461bcd60e51b815260206004820152600a6024820152694e4f5f5245434549564560b01b6044820152606490fdfea164736f6c6343000818000a";

type RevertingReceiverConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: RevertingReceiverConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class RevertingReceiver__factory extends ContractFactory {
  constructor(...args: RevertingReceiverConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      RevertingReceiver & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): RevertingReceiver__factory {
    return super.connect(runner) as RevertingReceiver__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): RevertingReceiverInterface {
    return new Interface(_abi) as RevertingReceiverInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): RevertingReceiver {
    return new Contract(address, _abi, runner) as unknown as RevertingReceiver;
  }
}
</file>

<file path="typechain-types/factories/contracts/test/FactoryCaller__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  FactoryCaller,
  FactoryCallerInterface,
} from "../../../contracts/test/FactoryCaller";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        internalType: "address",
        name: "recipient",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amountOut",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "maxCost",
        type: "uint256",
      },
    ],
    name: "buyFor",
    outputs: [
      {
        internalType: "uint256",
        name: "total",
        type: "uint256",
      },
    ],
    stateMutability: "payable",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x6080806040523461001657610126908161001c8239f35b600080fdfe608080604052600436101561001d575b50361561001b57600080fd5b005b600090813560e01c63f681929314610035575061000f565b60803660031901126100eb576004356001600160a01b03818116918290036101155760243590811680910361011557606483602093819363ed33da2760e01b8352600483015260443560248301528235604483015234905af190811561010a5782916100a7575b602082604051908152f35b905060203d602011610103575b601f8101601f191682016001600160401b038111838210176100ef576020918391604052810103126100eb5760209150513861009c565b5080fd5b634e487b7160e01b84526041600452602484fd5b503d6100b4565b6040513d84823e3d90fd5b8380fdfea164736f6c6343000818000a";

type FactoryCallerConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: FactoryCallerConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class FactoryCaller__factory extends ContractFactory {
  constructor(...args: FactoryCallerConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(overrides || {});
  }
  override deploy(overrides?: NonPayableOverrides & { from?: string }) {
    return super.deploy(overrides || {}) as Promise<
      FactoryCaller & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): FactoryCaller__factory {
    return super.connect(runner) as FactoryCaller__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): FactoryCallerInterface {
    return new Interface(_abi) as FactoryCallerInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): FactoryCaller {
    return new Contract(address, _abi, runner) as unknown as FactoryCaller;
  }
}
</file>

<file path="typechain-types/factories/contracts/test/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { FactoryCaller__factory } from "./FactoryCaller__factory";
</file>

<file path="typechain-types/factories/contracts/token/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { LaunchToken__factory } from "./LaunchToken__factory";
</file>

<file path="typechain-types/factories/contracts/token/LaunchToken__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  BigNumberish,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  LaunchToken,
  LaunchTokenInterface,
} from "../../../contracts/token/LaunchToken";

const _abi = [
  {
    inputs: [
      {
        internalType: "string",
        name: "name_",
        type: "string",
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "cap_",
        type: "uint256",
      },
      {
        internalType: "address",
        name: "owner_",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "allowance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientAllowance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "balance",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "needed",
        type: "uint256",
      },
    ],
    name: "ERC20InsufficientBalance",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address",
      },
    ],
    name: "ERC20InvalidApprover",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address",
      },
    ],
    name: "ERC20InvalidReceiver",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "ERC20InvalidSpender",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
    ],
    name: "OwnableInvalidOwner",
    type: "error",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "OwnableUnauthorizedAccount",
    type: "error",
  },
  {
    inputs: [],
    name: "TradingNotEnabled",
    type: "error",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Approval",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "Transfer",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address",
      },
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "cap",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "enableTrading",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "tradingEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

const _bytecode =
  "0x60a060405234620003de5762000f6a803803806200001d81620003e3565b9283398101608082820312620003de5781516001600160401b039190828111620003de57816200004f91850162000409565b6020918285015190848211620003de576200006c91860162000409565b90606060408601519501519060018060a01b0394858316809303620003de578151818111620002de576003908154906001948583811c93168015620003d3575b89841014620003bd578190601f9384811162000367575b5089908483116001146200030057600092620002f4575b505060001982851b1c191690851b1782555b8551928311620002de5760049586548581811c91168015620002d3575b89821014620002be5782811162000273575b50879184116001146200020857938394918492600095620001fc575b50501b92600019911b1c19161782555b8015620001e457600580546001600160a01b03198116831790915560405194167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a38315620001b75783608052604051610aee90816200047c823960805181818161052001526105f30152f35b62461bcd60e51b8352820152600b60248201526a636170206973207a65726f60a81b604482015260649150fd5b604051631e4fbdf760e01b8152600081840152602490fd5b01519350388062000137565b9190601f198416928760005284896000209460005b8b898383106200025b575050501062000240575b50505050811b01825562000147565b01519060f884600019921b161c191690553880808062000231565b8686015189559097019694850194889350016200021d565b87600052886000208380870160051c8201928b8810620002b4575b0160051c019086905b828110620002a75750506200011b565b6000815501869062000297565b925081926200028e565b602288634e487b7160e01b6000525260246000fd5b90607f169062000109565b634e487b7160e01b600052604160045260246000fd5b015190503880620000da565b90879350601f19831691866000528b6000209260005b8d82821062000350575050841162000337575b505050811b018255620000ec565b015160001983871b60f8161c1916905538808062000329565b8385015186558b9790950194938401930162000316565b90915084600052896000208480850160051c8201928c8610620003b3575b918991869594930160051c01915b828110620003a3575050620000c3565b6000815585945089910162000393565b9250819262000385565b634e487b7160e01b600052602260045260246000fd5b92607f1692620000ac565b600080fd5b6040519190601f01601f191682016001600160401b03811183821017620002de57604052565b919080601f84011215620003de5782516001600160401b038111620002de576020906200043f601f8201601f19168301620003e3565b92818452828287010111620003de5760005b8181106200046757508260009394955001015290565b85810183015184820184015282016200045156fe6080604081815260048036101561001557600080fd5b600092833560e01c90816306fdde03146107df57508063095ea7b31461073657806318160ddd1461071757806323b872dd14610632578063313ce56714610616578063355274ea146105db57806340c10f19146104d95780634ada218b146104b257806370a082311461047b578063715018a6146104305780638a8c523c146103fe5780638da5cb5b146103d557806395d89b41146102d15780639dc29fac146101d6578063a9059cbb146101a5578063dd62ed3e146101585763f2fde38b146100de57600080fd5b34610154576020366003190112610154576100f7610901565b90610100610a75565b6001600160a01b0391821692831561013e575050600580546001600160a01b03198116841790915516600080516020610aa28339815191528380a380f35b51631e4fbdf760e01b8152908101849052602490fd5b8280fd5b5050346101a157806003193601126101a15780602092610176610901565b61017e61091c565b6001600160a01b0391821683526001865283832091168252845220549051908152f35b5080fd5b5050346101a157806003193601126101a1576020906101cf6101c5610901565b6024359033610973565b5160018152f35b508290346101a157826003193601126101a1576101f1610901565b90602435906101fe610a75565b6001600160a01b03838116939084156102ba5760055460ff8160a01c1615610288575b5050838552846020528585205491838310610269575050818495600080516020610ac2833981519152936020938688528785520381872055816002540360025551908152a380f35b6102848484895194859463391434e360e21b86528501610955565b0390fd5b168085141590816102af575b506102a0578680610221565b5084516312f1f92360e01b8152fd5b905033141587610294565b8651634b637e8f60e11b8152808401879052602490fd5b509190346101a157816003193601126101a15780519082845460018160011c90600183169283156103cb575b60209384841081146103b85783885290811561039c5750600114610364575b505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b0390f35b634e487b7160e01b815260418552602490fd5b919250868652828620918387935b838510610388575050505083010138808061031c565b805488860183015293019284908201610372565b60ff1916878501525050151560051b840101905038808061031c565b634e487b7160e01b895260228a52602489fd5b91607f16916102fd565b5050346101a157816003193601126101a15760055490516001600160a01b039091168152602090f35b833461042d578060031936011261042d57610417610a75565b6005805460ff60a01b1916600160a01b17905580f35b80fd5b833461042d578060031936011261042d57610449610a75565b600580546001600160a01b0319811690915581906001600160a01b0316600080516020610aa28339815191528280a380f35b5050346101a15760203660031901126101a15760209181906001600160a01b036104a3610901565b16815280845220549051908152f35b5050346101a157816003193601126101a15760209060ff60055460a01c1690519015158152f35b5090346101545780600319360112610154576104f3610901565b9060243591610500610a75565b6001600160a01b03169283156105af576002549061051e8483610932565b7f00000000000000000000000000000000000000000000000000000000000000001061057d575082600080516020610ac2833981519152926105638795602094610932565b60025585855284835280852082815401905551908152a380f35b606490602084519162461bcd60e51b8352820152600c60248201526b18d85c08195e18d95959195960a21b6044820152fd5b6020606492519162461bcd60e51b83528201526007602482015266746f207a65726f60c81b6044820152fd5b5050346101a157816003193601126101a157602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b5050346101a157816003193601126101a1576020905160128152f35b50823461042d57606036600319011261042d5761064d610901565b61065561091c565b916044359360018060a01b038316808352600160205286832033845260205286832054916000198310610691575b6020886101cf898989610973565b8683106106f95781156106e25733156106cb575082526001602090815286832033845281529186902090859003905582906101cf87610683565b8751634a1406b160e11b8152908101849052602490fd5b875163e602df0560e01b8152908101849052602490fd5b9050610284868851938493637dc7a0d960e11b855233908501610955565b5050346101a157816003193601126101a1576020906002549051908152f35b503461015457816003193601126101545761074f610901565b6024359033156107c8576001600160a01b03169182156107b157508083602095338152600187528181208582528752205582519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925843392a35160018152f35b8351634a1406b160e11b8152908101859052602490fd5b835163e602df0560e01b8152808401869052602490fd5b84915083346101545782600319360112610154578260035460018160011c90600183169283156108ae575b60209384841081146103b857838852908115610892575060011461085957505050829003601f01601f19168201926001600160401b03841183851017610351575082918261034d9252826108b8565b91925060038652828620918387935b83851061087e575050505083010185808061031c565b805488860183015293019284908201610868565b60ff1916878501525050151560051b840101905085808061031c565b91607f169161080a565b6020808252825181830181905290939260005b8281106108ed57505060409293506000838284010152601f8019910116010190565b8181018601518482016040015285016108cb565b600435906001600160a01b038216820361091757565b600080fd5b602435906001600160a01b038216820361091757565b9190820180921161093f57565b634e487b7160e01b600052601160045260246000fd5b604091949392606082019560018060a01b0316825260208201520152565b6001600160a01b0392838216929091908315610a5c578416938415610a435760055460ff8160a01c1615610a0e575b5050600090838252816020526040822054908382106109f157509160408282600080516020610ac2833981519152958760209652828652038282205586815220818154019055604051908152a3565b6102848460405193849363391434e360e21b855260048501610955565b16808414159081610a38575b50610a265738806109a2565b6040516312f1f92360e01b8152600490fd5b905033141538610a1a565b60405163ec442f0560e01b815260006004820152602490fd5b604051634b637e8f60e11b815260006004820152602490fd5b6005546001600160a01b03163303610a8957565b60405163118cdaa760e01b8152336004820152602490fdfe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa164736f6c6343000818000a";

type LaunchTokenConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: LaunchTokenConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class LaunchToken__factory extends ContractFactory {
  constructor(...args: LaunchTokenConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    name_: string,
    symbol_: string,
    cap_: BigNumberish,
    owner_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      name_,
      symbol_,
      cap_,
      owner_,
      overrides || {}
    );
  }
  override deploy(
    name_: string,
    symbol_: string,
    cap_: BigNumberish,
    owner_: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(
      name_,
      symbol_,
      cap_,
      owner_,
      overrides || {}
    ) as Promise<
      LaunchToken & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): LaunchToken__factory {
    return super.connect(runner) as LaunchToken__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): LaunchTokenInterface {
    return new Interface(_abi) as LaunchTokenInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): LaunchToken {
    return new Contract(address, _abi, runner) as unknown as LaunchToken;
  }
}
</file>

<file path="typechain-types/factories/contracts/TreasuryRouter__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  BigNumberish,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../common";
import type {
  TreasuryRouter,
  TreasuryRouterInterface,
} from "../../contracts/TreasuryRouter";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_admin",
        type: "address",
      },
      {
        internalType: "address",
        name: "_initialVault",
        type: "address",
      },
      {
        internalType: "uint64",
        name: "_upgradeDelaySeconds",
        type: "uint64",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "ForwardFailed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "vault",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Forwarded",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "paused",
        type: "bool",
      },
    ],
    name: "ForwardingPaused",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "oldVault",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newVault",
        type: "address",
      },
    ],
    name: "VaultActivated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newVault",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "executeAfter",
        type: "uint64",
      },
    ],
    name: "VaultProposed",
    type: "event",
  },
  {
    inputs: [],
    name: "acceptVault",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "activeVault",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "admin",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "forward",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "forwardingPaused",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "pendingSince",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "pendingVault",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newVault",
        type: "address",
      },
    ],
    name: "proposeVault",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "paused",
        type: "bool",
      },
    ],
    name: "setForwardingPaused",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "upgradeDelay",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x60c03461017657601f61084b38819003918201601f19168301926001600160401b039290918385118386101761017b5781606092849260409788528339810103126101765761004d81610191565b8361005a60208401610191565b92015192831691828403610176576001600160a01b039082821615610148571691821561011a57610e10116100e457608052600080546001600160a01b03191691909117905560a052516106a590816101a6823960805181818160b301528181610150015281816102bc0152610401015260a0518181816101df0152818161034d015261045a0152f35b835162461bcd60e51b815260206004820152600f60248201526e19195b185e481d1bdbc81cdb585b1b608a1b6044820152606490fd5b845162461bcd60e51b815260206004820152600760248201526607661756c743d360cc1b6044820152606490fd5b855162461bcd60e51b8152602060048201526007602482015266061646d696e3d360cc1b6044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b03821682036101765756fe60406080815260049081361015610029575b5050361561001e57600080fd5b6100273461059b565b005b600091823560e01c9081630b2e1baf146103e0578163483b83c81461028c57816352113ba714610263578163535ea8161461023b5781637d979a4f1461020e5781637e48d4ea146101ca5781638e8c6691146101a3578163ce6063561461010657508063d264e05e146100e65763f851a4400361001157346100e257816003193601126100e257517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b82346101035780600319360112610103576101004761059b565b80f35b80fd5b90503461019f57602036600319011261019f57359081151580920361019f577f77931a4b47db78545305ad5b4bf71028f486d6ec695d5dbdc458bc05bca859dc9160209161017e337f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316146104fb565b6001805460ff60e01b191660e084901b60ff60e01b1617905551908152a180f35b8280fd5b5050346100e257816003193601126100e25760209060ff60015460e01c1690519015158152f35b5050346100e257816003193601126100e257517f00000000000000000000000000000000000000000000000000000000000000006001600160401b03168152602090f35b5050346100e257816003193601126100e257600154905160a09190911c6001600160401b03168152602090f35b5050346100e257816003193601126100e257905490516001600160a01b039091168152602090f35b5050346100e257816003193601126100e25760015490516001600160a01b039091168152602090f35b9190503461019f57602036600319011261019f576001600160a01b03823581811693918482036103dc576102e3907f00000000000000000000000000000000000000000000000000000000000000001633146104fb565b83156103af573b1561037e5750600180546001600160e01b03191683174260a081901b600160a01b600160e01b0316919091179091557f5cb4a822b49d038ed291acea6fac59902b34649b9a41fa3ef079c7d24ee93234916020916001600160401b0390610374907f000000000000000000000000000000000000000000000000000000000000000090831661056c565b915191168152a280f35b6020606492519162461bcd60e51b8352820152600c60248201526b1b9bdd0818dbdb9d1c9858dd60a21b6044820152fd5b506020606492519162461bcd60e51b8352820152600760248201526607661756c743d360cc1b6044820152fd5b8580fd5b90503461019f578260031936011261019f576001600160a01b0390610428337f00000000000000000000000000000000000000000000000000000000000000008416146104fb565b600154908282169361043b851515610533565b6001600160401b0361047f60a085901c8216610458811515610533565b7f00000000000000000000000000000000000000000000000000000000000000009061056c565b1642106104d057505083546001600160a01b03198116841785556001600160e01b0319909116600155167fc4fb0a69c59dd3724ce26374fc1b6ce92bed4fa90efafb34f552e80f02a2dfd88380a380f35b906020606492519162461bcd60e51b8352820152600560248201526464656c617960d81b6044820152fd5b1561050257565b60405162461bcd60e51b81526020600482015260096024820152683737ba1030b236b4b760b91b6044820152606490fd5b1561053a57565b60405162461bcd60e51b815260206004820152600a6024820152696e6f2070656e64696e6760b01b6044820152606490fd5b6001600160401b03918216908216019190821161058557565b634e487b7160e01b600052601160045260246000fd5b60ff60015460e01c1661069557801561069557600080546001600160a01b031691908080808085875af1903d1561068f576001600160401b03903d82811161067b5760405192601f8201601f19908116603f011684019081118482101761066757604052825260203d92013e5b1561063a5760207f6f1deddfc28100c291fae8f1064e4a91e844f0841993bb8fba9a913c3b801d8091604051908152a2565b60207f8936c63f7941213ec179a97cdc6c377a9ca1413f1c446afcd31722e61986a37791604051908152a2565b634e487b7160e01b83526041600452602483fd5b634e487b7160e01b82526041600452602482fd5b50610608565b5056fea164736f6c6343000818000a";

type TreasuryRouterConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: TreasuryRouterConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class TreasuryRouter__factory extends ContractFactory {
  constructor(...args: TreasuryRouterConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    _admin: AddressLike,
    _initialVault: AddressLike,
    _upgradeDelaySeconds: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      _admin,
      _initialVault,
      _upgradeDelaySeconds,
      overrides || {}
    );
  }
  override deploy(
    _admin: AddressLike,
    _initialVault: AddressLike,
    _upgradeDelaySeconds: BigNumberish,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(
      _admin,
      _initialVault,
      _upgradeDelaySeconds,
      overrides || {}
    ) as Promise<
      TreasuryRouter & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): TreasuryRouter__factory {
    return super.connect(runner) as TreasuryRouter__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): TreasuryRouterInterface {
    return new Interface(_abi) as TreasuryRouterInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): TreasuryRouter {
    return new Contract(address, _abi, runner) as unknown as TreasuryRouter;
  }
}
</file>

<file path="typechain-types/factories/contracts/TreasuryVault__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../common";
import type {
  TreasuryVault,
  TreasuryVaultInterface,
} from "../../contracts/TreasuryVault";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_multisig",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Withdraw",
    type: "event",
  },
  {
    inputs: [],
    name: "multisig",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "withdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x60a0346100a857601f61032138819003918201601f19168301916001600160401b038311848410176100ad578084926020946040528339810103126100a857516001600160a01b0381168082036100a857156100765760805260405161025d90816100c48239608051818181606f015261021d0152f35b60405162461bcd60e51b815260206004820152600a60248201526906d756c74697369673d360b41b6044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fdfe60806040818152600480361015610021575b505050361561001f57600080fd5b005b600092833560e01c9081634783c35b14610209575063f3fef3a30361001157346102055781600319360112610205576001600160a01b038135818116939192908490036102015760248035937f00000000000000000000000000000000000000000000000000000000000000001633036101d15784156101aa5747841161017a578580808087895af13d15610175576001600160401b033d81811161016357855191601f8201601f19908116603f011683019081118382101761015157865281528760203d92013e5b1561011e5750507f884edad9ce6fa2440d8a54cc123490eb96d2768479d49ff9c7366125a94243649160209151908152a280f35b600f906020606494519362461bcd60e51b85528401528201526e1d1c985b9cd9995c8819985a5b1959608a1b6044820152fd5b634e487b7160e01b8a5260418652848afd5b634e487b7160e01b8952604185528389fd5b6100ea565b600c906020606494519362461bcd60e51b85528401528201526b1a5b9cdd59999a58da595b9d60a21b6044820152fd5b915162461bcd60e51b815260208183015291820152630746f3d360e41b6044820152606490fd5b600c906020606494519362461bcd60e51b85528401528201526b6e6f74206d756c746973696760a01b6044820152fd5b8480fd5b8280fd5b84903461024c578160031936011261024c577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fdfea164736f6c6343000818000a";

type TreasuryVaultConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: TreasuryVaultConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class TreasuryVault__factory extends ContractFactory {
  constructor(...args: TreasuryVaultConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    _multisig: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(_multisig, overrides || {});
  }
  override deploy(
    _multisig: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(_multisig, overrides || {}) as Promise<
      TreasuryVault & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): TreasuryVault__factory {
    return super.connect(runner) as TreasuryVault__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): TreasuryVaultInterface {
    return new Interface(_abi) as TreasuryVaultInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): TreasuryVault {
    return new Contract(address, _abi, runner) as unknown as TreasuryVault;
  }
}
</file>

<file path="typechain-types/factories/contracts/UPVoteTreasury.sol/IERC20__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  IERC20,
  IERC20Interface,
} from "../../../contracts/UPVoteTreasury.sol/IERC20";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256",
      },
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class IERC20__factory {
  static readonly abi = _abi;
  static createInterface(): IERC20Interface {
    return new Interface(_abi) as IERC20Interface;
  }
  static connect(address: string, runner?: ContractRunner | null): IERC20 {
    return new Contract(address, _abi, runner) as unknown as IERC20;
  }
}
</file>

<file path="typechain-types/factories/contracts/UPVoteTreasury.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IERC20__factory } from "./IERC20__factory";
export { Ownable__factory } from "./Ownable__factory";
export { UPVoteTreasury__factory } from "./UPVoteTreasury__factory";
</file>

<file path="typechain-types/factories/contracts/UPVoteTreasury.sol/Ownable__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, Interface, type ContractRunner } from "ethers";
import type {
  Ownable,
  OwnableInterface,
} from "../../../contracts/UPVoteTreasury.sol/Ownable";

const _abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

export class Ownable__factory {
  static readonly abi = _abi;
  static createInterface(): OwnableInterface {
    return new Interface(_abi) as OwnableInterface;
  }
  static connect(address: string, runner?: ContractRunner | null): Ownable {
    return new Contract(address, _abi, runner) as unknown as Ownable;
  }
}
</file>

<file path="typechain-types/factories/contracts/UPVoteTreasury.sol/UPVoteTreasury__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  Contract,
  ContractFactory,
  ContractTransactionResponse,
  Interface,
} from "ethers";
import type {
  Signer,
  AddressLike,
  ContractDeployTransaction,
  ContractRunner,
} from "ethers";
import type { NonPayableOverrides } from "../../../common";
import type {
  UPVoteTreasury,
  UPVoteTreasuryInterface,
} from "../../../contracts/UPVoteTreasury.sol/UPVoteTreasury";

const _abi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "initialOwner",
        type: "address",
      },
      {
        internalType: "address",
        name: "initialFeeReceiver",
        type: "address",
      },
    ],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "minAmount",
        type: "uint256",
      },
    ],
    name: "AssetConfigured",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        indexed: false,
        internalType: "bool",
        name: "allowed",
        type: "bool",
      },
    ],
    name: "CampaignAllowed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "bool",
        name: "enabled",
        type: "bool",
      },
    ],
    name: "CampaignAllowlistToggled",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousReceiver",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newReceiver",
        type: "address",
      },
    ],
    name: "FeeReceiverUpdated",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "OwnershipTransferred",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "Rescue",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "voter",
        type: "address",
      },
      {
        indexed: true,
        internalType: "address",
        name: "asset",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountPaid",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "meta",
        type: "bytes32",
      },
    ],
    name: "VoteCast",
    type: "event",
  },
  {
    inputs: [],
    name: "NATIVE",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "assetConfig",
    outputs: [
      {
        internalType: "bool",
        name: "enabled",
        type: "bool",
      },
      {
        internalType: "uint256",
        name: "minAmount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    name: "campaignAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "campaignAllowlistEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "feeReceiver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "rescueBNB",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "address",
        name: "to",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "rescueToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "asset",
        type: "address",
      },
      {
        internalType: "bool",
        name: "enabled",
        type: "bool",
      },
      {
        internalType: "uint256",
        name: "minAmount",
        type: "uint256",
      },
    ],
    name: "setAsset",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        internalType: "bool",
        name: "allowed",
        type: "bool",
      },
    ],
    name: "setCampaignAllowed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "bool",
        name: "enabled",
        type: "bool",
      },
    ],
    name: "setCampaignAllowlistEnabled",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newFeeReceiver",
        type: "address",
      },
    ],
    name: "setFeeReceiver",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address",
      },
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        internalType: "bytes32",
        name: "meta",
        type: "bytes32",
      },
    ],
    name: "voteWithBNB",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "campaign",
        type: "address",
      },
      {
        internalType: "address",
        name: "token",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "bytes32",
        name: "meta",
        type: "bytes32",
      },
    ],
    name: "voteWithToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    stateMutability: "payable",
    type: "receive",
  },
] as const;

const _bytecode =
  "0x6080346101d6576001600160401b0390610f9d601f38829003908101601f1916830190848211848310176101db57808491604094859485528339810103126101d65761004a826101f1565b9161005860208092016101f1565b936001600160a01b039384169384156101a55760018060a01b0319906000968683895416178855855196887f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08180a31694851561016f575084906004541617600455825190838201908282109082111761015b5785927f1094737819eaf3ddf6cf22ca7ec4feda1dbaea06f781cb59d15386f521988b8f92859283526001815260018282018681528680528184528487209251151560ff80198554169116178355519101558382519160018352820152a251917fa92ff4390fe6943f0b30e8fe715dde86f85ab79b2b2c640a10fc094cc4036cc88180a3610d9790816102068239f35b634e487b7160e01b86526041600452602486fd5b62461bcd60e51b81526004810184905260116024820152704645455f52454345495645525f5a45524f60781b6044820152606490fd5b835162461bcd60e51b815260048101849052600a6024820152694f574e45525f5a45524f60b01b6044820152606490fd5b600080fd5b634e487b7160e01b600052604160045260246000fd5b51906001600160a01b03821682036101d65756fe6080604081815260049081361015610022575b505050361561002057600080fd5b005b600092833560e01c9081630f6506ae146109bf57508063284b6658146109505780632bdc50921461088d57806331a4759d1461080357806348a27a081461057f5780636d76eb32146104905780637948d5bb146104525780638da5cb5b1461042a578063a0cf0aea1461040f578063b3f00674146103e7578063d6dbaf581461038d578063e5711e8b1461030c578063efdcd9741461025f578063f2fde38b146101ba5763f5b186170361001257806003193601126101b657828080806100e76109f4565b6100f081610bd4565b818052600160205261013186832061012888519161010d83610a58565b6020600160ff83541615159283865201549301928352610ae5565b51341015610b22565b855134815260243560208201526001600160a01b039183913391841690600080516020610d6b833981519152908a90a434908754165af1610170610b95565b501561017a578280f35b906020606492519162461bcd60e51b8352820152601660248201527511915157d193d495d0549117d0939097d1905253115160521b6044820152fd5b8280fd5b5090346101b65760203660031901126101b6576101d56109f4565b8354916001600160a01b03808416926101ef338514610a20565b1693841561022f57505082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08580a36001600160a01b03191617815580f35b906020606492519162461bcd60e51b8352820152600a6024820152694f574e45525f5a45524f60b01b6044820152fd5b50346101b65760203660031901126101b6576102796109f4565b83546001600160a01b039182916102939083163314610a20565b169182156102d657508183549182167fa92ff4390fe6943f0b30e8fe715dde86f85ab79b2b2c640a10fc094cc4036cc88680a36001600160a01b03191617905580f35b5162461bcd60e51b815260208185015260116024820152704645455f52454345495645525f5a45524f60781b6044820152606490fd5b838234610389576060366003190112610389576103276109f4565b600080516020610d4b8339815191526020610340610a0a565b93604435906103818260018060a01b038097610360828c54163314610a20565b169661036d881515610aac565b88169761037b891515610b5f565b87610c91565b51908152a380f35b5080fd5b838234610389576020366003190112610389579081906001600160a01b036103b36109f4565b1681526001602052206103e3600160ff835416920154925192839283602090939291936040810194151581520152565b0390f35b5090346101b657826003193601126101b6575490516001600160a01b03909116815260209150f35b83823461038957816003193601126103895751908152602090f35b838234610389578160031936011261038957905490516001600160a01b039091168152602090f35b8382346103895760203660031901126103895760209160ff9082906001600160a01b0361047d6109f4565b1681526003855220541690519015158152f35b5090346101b657816003193601126101b6576001600160a01b0381358181169391929084900361057b576104cb602435938654163314610a20565b6104d6841515610b5f565b478311610546578480808086885af16104ed610b95565b5015610510575060208492600080516020610d4b8339815191529251908152a380f35b6020606492519162461bcd60e51b8352820152601160248201527010939097d49154d0d55157d19052531151607a1b6044820152fd5b6020606492519162461bcd60e51b8352820152601060248201526f24a729aaa32324a1a4a2a72a2fa1272160811b6044820152fd5b8480fd5b508290346103895760803660031901126103895761059b6109f4565b906105a4610a0a565b604435926105b181610bd4565b6001600160a01b03918216926105c8841515610aac565b838652602090600182528087206105fe8251916105e483610a58565b84600160ff83541615159283865201549301928352610ae5565b86156107d25781516370a0823160e01b808252308b8301529784826024818b5afa918215610795578a9261079f575b508351906323b872dd60e01b8252338c830152306024830152604482015284816064818d8c5af1908115610795578a91610768575b5015610725578251978852308a89015283886024818a5afa97881561071b5789986106e8575b5087039687116106d55791600080516020610d6b8339815191526106d2989994926106b78895518a1015610b22565b805192898452606435908401528633941692a4541690610c91565b80f35b634e487b7160e01b885260118952602488fd5b9097508381813d8311610714575b6107008183610a89565b810103126107105751968a610688565b8880fd5b503d6106f6565b83513d8b823e3d90fd5b825162461bcd60e51b8152808b01859052601e60248201527f534146455f45524332305f5452414e5346455246524f4d5f4641494c454400006044820152606490fd5b6107889150853d871161078e575b6107808183610a89565b810190610c79565b8b610662565b503d610776565b84513d8c823e3d90fd5b9091508481813d83116107cb575b6107b78183610a89565b810103126107c75751908b61062d565b8980fd5b503d6107ad565b815162461bcd60e51b8152808a01849052600b60248201526a414d4f554e545f5a45524f60a81b6044820152606490fd5b8382346103895780600319360112610389577fd19c4d9fde20f40edaf8d18b485f4394c7dfafc635e27ab83211781d6234ee1a60206108406109f4565b6108486109e0565b855490916001600160a01b03916108629083163314610a20565b169384865260038352610883828288209060ff801983541691151516179055565b519015158152a280f35b838234610389576060366003190112610389577f1094737819eaf3ddf6cf22ca7ec4feda1dbaea06f781cb59d15386f521988b8f6108c96109f4565b916108d26109e0565b61094a6044359260018060a01b036108ee818954163314610a20565b60018251916108fc83610a58565b85151583526020830198878a521697888a528160205261092e848b2093511515849060ff801983541691151516179055565b5191015551911515825260208201929092529081906040820190565b0390a280f35b5090346101b65760203660031901126101b65735908115158092036101b6577f062e9c104029bd67eb3a322a1bc109426d8ae594e3105cf62a31224fb2b1c29a916020916109a860018060a01b038654163314610a20565b60ff196002541660ff83161760025551908152a180f35b84903461038957816003193601126103895760209060ff6002541615158152f35b6024359081151582036109ef57565b600080fd5b600435906001600160a01b03821682036109ef57565b602435906001600160a01b03821682036109ef57565b15610a2757565b60405162461bcd60e51b81526020600482015260096024820152682727aa2fa7aba722a960b91b6044820152606490fd5b604081019081106001600160401b03821117610a7357604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b03821190821017610a7357604052565b15610ab357565b60405162461bcd60e51b815260206004820152600a602482015269544f4b454e5f5a45524f60b01b6044820152606490fd5b15610aec57565b60405162461bcd60e51b815260206004820152600e60248201526d1054d4d15517d11254d05093115160921b6044820152606490fd5b15610b2957565b60405162461bcd60e51b815260206004820152600e60248201526d414d4f554e545f544f4f5f4c4f5760901b6044820152606490fd5b15610b6657565b60405162461bcd60e51b8152602060048201526007602482015266544f5f5a45524f60c81b6044820152606490fd5b3d15610bcf573d906001600160401b038211610a735760405191610bc3601f8201601f191660200184610a89565b82523d6000602084013e565b606090565b6001600160a01b03168015610c445760ff60025416610bf05750565b600052600360205260ff6040600020541615610c0857565b60405162461bcd60e51b815260206004820152601460248201527310d05354105251d397d393d517d0531313d5d15160621b6044820152606490fd5b60405162461bcd60e51b815260206004820152600d60248201526c43414d504149474e5f5a45524f60981b6044820152606490fd5b908160209103126109ef575180151581036109ef5790565b60405163a9059cbb60e01b81526001600160a01b039283166004820152602481019390935260209183916044918391600091165af1908115610d3e57600091610d1f575b5015610cdd57565b60405162461bcd60e51b815260206004820152601a60248201527914d0519157d15490cc8c17d514905394d1915497d1905253115160321b6044820152606490fd5b610d38915060203d60201161078e576107808183610a89565b38610cd5565b6040513d6000823e3d90fdfee01920728668d89f092ef9cb92036bad90964bb622eec508d2c3ffe1d582efb2fb5f697f7829fe530034db24d35dbf179045ec934fbe10bf661418acc92b9445a164736f6c6343000818000a";

type UPVoteTreasuryConstructorParams =
  | [signer?: Signer]
  | ConstructorParameters<typeof ContractFactory>;

const isSuperArgs = (
  xs: UPVoteTreasuryConstructorParams
): xs is ConstructorParameters<typeof ContractFactory> => xs.length > 1;

export class UPVoteTreasury__factory extends ContractFactory {
  constructor(...args: UPVoteTreasuryConstructorParams) {
    if (isSuperArgs(args)) {
      super(...args);
    } else {
      super(_abi, _bytecode, args[0]);
    }
  }

  override getDeployTransaction(
    initialOwner: AddressLike,
    initialFeeReceiver: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ): Promise<ContractDeployTransaction> {
    return super.getDeployTransaction(
      initialOwner,
      initialFeeReceiver,
      overrides || {}
    );
  }
  override deploy(
    initialOwner: AddressLike,
    initialFeeReceiver: AddressLike,
    overrides?: NonPayableOverrides & { from?: string }
  ) {
    return super.deploy(
      initialOwner,
      initialFeeReceiver,
      overrides || {}
    ) as Promise<
      UPVoteTreasury & {
        deploymentTransaction(): ContractTransactionResponse;
      }
    >;
  }
  override connect(runner: ContractRunner | null): UPVoteTreasury__factory {
    return super.connect(runner) as UPVoteTreasury__factory;
  }

  static readonly bytecode = _bytecode;
  static readonly abi = _abi;
  static createInterface(): UPVoteTreasuryInterface {
    return new Interface(_abi) as UPVoteTreasuryInterface;
  }
  static connect(
    address: string,
    runner?: ContractRunner | null
  ): UPVoteTreasury {
    return new Contract(address, _abi, runner) as unknown as UPVoteTreasury;
  }
}
</file>

<file path="typechain-types/factories/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as openzeppelin from "./@openzeppelin";
export * as contracts from "./contracts";
</file>

<file path="typechain-types/hardhat.d.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { ethers } from "ethers";
import {
  DeployContractOptions,
  FactoryOptions,
  HardhatEthersHelpers as HardhatEthersHelpersBase,
} from "@nomicfoundation/hardhat-ethers/types";

import * as Contracts from ".";

declare module "hardhat/types/runtime" {
  interface HardhatEthersHelpers extends HardhatEthersHelpersBase {
    getContractFactory(
      name: "Ownable",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.Ownable__factory>;
    getContractFactory(
      name: "IERC1155Errors",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC1155Errors__factory>;
    getContractFactory(
      name: "IERC20Errors",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC20Errors__factory>;
    getContractFactory(
      name: "IERC721Errors",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC721Errors__factory>;
    getContractFactory(
      name: "IERC1363",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC1363__factory>;
    getContractFactory(
      name: "Clones",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.Clones__factory>;
    getContractFactory(
      name: "ERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.ERC20__factory>;
    getContractFactory(
      name: "IERC20Metadata",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC20Metadata__factory>;
    getContractFactory(
      name: "IERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC20__factory>;
    getContractFactory(
      name: "SafeERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.SafeERC20__factory>;
    getContractFactory(
      name: "Create2",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.Create2__factory>;
    getContractFactory(
      name: "Errors",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.Errors__factory>;
    getContractFactory(
      name: "IERC165",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC165__factory>;
    getContractFactory(
      name: "SafeCast",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.SafeCast__factory>;
    getContractFactory(
      name: "ReentrancyGuard",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.ReentrancyGuard__factory>;
    getContractFactory(
      name: "IPancakeRouter02",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IPancakeRouter02__factory>;
    getContractFactory(
      name: "ITreasuryVault",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.ITreasuryVault__factory>;
    getContractFactory(
      name: "LaunchCampaign",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.LaunchCampaign__factory>;
    getContractFactory(
      name: "LaunchFactory",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.LaunchFactory__factory>;
    getContractFactory(
      name: "LpTimelock",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.LpTimelock__factory>;
    getContractFactory(
      name: "MockERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.MockERC20__factory>;
    getContractFactory(
      name: "MockFeeOnTransferERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.MockFeeOnTransferERC20__factory>;
    getContractFactory(
      name: "MockRouter",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.MockRouter__factory>;
    getContractFactory(
      name: "RevertingReceiver",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.RevertingReceiver__factory>;
    getContractFactory(
      name: "FactoryCaller",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.FactoryCaller__factory>;
    getContractFactory(
      name: "LaunchToken",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.LaunchToken__factory>;
    getContractFactory(
      name: "TreasuryRouter",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.TreasuryRouter__factory>;
    getContractFactory(
      name: "TreasuryVault",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.TreasuryVault__factory>;
    getContractFactory(
      name: "IERC20",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.IERC20__factory>;
    getContractFactory(
      name: "Ownable",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.Ownable__factory>;
    getContractFactory(
      name: "UPVoteTreasury",
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<Contracts.UPVoteTreasury__factory>;

    getContractAt(
      name: "Ownable",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.Ownable>;
    getContractAt(
      name: "IERC1155Errors",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC1155Errors>;
    getContractAt(
      name: "IERC20Errors",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC20Errors>;
    getContractAt(
      name: "IERC721Errors",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC721Errors>;
    getContractAt(
      name: "IERC1363",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC1363>;
    getContractAt(
      name: "Clones",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.Clones>;
    getContractAt(
      name: "ERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.ERC20>;
    getContractAt(
      name: "IERC20Metadata",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC20Metadata>;
    getContractAt(
      name: "IERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC20>;
    getContractAt(
      name: "SafeERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.SafeERC20>;
    getContractAt(
      name: "Create2",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.Create2>;
    getContractAt(
      name: "Errors",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.Errors>;
    getContractAt(
      name: "IERC165",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC165>;
    getContractAt(
      name: "SafeCast",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.SafeCast>;
    getContractAt(
      name: "ReentrancyGuard",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.ReentrancyGuard>;
    getContractAt(
      name: "IPancakeRouter02",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IPancakeRouter02>;
    getContractAt(
      name: "ITreasuryVault",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.ITreasuryVault>;
    getContractAt(
      name: "LaunchCampaign",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.LaunchCampaign>;
    getContractAt(
      name: "LaunchFactory",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.LaunchFactory>;
    getContractAt(
      name: "LpTimelock",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.LpTimelock>;
    getContractAt(
      name: "MockERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.MockERC20>;
    getContractAt(
      name: "MockFeeOnTransferERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.MockFeeOnTransferERC20>;
    getContractAt(
      name: "MockRouter",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.MockRouter>;
    getContractAt(
      name: "RevertingReceiver",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.RevertingReceiver>;
    getContractAt(
      name: "FactoryCaller",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.FactoryCaller>;
    getContractAt(
      name: "LaunchToken",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.LaunchToken>;
    getContractAt(
      name: "TreasuryRouter",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.TreasuryRouter>;
    getContractAt(
      name: "TreasuryVault",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.TreasuryVault>;
    getContractAt(
      name: "IERC20",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.IERC20>;
    getContractAt(
      name: "Ownable",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.Ownable>;
    getContractAt(
      name: "UPVoteTreasury",
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<Contracts.UPVoteTreasury>;

    deployContract(
      name: "Ownable",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Ownable>;
    deployContract(
      name: "IERC1155Errors",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC1155Errors>;
    deployContract(
      name: "IERC20Errors",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20Errors>;
    deployContract(
      name: "IERC721Errors",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC721Errors>;
    deployContract(
      name: "IERC1363",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC1363>;
    deployContract(
      name: "Clones",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Clones>;
    deployContract(
      name: "ERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ERC20>;
    deployContract(
      name: "IERC20Metadata",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20Metadata>;
    deployContract(
      name: "IERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20>;
    deployContract(
      name: "SafeERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.SafeERC20>;
    deployContract(
      name: "Create2",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Create2>;
    deployContract(
      name: "Errors",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Errors>;
    deployContract(
      name: "IERC165",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC165>;
    deployContract(
      name: "SafeCast",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.SafeCast>;
    deployContract(
      name: "ReentrancyGuard",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ReentrancyGuard>;
    deployContract(
      name: "IPancakeRouter02",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IPancakeRouter02>;
    deployContract(
      name: "ITreasuryVault",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ITreasuryVault>;
    deployContract(
      name: "LaunchCampaign",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchCampaign>;
    deployContract(
      name: "LaunchFactory",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchFactory>;
    deployContract(
      name: "LpTimelock",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LpTimelock>;
    deployContract(
      name: "MockERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockERC20>;
    deployContract(
      name: "MockFeeOnTransferERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockFeeOnTransferERC20>;
    deployContract(
      name: "MockRouter",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockRouter>;
    deployContract(
      name: "RevertingReceiver",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.RevertingReceiver>;
    deployContract(
      name: "FactoryCaller",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.FactoryCaller>;
    deployContract(
      name: "LaunchToken",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchToken>;
    deployContract(
      name: "TreasuryRouter",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.TreasuryRouter>;
    deployContract(
      name: "TreasuryVault",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.TreasuryVault>;
    deployContract(
      name: "IERC20",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20>;
    deployContract(
      name: "Ownable",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Ownable>;
    deployContract(
      name: "UPVoteTreasury",
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.UPVoteTreasury>;

    deployContract(
      name: "Ownable",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Ownable>;
    deployContract(
      name: "IERC1155Errors",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC1155Errors>;
    deployContract(
      name: "IERC20Errors",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20Errors>;
    deployContract(
      name: "IERC721Errors",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC721Errors>;
    deployContract(
      name: "IERC1363",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC1363>;
    deployContract(
      name: "Clones",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Clones>;
    deployContract(
      name: "ERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ERC20>;
    deployContract(
      name: "IERC20Metadata",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20Metadata>;
    deployContract(
      name: "IERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20>;
    deployContract(
      name: "SafeERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.SafeERC20>;
    deployContract(
      name: "Create2",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Create2>;
    deployContract(
      name: "Errors",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Errors>;
    deployContract(
      name: "IERC165",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC165>;
    deployContract(
      name: "SafeCast",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.SafeCast>;
    deployContract(
      name: "ReentrancyGuard",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ReentrancyGuard>;
    deployContract(
      name: "IPancakeRouter02",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IPancakeRouter02>;
    deployContract(
      name: "ITreasuryVault",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.ITreasuryVault>;
    deployContract(
      name: "LaunchCampaign",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchCampaign>;
    deployContract(
      name: "LaunchFactory",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchFactory>;
    deployContract(
      name: "LpTimelock",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LpTimelock>;
    deployContract(
      name: "MockERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockERC20>;
    deployContract(
      name: "MockFeeOnTransferERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockFeeOnTransferERC20>;
    deployContract(
      name: "MockRouter",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.MockRouter>;
    deployContract(
      name: "RevertingReceiver",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.RevertingReceiver>;
    deployContract(
      name: "FactoryCaller",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.FactoryCaller>;
    deployContract(
      name: "LaunchToken",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.LaunchToken>;
    deployContract(
      name: "TreasuryRouter",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.TreasuryRouter>;
    deployContract(
      name: "TreasuryVault",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.TreasuryVault>;
    deployContract(
      name: "IERC20",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.IERC20>;
    deployContract(
      name: "Ownable",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.Ownable>;
    deployContract(
      name: "UPVoteTreasury",
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<Contracts.UPVoteTreasury>;

    // default types
    getContractFactory(
      name: string,
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<ethers.ContractFactory>;
    getContractFactory(
      abi: any[],
      bytecode: ethers.BytesLike,
      signer?: ethers.Signer
    ): Promise<ethers.ContractFactory>;
    getContractAt(
      nameOrAbi: string | any[],
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<ethers.Contract>;
    deployContract(
      name: string,
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<ethers.Contract>;
    deployContract(
      name: string,
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<ethers.Contract>;
  }
}
</file>

<file path="typechain-types/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as openzeppelin from "./@openzeppelin";
export type { openzeppelin };
import type * as contracts from "./contracts";
export type { contracts };
export * as factories from "./factories";
export type { Ownable } from "./@openzeppelin/contracts/access/Ownable";
export { Ownable__factory } from "./factories/@openzeppelin/contracts/access/Ownable__factory";
export type { IERC1155Errors } from "./@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors";
export { IERC1155Errors__factory } from "./factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC1155Errors__factory";
export type { IERC20Errors } from "./@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors";
export { IERC20Errors__factory } from "./factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC20Errors__factory";
export type { IERC721Errors } from "./@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors";
export { IERC721Errors__factory } from "./factories/@openzeppelin/contracts/interfaces/draft-IERC6093.sol/IERC721Errors__factory";
export type { IERC1363 } from "./@openzeppelin/contracts/interfaces/IERC1363";
export { IERC1363__factory } from "./factories/@openzeppelin/contracts/interfaces/IERC1363__factory";
export type { Clones } from "./@openzeppelin/contracts/proxy/Clones";
export { Clones__factory } from "./factories/@openzeppelin/contracts/proxy/Clones__factory";
export type { ERC20 } from "./@openzeppelin/contracts/token/ERC20/ERC20";
export { ERC20__factory } from "./factories/@openzeppelin/contracts/token/ERC20/ERC20__factory";
export type { IERC20Metadata } from "./@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata";
export { IERC20Metadata__factory } from "./factories/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata__factory";
export type { IERC20 } from "./@openzeppelin/contracts/token/ERC20/IERC20";
export { IERC20__factory } from "./factories/@openzeppelin/contracts/token/ERC20/IERC20__factory";
export type { SafeERC20 } from "./@openzeppelin/contracts/token/ERC20/utils/SafeERC20";
export { SafeERC20__factory } from "./factories/@openzeppelin/contracts/token/ERC20/utils/SafeERC20__factory";
export type { Create2 } from "./@openzeppelin/contracts/utils/Create2";
export { Create2__factory } from "./factories/@openzeppelin/contracts/utils/Create2__factory";
export type { Errors } from "./@openzeppelin/contracts/utils/Errors";
export { Errors__factory } from "./factories/@openzeppelin/contracts/utils/Errors__factory";
export type { IERC165 } from "./@openzeppelin/contracts/utils/introspection/IERC165";
export { IERC165__factory } from "./factories/@openzeppelin/contracts/utils/introspection/IERC165__factory";
export type { SafeCast } from "./@openzeppelin/contracts/utils/math/SafeCast";
export { SafeCast__factory } from "./factories/@openzeppelin/contracts/utils/math/SafeCast__factory";
export type { ReentrancyGuard } from "./@openzeppelin/contracts/utils/ReentrancyGuard";
export { ReentrancyGuard__factory } from "./factories/@openzeppelin/contracts/utils/ReentrancyGuard__factory";
export type { IPancakeRouter02 } from "./contracts/interfaces/IPancakeRouter02";
export { IPancakeRouter02__factory } from "./factories/contracts/interfaces/IPancakeRouter02__factory";
export type { ITreasuryVault } from "./contracts/ITreasuryVault";
export { ITreasuryVault__factory } from "./factories/contracts/ITreasuryVault__factory";
export type { LaunchCampaign } from "./contracts/LaunchCampaign";
export { LaunchCampaign__factory } from "./factories/contracts/LaunchCampaign__factory";
export type { LaunchFactory } from "./contracts/LaunchFactory";
export { LaunchFactory__factory } from "./factories/contracts/LaunchFactory__factory";
export type { LpTimelock } from "./contracts/LpTimelock";
export { LpTimelock__factory } from "./factories/contracts/LpTimelock__factory";
export type { MockERC20 } from "./contracts/mocks/MockERC20";
export { MockERC20__factory } from "./factories/contracts/mocks/MockERC20__factory";
export type { MockFeeOnTransferERC20 } from "./contracts/mocks/MockFeeOnTransferERC20";
export { MockFeeOnTransferERC20__factory } from "./factories/contracts/mocks/MockFeeOnTransferERC20__factory";
export type { MockRouter } from "./contracts/mocks/MockRouter";
export { MockRouter__factory } from "./factories/contracts/mocks/MockRouter__factory";
export type { RevertingReceiver } from "./contracts/mocks/RevertingReceiver";
export { RevertingReceiver__factory } from "./factories/contracts/mocks/RevertingReceiver__factory";
export type { FactoryCaller } from "./contracts/test/FactoryCaller";
export { FactoryCaller__factory } from "./factories/contracts/test/FactoryCaller__factory";
export type { LaunchToken } from "./contracts/token/LaunchToken";
export { LaunchToken__factory } from "./factories/contracts/token/LaunchToken__factory";
export type { TreasuryRouter } from "./contracts/TreasuryRouter";
export { TreasuryRouter__factory } from "./factories/contracts/TreasuryRouter__factory";
export type { TreasuryVault } from "./contracts/TreasuryVault";
export { TreasuryVault__factory } from "./factories/contracts/TreasuryVault__factory";
export type { UPVoteTreasury } from "./contracts/UPVoteTreasury.sol/UPVoteTreasury";
export { UPVoteTreasury__factory } from "./factories/contracts/UPVoteTreasury.sol/UPVoteTreasury__factory";
</file>

<file path="types/ethers-contracts/BondingCurveSale.sol/BondingCurveSale.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../common.js"
  
export declare namespace BondingCurveSale {
      
    export type InitParamsStruct = {token: AddressLike, tierSize: BigNumberish, startPrice: BigNumberish, priceStep: BigNumberish, maxTiersPerTx: BigNumberish, platformFeeBps: BigNumberish, endTime: BigNumberish, hardCapBNB: BigNumberish, lpPercent: BigNumberish, router: AddressLike, treasury: AddressLike, payout: AddressLike, mode: BigNumberish}

    export type InitParamsStructOutput = [token: string, tierSize: bigint, startPrice: bigint, priceStep: bigint, maxTiersPerTx: bigint, platformFeeBps: bigint, endTime: bigint, hardCapBNB: bigint, lpPercent: bigint, router: string, treasury: string, payout: string, mode: bigint] & {token: string, tierSize: bigint, startPrice: bigint, priceStep: bigint, maxTiersPerTx: bigint, platformFeeBps: bigint, endTime: bigint, hardCapBNB: bigint, lpPercent: bigint, router: string, treasury: string, payout: string, mode: bigint }
  
    }

  export interface BondingCurveSaleInterface extends Interface {
    getFunction(nameOrSignature: "audit" | "audited" | "buy" | "endTime" | "externalOk" | "finalize" | "finalized" | "hardCapBNB" | "initialize" | "listingPrice" | "lpLockedUntil" | "lpPercent" | "maxTiersPerTx" | "mode" | "owner" | "paused" | "payout" | "platformFeeBps" | "priceStep" | "quoteTokensOut" | "raised" | "renounceOwnership" | "router" | "selfTestExternalToken" | "sold" | "startPrice" | "tierSize" | "token" | "transferOwnership" | "treasury" | "unpauseSale"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "Bought" | "ExternalSelfTestPassed" | "Finalized" | "OwnershipTransferred" | "Paused" | "SaleAudited" | "Unpaused"): EventFragment;

    encodeFunctionData(functionFragment: 'audit', values?: undefined): string;
encodeFunctionData(functionFragment: 'audited', values?: undefined): string;
encodeFunctionData(functionFragment: 'buy', values: [BigNumberish, BigNumberish]): string;
encodeFunctionData(functionFragment: 'endTime', values?: undefined): string;
encodeFunctionData(functionFragment: 'externalOk', values?: undefined): string;
encodeFunctionData(functionFragment: 'finalize', values?: undefined): string;
encodeFunctionData(functionFragment: 'finalized', values?: undefined): string;
encodeFunctionData(functionFragment: 'hardCapBNB', values?: undefined): string;
encodeFunctionData(functionFragment: 'initialize', values: [BondingCurveSale.InitParamsStruct]): string;
encodeFunctionData(functionFragment: 'listingPrice', values?: undefined): string;
encodeFunctionData(functionFragment: 'lpLockedUntil', values?: undefined): string;
encodeFunctionData(functionFragment: 'lpPercent', values?: undefined): string;
encodeFunctionData(functionFragment: 'maxTiersPerTx', values?: undefined): string;
encodeFunctionData(functionFragment: 'mode', values?: undefined): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
encodeFunctionData(functionFragment: 'payout', values?: undefined): string;
encodeFunctionData(functionFragment: 'platformFeeBps', values?: undefined): string;
encodeFunctionData(functionFragment: 'priceStep', values?: undefined): string;
encodeFunctionData(functionFragment: 'quoteTokensOut', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'raised', values?: undefined): string;
encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
encodeFunctionData(functionFragment: 'router', values?: undefined): string;
encodeFunctionData(functionFragment: 'selfTestExternalToken', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'sold', values?: undefined): string;
encodeFunctionData(functionFragment: 'startPrice', values?: undefined): string;
encodeFunctionData(functionFragment: 'tierSize', values?: undefined): string;
encodeFunctionData(functionFragment: 'token', values?: undefined): string;
encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'treasury', values?: undefined): string;
encodeFunctionData(functionFragment: 'unpauseSale', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'audit', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'audited', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'buy', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'endTime', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'externalOk', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'finalize', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'finalized', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'hardCapBNB', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'listingPrice', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'lpLockedUntil', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'lpPercent', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'maxTiersPerTx', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'mode', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'payout', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'platformFeeBps', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'priceStep', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'quoteTokensOut', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'raised', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'router', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'selfTestExternalToken', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'sold', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'startPrice', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'tierSize', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'token', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'treasury', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'unpauseSale', data: BytesLike): Result;
  }

  
    export namespace BoughtEvent {
      export type InputTuple = [buyer: AddressLike, bnbIn: BigNumberish, fee: BigNumberish, netBNB: BigNumberish, tokensOut: BigNumberish, tierStart: BigNumberish, tiersCrossed: BigNumberish, soldAfter: BigNumberish];
      export type OutputTuple = [buyer: string, bnbIn: bigint, fee: bigint, netBNB: bigint, tokensOut: bigint, tierStart: bigint, tiersCrossed: bigint, soldAfter: bigint];
      export interface OutputObject {buyer: string, bnbIn: bigint, fee: bigint, netBNB: bigint, tokensOut: bigint, tierStart: bigint, tiersCrossed: bigint, soldAfter: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ExternalSelfTestPassedEvent {
      export type InputTuple = [probeAmount: BigNumberish];
      export type OutputTuple = [probeAmount: bigint];
      export interface OutputObject {probeAmount: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace FinalizedEvent {
      export type InputTuple = [raised: BigNumberish, lpBNB: BigNumberish, lpTokens: BigNumberish, listingPrice: BigNumberish, lockUntil: BigNumberish];
      export type OutputTuple = [raised: bigint, lpBNB: bigint, lpTokens: bigint, listingPrice: bigint, lockUntil: bigint];
      export interface OutputObject {raised: bigint, lpBNB: bigint, lpTokens: bigint, listingPrice: bigint, lockUntil: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace OwnershipTransferredEvent {
      export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
      export type OutputTuple = [previousOwner: string, newOwner: string];
      export interface OutputObject {previousOwner: string, newOwner: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace PausedEvent {
      export type InputTuple = [account: AddressLike];
      export type OutputTuple = [account: string];
      export interface OutputObject {account: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace SaleAuditedEvent {
      export type InputTuple = [];
      export type OutputTuple = [];
      export interface OutputObject {};
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace UnpausedEvent {
      export type InputTuple = [account: AddressLike];
      export type OutputTuple = [account: string];
      export interface OutputObject {account: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface BondingCurveSale extends BaseContract {
    
    connect(runner?: ContractRunner | null): BondingCurveSale;
    waitForDeployment(): Promise<this>;

    interface: BondingCurveSaleInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    audit: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    audited: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    buy: TypedContractMethod<
      [minTokensOut: BigNumberish, deadline: BigNumberish, ],
      [void],
      'payable'
    >
    

    
    endTime: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    externalOk: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    finalize: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    finalized: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    hardCapBNB: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    initialize: TypedContractMethod<
      [params: BondingCurveSale.InitParamsStruct, ],
      [void],
      'nonpayable'
    >
    

    
    listingPrice: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    lpLockedUntil: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    lpPercent: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    maxTiersPerTx: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    mode: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    paused: TypedContractMethod<
      [],
      [boolean],
      'view'
    >
    

    
    payout: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    platformFeeBps: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    priceStep: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    quoteTokensOut: TypedContractMethod<
      [bnbIn: BigNumberish, ],
      [[bigint, bigint, bigint] & {tokensOut: bigint, bnbUsed: bigint, tiersCrossed: bigint }],
      'view'
    >
    

    
    raised: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    renounceOwnership: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    router: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    selfTestExternalToken: TypedContractMethod<
      [probeAmount: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    sold: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    startPrice: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    tierSize: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    token: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    transferOwnership: TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    treasury: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    unpauseSale: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'audit'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'audited'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'buy'): TypedContractMethod<
      [minTokensOut: BigNumberish, deadline: BigNumberish, ],
      [void],
      'payable'
    >;
getFunction(nameOrSignature: 'endTime'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'externalOk'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'finalize'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'finalized'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'hardCapBNB'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'initialize'): TypedContractMethod<
      [params: BondingCurveSale.InitParamsStruct, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'listingPrice'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'lpLockedUntil'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'lpPercent'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'maxTiersPerTx'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'mode'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'paused'): TypedContractMethod<
      [],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'payout'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'platformFeeBps'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'priceStep'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'quoteTokensOut'): TypedContractMethod<
      [bnbIn: BigNumberish, ],
      [[bigint, bigint, bigint] & {tokensOut: bigint, bnbUsed: bigint, tiersCrossed: bigint }],
      'view'
    >;
getFunction(nameOrSignature: 'raised'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'router'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'selfTestExternalToken'): TypedContractMethod<
      [probeAmount: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'sold'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'startPrice'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'tierSize'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'token'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'treasury'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'unpauseSale'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'Bought'): TypedContractEvent<BoughtEvent.InputTuple, BoughtEvent.OutputTuple, BoughtEvent.OutputObject>;
getEvent(key: 'ExternalSelfTestPassed'): TypedContractEvent<ExternalSelfTestPassedEvent.InputTuple, ExternalSelfTestPassedEvent.OutputTuple, ExternalSelfTestPassedEvent.OutputObject>;
getEvent(key: 'Finalized'): TypedContractEvent<FinalizedEvent.InputTuple, FinalizedEvent.OutputTuple, FinalizedEvent.OutputObject>;
getEvent(key: 'OwnershipTransferred'): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
getEvent(key: 'Paused'): TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
getEvent(key: 'SaleAudited'): TypedContractEvent<SaleAuditedEvent.InputTuple, SaleAuditedEvent.OutputTuple, SaleAuditedEvent.OutputObject>;
getEvent(key: 'Unpaused'): TypedContractEvent<UnpausedEvent.InputTuple, UnpausedEvent.OutputTuple, UnpausedEvent.OutputObject>;

    filters: {
      
      'Bought(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256)': TypedContractEvent<BoughtEvent.InputTuple, BoughtEvent.OutputTuple, BoughtEvent.OutputObject>;
      Bought: TypedContractEvent<BoughtEvent.InputTuple, BoughtEvent.OutputTuple, BoughtEvent.OutputObject>;
    

      'ExternalSelfTestPassed(uint256)': TypedContractEvent<ExternalSelfTestPassedEvent.InputTuple, ExternalSelfTestPassedEvent.OutputTuple, ExternalSelfTestPassedEvent.OutputObject>;
      ExternalSelfTestPassed: TypedContractEvent<ExternalSelfTestPassedEvent.InputTuple, ExternalSelfTestPassedEvent.OutputTuple, ExternalSelfTestPassedEvent.OutputObject>;
    

      'Finalized(uint256,uint256,uint256,uint256,uint256)': TypedContractEvent<FinalizedEvent.InputTuple, FinalizedEvent.OutputTuple, FinalizedEvent.OutputObject>;
      Finalized: TypedContractEvent<FinalizedEvent.InputTuple, FinalizedEvent.OutputTuple, FinalizedEvent.OutputObject>;
    

      'OwnershipTransferred(address,address)': TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
      OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    

      'Paused(address)': TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
      Paused: TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
    

      'SaleAudited()': TypedContractEvent<SaleAuditedEvent.InputTuple, SaleAuditedEvent.OutputTuple, SaleAuditedEvent.OutputObject>;
      SaleAudited: TypedContractEvent<SaleAuditedEvent.InputTuple, SaleAuditedEvent.OutputTuple, SaleAuditedEvent.OutputObject>;
    

      'Unpaused(address)': TypedContractEvent<UnpausedEvent.InputTuple, UnpausedEvent.OutputTuple, UnpausedEvent.OutputObject>;
      Unpaused: TypedContractEvent<UnpausedEvent.InputTuple, UnpausedEvent.OutputTuple, UnpausedEvent.OutputObject>;
    
    };
  }
</file>

<file path="types/ethers-contracts/BondingCurveSale.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { BondingCurveSale } from './BondingCurveSale.js';
</file>

<file path="types/ethers-contracts/common.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  FunctionFragment,
  Typed,
  EventFragment,
  ContractTransaction,
  ContractTransactionResponse,
  DeferredTopicFilter,
  EventLog,
  TransactionRequest,
  LogDescription,
} from 'ethers'

export interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent> extends DeferredTopicFilter {}

export interface TypedContractEvent<
  InputTuple extends Array<any> = any,
  OutputTuple extends Array<any> = any,
  OutputObject = any,
> {
  (...args: Partial<InputTuple>): TypedDeferredTopicFilter<TypedContractEvent<InputTuple, OutputTuple, OutputObject>>
  name: string
  fragment: EventFragment
  getFragment(...args: Partial<InputTuple>): EventFragment
}

type __TypechainAOutputTuple<T> = T extends TypedContractEvent<infer _U, infer W> ? W : never
type __TypechainOutputObject<T> = T extends TypedContractEvent<infer _U, infer _W, infer V> ? V : never

export interface TypedEventLog<TCEvent extends TypedContractEvent> extends Omit<EventLog, 'args'> {
  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>
}

export interface TypedLogDescription<TCEvent extends TypedContractEvent> extends Omit<LogDescription, 'args'> {
  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>
}

export type TypedListener<TCEvent extends TypedContractEvent> = (
  ...listenerArg: [...__TypechainAOutputTuple<TCEvent>, TypedEventLog<TCEvent>, ...undefined[]]
) => void

export type MinEthersFactory<C, ARGS> = {
  deploy(...a: ARGS[]): Promise<C>
}

export type GetContractTypeFromFactory<F> = F extends MinEthersFactory<infer C, any> ? C : never
export type GetARGsTypeFromFactory<F> = F extends MinEthersFactory<any, any> ? Parameters<F['deploy']> : never

export type StateMutability = 'nonpayable' | 'payable' | 'view'

export type BaseOverrides = Omit<TransactionRequest, 'to' | 'data'>
export type NonPayableOverrides = Omit<BaseOverrides, 'value' | 'blockTag' | 'enableCcipRead'>
export type PayableOverrides = Omit<BaseOverrides, 'blockTag' | 'enableCcipRead'>
export type ViewOverrides = Omit<TransactionRequest, 'to' | 'data'>
export type Overrides<S extends StateMutability> = S extends 'nonpayable'
  ? NonPayableOverrides
  : S extends 'payable'
  ? PayableOverrides
  : ViewOverrides

export type PostfixOverrides<A extends Array<any>, S extends StateMutability> = A | [...A, Overrides<S>]
export type ContractMethodArgs<A extends Array<any>, S extends StateMutability> = PostfixOverrides<
  { [I in keyof A]-?: A[I] | Typed },
  S
>

export type DefaultReturnType<R> = R extends Array<any> ? R[0] : R

// export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {
export interface TypedContractMethod<
  A extends Array<any> = Array<any>,
  R = any,
  S extends StateMutability = 'payable',
> {
  (...args: ContractMethodArgs<A, S>): S extends 'view'
    ? Promise<DefaultReturnType<R>>
    : Promise<ContractTransactionResponse>

  name: string

  fragment: FunctionFragment

  getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment

  populateTransaction(...args: ContractMethodArgs<A, S>): Promise<ContractTransaction>
  staticCall(...args: ContractMethodArgs<A, 'view'>): Promise<DefaultReturnType<R>>
  send(...args: ContractMethodArgs<A, S>): Promise<ContractTransactionResponse>
  estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>
  staticCallResult(...args: ContractMethodArgs<A, 'view'>): Promise<R>
}
</file>

<file path="types/ethers-contracts/factories/BondingCurveSale.sol/BondingCurveSale__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { Addressable } from "ethers";
import { Contract, ContractFactory, ContractTransactionResponse, Interface } from "ethers"
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers"
import type { NonPayableOverrides } from "../../common.js"
  import type { BondingCurveSale, BondingCurveSaleInterface } from "../../BondingCurveSale.sol/BondingCurveSale.js";

  const _abi = [
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "EnforcedPause",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ExpectedPause",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SafeERC20FailedOperation",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "buyer",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "bnbIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "fee",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "netBNB",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "tokensOut",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "tierStart",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "tiersCrossed",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "soldAfter",
        "type": "uint256"
      }
    ],
    "name": "Bought",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "probeAmount",
        "type": "uint256"
      }
    ],
    "name": "ExternalSelfTestPassed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "raised",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "lpBNB",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "lpTokens",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "listingPrice",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "lockUntil",
        "type": "uint256"
      }
    ],
    "name": "Finalized",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [],
    "name": "SaleAudited",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "audit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "audited",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "minTokensOut",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      }
    ],
    "name": "buy",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "endTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "externalOk",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "finalize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "finalized",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "hardCapBNB",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tierSize",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "startPrice",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "priceStep",
            "type": "uint256"
          },
          {
            "internalType": "uint8",
            "name": "maxTiersPerTx",
            "type": "uint8"
          },
          {
            "internalType": "uint16",
            "name": "platformFeeBps",
            "type": "uint16"
          },
          {
            "internalType": "uint256",
            "name": "endTime",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "hardCapBNB",
            "type": "uint256"
          },
          {
            "internalType": "uint16",
            "name": "lpPercent",
            "type": "uint16"
          },
          {
            "internalType": "address",
            "name": "router",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "treasury",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "payout",
            "type": "address"
          },
          {
            "internalType": "enum BondingCurveSale.Mode",
            "name": "mode",
            "type": "uint8"
          }
        ],
        "internalType": "struct BondingCurveSale.InitParams",
        "name": "params",
        "type": "tuple"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "listingPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lpLockedUntil",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lpPercent",
    "outputs": [
      {
        "internalType": "uint16",
        "name": "",
        "type": "uint16"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "maxTiersPerTx",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "mode",
    "outputs": [
      {
        "internalType": "enum BondingCurveSale.Mode",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "paused",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "payout",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "platformFeeBps",
    "outputs": [
      {
        "internalType": "uint16",
        "name": "",
        "type": "uint16"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "priceStep",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "bnbIn",
        "type": "uint256"
      }
    ],
    "name": "quoteTokensOut",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "tokensOut",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "bnbUsed",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "tiersCrossed",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "raised",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "router",
    "outputs": [
      {
        "internalType": "contract IPancakeRouter02",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "probeAmount",
        "type": "uint256"
      }
    ],
    "name": "selfTestExternalToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "sold",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "startPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "tierSize",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "treasury",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "unpauseSale",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
] as const;

  const _bytecode = "0x608060405234801561000f575f80fd5b50308061003557604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b61003e81610048565b5060018055610097565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6121f1806100a45f395ff3fe6080604052600436106101d0575f3560e01c8063715018a6116100fd578063d6febde811610092578063f1a9af8911610062578063f1a9af89146104ff578063f2fde38b14610514578063f887ea4014610533578063fc0c546a14610552575f80fd5b8063d6febde814610483578063e091a29714610496578063ee9fab2c146104b0578063f0ea4bfc146104ea575f80fd5b8063b3f05b97116100cd578063b3f05b971461042c578063bb33d72914610445578063c78f19f914610459578063d5c786d51461046e575f80fd5b8063715018a6146103d257806388d519c4146103e65780638da5cb5b146103fb578063aa31f12a14610417575f80fd5b80633197cbb6116101735780635c975abb116101435780635c975abb1461034a57806361d027b31461036157806363bd1d4a1461039e57806368a9a2fd146103bd575f80fd5b80633197cbb6146102e3578063454967e2146102f85780634bb278f3146103175780634c6bf3521461032b575f80fd5b80631315b57d116101ae5780631315b57d146102435780631ddc0ef01461026e57806322dcd13e14610284578063295a5212146102b6575f80fd5b80630151a712146101d457806302c7e7af146102075780630baff0531461022a575b5f80fd5b3480156101df575f80fd5b50600e546101f290610100900460ff1681565b60405190151581526020015b60405180910390f35b348015610212575f80fd5b5061021c600c5481565b6040519081526020016101fe565b348015610235575f80fd5b506011546101f29060ff1681565b34801561024e575f80fd5b5060075461025c9060ff1681565b60405160ff90911681526020016101fe565b348015610279575f80fd5b50610282610576565b005b34801561028f575f80fd5b506007546102a390610100900461ffff1681565b60405161ffff90911681526020016101fe565b3480156102c1575f80fd5b50600b546102d690600160a01b900460ff1681565b6040516101fe9190611ea5565b3480156102ee575f80fd5b5061021c60085481565b348015610303575f80fd5b50610282610312366004611f5d565b6108b0565b348015610322575f80fd5b50610282610a68565b348015610336575f80fd5b50610282610345366004612036565b610f48565b348015610355575f80fd5b5060025460ff166101f2565b34801561036c575f80fd5b50600a54610386906201000090046001600160a01b031681565b6040516001600160a01b0390911681526020016101fe565b3480156103a9575f80fd5b50600b54610386906001600160a01b031681565b3480156103c8575f80fd5b5061021c60045481565b3480156103dd575f80fd5b506102826112bd565b3480156103f1575f80fd5b5061021c60065481565b348015610406575f80fd5b505f546001600160a01b0316610386565b348015610422575f80fd5b5061021c60105481565b348015610437575f80fd5b50600e546101f29060ff1681565b348015610450575f80fd5b506102826112ce565b348015610464575f80fd5b5061021c600f5481565b348015610479575f80fd5b5061021c60095481565b61028261049136600461204d565b61131d565b3480156104a1575f80fd5b50600a546102a39061ffff1681565b3480156104bb575f80fd5b506104cf6104ca366004612036565b6116c6565b604080519384526020840192909252908201526060016101fe565b3480156104f5575f80fd5b5061021c600d5481565b34801561050a575f80fd5b5061021c60055481565b34801561051f575f80fd5b5061028261052e36600461206d565b61183c565b34801561053e575f80fd5b50600354610386906001600160a01b031681565b34801561055d575f80fd5b506002546103869061010090046001600160a01b031681565b61057e611876565b60115460ff16156105c85760405162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e48185d591a5d1959608a1b60448201526064015b60405180910390fd5b6001600b54600160a01b900460ff1660018111156105e8576105e8611e91565b1480156105fd5750600e54610100900460ff16155b156106415760405162461bcd60e51b815260206004820152601460248201527314d95b198b5d195cdd081b9bdd081c185cdcd95960621b60448201526064016105bf565b600260019054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa9250505080156106b0575060408051601f3d908101601f191682019092526106ad9181019061208f565b60015b6106fc5760405162461bcd60e51b815260206004820152601760248201527f546f6b656e20686173206e6f20646563696d616c73282900000000000000000060448201526064016105bf565b8060ff166012146107465760405162461bcd60e51b81526020600482015260146024820152730a8ded6cadc40c8cac6d2dac2d8e640427a4062760631b60448201526064016105bf565b505f600454116107885760405162461bcd60e51b815260206004820152600d60248201526c7469657253697a65207a65726f60981b60448201526064016105bf565b60075460ff166107cf5760405162461bcd60e51b81526020600482015260126024820152716d617854696572735065725478207a65726f60701b60448201526064016105bf565b6007546103e861010090910461ffff16111561081c5760405162461bcd60e51b815260206004820152600c60248201526b08ccaca40e8dede40d0d2ced60a31b60448201526064016105bf565b6005546006545f9061082e90836120be565b9050818110156108775760405162461bcd60e51b81526020600482015260146024820152734e6f6e2d696e6372656173696e6720707269636560601b60448201526064016105bf565b6011805460ff191660011790556040517fb0d9faf9d00648965a2d7a2f09bb043d5e75236225bd4871040dfc44f2ca0e2e905f90a15050565b60025461010090046001600160a01b0316156109045760405162461bcd60e51b8152602060048201526013602482015272105b1c9958591e481a5b9a5d1a585b1a5e9959606a1b60448201526064016105bf565b80516001600160a01b03166109485760405162461bcd60e51b815260206004820152600a602482015269546f6b656e207a65726f60b01b60448201526064016105bf565b610951336118a2565b805160028054610100600160a81b0319166101006001600160a01b03938416810291909117909155610120830151600380546001600160a01b031990811692851692909217905560208401516004556040840151600555606084015160065560808401516007805460a087015160ff90931662ffffff199091161761ffff928316850217905560c085015160085560e085015160095591840151600a8054610140870151929094166001600160b01b031990941693909317620100009185169190910217909155610160830151600b805492831691909316908117835561018084015192916001600160a81b03191617600160a01b836001811115610a5857610a58611e91565b0217905550610a656118f1565b50565b610a7061194b565b610a78611876565b600e5460ff1615610abf5760405162461bcd60e51b8152602060048201526011602482015270105b1c9958591e48199a5b985b1a5e9959607a1b60448201526064016105bf565b610ac76118f1565b60085415610b0d57600854421015610b0d5760405162461bcd60e51b8152602060048201526009602482015268139bdd08195b99195960ba1b60448201526064016105bf565b600e805460ff19166001179055600454600c545f91610b2b916120e5565b905080600654610b3b91906120f8565b600554610b4891906120be565b600f55600a54600d545f9161271091610b659161ffff16906120f8565b610b6f91906120e5565b90505f600f5482670de0b6b3a7640000610b8991906120f8565b610b9391906120e5565b90505f600b54600160a01b900460ff166001811115610bb457610bb4611e91565b03610ca357604051306024820152604481018290525f9060640160408051808303601f190181529181526020820180516340c10f1960e01b6001600160e01b0390911617905260025490519192505f916101009091046001600160a01b031690610c1f90849061210f565b5f604051808303815f865af19150503d805f8114610c58576040519150601f19603f3d011682016040523d82523d5f602084013e610c5d565b606091505b5050905080610c9c5760405162461bcd60e51b815260206004820152600b60248201526a135a5b9d0819985a5b195960aa1b60448201526064016105bf565b5050610d4f565b6002546040516370a0823160e01b8152306004820152829161010090046001600160a01b0316906370a0823190602401602060405180830381865afa158015610cee573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610d12919061213b565b1015610d4f5760405162461bcd60e51b815260206004820152600c60248201526b115cd8dc9bddc81cda1bdc9d60a21b60448201526064016105bf565b600354600254610d71916001600160a01b036101009092048216911683611975565b6003546002545f916001600160a01b039081169163f305d71991869161010090041685858030610da3426104b06120be565b60405160e089901b6001600160e01b03191681526001600160a01b039687166004820152602481019590955260448501939093526064840191909152909216608482015260a481019190915260c40160606040518083038185885af1158015610e0e573d5f803e3d5ffd5b50505050506040513d601f19601f82011682018060405250810190610e339190612152565b925050504262ed4e00610e4691906120be565b601055478015610ee257600b546040515f916001600160a01b03169083908381818185875af1925050503d805f8114610e9a576040519150601f19603f3d011682016040523d82523d5f602084013e610e9f565b606091505b5050905080610ee05760405162461bcd60e51b815260206004820152600d60248201526c14185e5bdd5d0819985a5b1959609a1b60448201526064016105bf565b505b600d54600f5460105460408051938452602084018890528301859052606083019190915260808201527fc41f0f98d4fb976b95447bf10532e466abd386fadc28f784f4d9882713ddd86d9060a00160405180910390a15050505050610f4660018055565b565b610f50611876565b600e54610100900460ff1615610f995760405162461bcd60e51b815260206004820152600e60248201526d105b1c9958591e481d195cdd195960921b60448201526064016105bf565b600260019054906101000a90046001600160a01b03166001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610fea573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061100e919061208f565b60ff1660121461104f5760405162461bcd60e51b815260206004820152600c60248201526b42616420646563696d616c7360a01b60448201526064016105bf565b5f600b54600160a01b900460ff16600181111561106e5761106e611e91565b0361116457604051306024820152604481018290525f9060640160408051808303601f190181529181526020820180516340c10f1960e01b6001600160e01b0390911617905260025490519192505f916101009091046001600160a01b0316906110d990849061210f565b5f604051808303815f865af19150503d805f8114611112576040519150601f19603f3d011682016040523d82523d5f602084013e611117565b606091505b505090508061115d5760405162461bcd60e51b815260206004820152601260248201527127379036b4b73a103832b936b4b9b9b4b7b760711b60448201526064016105bf565b5050611215565b6002546040516370a0823160e01b8152306004820152829161010090046001600160a01b0316906370a0823190602401602060405180830381865afa1580156111af573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906111d3919061213b565b10156112155760405162461bcd60e51b81526020600482015260116024820152704e6f7420656e6f75676820657363726f7760781b60448201526064016105bf565b6002546112319061010090046001600160a01b03163083611a02565b5f600b54600160a01b900460ff16600181111561125057611250611e91565b03611271576002546112719061010090046001600160a01b03165f80611b45565b600e805461ff0019166101001790556040517fbf0e94a702abc5c74343be357bb4653bd75312708420e58778789f87bb1fee57906112b29083815260200190565b60405180910390a150565b6112c5611876565b610f465f6118a2565b6112d6611876565b600e5460ff16156113155760405162461bcd60e51b8152602060048201526009602482015268119a5b985b1a5e995960ba1b60448201526064016105bf565b610f46611ba9565b61132561194b565b61132d611be2565b600e5460ff16156113715760405162461bcd60e51b815260206004820152600e60248201526d14d85b1948199a5b985b1a5e995960921b60448201526064016105bf565b600e54610100900460ff168061139057505f546001600160a01b031633145b6113ce5760405162461bcd60e51b815260206004820152600f60248201526e45787465726e616c206e6f74204f4b60881b60448201526064016105bf565b801561140e578042111561140e5760405162461bcd60e51b8152602060048201526007602482015266115e1c1a5c995960ca1b60448201526064016105bf565b600854156114545760085442106114545760405162461bcd60e51b815260206004820152600a60248201526914d85b1948195b99195960b21b60448201526064016105bf565b348061148d5760405162461bcd60e51b81526020600482015260086024820152672d32b9379021272160c11b60448201526064016105bf565b600954156114e75760095481600d546114a691906120be565b11156114e75760405162461bcd60e51b815260206004820152601060248201526f12185c990818d85c081c995858da195960821b60448201526064016105bf565b6007545f906127109061150390610100900461ffff16846120f8565b61150d91906120e5565b90505f61151a828461217d565b600a546040519192505f91620100009091046001600160a01b03169084908381818185875af1925050503d805f811461156e576040519150601f19603f3d011682016040523d82523d5f602084013e611573565b606091505b50509050806115b65760405162461bcd60e51b815260206004820152600f60248201526e119959481cd95b990819985a5b1959608a1b60448201526064016105bf565b5f806115c1846116c6565b9250509150878210156116015760405162461bcd60e51b8152602060048201526008602482015267536c69707061676560c01b60448201526064016105bf565b81600c5f82825461161291906120be565b9250508190555085600d5f82825461162a91906120be565b9091555061163a90503383611c06565b336001600160a01b03167f281eb98c54359b388539461afe675a5276d4a48546196ccb3f81f8d4b10622f987878786600454600c5461167991906120e5565b600c54604080519687526020870195909552938501929092526060840152608083015260a0820185905260c082015260e00160405180910390a25050505050506116c260018055565b5050565b600c545f9081908190849081835b60075460ff16811015611824575f600454846116f091906120e5565b90505f600454856117019190612190565b90505f81600454611712919061217d565b90505f8360065461172391906120f8565b60055461173091906120be565b90505f670de0b6b3a764000061174683856120f8565b61175091906120e5565b905080871061179457611763838d6120be565b9b5061176f818861217d565b965061177b83896120be565b975089611787816121a3565b9a5050505050505061181c565b5f826117a889670de0b6b3a76400006120f8565b6117b291906120e5565b9050838111156117bf5750825b6117c9818e6120be565b9c506117d5888b61217d565b9b508c670de0b6b3a76400006117eb85846120f8565b6117f591906120e5565b6117ff8a8d61217d565b61180991906120be565b9c509c5050505050505050505050611835565b6001016116d4565b5061182f818461217d565b94505050505b9193909250565b611844611876565b6001600160a01b03811661186d57604051631e4fbdf760e01b81525f60048201526024016105bf565b610a65816118a2565b5f546001600160a01b03163314610f465760405163118cdaa760e01b81523360048201526024016105bf565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6118f9611be2565b6002805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861192e3390565b6040516001600160a01b03909116815260200160405180910390a1565b60026001540361196e57604051633ee5aeb560e01b815260040160405180910390fd5b6002600155565b604051636eb1769f60e11b81523060048201526001600160a01b0383811660248301525f919085169063dd62ed3e90604401602060405180830381865afa1580156119c2573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119e6919061213b565b90506119fc84846119f785856120be565b611d2c565b50505050565b6040516370a0823160e01b81526001600160a01b0383811660048301525f91908516906370a0823190602401602060405180830381865afa158015611a49573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611a6d919061213b565b9050611a836001600160a01b0385168484611b45565b6040516370a0823160e01b81526001600160a01b0384811660048301525f91908616906370a0823190602401602060405180830381865afa158015611aca573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611aee919061213b565b905082611afb838361217d565b14611b3e5760405162461bcd60e51b81526020600482015260136024820152722a37b5b2b7103a30bc17b232b33630ba34b7b760691b60448201526064016105bf565b5050505050565b6040516001600160a01b03838116602483015260448201839052611ba491859182169063a9059cbb906064015b604051602081830303815290604052915060e01b6020820180516001600160e01b038381831617835250505050611db7565b505050565b611bb1611e23565b6002805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa3361192e565b60025460ff1615610f465760405163d93c066560e01b815260040160405180910390fd5b5f600b54600160a01b900460ff166001811115611c2557611c25611e91565b03611d1057604051306024820152604481018290525f9060640160408051808303601f190181529181526020820180516340c10f1960e01b6001600160e01b0390911617905260025490519192505f916101009091046001600160a01b031690611c9090849061210f565b5f604051808303815f865af19150503d805f8114611cc9576040519150601f19603f3d011682016040523d82523d5f602084013e611cce565b606091505b5050905080611d0d5760405162461bcd60e51b815260206004820152600b60248201526a135a5b9d0819985a5b195960aa1b60448201526064016105bf565b50505b6002546116c29061010090046001600160a01b03168383611a02565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b179052611d7d8482611e46565b6119fc576040516001600160a01b0384811660248301525f6044830152611db191869182169063095ea7b390606401611b72565b6119fc84825b5f8060205f8451602086015f885af180611dd6576040513d5f823e3d81fd5b50505f513d91508115611ded578060011415611dfa565b6001600160a01b0384163b155b156119fc57604051635274afe760e01b81526001600160a01b03851660048201526024016105bf565b60025460ff16610f4657604051638dfc202b60e01b815260040160405180910390fd5b5f805f8060205f8651602088015f8a5af192503d91505f519050828015611e8557508115611e775780600114611e85565b5f866001600160a01b03163b115b93505050505b92915050565b634e487b7160e01b5f52602160045260245ffd5b6020810160028310611ec557634e487b7160e01b5f52602160045260245ffd5b91905290565b6040516101a0810167ffffffffffffffff81118282101715611efb57634e487b7160e01b5f52604160045260245ffd5b60405290565b6001600160a01b0381168114610a65575f80fd5b8035611f2081611f01565b919050565b60ff81168114610a65575f80fd5b8035611f2081611f25565b803561ffff81168114611f20575f80fd5b803560028110611f20575f80fd5b5f6101a08284031215611f6e575f80fd5b611f76611ecb565b611f7f83611f15565b8152602083013560208201526040830135604082015260608301356060820152611fab60808401611f33565b6080820152611fbc60a08401611f3e565b60a082015260c083013560c082015260e083013560e0820152610100611fe3818501611f3e565b90820152610120611ff5848201611f15565b90820152610140612007848201611f15565b90820152610160612019848201611f15565b9082015261018061202b848201611f4f565b908201529392505050565b5f60208284031215612046575f80fd5b5035919050565b5f806040838503121561205e575f80fd5b50508035926020909101359150565b5f6020828403121561207d575f80fd5b813561208881611f01565b9392505050565b5f6020828403121561209f575f80fd5b815161208881611f25565b634e487b7160e01b5f52601160045260245ffd5b80820180821115611e8b57611e8b6120aa565b634e487b7160e01b5f52601260045260245ffd5b5f826120f3576120f36120d1565b500490565b8082028115828204841417611e8b57611e8b6120aa565b5f82515f5b8181101561212e5760208186018101518583015201612114565b505f920191825250919050565b5f6020828403121561214b575f80fd5b5051919050565b5f805f60608486031215612164575f80fd5b8351925060208401519150604084015190509250925092565b81810381811115611e8b57611e8b6120aa565b5f8261219e5761219e6120d1565b500690565b5f600182016121b4576121b46120aa565b506001019056fea264697066735822122055e20e52ff4a2a3f04e79f2dbc89f514e00045ff39bf2ed69d4dae2c3499c49764736f6c63430008170033";

  
      type BondingCurveSaleConstructorParams = [signer?: Signer] | ConstructorParameters<typeof ContractFactory>;

      const isSuperArgs = (xs: BondingCurveSaleConstructorParams): xs is ConstructorParameters<typeof ContractFactory> =>
        xs.length > 1
    

  export class BondingCurveSale__factory extends ContractFactory {
    
      constructor(...args: BondingCurveSaleConstructorParams) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        
      }
    
    override getDeployTransaction(overrides?: NonPayableOverrides & { from?: string }): Promise<ContractDeployTransaction> {
      return super.getDeployTransaction(overrides || {});
    };
    override deploy(overrides?: NonPayableOverrides & { from?: string }) {
      return super.deploy(overrides || {}) as Promise<BondingCurveSale & {
        deploymentTransaction(): ContractTransactionResponse;
      }>;
    }
    override connect(runner: ContractRunner | null): BondingCurveSale__factory {
      return super.connect(runner) as BondingCurveSale__factory;
    }
    
    
    static readonly bytecode = _bytecode;
    static readonly abi = _abi;
    static createInterface(): BondingCurveSaleInterface {
      return new Interface(_abi) as BondingCurveSaleInterface;
    }
    
    override attach(address: string | Addressable): BondingCurveSale {
      return super.attach(address) as BondingCurveSale;
    }
  static connect(address: string, runner?: ContractRunner | null): BondingCurveSale {
      return new Contract(address, _abi, runner) as unknown as BondingCurveSale;
    }
  }
</file>

<file path="types/ethers-contracts/factories/BondingCurveSale.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { BondingCurveSale__factory } from './BondingCurveSale__factory.js';
</file>

<file path="types/ethers-contracts/factories/Factory.sol/Factory__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { Addressable } from "ethers";
import { Contract, ContractFactory, ContractTransactionResponse, Interface } from "ethers"
import type { Signer, AddressLike, ContractDeployTransaction, ContractRunner } from "ethers"
import type { NonPayableOverrides } from "../../common.js"
  import type { Factory, FactoryInterface } from "../../Factory.sol/Factory.js";

  const _abi = [
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token_",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "sale_",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "FailedDeployment",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "InsufficientBalance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "launchId",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sale",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "externalToken",
        "type": "bool"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "creator",
        "type": "address"
      }
    ],
    "name": "LaunchCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "inputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tierSize",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "startPrice",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "priceStep",
            "type": "uint256"
          },
          {
            "internalType": "uint8",
            "name": "maxTiersPerTx",
            "type": "uint8"
          },
          {
            "internalType": "uint16",
            "name": "platformFeeBps",
            "type": "uint16"
          },
          {
            "internalType": "uint256",
            "name": "endTime",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "hardCapBNB",
            "type": "uint256"
          },
          {
            "internalType": "uint16",
            "name": "lpPercent",
            "type": "uint16"
          },
          {
            "internalType": "address",
            "name": "router",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "treasury",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "payout",
            "type": "address"
          },
          {
            "internalType": "enum BondingCurveSale.Mode",
            "name": "mode",
            "type": "uint8"
          }
        ],
        "internalType": "struct BondingCurveSale.InitParams",
        "name": "initParams",
        "type": "tuple"
      }
    ],
    "name": "createExternalSale",
    "outputs": [
      {
        "internalType": "address",
        "name": "saleAddr",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "symbol",
        "type": "string"
      },
      {
        "components": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "tierSize",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "startPrice",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "priceStep",
            "type": "uint256"
          },
          {
            "internalType": "uint8",
            "name": "maxTiersPerTx",
            "type": "uint8"
          },
          {
            "internalType": "uint16",
            "name": "platformFeeBps",
            "type": "uint16"
          },
          {
            "internalType": "uint256",
            "name": "endTime",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "hardCapBNB",
            "type": "uint256"
          },
          {
            "internalType": "uint16",
            "name": "lpPercent",
            "type": "uint16"
          },
          {
            "internalType": "address",
            "name": "router",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "treasury",
            "type": "address"
          },
          {
            "internalType": "address payable",
            "name": "payout",
            "type": "address"
          },
          {
            "internalType": "enum BondingCurveSale.Mode",
            "name": "mode",
            "type": "uint8"
          }
        ],
        "internalType": "struct BondingCurveSale.InitParams",
        "name": "initParams",
        "type": "tuple"
      }
    ],
    "name": "createLaunch",
    "outputs": [
      {
        "internalType": "address",
        "name": "tokenAddr",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "saleAddr",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "saleImpl",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "tokenImpl",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
] as const;

  const _bytecode = "0x60c060405234801561000f575f80fd5b50604051610e99380380610e9983398101604081905261002e91610137565b338061005457604051631e4fbdf760e01b81525f60048201526024015b60405180910390fd5b61005d816100cd565b506001600160a01b0382161580159061007e57506001600160a01b03811615155b6100b65760405162461bcd60e51b8152602060048201526009602482015268696d706c207a65726f60b81b604482015260640161004b565b6001600160a01b039182166080521660a052610168565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b0381168114610132575f80fd5b919050565b5f8060408385031215610148575f80fd5b6101518361011c565b915061015f6020840161011c565b90509250929050565b60805160a051610cfc61019d5f395f818160fc01528181610201015261051801525f818161013601526101cd0152610cfc5ff3fe608060405234801561000f575f80fd5b506004361061007a575f3560e01c8063a30d9c2911610058578063a30d9c29146100e4578063baf17116146100f7578063f2fde38b1461011e578063ffc4992f14610131575f80fd5b8063715018a61461007e5780638b9a5f76146100885780638da5cb5b146100c0575b5f80fd5b610086610158565b005b61009b61009636600461082a565b61016b565b604080516001600160a01b039384168152929091166020830152015b60405180910390f35b5f546001600160a01b03165b6040516001600160a01b0390911681526020016100b7565b6100cc6100f23660046108a7565b6104be565b6100cc7f000000000000000000000000000000000000000000000000000000000000000081565b61008661012c3660046108ed565b610671565b6100cc7f000000000000000000000000000000000000000000000000000000000000000081565b6101606106ae565b6101695f6106da565b565b5f808061017b60208501856108ed565b6001600160a01b0316146101c85760405162461bcd60e51b815260206004820152600f60248201526e151bdad95b881cdc1958da599a5959608a1b60448201526064015b60405180910390fd5b6101fa7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610729565b915061022e7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610729565b6040516303bf912560e11b81529091506001600160a01b0383169063077f224a90610265908a908a908a908a903090600401610930565b5f604051808303815f87803b15801561027c575f80fd5b505af115801561028e573d5f803e3d5ffd5b505060405163130b83fd60e11b81526001600160a01b0384811660048301528516925063261707fa91506024015f604051808303815f87803b1580156102d2575f80fd5b505af11580156102e4573d5f803e3d5ffd5b505050505f838036038101906102fa91906109d6565b6001600160a01b0380851682526040516322a4b3f160e11b815291925083169063454967e29061032e908490600401610acf565b5f604051808303815f87803b158015610345575f80fd5b505af1158015610357573d5f803e3d5ffd5b50505050816001600160a01b0316631ddc0ef06040518163ffffffff1660e01b81526004015f604051808303815f87803b158015610393575f80fd5b505af11580156103a5573d5f803e3d5ffd5b505060405163f2fde38b60e01b81523360048201526001600160a01b038616925063f2fde38b91506024015f604051808303815f87803b1580156103e7575f80fd5b505af11580156103f9573d5f803e3d5ffd5b505060405163f2fde38b60e01b81523360048201526001600160a01b038516925063f2fde38b91506024015f604051808303815f87803b15801561043b575f80fd5b505af115801561044d573d5f803e3d5ffd5b505060018054925090505f61046183610ba5565b9091555050600154604080515f81523360208201526001600160a01b03808616939087169290917f816ba692e6c2b18528b47aa0119a28f55589e6e97283d075879ddf277c38da2b910160405180910390a4509550959350505050565b5f806104cd60208401846108ed565b6001600160a01b0316036105135760405162461bcd60e51b815260206004820152600d60248201526c151bdad95b881b9bdd081cd95d609a1b60448201526064016101bf565b6105457f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610729565b6040516322a4b3f160e11b81529091506001600160a01b0382169063454967e290610574908590600401610bc9565b5f604051808303815f87803b15801561058b575f80fd5b505af115801561059d573d5f803e3d5ffd5b505060405163f2fde38b60e01b81523360048201526001600160a01b038416925063f2fde38b91506024015f604051808303815f87803b1580156105df575f80fd5b505af11580156105f1573d5f803e3d5ffd5b505060018054925090505f61060583610ba5565b90915550506001600160a01b03811661062160208401846108ed565b60018054604080519283523360208401526001600160a01b03939093169290917f816ba692e6c2b18528b47aa0119a28f55589e6e97283d075879ddf277c38da2b910160405180910390a4919050565b6106796106ae565b6001600160a01b0381166106a257604051631e4fbdf760e01b81525f60048201526024016101bf565b6106ab816106da565b50565b5f546001600160a01b031633146101695760405163118cdaa760e01b81523360048201526024016101bf565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f610734825f61073a565b92915050565b5f814710156107655760405163cf47918160e01b8152476004820152602481018390526044016101bf565b763d602d80600a3d3981f3363d3d373d3d3d363d730000008360601b60e81c175f526e5af43d82803e903d91602b57fd5bf38360781b176020526037600983f090506001600160a01b0381166107345760405163b06ebf3d60e01b815260040160405180910390fd5b5f8083601f8401126107de575f80fd5b50813567ffffffffffffffff8111156107f5575f80fd5b60208301915083602082850101111561080c575f80fd5b9250929050565b5f6101a08284031215610824575f80fd5b50919050565b5f805f805f6101e0868803121561083f575f80fd5b853567ffffffffffffffff80821115610856575f80fd5b61086289838a016107ce565b9097509550602088013591508082111561087a575f80fd5b50610887888289016107ce565b909450925061089b90508760408801610813565b90509295509295909350565b5f6101a082840312156108b8575f80fd5b6108c28383610813565b9392505050565b6001600160a01b03811681146106ab575f80fd5b80356108e8816108c9565b919050565b5f602082840312156108fd575f80fd5b81356108c2816108c9565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b606081525f610943606083018789610908565b8281036020840152610956818688610908565b91505060018060a01b03831660408301529695505050505050565b6040516101a0810167ffffffffffffffff811182821017156109a157634e487b7160e01b5f52604160045260245ffd5b60405290565b803560ff811681146108e8575f80fd5b803561ffff811681146108e8575f80fd5b8035600281106108e8575f80fd5b5f6101a082840312156109e7575f80fd5b6109ef610971565b6109f8836108dd565b8152602083013560208201526040830135604082015260608301356060820152610a24608084016109a7565b6080820152610a3560a084016109b7565b60a082015260c083013560c082015260e083013560e0820152610100610a5c8185016109b7565b90820152610120610a6e8482016108dd565b90820152610140610a808482016108dd565b90820152610160610a928482016108dd565b90820152610180610aa48482016109c8565b908201529392505050565b60028110610acb57634e487b7160e01b5f52602160045260245ffd5b9052565b81516001600160a01b031681526101a081016020830151602083015260408301516040830152606083015160608301526080830151610b13608084018260ff169052565b5060a0830151610b2960a084018261ffff169052565b5060c083015160c083015260e083015160e083015261010080840151610b548285018261ffff169052565b5050610120838101516001600160a01b039081169184019190915261014080850151821690840152610160808501519091169083015261018080840151610b9d82850182610aaf565b505092915050565b5f60018201610bc257634e487b7160e01b5f52601160045260245ffd5b5060010190565b6101a08101610be882610bdb856108dd565b6001600160a01b03169052565b602083013560208301526040830135604083015260608301356060830152610c12608084016109a7565b60ff166080830152610c2660a084016109b7565b61ffff811660a08401525060c083013560c083015260e083013560e0830152610100610c538185016109b7565b61ffff1690830152610120610c698482016108dd565b6001600160a01b031690830152610140610c848482016108dd565b6001600160a01b031690830152610160610c9f8482016108dd565b6001600160a01b031690830152610180610cba8482016109c8565b610b9d82850182610aaf56fea264697066735822122096d0d086a8a8f283370460562a4855e429edd4c08c53f3d352c4881c8279736664736f6c63430008170033";

  
      type FactoryConstructorParams = [signer?: Signer] | ConstructorParameters<typeof ContractFactory>;

      const isSuperArgs = (xs: FactoryConstructorParams): xs is ConstructorParameters<typeof ContractFactory> =>
        xs.length > 1
    

  export class Factory__factory extends ContractFactory {
    
      constructor(...args: FactoryConstructorParams) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        
      }
    
    override getDeployTransaction(token_: AddressLike, sale_: AddressLike, overrides?: NonPayableOverrides & { from?: string }): Promise<ContractDeployTransaction> {
      return super.getDeployTransaction(token_, sale_, overrides || {});
    };
    override deploy(token_: AddressLike, sale_: AddressLike, overrides?: NonPayableOverrides & { from?: string }) {
      return super.deploy(token_, sale_, overrides || {}) as Promise<Factory & {
        deploymentTransaction(): ContractTransactionResponse;
      }>;
    }
    override connect(runner: ContractRunner | null): Factory__factory {
      return super.connect(runner) as Factory__factory;
    }
    
    
    static readonly bytecode = _bytecode;
    static readonly abi = _abi;
    static createInterface(): FactoryInterface {
      return new Interface(_abi) as FactoryInterface;
    }
    
    override attach(address: string | Addressable): Factory {
      return super.attach(address) as Factory;
    }
  static connect(address: string, runner?: ContractRunner | null): Factory {
      return new Contract(address, _abi, runner) as unknown as Factory;
    }
  }
</file>

<file path="types/ethers-contracts/factories/Factory.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { Factory__factory } from './Factory__factory.js';
</file>

<file path="types/ethers-contracts/factories/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as bondingCurveSaleSol from './BondingCurveSale.sol/index.js';
export * as factorySol from './Factory.sol/index.js';
export * as lpTimelockSol from './LpTimelock.sol/index.js';
export * as tokenTemplateSol from './TokenTemplate.sol/index.js';
export * as interfaces from './interfaces/index.js';
</file>

<file path="types/ethers-contracts/factories/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export * as iPancakeRouter02Sol from './IPancakeRouter02.sol/index.js';
</file>

<file path="types/ethers-contracts/factories/interfaces/IPancakeRouter02.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { IPancakeRouter02__factory } from './IPancakeRouter02__factory.js';
</file>

<file path="types/ethers-contracts/factories/interfaces/IPancakeRouter02.sol/IPancakeRouter02__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

  import { Contract, Interface, type ContractRunner } from "ethers";
  import type { IPancakeRouter02, IPancakeRouter02Interface } from "../../../interfaces/IPancakeRouter02.sol/IPancakeRouter02.js";

  const _abi = [
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountTokenDesired",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountTokenMin",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountETHMin",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      }
    ],
    "name": "addLiquidityETH",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountToken",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountETH",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "liquidity",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  }
] as const;

  export class IPancakeRouter02__factory {
    static readonly abi = _abi;
    static createInterface(): IPancakeRouter02Interface {
      return new Interface(_abi) as IPancakeRouter02Interface;
    }
    static connect(address: string, runner?: ContractRunner | null): IPancakeRouter02 {
      return new Contract(address, _abi, runner) as unknown as IPancakeRouter02;
    }
  }
</file>

<file path="types/ethers-contracts/factories/LpTimelock.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { LpTimelock__factory } from './LpTimelock__factory.js';
</file>

<file path="types/ethers-contracts/factories/LpTimelock.sol/LpTimelock__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { Addressable } from "ethers";
import { Contract, ContractFactory, ContractTransactionResponse, Interface } from "ethers"
import type { Signer, BigNumberish, AddressLike, ContractDeployTransaction, ContractRunner } from "ethers"
import type { NonPayableOverrides } from "../../common.js"
  import type { LpTimelock, LpTimelockInterface } from "../../LpTimelock.sol/LpTimelock.js";

  const _abi = [
  {
    "inputs": [
      {
        "internalType": "contract IERC20",
        "name": "_token",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_beneficiary",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_releaseTime",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "beneficiary",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "release",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "releaseTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC20",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
] as const;

  const _bytecode = "0x60e060405234801561000f575f80fd5b5060405161047238038061047283398101604081905261002e916100a8565b4281116100765760405162461bcd60e51b815260206004820152601260248201527152656c65617365206265666f7265206e6f7760701b604482015260640160405180910390fd5b6001600160a01b03928316608052911660a05260c0526100e8565b6001600160a01b03811681146100a5575f80fd5b50565b5f805f606084860312156100ba575f80fd5b83516100c581610091565b60208501519093506100d681610091565b80925050604084015190509250925092565b60805160a05160c05161034861012a5f395f818160a1015260fa01525f81816053015261023801525f818160d601528181610173015261026701526103485ff3fe608060405234801561000f575f80fd5b506004361061004a575f3560e01c806338af3eed1461004e57806386d1a69f14610092578063b91d40011461009c578063fc0c546a146100d1575b5f80fd5b6100757f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b61009a6100f8565b005b6100c37f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610089565b6100757f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000042101561015c5760405162461bcd60e51b815260206004820152600c60248201526b139bdd081c995b19585cd95960a21b60448201526064015b60405180910390fd5b6040516370a0823160e01b81523060048201525f907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906370a0823190602401602060405180830381865afa1580156101c0573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906101e491906102d5565b90505f81116102215760405162461bcd60e51b81526020600482015260096024820152684e6f20746f6b656e7360b81b6044820152606401610153565b60405163a9059cbb60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018390527f0000000000000000000000000000000000000000000000000000000000000000169063a9059cbb906044016020604051808303815f875af11580156102ad573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906102d191906102ec565b5050565b5f602082840312156102e5575f80fd5b5051919050565b5f602082840312156102fc575f80fd5b8151801515811461030b575f80fd5b939250505056fea2646970667358221220566158b7545749710a76d4a8613b8c130332fd22b122d76154ca9bc5b3c174b064736f6c63430008170033";

  
      type LpTimelockConstructorParams = [signer?: Signer] | ConstructorParameters<typeof ContractFactory>;

      const isSuperArgs = (xs: LpTimelockConstructorParams): xs is ConstructorParameters<typeof ContractFactory> =>
        xs.length > 1
    

  export class LpTimelock__factory extends ContractFactory {
    
      constructor(...args: LpTimelockConstructorParams) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        
      }
    
    override getDeployTransaction(_token: AddressLike, _beneficiary: AddressLike, _releaseTime: BigNumberish, overrides?: NonPayableOverrides & { from?: string }): Promise<ContractDeployTransaction> {
      return super.getDeployTransaction(_token, _beneficiary, _releaseTime, overrides || {});
    };
    override deploy(_token: AddressLike, _beneficiary: AddressLike, _releaseTime: BigNumberish, overrides?: NonPayableOverrides & { from?: string }) {
      return super.deploy(_token, _beneficiary, _releaseTime, overrides || {}) as Promise<LpTimelock & {
        deploymentTransaction(): ContractTransactionResponse;
      }>;
    }
    override connect(runner: ContractRunner | null): LpTimelock__factory {
      return super.connect(runner) as LpTimelock__factory;
    }
    
    
    static readonly bytecode = _bytecode;
    static readonly abi = _abi;
    static createInterface(): LpTimelockInterface {
      return new Interface(_abi) as LpTimelockInterface;
    }
    
    override attach(address: string | Addressable): LpTimelock {
      return super.attach(address) as LpTimelock;
    }
  static connect(address: string, runner?: ContractRunner | null): LpTimelock {
      return new Contract(address, _abi, runner) as unknown as LpTimelock;
    }
  }
</file>

<file path="types/ethers-contracts/factories/TokenTemplate.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export { TokenTemplate__factory } from './TokenTemplate__factory.js';
</file>

<file path="types/ethers-contracts/factories/TokenTemplate.sol/TokenTemplate__factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { Addressable } from "ethers";
import { Contract, ContractFactory, ContractTransactionResponse, Interface } from "ethers"
import type { Signer, ContractDeployTransaction, ContractRunner } from "ethers"
import type { NonPayableOverrides } from "../../common.js"
  import type { TokenTemplate, TokenTemplateInterface } from "../../TokenTemplate.sol/TokenTemplate.js";

  const _abi = [
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "AccessControlBadConfirmation",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "neededRole",
        "type": "bytes32"
      }
    ],
    "name": "AccessControlUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allowance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientAllowance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientBalance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "approver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidApprover",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "receiver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidReceiver",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSpender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "previousAdminRole",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "newAdminRole",
        "type": "bytes32"
      }
    ],
    "name": "RoleAdminChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleGranted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleRevoked",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DEFAULT_ADMIN_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "MINTER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "burn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "burnFrom",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      }
    ],
    "name": "getRoleAdmin",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sale",
        "type": "address"
      }
    ],
    "name": "grantMinter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "grantRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "hasRole",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "name_",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "symbol_",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "initialOwner",
        "type": "address"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "callerConfirmation",
        "type": "address"
      }
    ],
    "name": "renounceRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sale",
        "type": "address"
      }
    ],
    "name": "revokeMinter",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "revokeRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes4",
        "name": "interfaceId",
        "type": "bytes4"
      }
    ],
    "name": "supportsInterface",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
] as const;

  const _bytecode = "0x608060405234801562000010575f80fd5b5060408051602080820183525f8083528351918201909352918252339160036200003b83826200017c565b5060046200004a82826200017c565b5050506001600160a01b0381166200007b57604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b62000086816200008d565b5062000248565b600580546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b634e487b7160e01b5f52604160045260245ffd5b600181811c908216806200010757607f821691505b6020821081036200012657634e487b7160e01b5f52602260045260245ffd5b50919050565b601f8211156200017757805f5260205f20601f840160051c81016020851015620001535750805b601f840160051c820191505b8181101562000174575f81556001016200015f565b50505b505050565b81516001600160401b03811115620001985762000198620000de565b620001b081620001a98454620000f2565b846200012c565b602080601f831160018114620001e6575f8415620001ce5750858301515b5f19600386901b1c1916600185901b17855562000240565b5f85815260208120601f198616915b828110156200021657888601518255948401946001909101908401620001f5565b50858210156200023457878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b6110fd80620002565f395ff3fe608060405234801561000f575f80fd5b5060043610610187575f3560e01c806370a08231116100d9578063a217fddf11610093578063d53913931161006e578063d53913931461034b578063d547741f1461035f578063dd62ed3e14610372578063f2fde38b146103aa575f80fd5b8063a217fddf1461031e578063a9059cbb14610325578063cfbd488514610338575f80fd5b806370a08231146102a5578063715018a6146102cd57806379cc6790146102d55780638da5cb5b146102e857806391d148541461030357806395d89b4114610316575f80fd5b8063248a9ca311610144578063313ce5671161011f578063313ce5671461025d57806336568abe1461026c57806340c10f191461027f57806342966c6814610292575f80fd5b8063248a9ca314610215578063261707fa146102375780632f2ff15d1461024a575f80fd5b806301ffc9a71461018b57806306fdde03146101b3578063077f224a146101c8578063095ea7b3146101dd57806318160ddd146101f057806323b872dd14610202575b5f80fd5b61019e610199366004610cc1565b6103bd565b60405190151581526020015b60405180910390f35b6101bb6103f3565b6040516101aa9190610cef565b6101db6101d6366004610df3565b610483565b005b61019e6101eb366004610e62565b61056c565b6002545b6040519081526020016101aa565b61019e610210366004610e8a565b610583565b6101f4610223366004610ec3565b5f9081526006602052604090206001015490565b6101db610245366004610eda565b6105a6565b6101db610258366004610ef3565b6105c9565b604051601281526020016101aa565b6101db61027a366004610ef3565b6105ed565b6101db61028d366004610e62565b610625565b6101db6102a0366004610ec3565b61067f565b6101f46102b3366004610eda565b6001600160a01b03165f9081526020819052604090205490565b6101db61068c565b6101db6102e3366004610e62565b61069f565b6005546040516001600160a01b0390911681526020016101aa565b61019e610311366004610ef3565b6106b4565b6101bb6106de565b6101f45f81565b61019e610333366004610e62565b6106ed565b6101db610346366004610eda565b6106fa565b6101f45f805160206110a883398151915281565b6101db61036d366004610ef3565b61076a565b6101f4610380366004610f1d565b6001600160a01b039182165f90815260016020908152604080832093909416825291909152205490565b6101db6103b8366004610eda565b61078e565b5f6001600160e01b03198216637965db0b60e01b14806103ed57506301ffc9a760e01b6001600160e01b03198316145b92915050565b60606007805461040290610f45565b80601f016020809104026020016040519081016040528092919081815260200182805461042e90610f45565b80156104795780601f1061045057610100808354040283529160200191610479565b820191905f5260205f20905b81548152906001019060200180831161045c57829003601f168201915b5050505050905090565b60095460ff16156104d15760405162461bcd60e51b8152602060048201526013602482015272105b1c9958591e481a5b9a5d1a585b1a5e9959606a1b60448201526064015b60405180910390fd5b6001600160a01b0381166105145760405162461bcd60e51b815260206004820152600a6024820152694f776e6572207a65726f60b01b60448201526064016104c8565b6009805460ff1916600117905561052a816107c4565b6105345f82610815565b5061054c5f805160206110a883398151915282610815565b5060076105598482610fc8565b5060086105668382610fc8565b50505050565b5f336105798185856108a6565b5060019392505050565b5f336105908582856108b3565b61059b858585610929565b506001949350505050565b6105ae610986565b6105c55f805160206110a883398151915282610815565b5050565b5f828152600660205260409020600101546105e3816109b3565b6105668383610815565b6001600160a01b03811633146106165760405163334bd91960e11b815260040160405180910390fd5b61062082826109bd565b505050565b61063c5f805160206110a8833981519152336106b4565b6106755760405162461bcd60e51b815260206004820152600a6024820152692737ba1036b4b73a32b960b11b60448201526064016104c8565b6105c58282610a28565b6106893382610a5c565b50565b610694610986565b61069d5f6107c4565b565b6106aa8233836108b3565b6105c58282610a5c565b5f9182526006602090815260408084206001600160a01b0393909316845291905290205460ff1690565b60606008805461040290610f45565b5f33610579818585610929565b610702610986565b6107195f805160206110a8833981519152826106b4565b15610737576107355f805160206110a8833981519152826109bd565b505b61074e5f805160206110a8833981519152336106b4565b15610689576105c55f805160206110a8833981519152336109bd565b5f82815260066020526040902060010154610784816109b3565b61056683836109bd565b610796610986565b6001600160a01b0381166107bf57604051631e4fbdf760e01b81525f60048201526024016104c8565b610689815b600580546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0905f90a35050565b5f61082083836106b4565b61089f575f8381526006602090815260408083206001600160a01b03861684529091529020805460ff191660011790556108573390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45060016103ed565b505f6103ed565b6106208383836001610a90565b6001600160a01b038381165f908152600160209081526040808320938616835292905220545f19811015610566578181101561091b57604051637dc7a0d960e11b81526001600160a01b038416600482015260248101829052604481018390526064016104c8565b61056684848484035f610a90565b6001600160a01b03831661095257604051634b637e8f60e11b81525f60048201526024016104c8565b6001600160a01b03821661097b5760405163ec442f0560e01b81525f60048201526024016104c8565b610620838383610b62565b6005546001600160a01b0316331461069d5760405163118cdaa760e01b81523360048201526024016104c8565b6106898133610c88565b5f6109c883836106b4565b1561089f575f8381526006602090815260408083206001600160a01b0386168085529252808320805460ff1916905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45060016103ed565b6001600160a01b038216610a515760405163ec442f0560e01b81525f60048201526024016104c8565b6105c55f8383610b62565b6001600160a01b038216610a8557604051634b637e8f60e11b81525f60048201526024016104c8565b6105c5825f83610b62565b6001600160a01b038416610ab95760405163e602df0560e01b81525f60048201526024016104c8565b6001600160a01b038316610ae257604051634a1406b160e11b81525f60048201526024016104c8565b6001600160a01b038085165f908152600160209081526040808320938716835292905220829055801561056657826001600160a01b0316846001600160a01b03167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92584604051610b5491815260200190565b60405180910390a350505050565b6001600160a01b038316610b8c578060025f828254610b819190611088565b90915550610bfc9050565b6001600160a01b0383165f9081526020819052604090205481811015610bde5760405163391434e360e21b81526001600160a01b038516600482015260248101829052604481018390526064016104c8565b6001600160a01b0384165f9081526020819052604090209082900390555b6001600160a01b038216610c1857600280548290039055610c36565b6001600160a01b0382165f9081526020819052604090208054820190555b816001600160a01b0316836001600160a01b03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051610c7b91815260200190565b60405180910390a3505050565b610c9282826106b4565b6105c55760405163e2517d3f60e01b81526001600160a01b0382166004820152602481018390526044016104c8565b5f60208284031215610cd1575f80fd5b81356001600160e01b031981168114610ce8575f80fd5b9392505050565b5f602080835283518060208501525f5b81811015610d1b57858101830151858201604001528201610cff565b505f604082860101526040601f19601f8301168501019250505092915050565b634e487b7160e01b5f52604160045260245ffd5b5f82601f830112610d5e575f80fd5b813567ffffffffffffffff80821115610d7957610d79610d3b565b604051601f8301601f19908116603f01168101908282118183101715610da157610da1610d3b565b81604052838152866020858801011115610db9575f80fd5b836020870160208301375f602085830101528094505050505092915050565b80356001600160a01b0381168114610dee575f80fd5b919050565b5f805f60608486031215610e05575f80fd5b833567ffffffffffffffff80821115610e1c575f80fd5b610e2887838801610d4f565b94506020860135915080821115610e3d575f80fd5b50610e4a86828701610d4f565b925050610e5960408501610dd8565b90509250925092565b5f8060408385031215610e73575f80fd5b610e7c83610dd8565b946020939093013593505050565b5f805f60608486031215610e9c575f80fd5b610ea584610dd8565b9250610eb360208501610dd8565b9150604084013590509250925092565b5f60208284031215610ed3575f80fd5b5035919050565b5f60208284031215610eea575f80fd5b610ce882610dd8565b5f8060408385031215610f04575f80fd5b82359150610f1460208401610dd8565b90509250929050565b5f8060408385031215610f2e575f80fd5b610f3783610dd8565b9150610f1460208401610dd8565b600181811c90821680610f5957607f821691505b602082108103610f7757634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561062057805f5260205f20601f840160051c81016020851015610fa25750805b601f840160051c820191505b81811015610fc1575f8155600101610fae565b5050505050565b815167ffffffffffffffff811115610fe257610fe2610d3b565b610ff681610ff08454610f45565b84610f7d565b602080601f831160018114611029575f84156110125750858301515b5f19600386901b1c1916600185901b178555611080565b5f85815260208120601f198616915b8281101561105757888601518255948401946001909101908401611038565b508582101561107457878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b808201808211156103ed57634e487b7160e01b5f52601160045260245ffdfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6a26469706673582212203c26481ab1c92720b37201d848d6da19dd80f2fc3049e8ab415eb93aae77559664736f6c63430008170033";

  
      type TokenTemplateConstructorParams = [signer?: Signer] | ConstructorParameters<typeof ContractFactory>;

      const isSuperArgs = (xs: TokenTemplateConstructorParams): xs is ConstructorParameters<typeof ContractFactory> =>
        xs.length > 1
    

  export class TokenTemplate__factory extends ContractFactory {
    
      constructor(...args: TokenTemplateConstructorParams) {
        if (isSuperArgs(args)) {
          super(...args);
        } else {
          super(_abi, _bytecode, args[0]);
        }
        
      }
    
    override getDeployTransaction(overrides?: NonPayableOverrides & { from?: string }): Promise<ContractDeployTransaction> {
      return super.getDeployTransaction(overrides || {});
    };
    override deploy(overrides?: NonPayableOverrides & { from?: string }) {
      return super.deploy(overrides || {}) as Promise<TokenTemplate & {
        deploymentTransaction(): ContractTransactionResponse;
      }>;
    }
    override connect(runner: ContractRunner | null): TokenTemplate__factory {
      return super.connect(runner) as TokenTemplate__factory;
    }
    
    
    static readonly bytecode = _bytecode;
    static readonly abi = _abi;
    static createInterface(): TokenTemplateInterface {
      return new Interface(_abi) as TokenTemplateInterface;
    }
    
    override attach(address: string | Addressable): TokenTemplate {
      return super.attach(address) as TokenTemplate;
    }
  static connect(address: string, runner?: ContractRunner | null): TokenTemplate {
      return new Contract(address, _abi, runner) as unknown as TokenTemplate;
    }
  }
</file>

<file path="types/ethers-contracts/Factory.sol/Factory.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../common.js"
  
export declare namespace BondingCurveSale {
      
    export type InitParamsStruct = {token: AddressLike, tierSize: BigNumberish, startPrice: BigNumberish, priceStep: BigNumberish, maxTiersPerTx: BigNumberish, platformFeeBps: BigNumberish, endTime: BigNumberish, hardCapBNB: BigNumberish, lpPercent: BigNumberish, router: AddressLike, treasury: AddressLike, payout: AddressLike, mode: BigNumberish}

    export type InitParamsStructOutput = [token: string, tierSize: bigint, startPrice: bigint, priceStep: bigint, maxTiersPerTx: bigint, platformFeeBps: bigint, endTime: bigint, hardCapBNB: bigint, lpPercent: bigint, router: string, treasury: string, payout: string, mode: bigint] & {token: string, tierSize: bigint, startPrice: bigint, priceStep: bigint, maxTiersPerTx: bigint, platformFeeBps: bigint, endTime: bigint, hardCapBNB: bigint, lpPercent: bigint, router: string, treasury: string, payout: string, mode: bigint }
  
    }

  export interface FactoryInterface extends Interface {
    getFunction(nameOrSignature: "createExternalSale" | "createLaunch" | "owner" | "renounceOwnership" | "saleImpl" | "tokenImpl" | "transferOwnership"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "LaunchCreated" | "OwnershipTransferred"): EventFragment;

    encodeFunctionData(functionFragment: 'createExternalSale', values: [BondingCurveSale.InitParamsStruct]): string;
encodeFunctionData(functionFragment: 'createLaunch', values: [string, string, BondingCurveSale.InitParamsStruct]): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
encodeFunctionData(functionFragment: 'saleImpl', values?: undefined): string;
encodeFunctionData(functionFragment: 'tokenImpl', values?: undefined): string;
encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;

    decodeFunctionResult(functionFragment: 'createExternalSale', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'createLaunch', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'saleImpl', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'tokenImpl', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  }

  
    export namespace LaunchCreatedEvent {
      export type InputTuple = [launchId: BigNumberish, token: AddressLike, sale: AddressLike, externalToken: boolean, creator: AddressLike];
      export type OutputTuple = [launchId: bigint, token: string, sale: string, externalToken: boolean, creator: string];
      export interface OutputObject {launchId: bigint, token: string, sale: string, externalToken: boolean, creator: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace OwnershipTransferredEvent {
      export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
      export type OutputTuple = [previousOwner: string, newOwner: string];
      export interface OutputObject {previousOwner: string, newOwner: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface Factory extends BaseContract {
    
    connect(runner?: ContractRunner | null): Factory;
    waitForDeployment(): Promise<this>;

    interface: FactoryInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    createExternalSale: TypedContractMethod<
      [initParams: BondingCurveSale.InitParamsStruct, ],
      [string],
      'nonpayable'
    >
    

    
    createLaunch: TypedContractMethod<
      [name: string, symbol: string, initParams: BondingCurveSale.InitParamsStruct, ],
      [[string, string] & {tokenAddr: string, saleAddr: string }],
      'nonpayable'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    renounceOwnership: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    saleImpl: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    tokenImpl: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    transferOwnership: TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'createExternalSale'): TypedContractMethod<
      [initParams: BondingCurveSale.InitParamsStruct, ],
      [string],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'createLaunch'): TypedContractMethod<
      [name: string, symbol: string, initParams: BondingCurveSale.InitParamsStruct, ],
      [[string, string] & {tokenAddr: string, saleAddr: string }],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'saleImpl'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'tokenImpl'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'LaunchCreated'): TypedContractEvent<LaunchCreatedEvent.InputTuple, LaunchCreatedEvent.OutputTuple, LaunchCreatedEvent.OutputObject>;
getEvent(key: 'OwnershipTransferred'): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;

    filters: {
      
      'LaunchCreated(uint256,address,address,bool,address)': TypedContractEvent<LaunchCreatedEvent.InputTuple, LaunchCreatedEvent.OutputTuple, LaunchCreatedEvent.OutputObject>;
      LaunchCreated: TypedContractEvent<LaunchCreatedEvent.InputTuple, LaunchCreatedEvent.OutputTuple, LaunchCreatedEvent.OutputObject>;
    

      'OwnershipTransferred(address,address)': TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
      OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    
    };
  }
</file>

<file path="types/ethers-contracts/Factory.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { Factory } from './Factory.js';
</file>

<file path="types/ethers-contracts/hardhat.d.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */


import { ethers } from 'ethers'
import { DeployContractOptions, FactoryOptions, HardhatEthersHelpers as HardhatEthersHelpersBase} from "@nomicfoundation/hardhat-ethers/types";

import * as Contracts from "./index.js";

declare module "@nomicfoundation/hardhat-ethers/types" {
  interface HardhatEthersHelpers extends HardhatEthersHelpersBase {
  getContractFactory(name: 'BondingCurveSale', signerOrOptions?: ethers.Signer | FactoryOptions): Promise<Contracts.BondingCurveSale__factory>
getContractFactory(name: 'Factory', signerOrOptions?: ethers.Signer | FactoryOptions): Promise<Contracts.Factory__factory>
getContractFactory(name: 'IPancakeRouter02', signerOrOptions?: ethers.Signer | FactoryOptions): Promise<Contracts.IPancakeRouter02__factory>
getContractFactory(name: 'LpTimelock', signerOrOptions?: ethers.Signer | FactoryOptions): Promise<Contracts.LpTimelock__factory>
getContractFactory(name: 'TokenTemplate', signerOrOptions?: ethers.Signer | FactoryOptions): Promise<Contracts.TokenTemplate__factory>

  getContractAt(name: 'BondingCurveSale', address: string | ethers.Addressable, signer?: ethers.Signer): Promise<Contracts.BondingCurveSale>
getContractAt(name: 'Factory', address: string | ethers.Addressable, signer?: ethers.Signer): Promise<Contracts.Factory>
getContractAt(name: 'IPancakeRouter02', address: string | ethers.Addressable, signer?: ethers.Signer): Promise<Contracts.IPancakeRouter02>
getContractAt(name: 'LpTimelock', address: string | ethers.Addressable, signer?: ethers.Signer): Promise<Contracts.LpTimelock>
getContractAt(name: 'TokenTemplate', address: string | ethers.Addressable, signer?: ethers.Signer): Promise<Contracts.TokenTemplate>

  deployContract(name: 'BondingCurveSale', signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.BondingCurveSale>
deployContract(name: 'Factory', signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.Factory>
deployContract(name: 'IPancakeRouter02', signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.IPancakeRouter02>
deployContract(name: 'LpTimelock', signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.LpTimelock>
deployContract(name: 'TokenTemplate', signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.TokenTemplate>

  deployContract(name: 'BondingCurveSale', args: any[], signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.BondingCurveSale>
deployContract(name: 'Factory', args: any[], signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.Factory>
deployContract(name: 'IPancakeRouter02', args: any[], signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.IPancakeRouter02>
deployContract(name: 'LpTimelock', args: any[], signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.LpTimelock>
deployContract(name: 'TokenTemplate', args: any[], signerOrOptions?: ethers.Signer | DeployContractOptions): Promise<Contracts.TokenTemplate>

    // default types
    getContractFactory(
      name: string,
      signerOrOptions?: ethers.Signer | FactoryOptions
    ): Promise<ethers.ContractFactory>;
    getContractFactory(
      abi: any[],
      bytecode: ethers.BytesLike,
      signer?: ethers.Signer
    ): Promise<ethers.ContractFactory>;
    getContractAt(
      nameOrAbi: string | any[],
      address: string | ethers.Addressable,
      signer?: ethers.Signer
    ): Promise<ethers.Contract>;
    deployContract(
      name: string,
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<ethers.Contract>;
    deployContract(
      name: string,
      args: any[],
      signerOrOptions?: ethers.Signer | DeployContractOptions
    ): Promise<ethers.Contract>;
  }
}
</file>

<file path="types/ethers-contracts/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as bondingCurveSaleSol from './BondingCurveSale.sol/index.js';
export type { bondingCurveSaleSol };
import type * as factorySol from './Factory.sol/index.js';
export type { factorySol };
import type * as lpTimelockSol from './LpTimelock.sol/index.js';
export type { lpTimelockSol };
import type * as tokenTemplateSol from './TokenTemplate.sol/index.js';
export type { tokenTemplateSol };
import type * as interfaces from './interfaces/index.js';
export type { interfaces };
export * as factories from './factories/index.js';
export type { BondingCurveSale } from './BondingCurveSale.sol/BondingCurveSale.js';
export { BondingCurveSale__factory } from './factories/BondingCurveSale.sol/BondingCurveSale__factory.js';
export type { Factory } from './Factory.sol/Factory.js';
export { Factory__factory } from './factories/Factory.sol/Factory__factory.js';
export type { IPancakeRouter02 } from './interfaces/IPancakeRouter02.sol/IPancakeRouter02.js';
export { IPancakeRouter02__factory } from './factories/interfaces/IPancakeRouter02.sol/IPancakeRouter02__factory.js';
export type { LpTimelock } from './LpTimelock.sol/LpTimelock.js';
export { LpTimelock__factory } from './factories/LpTimelock.sol/LpTimelock__factory.js';
export type { TokenTemplate } from './TokenTemplate.sol/TokenTemplate.js';
export { TokenTemplate__factory } from './factories/TokenTemplate.sol/TokenTemplate__factory.js';
</file>

<file path="types/ethers-contracts/interfaces/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type * as iPancakeRouter02Sol from './IPancakeRouter02.sol/index.js';
export type { iPancakeRouter02Sol };
</file>

<file path="types/ethers-contracts/interfaces/IPancakeRouter02.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { IPancakeRouter02 } from './IPancakeRouter02.js';
</file>

<file path="types/ethers-contracts/interfaces/IPancakeRouter02.sol/IPancakeRouter02.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "../../common.js"
  

  export interface IPancakeRouter02Interface extends Interface {
    getFunction(nameOrSignature: "addLiquidityETH"): FunctionFragment;

    

    encodeFunctionData(functionFragment: 'addLiquidityETH', values: [AddressLike, BigNumberish, BigNumberish, BigNumberish, AddressLike, BigNumberish]): string;

    decodeFunctionResult(functionFragment: 'addLiquidityETH', data: BytesLike): Result;
  }

  

  export interface IPancakeRouter02 extends BaseContract {
    
    connect(runner?: ContractRunner | null): IPancakeRouter02;
    waitForDeployment(): Promise<this>;

    interface: IPancakeRouter02Interface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    addLiquidityETH: TypedContractMethod<
      [token: AddressLike, amountTokenDesired: BigNumberish, amountTokenMin: BigNumberish, amountETHMin: BigNumberish, to: AddressLike, deadline: BigNumberish, ],
      [[bigint, bigint, bigint] & {amountToken: bigint, amountETH: bigint, liquidity: bigint }],
      'payable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'addLiquidityETH'): TypedContractMethod<
      [token: AddressLike, amountTokenDesired: BigNumberish, amountTokenMin: BigNumberish, amountETHMin: BigNumberish, to: AddressLike, deadline: BigNumberish, ],
      [[bigint, bigint, bigint] & {amountToken: bigint, amountETH: bigint, liquidity: bigint }],
      'payable'
    >;

    

    filters: {
      
    };
  }
</file>

<file path="types/ethers-contracts/LpTimelock.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { LpTimelock } from './LpTimelock.js';
</file>

<file path="types/ethers-contracts/LpTimelock.sol/LpTimelock.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BytesLike, FunctionFragment, Result, Interface, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedListener, TypedContractMethod } from "../common.js"
  

  export interface LpTimelockInterface extends Interface {
    getFunction(nameOrSignature: "beneficiary" | "release" | "releaseTime" | "token"): FunctionFragment;

    

    encodeFunctionData(functionFragment: 'beneficiary', values?: undefined): string;
encodeFunctionData(functionFragment: 'release', values?: undefined): string;
encodeFunctionData(functionFragment: 'releaseTime', values?: undefined): string;
encodeFunctionData(functionFragment: 'token', values?: undefined): string;

    decodeFunctionResult(functionFragment: 'beneficiary', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'release', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'releaseTime', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'token', data: BytesLike): Result;
  }

  

  export interface LpTimelock extends BaseContract {
    
    connect(runner?: ContractRunner | null): LpTimelock;
    waitForDeployment(): Promise<this>;

    interface: LpTimelockInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    beneficiary: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    release: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    releaseTime: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    token: TypedContractMethod<
      [],
      [string],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'beneficiary'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'release'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'releaseTime'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'token'): TypedContractMethod<
      [],
      [string],
      'view'
    >;

    

    filters: {
      
    };
  }
</file>

<file path="types/ethers-contracts/TokenTemplate.sol/index.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
export type { TokenTemplate } from './TokenTemplate.js';
</file>

<file path="types/ethers-contracts/TokenTemplate.sol/TokenTemplate.ts">
/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "../common.js"
  

  export interface TokenTemplateInterface extends Interface {
    getFunction(nameOrSignature: "DEFAULT_ADMIN_ROLE" | "MINTER_ROLE" | "allowance" | "approve" | "balanceOf" | "burn" | "burnFrom" | "decimals" | "getRoleAdmin" | "grantMinter" | "grantRole" | "hasRole" | "initialize" | "mint" | "name" | "owner" | "renounceOwnership" | "renounceRole" | "revokeMinter" | "revokeRole" | "supportsInterface" | "symbol" | "totalSupply" | "transfer" | "transferFrom" | "transferOwnership"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "Approval" | "OwnershipTransferred" | "RoleAdminChanged" | "RoleGranted" | "RoleRevoked" | "Transfer"): EventFragment;

    encodeFunctionData(functionFragment: 'DEFAULT_ADMIN_ROLE', values?: undefined): string;
encodeFunctionData(functionFragment: 'MINTER_ROLE', values?: undefined): string;
encodeFunctionData(functionFragment: 'allowance', values: [AddressLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'approve', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'balanceOf', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'burn', values: [BigNumberish]): string;
encodeFunctionData(functionFragment: 'burnFrom', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'decimals', values?: undefined): string;
encodeFunctionData(functionFragment: 'getRoleAdmin', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'grantMinter', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'grantRole', values: [BytesLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'hasRole', values: [BytesLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'initialize', values: [string, string, AddressLike]): string;
encodeFunctionData(functionFragment: 'mint', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'name', values?: undefined): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
encodeFunctionData(functionFragment: 'renounceRole', values: [BytesLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'revokeMinter', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'revokeRole', values: [BytesLike, AddressLike]): string;
encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike]): string;
encodeFunctionData(functionFragment: 'symbol', values?: undefined): string;
encodeFunctionData(functionFragment: 'totalSupply', values?: undefined): string;
encodeFunctionData(functionFragment: 'transfer', values: [AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'transferFrom', values: [AddressLike, AddressLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;

    decodeFunctionResult(functionFragment: 'DEFAULT_ADMIN_ROLE', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'MINTER_ROLE', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'allowance', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'approve', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'balanceOf', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'burn', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'burnFrom', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'decimals', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getRoleAdmin', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'grantMinter', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'grantRole', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'hasRole', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'renounceRole', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'revokeMinter', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'revokeRole', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'totalSupply', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transfer', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferFrom', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  }

  
    export namespace ApprovalEvent {
      export type InputTuple = [owner: AddressLike, spender: AddressLike, value: BigNumberish];
      export type OutputTuple = [owner: string, spender: string, value: bigint];
      export interface OutputObject {owner: string, spender: string, value: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace OwnershipTransferredEvent {
      export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
      export type OutputTuple = [previousOwner: string, newOwner: string];
      export interface OutputObject {previousOwner: string, newOwner: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RoleAdminChangedEvent {
      export type InputTuple = [role: BytesLike, previousAdminRole: BytesLike, newAdminRole: BytesLike];
      export type OutputTuple = [role: string, previousAdminRole: string, newAdminRole: string];
      export interface OutputObject {role: string, previousAdminRole: string, newAdminRole: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RoleGrantedEvent {
      export type InputTuple = [role: BytesLike, account: AddressLike, sender: AddressLike];
      export type OutputTuple = [role: string, account: string, sender: string];
      export interface OutputObject {role: string, account: string, sender: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace RoleRevokedEvent {
      export type InputTuple = [role: BytesLike, account: AddressLike, sender: AddressLike];
      export type OutputTuple = [role: string, account: string, sender: string];
      export interface OutputObject {role: string, account: string, sender: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace TransferEvent {
      export type InputTuple = [from: AddressLike, to: AddressLike, value: BigNumberish];
      export type OutputTuple = [from: string, to: string, value: bigint];
      export interface OutputObject {from: string, to: string, value: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface TokenTemplate extends BaseContract {
    
    connect(runner?: ContractRunner | null): TokenTemplate;
    waitForDeployment(): Promise<this>;

    interface: TokenTemplateInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    DEFAULT_ADMIN_ROLE: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    MINTER_ROLE: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    allowance: TypedContractMethod<
      [owner: AddressLike, spender: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    approve: TypedContractMethod<
      [spender: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >
    

    
    balanceOf: TypedContractMethod<
      [account: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    burn: TypedContractMethod<
      [value: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    burnFrom: TypedContractMethod<
      [account: AddressLike, value: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    decimals: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    getRoleAdmin: TypedContractMethod<
      [role: BytesLike, ],
      [string],
      'view'
    >
    

    
    grantMinter: TypedContractMethod<
      [sale: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    grantRole: TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    hasRole: TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [boolean],
      'view'
    >
    

    
    initialize: TypedContractMethod<
      [name_: string, symbol_: string, initialOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    mint: TypedContractMethod<
      [to: AddressLike, amount: BigNumberish, ],
      [void],
      'nonpayable'
    >
    

    
    name: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    renounceOwnership: TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >
    

    
    renounceRole: TypedContractMethod<
      [role: BytesLike, callerConfirmation: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    revokeMinter: TypedContractMethod<
      [sale: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    revokeRole: TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [void],
      'nonpayable'
    >
    

    
    supportsInterface: TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >
    

    
    symbol: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    totalSupply: TypedContractMethod<
      [],
      [bigint],
      'view'
    >
    

    
    transfer: TypedContractMethod<
      [to: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >
    

    
    transferFrom: TypedContractMethod<
      [from: AddressLike, to: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >
    

    
    transferOwnership: TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'DEFAULT_ADMIN_ROLE'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'MINTER_ROLE'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'allowance'): TypedContractMethod<
      [owner: AddressLike, spender: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'approve'): TypedContractMethod<
      [spender: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'balanceOf'): TypedContractMethod<
      [account: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'burn'): TypedContractMethod<
      [value: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'burnFrom'): TypedContractMethod<
      [account: AddressLike, value: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'decimals'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getRoleAdmin'): TypedContractMethod<
      [role: BytesLike, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'grantMinter'): TypedContractMethod<
      [sale: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'grantRole'): TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'hasRole'): TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'initialize'): TypedContractMethod<
      [name_: string, symbol_: string, initialOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'mint'): TypedContractMethod<
      [to: AddressLike, amount: BigNumberish, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'name'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<
      [],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'renounceRole'): TypedContractMethod<
      [role: BytesLike, callerConfirmation: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'revokeMinter'): TypedContractMethod<
      [sale: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'revokeRole'): TypedContractMethod<
      [role: BytesLike, account: AddressLike, ],
      [void],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'supportsInterface'): TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >;
getFunction(nameOrSignature: 'symbol'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'totalSupply'): TypedContractMethod<
      [],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'transfer'): TypedContractMethod<
      [to: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'transferFrom'): TypedContractMethod<
      [from: AddressLike, to: AddressLike, value: BigNumberish, ],
      [boolean],
      'nonpayable'
    >;
getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<
      [newOwner: AddressLike, ],
      [void],
      'nonpayable'
    >;

    getEvent(key: 'Approval'): TypedContractEvent<ApprovalEvent.InputTuple, ApprovalEvent.OutputTuple, ApprovalEvent.OutputObject>;
getEvent(key: 'OwnershipTransferred'): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
getEvent(key: 'RoleAdminChanged'): TypedContractEvent<RoleAdminChangedEvent.InputTuple, RoleAdminChangedEvent.OutputTuple, RoleAdminChangedEvent.OutputObject>;
getEvent(key: 'RoleGranted'): TypedContractEvent<RoleGrantedEvent.InputTuple, RoleGrantedEvent.OutputTuple, RoleGrantedEvent.OutputObject>;
getEvent(key: 'RoleRevoked'): TypedContractEvent<RoleRevokedEvent.InputTuple, RoleRevokedEvent.OutputTuple, RoleRevokedEvent.OutputObject>;
getEvent(key: 'Transfer'): TypedContractEvent<TransferEvent.InputTuple, TransferEvent.OutputTuple, TransferEvent.OutputObject>;

    filters: {
      
      'Approval(address,address,uint256)': TypedContractEvent<ApprovalEvent.InputTuple, ApprovalEvent.OutputTuple, ApprovalEvent.OutputObject>;
      Approval: TypedContractEvent<ApprovalEvent.InputTuple, ApprovalEvent.OutputTuple, ApprovalEvent.OutputObject>;
    

      'OwnershipTransferred(address,address)': TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
      OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    

      'RoleAdminChanged(bytes32,bytes32,bytes32)': TypedContractEvent<RoleAdminChangedEvent.InputTuple, RoleAdminChangedEvent.OutputTuple, RoleAdminChangedEvent.OutputObject>;
      RoleAdminChanged: TypedContractEvent<RoleAdminChangedEvent.InputTuple, RoleAdminChangedEvent.OutputTuple, RoleAdminChangedEvent.OutputObject>;
    

      'RoleGranted(bytes32,address,address)': TypedContractEvent<RoleGrantedEvent.InputTuple, RoleGrantedEvent.OutputTuple, RoleGrantedEvent.OutputObject>;
      RoleGranted: TypedContractEvent<RoleGrantedEvent.InputTuple, RoleGrantedEvent.OutputTuple, RoleGrantedEvent.OutputObject>;
    

      'RoleRevoked(bytes32,address,address)': TypedContractEvent<RoleRevokedEvent.InputTuple, RoleRevokedEvent.OutputTuple, RoleRevokedEvent.OutputObject>;
      RoleRevoked: TypedContractEvent<RoleRevokedEvent.InputTuple, RoleRevokedEvent.OutputTuple, RoleRevokedEvent.OutputObject>;
    

      'Transfer(address,address,uint256)': TypedContractEvent<TransferEvent.InputTuple, TransferEvent.OutputTuple, TransferEvent.OutputObject>;
      Transfer: TypedContractEvent<TransferEvent.InputTuple, TransferEvent.OutputTuple, TransferEvent.OutputObject>;
    
    };
  }
</file>

<file path="vitest.config.js">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,      // enable describe/it/expect globally
    environment: 'node' // run in Node environment
  }
});
</file>

<file path="docs/activity-feed.md">
# Activity Feed Plan (Profile)

This document outlines the event-indexing plan for the Profile Activity feed, the API contract, and the aggregation rules. The goal is to power **Trades / Comments / Created / Interactions** without heavy per-campaign polling.

## 1) Schema (event store)
We will use the existing `activity_events` table (see `db/migrations/001_init.sql`) as a unified append-only event log. It is chain-aware, wallet-aware, and can be queried by actor/campaign/token.

### Core event types
- `CREATE_CAMPAIGN`  emitted when a new campaign is created
- `BUY` / `SELL`  emitted when curve trades happen
- `COMMENT`  emitted when a user posts on a token
- `UPVOTE`  emitted from VoteTreasury
- `FINALIZE`  campaign graduation

### Event keying
- `chain_id + tx_hash + log_index` for on-chain events
- `chain_id + comment_id` for comment events (store in `meta` as `comment_id`)

## 2) API contract (profile activity)
We expose small, focused endpoints per tab. Each endpoint returns:
```
{
  items: ActivityItem[]
  nextCursor: string | null
}
```
`nextCursor` enables pagination; format is `blockNumber:logIndex` for on-chain sources.

### Implemented now
- `GET /api/activity/trades?chainId=97&address=0x...&limit=50&cursor=BLOCK:LOG`
  - Source: `curve_trades` (joined with `campaigns` for display fields)
- `GET /api/activity/comments?chainId=97&address=0x...&limit=50&cursor=TS:ID`
  - Source: `token_comments` (joined with `campaigns` for display fields)
- `GET /api/activity/created?chainId=97&address=0x...&limit=50&cursor=TS:ADDR`
  - Source: `campaigns` where `creator_address = address`
- `GET /api/activity/interactions?chainId=97&address=0x...&limit=50&cursor=BLOCK:LOG`
  - Source: `votes` (VoteTreasury), joined with `campaigns`

### Planned
- Combined feed endpoint: `GET /api/activity/feed` (mix of all types, de-duped and sorted)

## 3) Feed aggregation rules
When we build a **combined** feed (optional future), the aggregation rules are:
- Normalize each item to `{type, ts, address, campaign, txHash, meta}`
- **Sort by descending timestamp**, then `block_number`, then `log_index`
- De-dupe by `type + tx_hash + log_index` (or `comment_id` for comments)
- Apply per-type limits to avoid large single-source bursts

## 4) Indexer responsibilities (next iteration)
Extend `realtime-indexer` to append to `activity_events` as events are indexed:
- Factory `CampaignCreated` -> `CREATE_CAMPAIGN`
- Campaign `TokensPurchased` -> `BUY`
- Campaign `TokensSold` -> `SELL`
- VoteTreasury `VoteCast` -> `UPVOTE`
- Comment API -> `COMMENT` (write event at comment creation time)

This keeps Profile Activity fast, unified, and reliable.
</file>

<file path="frontend/api/LEAGUE_EPOCHS_AND_CLAIMS.sql">
-- League epochs (finalized snapshots) + claims
-- Safe to run multiple times.

-- Stores finalized prize meta per epoch (week/month)
CREATE TABLE IF NOT EXISTS public.league_epoch_meta (
  chain_id integer NOT NULL,
  period text NOT NULL CHECK (period IN ('weekly','monthly')),
  epoch_start timestamptz NOT NULL,
  epoch_end timestamptz NOT NULL,
  computed_at timestamptz NOT NULL DEFAULT now(),

  protocol_fee_bps integer NOT NULL,
  league_fee_bps integer NOT NULL,
  total_league_fee_raw numeric(78,0) NOT NULL,
  league_count integer NOT NULL,
  winners integer NOT NULL,
  split_bps integer[] NOT NULL,

  PRIMARY KEY (chain_id, period, epoch_start)
);

-- Stores finalized winners per league/category for a finalized epoch.
-- payload holds the exact row the UI needs to render (campaign metadata + metric fields).
CREATE TABLE IF NOT EXISTS public.league_epoch_winners (
  chain_id integer NOT NULL,
  period text NOT NULL CHECK (period IN ('weekly','monthly')),
  epoch_start timestamptz NOT NULL,
  epoch_end timestamptz NOT NULL,
  category text NOT NULL,
  rank integer NOT NULL CHECK (rank BETWEEN 1 AND 5),

  recipient_address text NOT NULL,     -- creator for campaign leagues, wallet for top_earner
  amount_raw numeric(78,0) NOT NULL,   -- payout for this rank
  payload jsonb NOT NULL,              -- UI row

  computed_at timestamptz NOT NULL DEFAULT now(),

  PRIMARY KEY (chain_id, period, epoch_start, category, rank)
);

CREATE INDEX IF NOT EXISTS league_epoch_winners_recipient_idx
  ON public.league_epoch_winners(chain_id, recipient_address, period, epoch_start DESC);

-- Claim records to prevent double-claim
CREATE TABLE IF NOT EXISTS public.league_epoch_claims (
  chain_id integer NOT NULL,
  period text NOT NULL CHECK (period IN ('weekly','monthly')),
  epoch_start timestamptz NOT NULL,
  category text NOT NULL,
  rank integer NOT NULL CHECK (rank BETWEEN 1 AND 5),

  recipient_address text NOT NULL,
  claimed_at timestamptz NOT NULL DEFAULT now(),
  signature text,

  PRIMARY KEY (chain_id, period, epoch_start, category, rank)
);
</file>

<file path="frontend/api/rewards.js">
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json } from "../server/http.js";

// GET /api/rewards?chainId=56&address=0x...
// Returns *unclaimed* prizes for the recipient.
export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId);
    const address = String(q.address ?? "").toLowerCase();
    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
    if (!isAddress(address)) return json(res, 400, { error: "Invalid address" });
    if (!pool) return json(res, 500, { error: "Server misconfigured: DATABASE_URL missing" });

    // Find winnings for the recipient and exclude already-claimed rows.
    const { rows } = await pool.query(
      `SELECT
          w.period,
          w.epoch_start AS "epochStart",
          w.epoch_end AS "epochEnd",
          w.category,
          w.rank,
          w.amount_raw AS "amountRaw",
          w.payload,
          w.computed_at AS "computedAt"
        FROM league_epoch_winners w
        LEFT JOIN league_epoch_claims c
          ON c.chain_id = w.chain_id
         AND c.period = w.period
         AND c.epoch_start = w.epoch_start
         AND c.category = w.category
         AND c.rank = w.rank
        WHERE w.chain_id = $1
          AND lower(w.recipient_address) = $2
          AND c.claimed_at IS NULL
        ORDER BY w.epoch_start DESC, w.period DESC, w.category ASC, w.rank ASC`,
      [chainId, address]
    );

    return json(res, 200, {
      address,
      chainId,
      rewards: rows.map((r) => ({
        period: r.period,
        epochStart: r.epochStart,
        epochEnd: r.epochEnd,
        category: r.category,
        rank: r.rank,
        amountRaw: r.amountRaw,
        payload: r.payload,
        computedAt: r.computedAt,
      })),
    });
  } catch (e) {
    // If schema isn't deployed yet, fail gracefully (UI can show empty state).
    const code = e?.code;
    console.error("[api/rewards]", e);
    if (code === "42P01" || code === "42703") {
      return json(res, 200, { rewards: [], warning: "DB schema missing league epoch tables" });
    }
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/src/constants/navigation.ts">
/**
 * Navigation and social link configuration
 */

import { Plus, Trophy, BookOpen } from "lucide-react";
import carouselIcon from "@/assets/menu-icons/carousel.png";
import upArrowIcon from "@/assets/menu-icons/up-arrow.png";
import userIcon from "@/assets/menu-icons/user.png";
import twitterIcon from "@/assets/social/twitter.png";
import discordIcon from "@/assets/social/discord.png";
import telegramIcon from "@/assets/social/telegram.png";
import { SocialItem } from "@/components/ui/social-media";

export interface NavItem {
  icon: string | typeof Plus;
  label: string;
  path: string;
}

export const navItems: NavItem[] = [
  { icon: carouselIcon, label: "Launchpad", path: "/" },
  { icon: Plus, label: "Create Coin", path: "/create" },
  { icon: Trophy, label: "Battle Leagues", path: "/battle-leagues" },
  { icon: userIcon, label: "Profile", path: "/profile" },
  { icon: BookOpen, label: "Docs", path: "/docs" },
];

export const socialLinks: SocialItem[] = [
  {
    href: "https://twitter.com/launchpad",
    ariaLabel: "X",
    tooltip: "X",
    color: "#000000",
    svgUrl: twitterIcon,
  },
  {
    href: "https://discord.gg/launchpad",
    ariaLabel: "Discord",
    tooltip: "Discord",
    color: "#5865F2",
    svgUrl: discordIcon,
  },
  {
    href: "https://t.me/launchpad",
    ariaLabel: "Telegram",
    tooltip: "Telegram",
    color: "#0088cc",
    svgUrl: telegramIcon,
  },
  // Docs moved into the main navigation
];
</file>

<file path="frontend/src/hooks/useCurveTrades.ts">
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ethers } from "ethers";
import { getActiveChainId, type SupportedChainId } from "@/lib/chainConfig";
import { useAblyTokenChannel } from "@/hooks/useAblyTokenChannel";

// Realtime-indexer HTTP base (Railway). Example: https://upmeme-production.up.railway.app
const API_BASE = String(import.meta.env.VITE_REALTIME_API_BASE || "").replace(/\/$/, "");

type RealtimeChannel = any;

export type CurveTradePoint = {
  type: "buy" | "sell";
  from: string;
  to: string;
  tokensWei: bigint;
  nativeWei: bigint;
  pricePerToken: number; // BNB per token
  timestamp: number; // unix seconds
  txHash: string;
  blockNumber: number;
  logIndex: number;
};

type UseCurveTradesOptions = {
  enabled?: boolean;
  chainId?: number;
  limit?: number;
  /** Safety net: periodically re-fetch snapshot to reconcile any missed messages. */
  reconcileMs?: number;
};

function keyOf(t: Pick<CurveTradePoint, "txHash" | "logIndex">) {
  return `${t.txHash.toLowerCase()}:${Number(t.logIndex ?? 0)}`;
}

function sortAsc(a: CurveTradePoint, b: CurveTradePoint) {
  if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;
  return Number(a.logIndex ?? 0) - Number(b.logIndex ?? 0);
}

function mergeTrades(prev: CurveTradePoint[], next: CurveTradePoint[]) {
  const map = new Map<string, CurveTradePoint>();
  for (const t of prev) map.set(keyOf(t), t);
  for (const t of next) map.set(keyOf(t), t);
  return Array.from(map.values()).sort(sortAsc);
}

function toBigIntWei(amount: unknown, kind: "ether" | "token"): bigint {
  // Postgres numerics often come through as strings (best case).
  const s = typeof amount === "string" ? amount : typeof amount === "number" ? String(amount) : "0";
  try {
    if (kind === "ether") return ethers.parseEther(s);
    return ethers.parseUnits(s, 18);
  } catch {
    return 0n;
  }
}

function toNumber(amount: unknown): number {
  if (typeof amount === "number") return amount;
  if (typeof amount === "string") {
    const n = Number(amount);
    return Number.isFinite(n) ? n : 0;
  }
  return 0;
}

function toTimestampSec(v: unknown): number {
  try {
    if (v instanceof Date) return Math.floor(v.getTime() / 1000);
    if (typeof v === "number") return Math.floor(v > 1e12 ? v / 1000 : v);
    if (typeof v === "string") {
      const s = v.trim();
      if (/^\d+(?:\.\d+)?$/.test(s)) {
        const n = Number(s);
        return Number.isFinite(n) ? Math.floor(n > 1e12 ? n / 1000 : n) : 0;
      }
      const ms = new Date(s).getTime();
      return Number.isFinite(ms) ? Math.floor(ms / 1000) : 0;
    }
    const ms = new Date(String(v)).getTime();
    return Number.isFinite(ms) ? Math.floor(ms / 1000) : 0;
  } catch {
    return 0;
  }
}

async function fetchJson(url: string, signal?: AbortSignal) {
  const r = await fetch(url, { method: "GET", signal });
  if (!r.ok) {
    const text = await r.text().catch(() => "");
    throw new Error(text || `HTTP ${r.status}`);
  }
  return r.json();
}

/**
 * Curve trades (bonding curve) backed by:
 *  1) Snapshot: Railway realtime-indexer REST endpoint
 *  2) Realtime: Ably channel updates
 *  3) Safety: periodic snapshot reconcile to avoid drift under heavy load
 */
export function useCurveTrades(campaignAddress?: string, opts?: UseCurveTradesOptions) {
  const enabled = opts?.enabled ?? true;
  const [points, setPoints] = useState<CurveTradePoint[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Only hard-reset state when the campaign address actually changes.
  // This prevents brief "trade list resets" that can cause the chart to
  // momentarily drop the latest candle while the indexer catches up.
  const prevCampaignRef = useRef<string>("");

  const chainId = useMemo<SupportedChainId>(() => {
    const cid = Number(opts?.chainId ?? 97);
    return getActiveChainId(cid);
  }, [opts?.chainId]);

  const inFlightRef = useRef(false);
  const initialLoadedRef = useRef(false);

  // If Ably realtime is temporarily unavailable (e.g., mobile networks, WS blocked),
  // this snapshot reconcile keeps the UI fresh. Keep it relatively low for testnet UX.
  const reconcileMs = opts?.reconcileMs ?? 10_000;
  const limit = Math.min(Math.max(Number(opts?.limit ?? 200), 1), 200);

  const apiTradesUrl = useMemo(() => {
    if (!API_BASE || !campaignAddress) return "";
    return `${API_BASE}/api/token/${campaignAddress.toLowerCase()}/trades?chainId=${chainId}&limit=${limit}`;
  }, [campaignAddress, chainId, limit]);

  const applySnapshot = useCallback((rows: any[]) => {
    const next: CurveTradePoint[] = (rows || [])
      .map((r: any) => {
        const side = String(r.side || r.type || "").toLowerCase() === "sell" ? "sell" : "buy";
        const txHash = String(r.tx_hash || r.txHash || "");
        const logIndex = Number(r.log_index ?? r.logIndex ?? 0);
        const blockNumber = Number(r.block_number ?? r.blockNumber ?? 0);
        const ts = toTimestampSec(r.block_time ?? r.timestamp ?? r.time);

        const tokensWei = toBigIntWei(r.token_amount ?? r.tokens ?? r.tokensWei, "token");
        const nativeWei = toBigIntWei(r.bnb_amount ?? r.native ?? r.nativeWei, "ether");

        const tokens = Number(ethers.formatUnits(tokensWei, 18));
        const bnb = Number(ethers.formatEther(nativeWei));
        const pricePerToken = toNumber(r.price_bnb ?? r.pricePerToken) || (tokens > 0 ? bnb / tokens : 0);

        return {
          type: side,
          from: String(r.wallet || r.trader || r.from || "").toLowerCase(),
          to: String(campaignAddress || "").toLowerCase(),
          tokensWei,
          nativeWei,
          pricePerToken,
          timestamp: ts,
          txHash,
          blockNumber,
          logIndex,
        } satisfies CurveTradePoint;
      })
      .filter((t) => /^0x[a-f0-9]{64}$/i.test(t.txHash) && Number.isFinite(t.blockNumber));

    setPoints((prev) => mergeTrades(prev, next));
  }, [campaignAddress]);

  const pullSnapshot = useCallback(async (signal?: AbortSignal) => {
    if (!enabled || !campaignAddress) {
      setPoints([]);
      setLoading(false);
      setError(null);
      return;
    }
    if (!apiTradesUrl) {
      setError("Missing VITE_REALTIME_API_BASE");
      setLoading(false);
      return;
    }
    if (inFlightRef.current) return;
    inFlightRef.current = true;
    try {
      // Avoid "page reload" feel by only showing the loading state for the first fetch.
      if (!initialLoadedRef.current) setLoading(true);
      const rows = await fetchJson(apiTradesUrl, signal);
      applySnapshot(Array.isArray(rows) ? rows : []);
      setError(null);
      initialLoadedRef.current = true;
    } catch (e: any) {
      const msg = e?.message || "Failed to load trades";
      setError(String(msg));
    } finally {
      setLoading(false);
      inFlightRef.current = false;
    }
  }, [enabled, campaignAddress, apiTradesUrl, applySnapshot]);

  // Initial snapshot + periodic reconcile
  useEffect(() => {
    const ac = new AbortController();
    const curr = (campaignAddress || "").toLowerCase();
    const prev = prevCampaignRef.current;
    // Only reset when the campaign truly changed. Avoid resets caused by
    // incidental prop changes (e.g., undefined -> 97 chainId) which can
    // temporarily clear the trade series and cause chart flicker.
    if (curr !== prev) {
      prevCampaignRef.current = curr;
      setPoints([]);
      setLoading(true);
      setError(null);
      initialLoadedRef.current = false;
    }

    pullSnapshot(ac.signal);

    if (!enabled || !campaignAddress) return () => ac.abort();

    const t = setInterval(() => {
      pullSnapshot(ac.signal);
    }, reconcileMs);

    return () => {
      clearInterval(t);
      ac.abort();
    };
  }, [enabled, campaignAddress, pullSnapshot, reconcileMs]);

  // Ably realtime stream (trade events)  shared per campaign to avoid multiple WebSockets.
  const ably = useAblyTokenChannel({ enabled: enabled && !!campaignAddress, chainId, campaignAddress });
  useEffect(() => {
    if (!enabled || !campaignAddress) return;
    if (ably.missingBase || !ably.channel) return;

    const onTrade = (msg: any) => {
      const data = msg?.data;
      if (Array.isArray(data)) return applySnapshot(data);
      if (data && typeof data === "object") return applySnapshot([data]);
    };

    try {
      ably.channel.subscribe("trade", onTrade);
    } catch {
      // ignore
    }

    return () => {
      try {
        ably.channel.unsubscribe("trade", onTrade);
      } catch {
        // ignore
      }
    };
  }, [enabled, campaignAddress, ably.channel, ably.missingBase, applySnapshot]);


  return { points, loading, error };
}
</file>

<file path="frontend/src/lib/rewardsApi.ts">
import { ethers } from "ethers";

export type RewardItem = {
  period: "weekly" | "monthly";
  epochStart: string;
  epochEnd: string;
  category: string;
  rank: number;
  amountRaw: string;
  payload: any;
  computedAt?: string;
};

export function buildLeagueClaimMessage(args: {
  chainId: number;
  recipient: string;
  period: "weekly" | "monthly";
  epochStart: string;
  category: string;
  rank: number;
  nonce: string;
}): string {
  const { chainId, recipient, period, epochStart, category, rank, nonce } = args;
  return [
    "MemeBattles League",
    "Action: LEAGUE_CLAIM",
    `ChainId: ${chainId}`,
    `Recipient: ${recipient.toLowerCase()}`,
    `Period: ${period}`,
    `EpochStart: ${epochStart}`,
    `Category: ${category}`,
    `Rank: ${rank}`,
    `Nonce: ${nonce}`,
  ].join("\n");
}

export async function fetchClaimableRewards(chainId: number, address: string): Promise<RewardItem[]> {
  const qs = new URLSearchParams({ chainId: String(chainId), address: address.toLowerCase() });
  const r = await fetch(`/api/rewards?${qs.toString()}`);
  const j = await r.json();
  return Array.isArray(j?.rewards) ? (j.rewards as RewardItem[]) : [];
}

export async function submitLeagueClaim(params: {
  chainId: number;
  period: "weekly" | "monthly";
  epochStart: string;
  category: string;
  rank: number;
  recipient: string;
  nonce: string;
  signature: string;
}): Promise<{ ok: boolean; claimedAt?: string | null; amountRaw?: string }> {
  const r = await fetch(`/api/league`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ action: "claim", ...params }),
  });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error || "Claim failed");
  return j;
}

export function formatWeiToBnb(weiLike: string | number | bigint, decimals = 18): string {
  try {
    const v = typeof weiLike === "bigint" ? weiLike : BigInt(String(weiLike));
    return ethers.formatUnits(v, decimals);
  } catch {
    return "0";
  }
}
</file>

<file path="frontend/src/pages/Create.tsx">
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { X, ImageIcon, Info, BookOpen } from "lucide-react";
import { z } from "zod";
import { ethers } from "ethers";
import ProcessingCard from "@/components/ui/processing-card";
import { useTokenForm } from "@/hooks/useTokenForm";
import { useTokenProcessing } from "@/hooks/useTokenProcessing";
import { tokenSchema, TOKEN_VALIDATION_LIMITS } from "@/constants/validation";
import { TokenCategory } from "@/types/token";

// NEW: import wallet + launchpad client
import { useWallet } from "@/hooks/useWallet";
import { useLaunchpad } from "@/lib/launchpadClient";
import type React from "react";
import { useState } from "react";
import { Link } from "react-router-dom";

const Create = () => {
  const {
    formData,
    setTokenName,
    setTicker,
    setDescription,
    setCategory,
    setWebsite,
    setTwitter,
    setOtherLink,
    setShowSocialLinks,
    handleImageChange,
    handleRemoveImage,
    handleReset,
    clearSocialLinks,
  } = useTokenForm();

  const {
    isProcessing,
    processingStatus,
    processingProgress,
    startProcessing,
    setProcessingRedirectTo,
  } = useTokenProcessing();

  // NEW: hooks for wallet + contracts
  const wallet = useWallet();
  const { createCampaign, fetchCampaigns } = useLaunchpad();

  // Optional creator initial buy (tokens, 18 decimals) performed in the same tx.
  const [initialBuyBnb, setInitialBuyBnb] = useState("");

  // UPDATED: async and actually calls the contract
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (formData.category === "project") {
      toast.error("Project tokens coming soon!");
      return;
    }

    // Validate inputs
    try {
      tokenSchema.parse({
        name: formData.name,
        ticker: formData.ticker,
        description: formData.description || undefined,
        website: formData.website || undefined,
        twitter: formData.twitter || undefined,
        otherLink: formData.otherLink || undefined,
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        toast.error(error.errors[0]?.message ?? "Validation error");
        return;
      }
      toast.error("Validation failed");
      return;
    }

    // Require image
    if (!formData.imagePreview || !formData.image) {
      toast.error("Please upload a token image");
      return;
    }

    // Require wallet connection
    if (!wallet.isConnected) {
      toast.error("Please connect your wallet first");
      return;
    }


    // Optional creator initial buy validation (max 1 BNB to keep launches fair)
    const initialBuyBnbTrim = (initialBuyBnb ?? "").trim();
    if (initialBuyBnbTrim) {
      let wei: bigint;
      try {
        wei = ethers.parseEther(initialBuyBnbTrim);
      } catch {
        toast.error("Initial buy must be a valid BNB amount (e.g. 0.1)");
        return;
      }
      if (wei > ethers.parseEther("1")) {
        toast.error("Initial buy max is 1 BNB");
        return;
      }
    }

    try {
      // Show nice processing overlay
      startProcessing();

      // IMPORTANT: Do not store base64 images on-chain.
      // Upload to Supabase Storage via the Vercel API route and pass the resulting URL.
      let logoURI = "";
      {
        const chainId = String(wallet.chainId ?? import.meta.env.VITE_TARGET_CHAIN_ID ?? "97");
        const address = (wallet.account ?? "").toLowerCase();
        const qs = new URLSearchParams({ kind: "logo", chainId, address }).toString();
        const fd = new FormData();
        fd.append("file", formData.image);

        const res = await fetch(`/api/upload?${qs}`, {
          method: "POST",
          body: fd,
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error(txt || `Logo upload failed (${res.status})`);
        }

        const json = (await res.json()) as { url?: string };
        if (!json?.url) throw new Error("Logo upload failed (missing url)");
        logoURI = json.url;
      }

      // For now we use 0 for pricing params.
      // We can later extend the form to include basePrice / slope / target.
      await createCampaign({
        name: formData.name,
        symbol: formData.ticker.toUpperCase(),
        logoURI,
        xAccount: formData.twitter || "",
        website: formData.website || "",
        extraLink: formData.otherLink || "",
        initialBuyBnb,
        basePriceWei: 0n,
        priceSlopeWei: 0n,
        graduationTargetWei: 0n,
        lpReceiver: "", // lets factory use msg.sender logic
      });

      toast.success("Campaign created on-chain!");

      // Best-effort: resolve the created campaign address so we can redirect using campaignAddress-only routes.
      try {
        const symbol = formData.ticker.toUpperCase();
        const creator = (wallet.account ?? "").toLowerCase();
        const maxAttempts = 10;
        const delayMs = 800;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const campaigns = (await fetchCampaigns()) ?? [];
          const matches = campaigns.filter((c) =>
            (c.creator ?? "").toLowerCase() === creator &&
            (c.symbol ?? "").toUpperCase() === symbol
          );

          if (matches.length > 0) {
            matches.sort((a, b) => {
              const at = (a.createdAt ?? 0);
              const bt = (b.createdAt ?? 0);
              if (bt !== at) return bt - at;
              return (b.id ?? 0) - (a.id ?? 0);
            });
            const newest = matches[0];
            if (newest?.campaign) {
              setProcessingRedirectTo(`/token/${newest.campaign}`);
              break;
            }
          }

          await new Promise((r) => setTimeout(r, delayMs));
        }
      } catch (e) {
        // If this fails, the processing hook will fall back to the Launchpad feed
        console.warn("[Create] Failed to resolve created campaign address", e);
      }

      // After this, useTokenProcessing will handle the rest of the UX
    } catch (error: any) {
      console.error(error);
      const message =
        error?.shortMessage ||
        error?.reason ||
        error?.message ||
        "Failed to create campaign";
      toast.error(message);
    }
  };

  const isProjectDisabled = formData.category === "project";

  return (
    <>
      {/* Processing Overlay */}
      {isProcessing && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
          <div className="w-full max-w-2xl px-4">
            <ProcessingCard
              name={formData.name || "Token"}
              status={processingStatus}
              progress={processingProgress}
              className="rounded-2xl border border-white/20 shadow-lg bg-white/[0.03]"
            />
          </div>
        </div>
      )}

      <div className="h-full overflow-y-auto pb-6 md:pb-8">
        <div className="max-w-4xl mx-auto px-4 md:px-6 lg:px-8 py-6 md:py-12">
          <h1 className="text-4xl md:text-5xl lg:text-7xl font-retro tracking-tight text-foreground mb-6 md:mb-8">
            Create a new coin
          </h1>

          {/* Playbook Banner */}
          <div className="bg-gradient-to-r from-accent/20 to-accent/10 rounded-2xl p-4 md:p-6 mb-4 md:mb-6 flex flex-col md:flex-row items-start md:items-center justify-between gap-4 shadow-xl border border-accent/30 backdrop-blur-sm">
            <div className="flex items-center gap-3 md:gap-4">
              <div className="bg-accent/20 p-3 md:p-4 rounded-xl">
                <BookOpen className="h-6 w-6 md:h-8 md:w-8 text-accent" />
              </div>
              <div>
                <h2 className="text-lg md:2xl font-retro text-foreground mb-1">
                  First time launching?
                </h2>
                <p className="text-sm md:text-base text-muted-foreground font-retro">
                  We recommend reading our creator playbook first.
                </p>
              </div>
            </div>
            <Button
              asChild
              className="bg-accent hover:bg-accent/90 text-accent-foreground font-retro text-base md:text-lg px-6 md:px-8 py-4 md:py-6 rounded-xl shadow-lg w-full md:w-auto"
            >
              <Link to="/playbook">Read Playbook</Link>
            </Button>
          </div>

          {/* Main Form Card */}
          <div className="bg-card/50 backdrop-blur-md rounded-2xl p-4 md:p-8 shadow-2xl border border-border relative">
            <button
              onClick={handleReset}
              className="absolute top-4 right-4 md:top-6 md:right-6 text-accent hover:text-accent/80 font-retro text-xs md:text-sm transition-colors"
            >
              Reset all
            </button>

            <form onSubmit={handleSubmit} className="space-y-4 md:space-y-6 mt-4">
              {/* Token Image */}
              <div>
                <label className="block text-foreground font-retro mb-3 text-base md:text-lg">
                  Token Image
                </label>
                <div className="flex items-center gap-4">
                  {!formData.imagePreview ? (
                    <label
                      htmlFor="image-upload"
                      className="w-24 h-24 md:w-32 md:h-32 border-2 border-dashed border-border rounded-xl flex items-center justify-center cursor-pointer hover:border-accent transition-colors bg-background/50"
                    >
                      <ImageIcon className="h-8 w-8 md:h-12 md:w-12 text-muted-foreground" />
                    </label>
                  ) : (
                    <div className="relative w-24 h-24 md:w-32 md:h-32">
                      <img
                        src={formData.imagePreview}
                        alt="Token preview"
                        className="w-full h-full object-cover rounded-xl border-2 border-border"
                      />
                      <button
                        type="button"
                        onClick={handleRemoveImage}
                        className="absolute -top-2 -right-2 bg-accent hover:bg-accent/90 rounded-full p-1 transition-colors"
                      >
                        <X className="h-4 w-4 text-accent-foreground" />
                      </button>
                    </div>
                  )}
                  <input
                    id="image-upload"
                    type="file"
                    accept="image/*"
                    onChange={handleImageChange}
                    className="hidden"
                    disabled={isProjectDisabled}
                  />
                </div>
              </div>

              {/* Token Name */}
              <div>
                <label className="block text-foreground font-retro mb-3 text-base md:text-lg">
                  Token name
                </label>
                <Input
                  value={formData.name}
                  onChange={(e) => setTokenName(e.target.value)}
                  placeholder="Token"
                  className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro text-lg md:text-xl h-12 md:h-14 rounded-lg focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={isProjectDisabled}
                  maxLength={TOKEN_VALIDATION_LIMITS.NAME_MAX_LENGTH}
                />
              </div>

              {/* Token Ticker */}
              <div>
                <label className="block text-foreground font-retro mb-3 text-base md:text-lg">
                  Token ticker
                </label>
                <Input
                  value={formData.ticker}
                  onChange={(e) => setTicker(e.target.value)}
                  placeholder="TICKER"
                  maxLength={TOKEN_VALIDATION_LIMITS.TICKER_MAX_LENGTH}
                  className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro text-lg md:text-xl h-12 md:h-14 rounded-lg uppercase focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={isProjectDisabled}
                />
              </div>

              {/* Token Category */}
              <div>
                <div className="flex items-center gap-2 mb-3">
                  <label className="text-foreground font-retro text-base md:text-lg">
                    Token Category
                  </label>
                  <Info className="h-4 w-4 text-accent" />
                </div>
                <div className="flex gap-3">
                  <button
                    type="button"
                    onClick={() => setCategory("meme")}
                    className={`flex-1 py-3 md:py-4 px-4 md:px-6 rounded-lg font-retro text-base md:text-lg transition-all ${
                      formData.category === "meme"
                        ? "bg-accent text-accent-foreground shadow-lg shadow-accent/20"
                        : "bg-muted text-muted-foreground border border-border hover:bg-muted/80"
                    }`}
                  >
                    Meme
                  </button>
                  <div className="relative flex-1">
                    <button
                      type="button"
                      onClick={() => setCategory("project")}
                      className={`w-full py-3 md:py-4 px-4 md:px-6 rounded-lg font-retro text-base md:text-lg transition-all ${
                        formData.category === "project"
                          ? "bg-accent text-accent-foreground shadow-lg shadow-accent/20"
                          : "bg-muted text-muted-foreground border border-border hover:bg-muted/80"
                      }`}
                    >
                      Project
                    </button>
                    {formData.category === "project" && (
                      <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 translate-y-full bg-background/90 backdrop-blur-sm text-accent text-xs font-retro px-3 py-1 rounded border border-accent/30 whitespace-nowrap z-10">
                        UP meme projects coming soon
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {/* Token Description */}
              <div>
                <label className="block text-foreground font-retro mb-3 text-base md:text-lg">
                  Token description{" "}
                  <span className="text-muted-foreground">(optional)</span>
                </label>
                <Textarea
                  value={formData.description}
                  onChange={(e) => setDescription(e.target.value)}
                  placeholder="Description"
                  className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro text-base md:text-lg min-h-24 rounded-lg resize-none focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed"
                  maxLength={TOKEN_VALIDATION_LIMITS.DESCRIPTION_MAX_LENGTH}
                  disabled={isProjectDisabled}
                />
              </div>

              {/* Social Links */}
              <div>
                {!formData.showSocialLinks ? (
                  <button
                    type="button"
                    onClick={() => setShowSocialLinks(true)}
                    className="text-accent hover:text-accent/80 font-retro text-base md:text-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={isProjectDisabled}
                  >
                    Add Social Links
                  </button>
                ) : (
                  <div className="space-y-4">
                    <div className="flex items-center justify-between mb-3">
                      <label className="text-foreground font-retro text-base md:text-lg">
                        Social Links
                      </label>
                      <button
                        type="button"
                        onClick={clearSocialLinks}
                        className="text-muted-foreground hover:text-foreground transition-colors"
                      >
                        <X className="h-5 w-5" />
                      </button>
                    </div>

                    <div>
                      <label className="block text-muted-foreground font-retro mb-2 text-xs md:text-sm">
                        Website
                      </label>
                      <Input
                        value={formData.website}
                        onChange={(e) => setWebsite(e.target.value)}
                        placeholder="https://example.com"
                        type="url"
                        className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro rounded-lg focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed h-12"
                        disabled={isProjectDisabled}
                      />
                    </div>

                    <div>
                      <label className="block text-muted-foreground font-retro mb-2 text-xs md:text-sm">
                        X (Twitter)
                      </label>
                      <Input
                        value={formData.twitter}
                        onChange={(e) => setTwitter(e.target.value)}
                        placeholder="https://x.com/username"
                        type="url"
                        className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro rounded-lg focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed h-12"
                        disabled={isProjectDisabled}
                      />
                    </div>

                    <div>
                      <label className="block text-muted-foreground font-retro mb-2 text-xs md:text-sm">
                        Other Link
                      </label>
                      <Input
                        value={formData.otherLink}
                        onChange={(e) => setOtherLink(e.target.value)}
                        placeholder="https://..."
                        type="url"
                        className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro rounded-lg focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed h-12"
                        disabled={isProjectDisabled}
                      />
                    </div>
                  </div>
                )}
              </div>

              {/* Optional creator initial buy */}
              <div className="pt-4">
                <label className="block text-muted-foreground font-retro mb-2 text-xs md:text-sm">
                  Initial buy (BNB, optional)
                </label>
                <Input
                  value={initialBuyBnb}
                  onChange={(e) => setInitialBuyBnb(e.target.value)}
                  placeholder="0.00"
                  inputMode="decimal"
                  className="bg-background/50 border-border text-foreground placeholder:text-muted-foreground font-retro rounded-lg focus:border-accent focus:ring-accent disabled:opacity-50 disabled:cursor-not-allowed h-12"
                  disabled={isProjectDisabled}
                />
                <p className="mt-2 text-xs text-muted-foreground">
                  If set, the creator will spend this amount of BNB to buy tokens in the same transaction as campaign creation.
                  Max 1 BNB.
                </p>
              </div>

              {/* Create Button */}
              <div className="pt-4">
                <Button
                  type="submit"
                  disabled={isProjectDisabled}
                  className={`w-full font-retro text-xl md:text-2xl py-6 md:py-8 rounded-2xl shadow-lg transition-all ${
                    isProjectDisabled
                      ? "bg-muted text-muted-foreground cursor-not-allowed"
                      : "bg-accent hover:bg-accent/90 text-accent-foreground shadow-accent/20"
                  }`}
                >
                  Create Coin
                </Button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </>
  );
};

export default Create;
</file>

<file path="frontend/src/pages/Playbook.tsx">
/**
 * Playbook Page
 * Practical, step-by-step docs for using the platform.
 */

import React, { useCallback, useRef } from "react";
import { Link } from "react-router-dom";
import {
  ArrowRight,
  BookOpen,
  MessageCircle,
  Rocket,
  ShieldCheck,
  TrendingUp,
  Zap,
} from "lucide-react";

import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";

function Section({
  id,
  icon: Icon,
  title,
  subtitle,
  children,
}: {
  id: string;
  icon: typeof Rocket;
  title: string;
  subtitle?: string;
  children: React.ReactNode;
}) {
  return (
    <Card
      id={id}
      className="bg-card/30 backdrop-blur-md border border-border rounded-2xl overflow-hidden scroll-mt-6"
    >
      <div className="p-5 md:p-6 flex gap-4 items-start">
        <div className="shrink-0 rounded-xl border border-border/60 bg-background/40 p-3">
          <Icon className="h-5 w-5 text-accent" />
        </div>

        <div className="flex-1">
          <div className="flex flex-col gap-1">
            <h2 className="text-lg md:text-xl font-retro text-foreground">{title}</h2>
            {subtitle ? (
              <p className="text-sm text-muted-foreground leading-relaxed">{subtitle}</p>
            ) : null}
          </div>

          <div className="mt-4">{children}</div>
        </div>
      </div>
    </Card>
  );
}

const Playbook = () => {
  // Scroll container is the element with overflow-y-auto (this page does NOT scroll the window)
  const scrollRef = useRef<HTMLDivElement>(null);

  const scrollToSection = useCallback((id: string) => {
    const container = scrollRef.current;
    if (!container) return;

    const el = container.querySelector<HTMLElement>(`#${CSS.escape(id)}`);
    if (!el) return;

    // Scroll inside the container (not the window)
    el.scrollIntoView({ behavior: "smooth", block: "start", inline: "nearest" });

    // Optional: update hash for shareable anchors without relying on window scrolling
    // (won't cause navigation, only updates URL fragment)
    if (typeof window !== "undefined") {
      const url = new URL(window.location.href);
      url.hash = id;
      window.history.replaceState({}, "", url.toString());
    }
  }, []);

  return (
    <div
      ref={scrollRef}
      className="h-full w-full overflow-y-auto scrollbar-thin scrollbar-thumb-accent/40 scrollbar-track-muted/20"
    >
      <div className="mx-auto max-w-5xl px-4 md:px-6 pb-10">
        {/* Hero */}
        <div className="pt-4 md:pt-6 pb-6 md:pb-8">
          <div className="flex items-start justify-between gap-4 flex-col md:flex-row">
            <div className="min-w-0">
              <div className="flex items-center gap-3">
                <div className="rounded-2xl border border-border/60 bg-background/40 p-3">
                  <BookOpen className="h-6 w-6 text-accent" />
                </div>
                <div>
                  <h1 className="text-2xl md:text-4xl font-retro text-foreground leading-tight">
                    Playbook
                  </h1>
                  <p className="text-muted-foreground mt-1">
                    A practical guide to launching, discovering, and trading tokens.
                  </p>
                </div>
              </div>

              {/* Anchor buttons */}
              <div className="mt-4 flex flex-wrap gap-2">
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => scrollToSection("quickstart")}
                >
                  Quickstart
                </Button>
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => scrollToSection("bonding")}
                >
                  Bonding
                </Button>
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => scrollToSection("trading")}
                >
                  Trading
                </Button>
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => scrollToSection("safety")}
                >
                  Safety
                </Button>
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={() => scrollToSection("faq")}
                >
                  FAQ
                </Button>
              </div>
            </div>

            <div className="flex flex-col sm:flex-row gap-2 w-full md:w-auto">
              <Button asChild className="w-full sm:w-auto">
                <Link to="/create">
                  Create a token <ArrowRight className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            </div>
          </div>

          <div className="mt-6 rounded-2xl border border-border/60 bg-background/30 backdrop-blur p-4 md:p-5">
            <div className="flex flex-col md:flex-row md:items-center gap-3 md:gap-6">
              <div className="flex-1 text-sm text-muted-foreground">
                This playbook explains the core flow: create a campaign, participate during bonding,
                and trade once tokens graduate to a DEX. If you are building a community, review the
                safety section before sharing links.
              </div>
              <div className="flex gap-2">
                <Button asChild size="sm" variant="secondary">
                  <Link to="/">Launchpad</Link>
                </Button>
                <Button asChild size="sm" variant="secondary">
                  <Link to="/profile">Profile</Link>
                </Button>
              </div>
            </div>
          </div>
        </div>

        {/* Sections */}
        <div className="space-y-4 md:space-y-6">
          <Section
            id="quickstart"
            icon={Rocket}
            title="1) Launch a token"
            subtitle="Create a campaign, set the basics, and publish."
          >
            <ol className="list-decimal pl-5 space-y-2 text-sm text-muted-foreground">
              <li>
                Go to{" "}
                <Link className="text-accent hover:underline" to="/create">
                  Create
                </Link>{" "}
                and fill in name, ticker, logo, and links.
              </li>
              <li>Double-check external URLs. Use only official domains/handles.</li>
              <li>Submit the transaction and confirm in your wallet.</li>
              <li>After creation, your token appears in the Launchpad feed.</li>
            </ol>

            <div className="mt-4 grid grid-cols-1 md:grid-cols-2 gap-3">
              <Card className="rounded-2xl border border-border/60 bg-background/30 p-4">
                <p className="font-retro text-foreground">Best practices</p>
                <ul className="mt-2 text-sm text-muted-foreground list-disc pl-5 space-y-1">
                  <li>Keep ticker short and unique.</li>
                  <li>Use a square logo and a readable name.</li>
                  <li>Provide at least one verified social link.</li>
                </ul>
              </Card>
              <Card className="rounded-2xl border border-border/60 bg-background/30 p-4">
                <p className="font-retro text-foreground">Common mistakes</p>
                <ul className="mt-2 text-sm text-muted-foreground list-disc pl-5 space-y-1">
                  <li>Copy/paste wrong links (scam lookalikes).</li>
                  <li>Launching without a clear plan for updates.</li>
                  <li>Overpromising or implying guaranteed returns.</li>
                </ul>
              </Card>
            </div>
          </Section>

          <Section
            id="bonding"
            icon={Zap}
            title="2) Understand bonding"
            subtitle="During bonding, buys and sells happen against the campaign mechanics."
          >
            <div className="text-sm text-muted-foreground space-y-2">
              <p>
                Tokens can start in a bonding phase. In this phase, price typically changes as supply
                changes, and trades are executed via the launch contracts (not a DEX pool).
              </p>
              <p>
                Once the campaign reaches its graduation criteria, it can transition to DEX trading.
                Graduated tokens appear in the dedicated graduated row on the Launchpad feed.
              </p>
            </div>
          </Section>

          <Section
            id="trading"
            icon={TrendingUp}
            title="3) Discover and trade"
            subtitle="Use the Launchpad feed to find tokens, then open details for chart, activity, and actions."
          >
            <ol className="list-decimal pl-5 space-y-2 text-sm text-muted-foreground">
              <li>Open the Launchpad feed on the home page and browse the sections.</li>
              <li>Tap a card to center it, then tap again to open token details.</li>
              <li>
                On Token Details, review price action, holders, volume, and recent activity before trading.
              </li>
            </ol>

            <div className="mt-4 rounded-2xl border border-border/60 bg-background/30 p-4 text-sm text-muted-foreground">
              Tip: If you are on mobile, use horizontal swipe to continue browsing cards.
            </div>
          </Section>

          <Section
            id="safety"
            icon={ShieldCheck}
            title="4) Safety and risk"
            subtitle="Practical checks to reduce mistakes and avoid obvious scams."
          >
            <ul className="list-disc pl-5 space-y-2 text-sm text-muted-foreground">
              <li>Verify the token/campaign address before sharing or trading.</li>
              <li>Prefer official links. Be cautious with rebranded or lookalike domains.</li>
              <li>Do not connect your wallet to unknown sites.</li>
              <li>Assume high volatility. Use position sizing you can tolerate.</li>
            </ul>
          </Section>

          <Section id="faq" icon={MessageCircle} title="FAQ" subtitle="Answers to the most common questions.">
            <Accordion type="single" collapsible className="w-full">
              <AccordionItem value="faq-1">
                <AccordionTrigger>What is the difference between bonding and graduated?</AccordionTrigger>
                <AccordionContent>
                  Bonding is the initial phase where trades occur against the launch campaign mechanics
                  (not a DEX pool). Graduated tokens have transitioned to DEX trading, typically with
                  external liquidity and standard swaps.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-2">
                <AccordionTrigger>Can I buy and sell during bonding?</AccordionTrigger>
                <AccordionContent>
                  Yes. If a token is in bonding, buy/sell actions are executed through the campaign.
                  Expect higher price impact on thin liquidity phases and always review the details page
                  before trading.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-3">
                <AccordionTrigger>How do I open Token Details from the carousel?</AccordionTrigger>
                <AccordionContent>
                  First click to center/highlight a card, then click it again to navigate to the token.
                  This prevents accidental navigation when you are just scrolling.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-4">
                <AccordionTrigger>Why does my transaction fail or get stuck?</AccordionTrigger>
                <AccordionContent>
                  The most common causes are: insufficient gas, RPC congestion, slippage/price movement,
                  or wallet rejection. Try increasing gas slightly, refreshing, and re-submitting. Always
                  confirm you are on the correct network.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-5">
                <AccordionTrigger>Why does the price jump when I buy or sell?</AccordionTrigger>
                <AccordionContent>
                  Price impact is expected, especially during bonding or on low liquidity. Larger orders
                  move the price more. Consider splitting entries/exits and avoid market-chasing.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-6">
                <AccordionTrigger>Where do I find the contract / token address?</AccordionTrigger>
                <AccordionContent>
                  On the token card and Token Details page you can copy the address. Always verify the
                  address before sharing or trading to avoid clones.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-7">
                <AccordionTrigger>Why does the chart look different before DEX trading?</AccordionTrigger>
                <AccordionContent>
                  Before DEX trading, price data can come from campaign trades rather than an external pool.
                  After graduation, charts generally reflect DEX activity and liquidity conditions.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-8">
                <AccordionTrigger>How do I avoid fake links and impersonators?</AccordionTrigger>
                <AccordionContent>
                  Only trust links shown on the official token page, and verify handles/domains. Be cautious
                  of lookalike accounts, changed usernames, and URLs with extra characters.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-9">
                <AccordionTrigger>Can I edit token name, ticker, or image after launch?</AccordionTrigger>
                <AccordionContent>
                  In most launch flows, core metadata is meant to be immutable once created. If your setup
                  supports profile-based overrides, those changes affect UI display but do not change the
                  on-chain token itself.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-10">
                <AccordionTrigger>Why dont I see my new token immediately?</AccordionTrigger>
                <AccordionContent>
                  It can take a short time for indexing / refresh. Try refreshing the page. If you just created
                  a token, it should appear in the Launchpad feed shortly after confirmation.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-11">
                <AccordionTrigger>Do you offer financial advice?</AccordionTrigger>
                <AccordionContent>
                  No. This playbook is product documentation only. Crypto assets can be highly volatile;
                  always do your own research and manage risk responsibly.
                </AccordionContent>
              </AccordionItem>

              <AccordionItem value="faq-12">
                <AccordionTrigger>How do I report a bug or suspicious token?</AccordionTrigger>
                <AccordionContent>
                  Use the official social links and channels. Include the token address, screenshots, and a
                  clear description of what happened. Never share your seed phrase or private keys.
                </AccordionContent>
              </AccordionItem>
            </Accordion>
          </Section>
        </div>
      </div>
    </div>
  );
};

export default Playbook;
</file>

<file path="frontend/src/types/profile.ts">
/**
 * Profile and user-related TypeScript interfaces
 */

export type ProfileTab = "balances" | "coins" | "replies" | "rewards" | "notifications" | "followers";

export interface Coin {
  id: number;
  image: string;
  name: string;
  ticker: string;
  marketCap: string;
  timeAgo: string;
}
</file>

<file path="realtime-indexer/src/leagueFeed.ts">
import type { Pool } from "pg";
import { publishLeague } from "./ably.js";

export type LeagueCampaignPatch = {
  campaignAddress: string; // lowercase

  lastPriceBnb?: string | null;
  marketcapBnb?: string | null;
  vol24hBnb?: string | null;

  votes24h?: number;
  votesAllTime?: number;
  trendingScore?: string | null;

  raisedTotalBnb?: string | null;
};

type Opts = {
  pool: Pool;
  flushMs?: number; // default 500
};

/**
 * Global league feed publisher:
 * - batches per-campaign patches and publishes every flushMs to league:<chainId>
 * - maintains a best-effort raisedTotalBnb accumulator per campaign
 */
export function createLeagueFeedPublisher(opts: Opts) {
  const pool = opts.pool;
  const flushMs = Math.max(100, Number(opts.flushMs ?? 500));

  // chainId -> (campaign -> patch)
  const pendingByChain = new Map<number, Map<string, LeagueCampaignPatch>>();

  // chainId -> (campaign -> raisedTotalBnb number)
  const raisedByChain = new Map<number, Map<string, number>>();

  let timer: NodeJS.Timeout | null = null;

  const nowSec = () => Math.floor(Date.now() / 1000);

  function getPending(chainId: number) {
    let m = pendingByChain.get(chainId);
    if (!m) {
      m = new Map();
      pendingByChain.set(chainId, m);
    }
    return m;
  }

  function getRaisedMap(chainId: number) {
    let m = raisedByChain.get(chainId);
    if (!m) {
      m = new Map();
      raisedByChain.set(chainId, m);
    }
    return m;
  }

  function mergePatch(chainId: number, campaign: string, partial: Partial<LeagueCampaignPatch>) {
    const addr = campaign.toLowerCase();
    const m = getPending(chainId);
    const prev = m.get(addr) || ({ campaignAddress: addr } as LeagueCampaignPatch);
    m.set(addr, { ...prev, ...partial, campaignAddress: addr });
  }

  async function loadRaisedTotal(chainId: number, campaign: string): Promise<number> {
    const addr = campaign.toLowerCase();
    const r = await pool.query(
      `select
         coalesce(sum(case when side='buy' then bnb_amount else -bnb_amount end), 0) as raised_total_bnb
       from public.curve_trades
       where chain_id=$1 and campaign_address=$2`,
      [chainId, addr]
    );
    return Number(r.rows[0]?.raised_total_bnb ?? 0);
  }

  async function applyRaisedDelta(chainId: number, campaign: string, deltaBnb: number) {
    const addr = campaign.toLowerCase();
    const rm = getRaisedMap(chainId);

    let cur = rm.get(addr);
    if (cur == null) {
      // Lazy-init once per campaign per process lifetime
      cur = await loadRaisedTotal(chainId, addr);
    }

    const next = cur + deltaBnb;
    rm.set(addr, next);

    mergePatch(chainId, addr, { raisedTotalBnb: String(next) });
  }

  async function flushOnce() {
    const ts = nowSec();

    for (const [chainId, m] of pendingByChain.entries()) {
      if (m.size === 0) continue;

      const items = Array.from(m.values());
      m.clear(); // clear first to avoid buildup

      try {
        await publishLeague(chainId, "campaign_patch", {
          type: "campaign_patch",
          chainId,
          ts,
          items,
        });
      } catch {
        // best-effort: drop rather than block the indexer loop
      }
    }
  }

  function start() {
    if (timer) return;
    timer = setInterval(() => {
      flushOnce().catch(() => {});
    }, flushMs);
  }

  function stop() {
    if (!timer) return;
    clearInterval(timer);
    timer = null;
  }

  return {
    start,
    stop,

    queueStats(
      chainId: number,
      campaign: string,
      p: { lastPriceBnb: string | null; marketcapBnb: string | null; vol24hBnb: string }
    ) {
      mergePatch(chainId, campaign, {
        lastPriceBnb: p.lastPriceBnb,
        marketcapBnb: p.marketcapBnb,
        vol24hBnb: p.vol24hBnb,
      });
    },

    queueVotes(chainId: number, campaign: string, p: { votes24h: number; votesAllTime: number; trendingScore?: string | null }) {
      mergePatch(chainId, campaign, {
        votes24h: p.votes24h,
        votesAllTime: p.votesAllTime,
        trendingScore: p.trendingScore ?? null,
      });
    },

    queueRaisedDelta(chainId: number, campaign: string, deltaBnb: number) {
      // fire-and-forget; do not block trade processing
      applyRaisedDelta(chainId, campaign, deltaBnb).catch(() => {});
    },
  };
}
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MemeBattles</title>
    <meta name="description" content="Launch a meme or project on BSC today with just a few button">
    <meta name="author" content="MemeBattles Launchpad" />

    
    
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/public/assets/UPMEME.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@updotmeme" />
    <meta name="twitter:image" content="/assets/UPMEME.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
  
  
  
  <meta property="og:title" content="MemeBattles">
  <meta name="twitter:title" content="MemeBattles">
  <meta property="og:description" content="launch a meme or project on BSC today with just a few button">
  <meta name="twitter:description" content="launch a meme or project on BSC today with just a few button">
  <!--
    IMPORTANT:
    Use a local favicon (served from /public) so deployments update correctly.
    The query string helps bust aggressive browser caching.
  -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=mb1">
</head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #ddab4d);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #ddab4d);
}

@layer base {
  a:hover {
    color: hsl(var(--accent));
  }
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="frontend/src/components/token/CurvePriceChart.tsx">
// src/components/token/CurvePriceChart.tsx
// Market-cap chart for bonding-curve trades, rendered with TradingView Lightweight Charts.

import { useEffect, useMemo, useRef, useState } from "react";
import { ethers } from "ethers";

import { useCurveTrades, type CurveTradePoint } from "@/hooks/useCurveTrades";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { CurveTradesChart } from "@/lib/chart/CurveTradesChart";
import type { CurveTradePoint as ChartPoint } from "@/lib/chart/buildCandles";

type CurvePriceChartProps = {
  campaignAddress?: string;
  /** Optional override to avoid opening additional realtime connections in child components. */
  curvePointsOverride?: CurveTradePoint[];
  loadingOverride?: boolean;
  errorOverride?: string | null;
};

type TimeframeKey = "5s" | "1m" | "5m" | "15m" | "30m" | "1h" | "4h" | "1d";

const TIMEFRAMES: Array<{ key: TimeframeKey; label: string; seconds: number }> = [
  { key: "5s", label: "5s", seconds: 5 },
  { key: "1m", label: "1m", seconds: 60 },
  { key: "5m", label: "5m", seconds: 5 * 60 },
  { key: "15m", label: "15m", seconds: 15 * 60 },
  { key: "30m", label: "30m", seconds: 30 * 60 },
  { key: "1h", label: "1h", seconds: 60 * 60 },
  { key: "4h", label: "4h", seconds: 4 * 60 * 60 },
  { key: "1d", label: "1d", seconds: 24 * 60 * 60 },
];

function tokensFromWeiSafe(wei: bigint | undefined | null): number {
  try {
    if (!wei) return 0;
    const n = Number(ethers.formatUnits(wei, 18));
    return Number.isFinite(n) ? n : 0;
  } catch {
    return 0;
  }
}

/**
 * Builds market-cap series in USD:
 * - circulatingTokens += buyTokens; -= sellTokens
 * - mcapBNB = pricePerToken(BNB) * circulatingTokens
 * - mcapUSD = mcapBNB * bnbUsd
 */
function toMarketCapPointsUsd(trades: CurveTradePoint[], bnbUsd: number): ChartPoint[] {
  if (!trades?.length || !Number.isFinite(bnbUsd) || bnbUsd <= 0) return [];

  const sorted = [...trades].sort((a, b) => {
    if ((a.timestamp ?? 0) !== (b.timestamp ?? 0)) return (a.timestamp ?? 0) - (b.timestamp ?? 0);
    if ((a.blockNumber ?? 0) !== (b.blockNumber ?? 0)) return (a.blockNumber ?? 0) - (b.blockNumber ?? 0);
    return Number(a.logIndex ?? 0) - Number(b.logIndex ?? 0);
  });

  let circ = 0;
  const out: ChartPoint[] = [];

  for (const t of sorted) {
    const delta = tokensFromWeiSafe(t.tokensWei);
    circ += t.type === "sell" ? -delta : delta;
    if (circ < 0) circ = 0;

    const priceBnb = Number(t.pricePerToken ?? 0);
    const mcUsd = priceBnb * circ * bnbUsd;

    const tsMs = Number(t.timestamp ?? 0) * 1000;
    if (!Number.isFinite(tsMs) || tsMs <= 0) continue;
    if (!Number.isFinite(mcUsd) || mcUsd <= 0) continue;

    out.push({ ts: tsMs, value: mcUsd });
  }

  return out;
}

export const CurvePriceChart = ({
  campaignAddress,
  curvePointsOverride,
  loadingOverride,
  errorOverride,
}: CurvePriceChartProps) => {
  // HOOKS MUST ALWAYS RUN BEFORE ANY RETURN
  const [tf, setTf] = useState<TimeframeKey>("1m");
const bucketSec = useMemo(
  () => TIMEFRAMES.find((t) => t.key === tf)?.seconds ?? 60,
  [tf]
);

const live = useCurveTrades(campaignAddress, { enabled: !curvePointsOverride });
const livePoints = curvePointsOverride ?? live.points;
const liveLoading = loadingOverride ?? live.loading;
const liveError = errorOverride ?? live.error;

const { price: bnbUsd, loading: bnbUsdLoading, error: bnbUsdError } = useBnbUsdPrice(true);

// Keep last known-good USD so we never blank during refresh.
const lastUsdRef = useRef<number>(0);
useEffect(() => {
  if (bnbUsd && Number.isFinite(bnbUsd) && bnbUsd > 0) lastUsdRef.current = bnbUsd;
}, [bnbUsd]);

const usd = (bnbUsd && Number.isFinite(bnbUsd) && bnbUsd > 0 ? bnbUsd : lastUsdRef.current) || 0;

const chartPointsComputed: ChartPoint[] = useMemo(() => {
  if (!usd || usd <= 0) return [];
  return toMarketCapPointsUsd(livePoints || [], usd);
}, [livePoints, usd]);

// Keep last non-empty points to avoid flicker on brief loading toggles.
const lastPointsRef = useRef<ChartPoint[]>([]);
useEffect(() => {
  if (chartPointsComputed.length) lastPointsRef.current = chartPointsComputed;
}, [chartPointsComputed]);

const renderPoints = chartPointsComputed.length ? chartPointsComputed : lastPointsRef.current;

// Only show blocking placeholders when we truly have no points to render.
if (renderPoints.length === 0) {
  if (liveError) {
    return <div className="flex items-center justify-center h-full text-xs text-destructive p-4">{liveError}</div>;
  }
  if (bnbUsdError) {
    return <div className="flex items-center justify-center h-full text-xs text-destructive p-4">{bnbUsdError}</div>;
  }
  if (liveLoading) {
    return <div className="flex items-center justify-center h-full text-xs text-muted-foreground p-4">Loading curve trades</div>;
  }
  if (bnbUsdLoading || !usd) {
    return <div className="flex items-center justify-center h-full text-xs text-muted-foreground p-4">Loading USD conversion</div>;
  }
  return <div className="flex items-center justify-center h-full text-xs text-muted-foreground p-4">No curve data available yet.</div>;
}
  

  return (
    <div className="w-full h-full flex flex-col">
      {/* timeframe dropdown (default 1m) */}
      <div className="flex items-center justify-end px-2 pb-2">
        <select
          value={tf}
          onChange={(e) => setTf(e.target.value as TimeframeKey)}
          className="h-7 rounded-md border border-border bg-background/50 px-2 text-[11px] text-foreground outline-none"
        >
          {TIMEFRAMES.map((t) => (
            <option key={t.key} value={t.key}>
              {t.label}
            </option>
          ))}
        </select>
      </div>

      <div className="flex-1 min-h-[260px]">
        <CurveTradesChart points={renderPoints} intervalSec={bucketSec} />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/token/UpvoteDialog.tsx">
import { useEffect, useMemo, useState } from "react";
import { ethers } from "ethers";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { useWallet } from "@/hooks/useWallet";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { getActiveChainId, getVoteTreasuryAddress } from "@/lib/chainConfig";

// Client-side minimum guardrails (in addition to any on-chain minAmount)
// Requirement: minimum is 0.005 BNB OR ~$2 worth of BNB (whichever is higher).
const ABS_MIN_BNB = 0.005;
const USD_MIN = 2;

const UPVOTE_ABI = [
  "function voteWithBNB(address campaign, bytes32 meta) payable",
  "function assetConfig(address asset) view returns (bool enabled, uint256 minAmount)",
];

function safeLowerHex(s?: string | null): string {
  const v = String(s ?? "").trim();
  return v ? v.toLowerCase() : "";
}

type Props = {
  campaignAddress: string;
  className?: string;
  buttonVariant?: "default" | "secondary" | "outline" | "ghost" | "destructive";
  buttonSize?: "default" | "sm" | "lg" | "icon";
};

/**
 * Upvote Dialog (BNB-only for v1)
 * - Reads minAmount for native (address(0)) from the UPVoteTreasury contract
 * - Enforces a client-side minimum: max(0.005 BNB, ~$2 in BNB, on-chain minAmount)
 * - Sends one payable tx => one vote
 */
export function UpvoteDialog({
  campaignAddress,
  className,
  buttonVariant = "secondary",
  buttonSize = "sm",
}: Props) {
  const { toast } = useToast();
  const wallet = useWallet();
  const { price: priceUsd } = useBnbUsdPrice();

  const chainId = getActiveChainId(wallet.chainId);
  const treasuryAddress = useMemo(() => {
    return safeLowerHex(getVoteTreasuryAddress(chainId));
  }, [chainId]);

  const [open, setOpen] = useState(false);
  const [loadingCfg, setLoadingCfg] = useState(false);
  const [minAmountWei, setMinAmountWei] = useState<bigint | null>(null);
  const [enabled, setEnabled] = useState<boolean>(true);
  const [hasContractCode, setHasContractCode] = useState<boolean | null>(null);
  const [balanceWei, setBalanceWei] = useState<bigint | null>(null);
  const [estTotalWei, setEstTotalWei] = useState<bigint | null>(null);
  const [insufficient, setInsufficient] = useState<boolean>(false);
  const [amountBnb, setAmountBnb] = useState<string>("");
  const [submitting, setSubmitting] = useState(false);
  const [prefilled, setPrefilled] = useState(false);
  const [touched, setTouched] = useState(false);

  // Prevent the dialog from closing while the wallet prompt / tx is in-flight.
  const lockDialog = submitting;

  const absMinWei = useMemo(() => {
    try {
      return ethers.parseEther(String(ABS_MIN_BNB));
    } catch {
      return 0n;
    }
  }, []);

  const usdMinWei = useMemo(() => {
    const p = Number(priceUsd ?? 0);
    if (!Number.isFinite(p) || p <= 0) return 0n;
    const bnb = USD_MIN / p;
    if (!Number.isFinite(bnb) || bnb <= 0) return 0n;
    try {
      // Use a string round-trip to avoid BigInt overflow/precision issues.
      return ethers.parseEther(bnb.toFixed(18));
    } catch {
      return 0n;
    }
  }, [priceUsd]);

  const effectiveMinWei = useMemo(() => {
    let m = minAmountWei ?? 0n;
    if (absMinWei > m) m = absMinWei;
    if (usdMinWei > m) m = usdMinWei;
    return m;
  }, [minAmountWei, absMinWei, usdMinWei]);

  const humanEffectiveMin = useMemo(() => {
    try {
      return ethers.formatEther(effectiveMinWei);
    } catch {
      return "";
    }
  }, [effectiveMinWei]);

  const minUsdLabel = useMemo(() => {
    const p = Number(priceUsd ?? 0);
    if (!Number.isFinite(p) || p <= 0) return null;
    try {
      const minBnb = Number(ethers.formatEther(effectiveMinWei));
      if (!Number.isFinite(minBnb) || minBnb <= 0) return null;
      const usd = minBnb * p;
      if (!Number.isFinite(usd) || usd <= 0) return null;
      return `$${usd.toFixed(2)}`;
    } catch {
      return null;
    }
  }, [priceUsd, effectiveMinWei]);


// Load wallet BNB balance when dialog opens / account changes
useEffect(() => {
  if (!open) return;
  if (!wallet.provider) return;
  if (!wallet.account) {
    setBalanceWei(null);
    return;
  }
  let cancelled = false;
  (async () => {
    try {
      const bal = await wallet.provider.getBalance(wallet.account);
      if (cancelled) return;
      setBalanceWei(BigInt(bal));
    } catch {
      if (cancelled) return;
      setBalanceWei(null);
    }
  })();
  return () => {
    cancelled = true;
  };
}, [open, wallet.provider, wallet.account, chainId]);

  const amountWei = useMemo(() => {
    try {
      return ethers.parseEther(String(amountBnb || "0"));
    } catch {
      return null;
    }
  }, [amountBnb]);

  const tooLow = useMemo(() => {
    if (amountWei == null) return false;
    if (amountWei <= 0n) return false;
    return amountWei < effectiveMinWei;
  }, [amountWei, effectiveMinWei]);

  // When the dialog opens, allow a one-time prefill to the effective minimum.
  useEffect(() => {
    if (!open) return;
    setPrefilled(false);
    setTouched(false);
  }, [open]);

  // Load minAmount + enabled whenever dialog opens (or chain changes)
  useEffect(() => {
    if (!open) return;
    if (!treasuryAddress) {
      setMinAmountWei(null);
      setEnabled(false);
      setHasContractCode(null);
      return;
    }
    if (!wallet.provider) return;

    let cancelled = false;
    setLoadingCfg(true);
    (async () => {
      try {
        // Guardrail: if the address has no bytecode, the contract is not deployed on this chain.
        const code = await wallet.provider.getCode(treasuryAddress);
        const hasCode = code != null && code !== "0x";
        if (cancelled) return;
        setHasContractCode(hasCode);
        if (!hasCode) {
          setEnabled(false);
          setMinAmountWei(null);
          return;
        }

        const c = new ethers.Contract(treasuryAddress, UPVOTE_ABI, wallet.provider);
        const res = await c.assetConfig(ethers.ZeroAddress);
        // ethers v6 returns a Result: [enabled, minAmount] + named props
        const isEnabled = Boolean(res?.enabled ?? res?.[0]);
        const min = BigInt(res?.minAmount ?? res?.[1] ?? 0);
        if (cancelled) return;
        setEnabled(isEnabled);
        setMinAmountWei(min);
      } catch (e: any) {
        if (cancelled) return;
        setEnabled(false);
        setMinAmountWei(null);
        setHasContractCode(false);
      } finally {
        if (!cancelled) setLoadingCfg(false);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [open, treasuryAddress, wallet.provider]);

  // One-time prefill: set the input to the effective minimum when the dialog opens.
  useEffect(() => {
    if (!open) return;
    if (touched) return;
    if (lockDialog) return;
    // If we haven't touched the input, keep it aligned with the effective minimum.
    if (amountWei != null && amountWei > 0n && amountWei < effectiveMinWei) {
      try {
        const v = Number(ethers.formatEther(effectiveMinWei));
        if (Number.isFinite(v) && v > 0) {
          setAmountBnb(v.toFixed(6));
          setPrefilled(true);
        }
      } catch {
        // ignore
      }
      return;
    }
    if (prefilled) return;
    if (amountBnb.trim() !== "") return;
    if (effectiveMinWei <= 0n) return;
    try {
      const v = Number(ethers.formatEther(effectiveMinWei));
      if (!Number.isFinite(v) || v <= 0) return;
      setAmountBnb(v.toFixed(6));
      setPrefilled(true);
    } catch {
      // ignore
    }
  }, [open, prefilled, touched, lockDialog, amountBnb, amountWei, effectiveMinWei]);

// Estimate total cost (value + gas) and mark insufficient balance.
useEffect(() => {
  if (!open) return;
  if (!wallet.provider) return;
  if (!wallet.account) return;
  if (!treasuryAddress) return;
  if (hasContractCode === false) return;
  if (!enabled) return;

  let cancelled = false;
  (async () => {
    try {
      // Parse value
      let valueWei: bigint = 0n;
      try {
        valueWei = ethers.parseEther(String(amountBnb || "0"));
      } catch {
        setEstTotalWei(null);
        setInsufficient(false);
        return;
      }
      if (valueWei <= 0n) {
        setEstTotalWei(null);
        setInsufficient(false);
        return;
      }
      if (valueWei < effectiveMinWei) {
        // Too low amount is handled elsewhere; don't flag as insufficient.
        setEstTotalWei(null);
        setInsufficient(false);
        return;
      }

      const provider = wallet.provider;
      const fee = await provider.getFeeData();
      const gasPrice = BigInt(fee.gasPrice ?? 0n);

      // If gas price is missing, fall back to just value comparison.
      if (gasPrice === 0n) {
        setEstTotalWei(valueWei);
        if (balanceWei != null) setInsufficient(balanceWei < valueWei);
        return;
      }

      const c = new ethers.Contract(treasuryAddress, UPVOTE_ABI, provider);
      const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));
      let gasLimit: bigint;
      try {
        gasLimit = BigInt(await c.voteWithBNB.estimateGas(campaignAddress, meta, { value: valueWei }));
      } catch {
        // If estimation fails for any reason, use a conservative fallback.
        gasLimit = 150000n;
      }

      // Add a buffer (20%) to avoid borderline failures
      const bufferedGas = (gasLimit * 120n) / 100n;
      const total = valueWei + bufferedGas * gasPrice;

      if (cancelled) return;
      setEstTotalWei(total);
      if (balanceWei != null) setInsufficient(balanceWei < total);
    } catch {
      if (cancelled) return;
      setEstTotalWei(null);
      setInsufficient(false);
    }
  })();

  return () => {
    cancelled = true;
  };
}, [open, wallet.provider, wallet.account, treasuryAddress, hasContractCode, enabled, amountBnb, effectiveMinWei, campaignAddress, balanceWei]);

  const canUpvote = Boolean(
    treasuryAddress &&
      hasContractCode !== false &&
      enabled &&
      campaignAddress &&
      wallet.provider &&
      amountWei != null &&
      amountWei > 0n &&
      !tooLow &&
      !insufficient
  );

  const handleUpvote = async () => {
    try {
      const ABORT = "__UPVOTE_ABORT__";
      const fail = (title: string, description: string) => {
        toast({ title, description });
        throw new Error(ABORT);
      };

      // Lock dialog from the moment the user confirms, including wallet confirmation time.
      setSubmitting(true);

      if (!treasuryAddress) {
        fail("UP Vote is not configured", "Missing vote treasury address for this chain.");
      }
      if (hasContractCode === false) {
        fail(
          "UP Vote contract not deployed",
          "The configured vote treasury address has no contract code on this network. Switch networks or update the contract address."
        );
      }
      if (!wallet.signer) {
        await wallet.connect();
      }
      if (!wallet.signer) {
        fail("Wallet not connected", "Please connect your wallet to upvote.");
      }

      // Validate amount
      let valueWei: bigint;
      try {
        valueWei = ethers.parseEther(String(amountBnb));
      } catch {
        fail("Invalid amount", "Enter a valid BNB amount.");
      }
      if (valueWei < effectiveMinWei) {
        fail(
          "Amount too low",
          `Minimum is ${humanEffectiveMin} BNB${minUsdLabel ? ` (~${minUsdLabel})` : ""} for 1 vote.`
        );
      }


// Check balance (value + estimated gas)
if (balanceWei != null) {
  // If we computed estTotalWei, use it; else at least ensure value fits.
  const needed = estTotalWei ?? valueWei;
  if (balanceWei < needed) {
      fail(
        "Insufficient BNB",
        "You don't have enough BNB to cover the vote fee (and gas)."
      );
  }
}

      const c = new ethers.Contract(treasuryAddress, UPVOTE_ABI, wallet.signer);
      const meta = ethers.keccak256(ethers.toUtf8Bytes("user"));
      // BSC (56/97) is legacy gas (no EIP-1559). Some RPCs (and MetaMask) log
      // noisy errors for `eth_maxPriorityFeePerGas`. Force a legacy tx by
      // supplying gasPrice and type=0 when available.
      let gasPrice: bigint | undefined;
      try {
        const gpHex = await wallet.provider!.send("eth_gasPrice", []);
        gasPrice = gpHex ? BigInt(gpHex) : undefined;
      } catch {
        try {
          const fee = await wallet.provider!.getFeeData();
          gasPrice = fee.gasPrice != null ? BigInt(fee.gasPrice) : undefined;
        } catch {
          gasPrice = undefined;
        }
      }

      const overrides: any = { value: valueWei };
      if (gasPrice && gasPrice > 0n) {
        overrides.gasPrice = gasPrice;
        overrides.type = 0;
      }

      const tx = await c.voteWithBNB(campaignAddress, meta, overrides);

      toast({ title: "Upvote sent", description: "Waiting for confirmation" });
      await tx.wait();
      toast({ title: "Upvoted", description: "Your vote has been recorded." });
      setOpen(false);

      // Nudge any UI surfaces that render vote-sorted leaderboards to refresh immediately.
      try {
        window.dispatchEvent(
          new CustomEvent("upmeme:upvoteConfirmed", {
            detail: { chainId, campaignAddress: safeLowerHex(campaignAddress) },
          })
        );
        window.dispatchEvent(
          new CustomEvent("upmeme:txConfirmed", {
            detail: { kind: "upvote", chainId, campaignAddress: safeLowerHex(campaignAddress), txHash: tx?.hash },
          })
        );
      } catch {}
    } catch (e: any) {
      // Errors thrown via `fail(...)` already displayed a toast.
      const msg = String(e?.shortMessage || e?.message || "Transaction failed");
      if (!msg.includes("__UPVOTE_ABORT__")) {
        toast({ title: "Upvote failed", description: msg });
      }
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(next) => {
        // Do not allow closing while awaiting wallet confirmation / tx confirmation.
        if (!next && lockDialog) return;
        setOpen(next);
      }}
    >
      <DialogTrigger asChild>
        <Button
          variant={buttonVariant}
          size={buttonSize}
          className={className}
          disabled={!treasuryAddress}
          title={!treasuryAddress ? "UP Vote treasury not configured" : "Upvote"}
        >
          UP Vote
        </Button>
      </DialogTrigger>
      <DialogContent
        onPointerDownOutside={(e) => {
          if (lockDialog) e.preventDefault();
        }}
        onInteractOutside={(e) => {
          if (lockDialog) e.preventDefault();
        }}
        onEscapeKeyDown={(e) => {
          if (lockDialog) e.preventDefault();
        }}
      >
        <DialogHeader>
          <DialogTitle>UP Vote</DialogTitle>
          <DialogDescription>
            Pay a small BNB fee to upvote this campaign. 1 transaction = 1 vote.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-3">
          <div className="text-sm text-muted-foreground">
            {loadingCfg ? (
              "Loading fee"
            ) : enabled ? (
              <>
                Minimum fee:{" "}
                <span className="text-foreground">{humanEffectiveMin} BNB</span>
                {minUsdLabel ? (
                  <>
                    {" "} <span className="text-foreground">{minUsdLabel}</span>
                  </>
                ) : null}
                <span className="ml-2">(min: max(0.005 BNB, ~$2))</span>
              </>
            ) : (
              "UP Vote is currently disabled on this chain."
            )}
          </div>


<div className="text-xs text-muted-foreground">
  Balance:{" "}
  <span className="text-foreground">
    {balanceWei != null ? `${Number(ethers.formatEther(balanceWei)).toFixed(6)} BNB` : ""}
  </span>
  {insufficient ? (
    <span className="ml-2 text-destructive">Insufficient for this vote.</span>
  ) : null}
</div>

          <div className="flex items-center gap-2">
            <Input
              value={amountBnb}
              onChange={(e) => {
                setTouched(true);
                setAmountBnb(e.target.value);
              }}
              placeholder="0.001"
              inputMode="decimal"
            />
            <div className="text-sm text-muted-foreground">BNB</div>
          </div>

          {amountBnb.trim() !== "" && amountWei == null ? (
            <div className="text-xs text-destructive">
              Enter a valid BNB amount.
            </div>
          ) : null}

          {tooLow ? (
            <div className="text-xs text-destructive">
              Minimum is {humanEffectiveMin} BNB{minUsdLabel ? ` (~${minUsdLabel})` : ""}.
            </div>
          ) : null}

          <div className="text-xs text-muted-foreground">
            Off-chain cooldown & daily caps apply to keep the list fair.
          </div>
        </div>

        <DialogFooter>
          <Button
            variant="secondary"
            onClick={() => setOpen(false)}
            disabled={submitting}
          >
            Cancel
          </Button>
          <Button
            onClick={handleUpvote}
            disabled={!canUpvote || submitting || loadingCfg}
          >
            {submitting ? "Upvoting" : "Confirm Upvote"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="frontend/src/hooks/useAblyLeagueChannel.ts">
import { useEffect, useMemo, useState } from "react";
import Ably from "ably";

// Realtime-indexer HTTP base (Railway). Example: https://upmeme-production.up.railway.app
const API_BASE = String(import.meta.env.VITE_REALTIME_API_BASE || "").replace(/\/$/, "");

type Entry = {
  key: string;
  client: Ably.Realtime;
  channelName: string;
  channel: any;
  refs: number;
  closeTimer: any | null;
};

// Cache Ably connections per chainId to prevent multiple WebSockets being opened
// on the Home feed (Featured + Campaign Grid).
const CACHE = new Map<string, Entry>();

function channelNameFor(chainId: number) {
  return `league:${chainId}`;
}

function authUrlFor(chainId: number) {
  const base = String(API_BASE || "").replace(/\/$/, "");
  return `${base}/api/ably/token?chainId=${chainId}&scope=league`;
}

function acquire(chainId: number) {
  const key = `league:${chainId}`;
  const existing = CACHE.get(key);
  if (existing) {
    existing.refs += 1;
    if (existing.closeTimer) {
      clearTimeout(existing.closeTimer);
      existing.closeTimer = null;
    }
    return existing;
  }

  const authUrl = authUrlFor(chainId);
  const client = new Ably.Realtime({
    authUrl,
    authMethod: "GET",
  });

  const chName = channelNameFor(chainId);
  const channel = client.channels.get(chName);

  // Rewind a short window so reconnects pick up recent updates.
  try {
    channel.setOptions({ params: { rewind: "120s" } });
  } catch {
    // ignore
  }

  // Attach eagerly
  try {
    channel.attach();
  } catch {
    // ignore
  }

  const entry: Entry = {
    key,
    client,
    channelName: chName,
    channel,
    refs: 1,
    closeTimer: null,
  };
  CACHE.set(key, entry);
  return entry;
}

function release(key: string) {
  const entry = CACHE.get(key);
  if (!entry) return;
  entry.refs -= 1;
  if (entry.refs > 0) return;

  entry.closeTimer = setTimeout(() => {
    try {
      entry.channel.unsubscribe();
    } catch {
      // ignore
    }
    try {
      entry.client.close();
    } catch {
      // ignore
    }
    CACHE.delete(key);
  }, 1500);
}

export function useAblyLeagueChannel(opts: { enabled: boolean; chainId: number }) {
  const { enabled, chainId } = opts;

  const key = useMemo(() => {
    if (!enabled) return "";
    return `league:${chainId}`;
  }, [enabled, chainId]);

  const [entry, setEntry] = useState<Entry | null>(null);
  const [connectionState, setConnectionState] = useState<string>("initialized");

  useEffect(() => {
    if (!enabled) {
      setEntry(null);
      setConnectionState("disabled");
      return;
    }
    if (!API_BASE) {
      setEntry(null);
      setConnectionState("missing_base");
      return;
    }

    const e = acquire(chainId);
    setEntry(e);

    try {
      setConnectionState(e.client.connection.state);
    } catch {
      // ignore
    }

    // Track Ably connection health for self-heal fallback
    const onConn = () => {
      try {
        setConnectionState(e.client.connection.state);
      } catch {
        // ignore
      }
    };
    try {
      e.client.connection.on(onConn);
    } catch {
      // ignore
    }

    return () => {
        try {
        e.client.connection.off(onConn);
      } catch {
        // ignore
      }
      release(e.key);
    };
  }, [enabled, chainId]);

  return {
    client: entry?.client ?? null,
    channel: entry?.channel ?? null,
    channelName: entry?.channelName ?? null,
    ready: Boolean(entry && entry.client && entry.channel),
    missingBase: enabled && !API_BASE,
    cacheKey: key,
    connectionState,
    isConnected: connectionState === "connected",
  };
}
</file>

<file path="frontend/src/hooks/useTokenProcessing.ts">
/**
 * Custom hook for managing token creation processing state.
 *
 * Internal navigation must be campaignAddress-only.
 * This hook therefore navigates to a caller-provided redirect path (e.g. /token/0x...).
 * If none is provided, it navigates to the Launchpad feed.
 */

import { useCallback, useEffect, useRef, useState } from "react";
import { useNavigate } from "react-router-dom";
import { toast } from "sonner";
import { ProcessingStatus } from "@/types/token";
import { PROCESSING_TIMING } from "@/constants/processingStages";

export const useTokenProcessing = () => {
  const navigate = useNavigate();
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingStatus, setProcessingStatus] = useState<ProcessingStatus>("queued");
  const [processingProgress, setProcessingProgress] = useState(0);

  // Caller can set the redirect at any time (e.g. after on-chain create resolves).
  const redirectToRef = useRef<string | null>(null);

  const setProcessingRedirectTo = useCallback((path: string | null) => {
    redirectToRef.current = path;
  }, []);

  useEffect(() => {
    if (!isProcessing) return;

    // Change status from queued to running
    const statusTimer = setTimeout(() => {
      setProcessingStatus("running");
    }, PROCESSING_TIMING.QUEUED_TO_RUNNING_DELAY);

    // Gradually increase progress
    const progressInterval = setInterval(() => {
      setProcessingProgress((prev) => {
        if (prev >= PROCESSING_TIMING.MAX_PROGRESS_THRESHOLD) return prev;
        return (
          prev +
          Math.random() * PROCESSING_TIMING.MAX_PROGRESS_INCREMENT +
          PROCESSING_TIMING.MIN_PROGRESS_INCREMENT
        );
      });
    }, PROCESSING_TIMING.PROGRESS_UPDATE_INTERVAL);

    // Complete the process
    const completeTimer = setTimeout(() => {
      setProcessingProgress(100);
      setProcessingStatus("succeeded");
      clearInterval(progressInterval);

      // Navigate after showing success
      setTimeout(() => {
        // IMPORTANT: do not navigate to the Showcase as a fallback if we simply haven't
        // resolved the campaign address yet (indexer / RPC delay). Wait briefly for the
        // caller to provide a redirect path.
        (async () => {
          const started = Date.now();
          const maxWaitMs = 20000;
          while (!redirectToRef.current && Date.now() - started < maxWaitMs) {
            await new Promise((r) => setTimeout(r, 500));
          }
          toast.success("Token created successfully!");
          navigate(redirectToRef.current ?? "/");
        })();
      }, PROCESSING_TIMING.SUCCESS_NAVIGATION_DELAY);
    }, PROCESSING_TIMING.TOTAL_PROCESS_DURATION);

    return () => {
      clearTimeout(statusTimer);
      clearTimeout(completeTimer);
      clearInterval(progressInterval);
    };
  }, [isProcessing, navigate]);

  const startProcessing = useCallback(() => {
    setProcessingRedirectTo(null);
    setIsProcessing(true);
    setProcessingStatus("queued");
    setProcessingProgress(0);
  }, [setProcessingRedirectTo]);

  return {
    isProcessing,
    processingStatus,
    processingProgress,
    startProcessing,
    setProcessingRedirectTo,
  };
};
</file>

<file path="frontend/src/lib/launchpadClient.ts">
import { Contract, ethers } from "ethers";
import LaunchFactoryArtifact from "@/abi/LaunchFactory.json";
import LaunchCampaignArtifact from "@/abi/LaunchCampaign.json";
import LaunchTokenArtifact from "@/abi/LaunchToken.json";
import { useWallet } from "@/hooks/useWallet";
import { useCallback, useMemo, useRef } from "react";
import { getActiveChainId, getFactoryAddress, type SupportedChainId } from "@/lib/chainConfig";
import { getReadProvider } from "@/lib/readProvider";

// Public endpoints can be very sensitive to getLogs volume.
// Keep scans small + chunked.
const LOG_CHUNK_SIZE = 700;

// For UI-only rollups (holders/volume), recent history is sufficient.
// 50k blocks is roughly 12 days on BSC (approx).
const DEFAULT_ACTIVITY_LOOKBACK_BLOCKS = 50_000;

// ---------------- ABI helpers ----------------
const toAbi = (x: any) => (x?.abi ?? x) as ethers.InterfaceAbi;
const FACTORY_ABI = toAbi(LaunchFactoryArtifact);
const CAMPAIGN_ABI = toAbi(LaunchCampaignArtifact);
const TOKEN_ABI = toAbi(LaunchTokenArtifact);

// ---------------- Types ----------------
export type CampaignInfo = {
  id: number;
  campaign: string;
  token: string;
  creator: string;
  name: string;
  symbol: string;
  logoURI: string;
  xAccount: string;
  website: string;
  extraLink: string;

  createdAt?: number;

  // Optional UI-only metadata 
  holders?: string;
  volume?: string;
  marketCap?: string;
  timeAgo?: string;
  telegram?: string;
  discord?: string;

  // Optional DEX metadata for charts
  dexPairAddress?: string;
  dexScreenerUrl?: string;
};

export type CampaignMetrics = {
  sold: bigint;
  curveSupply: bigint;
  liquiditySupply: bigint;
  creatorReserve: bigint;
  currentPrice: bigint;
  basePrice: bigint;
  priceSlope: bigint;
  graduationTarget: bigint;
  liquidityBps: bigint;
  protocolFeeBps: bigint;

  launched?: boolean;
  finalizedAt?: bigint;
};

export type CampaignActivity = {
  buyers: number;
  sellers: number;
  buyVolumeWei: bigint;
  sellVolumeWei: bigint;
  fromBlock: number;
  toBlock: number;
};

export type CampaignCardStats = {
  holders: string;
  volume: string;
  marketCap: string;
  /** Unrounded market cap in BNB (for precise USD conversion / ATH tracking). */
  marketCapBnb?: number;
};

export type CampaignSummary = {
  campaign: CampaignInfo;
  metrics: CampaignMetrics | null;
  stats: CampaignCardStats;
};

// ---------------- Formatting helpers ----------------
const formatBnbFromWei = (wei: bigint): string => {
  try {
    const raw = ethers.formatEther(wei);
    const n = Number(raw);
    if (!Number.isFinite(n)) return `${raw} BNB`;
    const abs = Math.abs(n);
    const pretty = abs >= 1 ? n.toFixed(2) : abs >= 0.01 ? n.toFixed(4) : abs >= 0.0001 ? n.toFixed(6) : n.toFixed(8);
    return `${pretty} BNB`;
  } catch {
    return `${wei.toString()} wei`;
  }
};

const formatCount = (n: number): string => {
  if (!Number.isFinite(n)) return "";
  return String(n);
};

// ---------------- Rate-limit utilities ----------------
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

function isRateLimitish(e: any): boolean {
  const code = e?.code ?? e?.error?.code ?? e?.info?.error?.code;
  const msg = String(e?.message ?? e?.info?.error?.message ?? "").toLowerCase();
  return (
    code === -32005 ||
    msg.includes("rate limit") ||
    msg.includes("limit exceeded") ||
    msg.includes("triggered rate limit")
  );
}

async function withBackoff<T>(fn: () => Promise<T>, retries = 3): Promise<T> {
  let lastErr: any = null;
  for (let i = 0; i <= retries; i++) {
    try {
      return await fn();
    } catch (e) {
      lastErr = e;
      if (!isRateLimitish(e) || i === retries) break;
      // quadratic-ish backoff
      await sleep(200 * (i + 1) * (i + 1));
    }
  }
  throw lastErr;
}

// Simple semaphore to avoid multiple parallel log scans nuking public RPCs
function createSemaphore(max: number) {
  let inFlight = 0;
  const queue: Array<() => void> = [];

  const acquire = async () => {
    if (inFlight < max) {
      inFlight++;
      return;
    }
    await new Promise<void>((resolve) => queue.push(resolve));
    inFlight++;
  };

  const release = () => {
    inFlight--;
    const next = queue.shift();
    if (next) next();
  };

  return async <T>(fn: () => Promise<T>): Promise<T> => {
    await acquire();
    try {
      return await fn();
    } finally {
      release();
    }
  };
}

const runLogScanLimited = createSemaphore(1);

// ---------------- Log helper (chunked + retry + tiny delay) ----------------
async function getLogsChunked(
  provider: ethers.Provider,
  params: { address: string; topics?: (string | string[] | null)[] },
  fromBlock: number,
  toBlock: number
) {
  const logs: any[] = [];
  for (let start = fromBlock; start <= toBlock; start += LOG_CHUNK_SIZE) {
    const end = Math.min(toBlock, start + LOG_CHUNK_SIZE - 1);

    const chunk = await withBackoff(
      () => provider.getLogs({ ...params, fromBlock: start, toBlock: end } as any),
      3
    );

    logs.push(...chunk);

    // tiny pacing helps public endpoints a lot
    await sleep(80);
  }
  return logs;
}

// ---------------- Hook ----------------
export function useLaunchpad() {
  const { provider: walletProvider, signer, chainId: walletChainId } = useWallet() as any;

  const activeChainId = useMemo<SupportedChainId>(() => {
    return getActiveChainId(walletChainId) as SupportedChainId;
  }, [walletChainId]);

  const factoryAddress = useMemo(() => getFactoryAddress(activeChainId), [activeChainId]);

  // Read provider (public RPC, batching disabled in readProvider.ts)
  const readProvider = useMemo(() => {
    return getReadProvider(activeChainId);
  }, [activeChainId]);

  // Cache fromBlock per campaign so we dont recompute it repeatedly
  const fromBlockCacheRef = useRef<Map<string, number>>(new Map());

  const getFactoryRead = useCallback(() => {
    if (!factoryAddress) return null;
    return new Contract(factoryAddress, FACTORY_ABI, readProvider) as any;
  }, [factoryAddress, readProvider]);

  const getFactoryWrite = useCallback(() => {
    if (!factoryAddress || !signer) return null;
    return new Contract(factoryAddress, FACTORY_ABI, signer) as any;
  }, [factoryAddress, signer]);

  const getCampaignRead = useCallback(
    (address: string) => {
      if (!address) return null;
      return new Contract(address, CAMPAIGN_ABI, readProvider) as any;
    },
    [readProvider]
  );

  // --- READS ---

  /** Total number of campaigns in the factory (used for paging / infinite scroll). */
  const fetchCampaignsCount = useCallback(async (): Promise<number> => {
    const factory = getFactoryRead();
    if (!factory) return 0;
    const total: bigint = await factory.campaignsCount();
    return Number(total ?? 0n);
  }, [getFactoryRead]);

  /**
   * Fetch a raw campaign page from the factory.
   * NOTE: Factory pages are ordered oldest->newest; we return newest->oldest by default.
   */
  const fetchCampaignPage = useCallback(
    async (offset: number, limit: number, opts?: { newestFirst?: boolean }): Promise<CampaignInfo[]> => {
      const factory = getFactoryRead();
      if (!factory) return [];
      const total = await fetchCampaignsCount();
      if (total <= 0) return [];

      const safeLimit = Math.max(1, Math.min(50, Number(limit ?? 24)));
      const safeOffset = Math.max(0, Math.min(total, Number(offset ?? 0)));

      const page = await factory.getCampaignPage(safeOffset, safeLimit);
      const mapped = (page ?? []).map((c: any, idx: number) => ({
        id: safeOffset + idx,
        campaign: c.campaign,
        token: c.token,
        creator: c.creator,
        name: c.name,
        symbol: c.symbol,
        logoURI: c.logoURI,
        xAccount: c.xAccount,
        website: c.website,
        extraLink: c.extraLink,
        createdAt: c.createdAt ? Number(c.createdAt) : undefined,
      })) as CampaignInfo[];

      const newestFirst = opts?.newestFirst ?? true;
      return newestFirst ? mapped.slice().reverse() : mapped;
    },
    [getFactoryRead, fetchCampaignsCount]
  );

  const fetchCampaigns = useCallback(async (): Promise<CampaignInfo[]> => {
    const totalNumber = await fetchCampaignsCount();
    if (totalNumber <= 0) return [];

    // Default behavior (kept for backward compatibility): return the latest 25.
    const limit = Math.min(totalNumber, 25);
    const offset = Math.max(0, totalNumber - limit);
    return await fetchCampaignPage(offset, limit, { newestFirst: true });
  }, [fetchCampaignsCount, fetchCampaignPage]);

  /**
   * Fetch only the on-chain logoURI for a given campaign.
   *
   * This is used as a lightweight hydration step for the campaign grid when the
   * DB-backed feed does not have logo_uri populated yet (but the campaign
   * contract does).
   */
  const fetchCampaignLogoURI = useCallback(
    async (campaignAddress: string): Promise<string | null> => {
      const addr = String(campaignAddress ?? '').trim();
      if (!addr) return null;
      const campaign = getCampaignRead(addr);
      if (!campaign) return null;
      try {
        const uri = await campaign.logoURI();
        const s = uri != null ? String(uri).trim() : '';
        return s ? s : null;
      } catch {
        return null;
      }
    },
    [getCampaignRead]
  );

  const fetchCampaignMetrics = useCallback(
    async (campaignAddress: string): Promise<CampaignMetrics | null> => {
      if (!campaignAddress) return null;

      const campaign = getCampaignRead(campaignAddress);
      if (!campaign) return null;

      const [
        sold,
        curveSupply,
        liquiditySupply,
        creatorReserve,
        basePrice,
        priceSlope,
        graduationTarget,
        liquidityBps,
        protocolFeeBps,
        currentPrice,
      ] = await Promise.all([
        campaign.sold(),
        campaign.curveSupply(),
        campaign.liquiditySupply(),
        campaign.creatorReserve(),
        campaign.basePrice(),
        campaign.priceSlope(),
        campaign.graduationTarget(),
        campaign.liquidityBps(),
        campaign.protocolFeeBps(),
        campaign.currentPrice(),
      ]);

      let launched = false;
      let finalizedAt = 0n;
      try {
        launched = await campaign.launched();
      } catch {
        // ignore
      }
      try {
        finalizedAt = await campaign.finalizedAt();
      } catch {
        // ignore
      }

      return {
        sold,
        curveSupply,
        liquiditySupply,
        creatorReserve,
        basePrice,
        priceSlope,
        graduationTarget,
        liquidityBps,
        protocolFeeBps,
        currentPrice,
        launched,
        finalizedAt,
      };
    },
    [getCampaignRead]
  );

  /**
   * IMPORTANT CHANGE:
   * We no longer try to find the exact creation block via factory logs.
   * That was causing rate limits on public endpoints.
   *
   * Instead we use a bounded lookback window (cached per campaign).
   */
  const getFromBlockForCampaign = useCallback(
    async (campaignAddress: string): Promise<number> => {
      const key = campaignAddress.toLowerCase();
      const cached = fromBlockCacheRef.current.get(key);
      if (typeof cached === "number") return cached;

      const latest = await readProvider.getBlockNumber();
      const fromBlock = Math.max(0, latest - DEFAULT_ACTIVITY_LOOKBACK_BLOCKS);
      fromBlockCacheRef.current.set(key, fromBlock);
      return fromBlock;
    },
    [readProvider]
  );

  const fetchCampaignActivity = useCallback(
    async (campaignAddress: string): Promise<CampaignActivity | null> => {
      if (!campaignAddress) return null;

      const latest = await readProvider.getBlockNumber();
      const fromBlock = await getFromBlockForCampaign(campaignAddress);

      // Phase 2 fast-path: prefer cheap counters over log scanning
      try {
        const c = getCampaignRead(campaignAddress);
        if (c) {
          const [buyersCount, totalBuyVolumeWei, totalSellVolumeWei] = await Promise.all([
            c.buyersCount(),
            c.totalBuyVolumeWei(),
            c.totalSellVolumeWei(),
          ]);

          return {
            buyers: Number(buyersCount),
            sellers: 0,
            buyVolumeWei: totalBuyVolumeWei as bigint,
            sellVolumeWei: totalSellVolumeWei as bigint,
            fromBlock,
            toBlock: latest,
          };
        }
      } catch (e) {
        console.warn("[fetchCampaignActivity] Counters not available; falling back to logs", e);
      }

      // Fallback: log scanning (limited concurrency + chunked + retry)
      return runLogScanLimited(async () => {
        const iface = new ethers.Interface(CAMPAIGN_ABI);
        const buyTopic = iface.getEvent("TokensPurchased").topicHash;
        const sellTopic = iface.getEvent("TokensSold").topicHash;

        let buyVolumeWei = 0n;
        let sellVolumeWei = 0n;
        const buyers = new Set<string>();
        const sellers = new Set<string>();

        try {
          const buyLogs = await getLogsChunked(
            readProvider,
            { address: campaignAddress, topics: [buyTopic] },
            fromBlock,
            latest
          );

          for (const log of buyLogs) {
            const parsed = iface.parseLog(log);
            const buyer = String(parsed.args.buyer).toLowerCase();
            const cost = parsed.args.cost as bigint;
            buyers.add(buyer);
            buyVolumeWei += cost;
          }

          const sellLogs = await getLogsChunked(
            readProvider,
            { address: campaignAddress, topics: [sellTopic] },
            fromBlock,
            latest
          );

          for (const log of sellLogs) {
            const parsed = iface.parseLog(log);
            const seller = String(parsed.args.seller).toLowerCase();
            const payout = parsed.args.payout as bigint;
            sellers.add(seller);
            sellVolumeWei += payout;
          }
        } catch (e) {
          console.warn("[fetchCampaignActivity] log scan failed", e);
        }

        return {
          buyers: buyers.size,
          sellers: sellers.size,
          buyVolumeWei,
          sellVolumeWei,
          fromBlock,
          toBlock: latest,
        };
      });
    },
    [getCampaignRead, getFromBlockForCampaign, readProvider]
  );

  const fetchCampaignSummary = useCallback(
    async (campaign: CampaignInfo): Promise<CampaignSummary> => {
      const metrics = await fetchCampaignMetrics(campaign.campaign);

      let holders = "";
      let volume = "";
      let marketCap = "";
      let marketCapBnb: number | undefined = undefined;

      // Activity rollups (safe + limited)
      try {
        const activity = await fetchCampaignActivity(campaign.campaign);
        if (activity) {
          holders = formatCount(activity.buyers);
          volume = formatBnbFromWei(activity.buyVolumeWei + activity.sellVolumeWei);
        }
      } catch (e) {
        console.warn("[fetchCampaignSummary] activity fetch failed", e);
      }

      // Market cap (derived): currentPrice * totalSupply
      try {
        if (metrics) {
          const token = new Contract(campaign.token, TOKEN_ABI, readProvider) as any;
const totalSupply: bigint = await token.totalSupply();

// During bonding, only *sold* tokens are circulating.
// The remaining supply is still held/reserved by the campaign (e.g., liquidity/creator allocations).
// After graduation (launched), we fall back to totalSupply as circulating if no DEX market cap is available.
const circulating: bigint = metrics.launched ? totalSupply : metrics.sold;

const mcWei = (metrics.currentPrice * circulating) / 10n ** 18n;
marketCap = formatBnbFromWei(mcWei);
// Also return an unrounded numeric value for consistent USD conversion on the carousel.
try {
  const mcBnbRaw = Number(ethers.formatEther(mcWei));
  if (Number.isFinite(mcBnbRaw) && mcBnbRaw > 0) marketCapBnb = mcBnbRaw;
} catch {
  // ignore
}
        }
      } catch (e) {
        console.warn("[fetchCampaignSummary] market cap calc failed", e);
      }

      return { campaign, metrics, stats: { holders, volume, marketCap, marketCapBnb } };
    },
    [fetchCampaignActivity, fetchCampaignMetrics, readProvider]
  );

  const fetchCampaignCardStats = useCallback(
    async (campaign: CampaignInfo): Promise<CampaignCardStats> => {
      const summary = await fetchCampaignSummary(campaign);
      return summary.stats;
    },
    [fetchCampaignSummary]
  );

  // --- WRITES ---

  function emitTxConfirmed(detail: any) {
    try {
      if (typeof window === "undefined") return;
      window.dispatchEvent(new CustomEvent("upmeme:txConfirmed", { detail }));
    } catch {
      // non-fatal
    }
  }

  async function legacyGasOverrides(extra: any = {}) {
    // BSC (56/97) is legacy gas. Some RPCs log noisy errors for `eth_maxPriorityFeePerGas`.
    // Force a legacy tx by providing gasPrice and type=0 when available.
    try {
      const p: any = signer?.provider ?? walletProvider ?? readProvider;
      if (!p || typeof p.send !== "function") return extra;
      const gpHex = await p.send("eth_gasPrice", []);
      const gasPrice = gpHex ? BigInt(gpHex) : 0n;
      if (gasPrice > 0n) return { ...extra, gasPrice, type: 0 };
      return extra;
    } catch {
      return extra;
    }
  }

  const createCampaign = useCallback(
    async (params: {
      name: string;
      symbol: string;
      logoURI: string;
      xAccount: string;
      website: string;
      extraLink: string;
      initialBuyBnb?: string;
      basePriceWei?: bigint;
      priceSlopeWei?: bigint;
      graduationTargetWei?: bigint;
      lpReceiver?: string;
    }) => {

      const writer = getFactoryWrite();
      if (!writer) throw new Error("Wallet not connected");

      const basePriceWei = params.basePriceWei ?? 0n;
      const priceSlopeWei = params.priceSlopeWei ?? 0n;
      // Creator initial buy is now specified in BNB (exact value spent in the same tx).
      // This avoids huge "token count" inputs causing UX and quoting issues.
      const initialBuyBnbWei = (() => {
        const s = String(params.initialBuyBnb ?? "").trim();
        if (!s) return 0n;
        try {
          const v = ethers.parseEther(s);
          return v > 0n ? v : 0n;
        } catch {
          throw new Error("Invalid initial buy BNB amount");
        }
      })();

      const valueToSend = initialBuyBnbWei;

      const tx = await writer.createCampaign(
        {
        name: params.name,
        symbol: params.symbol,
        logoURI: params.logoURI,
        xAccount: params.xAccount,
        website: params.website,
        extraLink: params.extraLink,
        basePrice: basePriceWei,
        priceSlope: priceSlopeWei,
        graduationTarget: params.graduationTargetWei ?? 0n,
        lpReceiver: params.lpReceiver || ethers.ZeroAddress,
        initialBuyBnbWei: initialBuyBnbWei,
        },
        await legacyGasOverrides({ value: valueToSend })
      );

      const receipt = await tx.wait();
      emitTxConfirmed({ kind: "create", chainId: activeChainId, txHash: receipt?.hash ?? tx?.hash });
      return receipt;
    },
    [getFactoryWrite, getFactoryRead, activeChainId]
  );

  const buyTokens = useCallback(
    async (campaignAddress: string, amountWei: bigint, maxCostWei: bigint) => {

      if (!signer) throw new Error("Wallet not connected");
      const campaign = new Contract(campaignAddress, CAMPAIGN_ABI, signer) as any;

      const tx = await campaign.buyExactTokens(amountWei, maxCostWei, await legacyGasOverrides({ value: maxCostWei }));
      const receipt = await tx.wait();
      emitTxConfirmed({ kind: "buy", chainId: activeChainId, campaignAddress: campaignAddress.toLowerCase(), txHash: receipt?.hash ?? tx?.hash });
      return receipt;
    },
    [signer, activeChainId]
  );

  const sellTokens = useCallback(
    async (campaignAddress: string, amountWei: bigint, minAmountWei: bigint) => {

      if (!signer) throw new Error("Wallet not connected");
      const campaign = new Contract(campaignAddress, CAMPAIGN_ABI, signer) as any;

      const tx = await campaign.sellExactTokens(amountWei, minAmountWei, await legacyGasOverrides());
      const receipt = await tx.wait();
      emitTxConfirmed({ kind: "sell", chainId: activeChainId, campaignAddress: campaignAddress.toLowerCase(), txHash: receipt?.hash ?? tx?.hash });
      return receipt;
    },
    [signer, activeChainId]
  );

  const finalizeCampaign = useCallback(
    async (campaignAddress: string, minTokens: bigint, minBnb: bigint) => {

      if (!signer) throw new Error("Wallet not connected");
      const campaign = new Contract(campaignAddress, CAMPAIGN_ABI, signer) as any;

      const tx = await campaign.finalize(minTokens, minBnb, await legacyGasOverrides());
      const receipt = await tx.wait();
      emitTxConfirmed({ kind: "finalize", chainId: activeChainId, campaignAddress: campaignAddress.toLowerCase(), txHash: receipt?.hash ?? tx?.hash });
      return receipt;
    },
    [signer, activeChainId]
  );

  return {
    fetchCampaignsCount,
    fetchCampaignPage,
    fetchCampaigns,
    fetchCampaignLogoURI,
    fetchCampaignMetrics,
    fetchCampaignCardStats,
    fetchCampaignActivity,
    fetchCampaignSummary,
    createCampaign,
    buyTokens,
    sellTokens,
    finalizeCampaign,

    // keeping these around in case you need them later
    walletProvider,
    activeChainId,
    factoryAddress,
  };
}
</file>

<file path="frontend/src/lib/media.ts">
// Normalize token/campaign image URIs so they render correctly in browsers.
// Supports ipfs:// and ar:// in addition to http(s):// and relative paths.
export function resolveImageUri(uri?: string | null): string | undefined {
  const raw = String(uri ?? "").trim();
  if (!raw) return undefined;

  // Some backends store a bare CID (e.g. Qm..., bafy...) or "ipfs/<cid>/...".
  // Normalize those to a gateway URL so browsers can load them.
  const isLikelyCid = (s: string) =>
    /^Qm[1-9A-HJ-NP-Za-km-z]{44,}$/.test(s) || // CIDv0 base58btc
    /^b[a-z2-7]{20,}$/i.test(s); // CIDv1 base32-ish (bafy..., etc.)

  // ipfs/<cid>/<path>
  if (raw.startsWith("ipfs/")) {
    const p = raw.slice("ipfs/".length);
    return `https://cloudflare-ipfs.com/ipfs/${p}`;
  }

  // bare CID
  if (isLikelyCid(raw)) {
    return `https://cloudflare-ipfs.com/ipfs/${raw}`;
  }

  // ipfs://<cid>/<path> or ipfs://ipfs/<cid>/<path>
  if (raw.startsWith("ipfs://")) {
    let p = raw.slice("ipfs://".length);
    if (p.startsWith("ipfs/")) p = p.slice("ipfs/".length);
    // Use a public gateway. You can swap this later to your own gateway if desired.
    return `https://cloudflare-ipfs.com/ipfs/${p}`;
  }

  // ar://<txid>
  if (raw.startsWith("ar://")) {
    const tx = raw.slice("ar://".length);
    return `https://arweave.net/${tx}`;
  }

  // data URIs are fine
  if (raw.startsWith("data:")) return raw;

  // absolute URLs
  if (raw.startsWith("https://") || raw.startsWith("http://")) return raw;

  // relative URLs (e.g. /assets/..)
  if (raw.startsWith("/")) return raw;

  // Fall back: treat as relative (some CDNs give naked paths); callers can still choose placeholder
  return raw;
}
</file>

<file path="realtime-indexer/src/server.ts">
import express from "express";
import cors from "cors";
import { ENV } from "./env.js";
import { pool } from "./db.js";
import { ablyRest, tokenChannel, leagueChannel } from "./ably.js";
import { runIndexerOnce } from "./indexer.js";
import { startTelemetryReporter, type TelemetrySnapshot } from "./telemetry.js";
import type { Request, Response, NextFunction, RequestHandler } from "express";

const app = express();

// ---------------------------------------------------------------------------
// Minimal in-process metrics (safe to expose)
// ---------------------------------------------------------------------------
let reqCount1m = 0;
let errCount1m = 0;

setInterval(() => {
  reqCount1m = 0;
  errCount1m = 0;
}, 60_000);

app.use((req, res, next) => {
  reqCount1m++;
  res.on("finish", () => {
    if (res.statusCode >= 500) errCount1m++;
  });
  next();
});

const wrap =
  (fn: (req: Request, res: Response, next: NextFunction) => Promise<any>): RequestHandler =>
  (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };

const allowedOrigins = new Set([
  "http://localhost:5173",
  "http://localhost:3000",
  "https://upmeme.vercel.app",
  "https://meme-battles.vercel.app",
]);

function isAllowedOrigin(origin?: string) {
  if (!origin) return true; // allow non-browser (curl, server-to-server)
  if (allowedOrigins.has(origin)) return true;

  // Allow Vercel preview deployments for this project:
  // e.g. https://upmeme-git-somebranch-uptokendev.vercel.app
  // If you have a custom pattern, adjust as needed.
  try {
    const u = new URL(origin);
    const host = u.hostname.toLowerCase();
    if (host.endsWith(".vercel.app") && (host.includes("upmeme") || host.includes("meme-battles"))) {
      return true;
    }
    if (host.includes("meme-battles")) return true;
  } catch {
    // ignore invalid origin
  }

  return false;
}

app.use(
  cors({
    origin: (origin, cb) => {
      cb(null, isAllowedOrigin(origin));
    },
    credentials: false,
  })
);
app.options("*", cors());

// Extremely lightweight health (no DB). Safe for frequent monitoring.
app.get("/healthz", (_req, res) => {
  res.json({ ok: true });
});

app.get("/health", async (_req, res) => {
  try {
    const r = await pool.query("select 1 as ok");
    res.json({ ok: true, db: r.rows[0].ok });
  } catch (e: any) {
    res.status(500).json({ ok: false, error: e?.message || String(e) });
  }
});

/**
 * Ably token auth endpoint
 *
 * TokenDetails (per-campaign): /api/ably/token?chainId=97&campaign=0x...
 * League (global):             /api/ably/token?chainId=97&scope=league
 */
app.get("/api/ably/token", async (req, res) => {
  try {
    const chainId = Number(req.query.chainId || 97);
    const scope = String(req.query.scope || "token");

    if (scope === "league") {
      const channel = leagueChannel(chainId);
      const capability = { [channel]: ["subscribe"] };

      const tokenRequest = await ablyRest.auth.createTokenRequest({
        clientId: "public",
        capability: JSON.stringify(capability),
        ttl: 60 * 60 * 1000, // 1 hour
      });

      return res.json(tokenRequest);
    }

    const campaign = String(req.query.campaign || "").toLowerCase();
    if (!/^0x[a-f0-9]{40}$/.test(campaign)) {
      return res.status(400).json({ error: "Invalid campaign address" });
    }

    const channel = tokenChannel(chainId, campaign);
    const capability = { [channel]: ["subscribe"] };

    const tokenRequest = await ablyRest.auth.createTokenRequest({
      // IMPORTANT: clientId MUST be stable across re-auth on an existing connection.
      // Using a random clientId triggers Ably 40102 (mismatched clientId).
      clientId: "public",
      capability: JSON.stringify(capability),
      ttl: 60 * 60 * 1000, // 1 hour
    });

    return res.json(tokenRequest);
  } catch (e: any) {
    return res.status(500).json({ error: e?.message || String(e) });
  }
});

// ---------------------------------------------------------------------------
// Profile Activity (v1)
// ---------------------------------------------------------------------------
// Trades activity (bonding curve buys/sells) for a wallet.
// GET /api/activity/trades?chainId=97&address=0x...&limit=50&cursor=BLOCK:LOG
app.get("/api/activity/trades", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const address = String(req.query.address || "").trim().toLowerCase();
  const limit = Math.min(Number(req.query.limit || 50), 200);
  const cursorRaw = String(req.query.cursor || "").trim();

  if (!Number.isFinite(chainId)) {
    return res.status(400).json({ error: "Invalid chainId" });
  }
  if (!/^0x[a-f0-9]{40}$/.test(address)) {
    return res.status(400).json({ error: "Invalid address" });
  }

  let cursorBlock: number | null = null;
  let cursorLog: number | null = null;
  if (cursorRaw) {
    const parts = cursorRaw.split(":");
    const b = Number(parts[0]);
    const l = Number(parts[1]);
    if (Number.isFinite(b) && Number.isFinite(l)) {
      cursorBlock = b;
      cursorLog = l;
    }
  }

  const params: any[] = [chainId, address];
  let whereCursor = "";
  if (cursorBlock != null && cursorLog != null) {
    params.push(cursorBlock, cursorLog);
    whereCursor = "and (t.block_number < $3 or (t.block_number = $3 and t.log_index < $4))";
  }

  params.push(limit);

  const r = await pool.query(
    `select
       t.tx_hash,
       t.log_index,
       t.block_number,
       t.block_time,
       t.side,
       t.wallet,
       t.token_amount,
       t.bnb_amount,
       t.price_bnb,
       t.campaign_address,
       c.name,
       c.symbol,
       c.logo_uri
     from public.curve_trades t
     left join public.campaigns c
       on c.chain_id = t.chain_id
      and c.campaign_address = t.campaign_address
     where t.chain_id = $1
       and t.wallet = $2
       ${whereCursor}
     order by t.block_number desc, t.log_index desc
     limit $${params.length}`,
    params
  );

  const items = (r.rows || []).map((row: any) => ({
    id: `${row.tx_hash}:${row.log_index}`,
    txHash: row.tx_hash,
    logIndex: Number(row.log_index),
    blockNumber: Number(row.block_number),
    blockTime: row.block_time,
    side: row.side,
    wallet: row.wallet,
    tokenAmount: row.token_amount,
    bnbAmount: row.bnb_amount,
    priceBnb: row.price_bnb,
    campaignAddress: row.campaign_address,
    campaignName: row.name ?? null,
    campaignSymbol: row.symbol ?? null,
    logoUri: row.logo_uri ?? null,
  }));

  const last = items[items.length - 1];
  const nextCursor = last ? `${last.blockNumber}:${last.logIndex}` : null;

  res.json({ items, nextCursor });
}));

// Comments activity for a wallet (authored comments).
// GET /api/activity/comments?chainId=97&address=0x...&limit=50&cursor=TS:ID
app.get("/api/activity/comments", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const address = String(req.query.address || "").trim().toLowerCase();
  const limit = Math.min(Number(req.query.limit || 50), 200);
  const cursorRaw = String(req.query.cursor || "").trim();

  if (!Number.isFinite(chainId)) {
    return res.status(400).json({ error: "Invalid chainId" });
  }
  if (!/^0x[a-f0-9]{40}$/.test(address)) {
    return res.status(400).json({ error: "Invalid address" });
  }

  let cursorTs: Date | null = null;
  let cursorId: number | null = null;
  if (cursorRaw) {
    const parts = cursorRaw.split(":");
    const ts = Number(parts[0]);
    const id = Number(parts[1]);
    if (Number.isFinite(ts) && Number.isFinite(id)) {
      cursorTs = new Date(ts * 1000);
      cursorId = id;
    }
  }

  const params: any[] = [chainId, address];
  let whereCursor = "";
  if (cursorTs && cursorId != null) {
    params.push(cursorTs, cursorId);
    whereCursor = "and (c.created_at < $3 or (c.created_at = $3 and c.id < $4))";
  }

  params.push(limit);

  const r = await pool.query(
    `select
       c.id,
       c.campaign_address,
       c.token_address,
       c.author_address,
       c.body,
       c.parent_id,
       c.created_at,
       camp.name,
       camp.symbol,
       camp.logo_uri
     from public.token_comments c
     left join public.campaigns camp
       on camp.chain_id = c.chain_id
      and camp.campaign_address = c.campaign_address
     where c.chain_id = $1
       and c.author_address = $2
       and c.status = 0
       ${whereCursor}
     order by c.created_at desc, c.id desc
     limit $${params.length}`,
    params
  );

  const items = (r.rows || []).map((row: any) => ({
    id: Number(row.id),
    campaignAddress: row.campaign_address,
    tokenAddress: row.token_address,
    authorAddress: row.author_address,
    body: row.body,
    parentId: row.parent_id,
    createdAt: row.created_at,
    campaignName: row.name ?? null,
    campaignSymbol: row.symbol ?? null,
    logoUri: row.logo_uri ?? null,
  }));

  const last = items[items.length - 1];
  const nextCursor = last
    ? `${Math.floor(new Date(last.createdAt).getTime() / 1000)}:${last.id}`
    : null;

  res.json({ items, nextCursor });
}));

// Created campaigns for a wallet.
// GET /api/activity/created?chainId=97&address=0x...&limit=50&cursor=TS:ADDR
app.get("/api/activity/created", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const address = String(req.query.address || "").trim().toLowerCase();
  const limit = Math.min(Number(req.query.limit || 50), 200);
  const cursorRaw = String(req.query.cursor || "").trim();

  if (!Number.isFinite(chainId)) {
    return res.status(400).json({ error: "Invalid chainId" });
  }
  if (!/^0x[a-f0-9]{40}$/.test(address)) {
    return res.status(400).json({ error: "Invalid address" });
  }

  let cursorTs: Date | null = null;
  let cursorAddr: string | null = null;
  if (cursorRaw) {
    const parts = cursorRaw.split(":");
    const ts = Number(parts[0]);
    const addr = String(parts[1] || "").toLowerCase();
    if (Number.isFinite(ts) && /^0x[a-f0-9]{40}$/.test(addr)) {
      cursorTs = new Date(ts * 1000);
      cursorAddr = addr;
    }
  }

  const params: any[] = [chainId, address];
  let whereCursor = "";
  if (cursorTs && cursorAddr) {
    params.push(cursorTs, cursorAddr);
    whereCursor = `and (
      coalesce(c.created_at_chain, c.created_at) < $3
      or (coalesce(c.created_at_chain, c.created_at) = $3 and c.campaign_address < $4)
    )`;
  }

  params.push(limit);

  const r = await pool.query(
    `select
       c.campaign_address,
       c.token_address,
       c.name,
       c.symbol,
       c.logo_uri,
       c.created_at_chain,
       c.created_at
     from public.campaigns c
     where c.chain_id = $1
       and c.creator_address = $2
       ${whereCursor}
     order by coalesce(c.created_at_chain, c.created_at) desc, c.campaign_address desc
     limit $${params.length}`,
    params
  );

  const items = (r.rows || []).map((row: any) => ({
    campaignAddress: row.campaign_address,
    tokenAddress: row.token_address,
    name: row.name ?? null,
    symbol: row.symbol ?? null,
    logoUri: row.logo_uri ?? null,
    createdAt: row.created_at_chain ?? row.created_at ?? null,
  }));

  const last = items[items.length - 1];
  const lastTs = last?.createdAt ? Math.floor(new Date(last.createdAt).getTime() / 1000) : null;
  const nextCursor = last && lastTs ? `${lastTs}:${last.campaignAddress}` : null;

  res.json({ items, nextCursor });
}));

// Interactions (Upvotes) for a wallet.
// GET /api/activity/interactions?chainId=97&address=0x...&limit=50&cursor=BLOCK:LOG
app.get("/api/activity/interactions", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const address = String(req.query.address || "").trim().toLowerCase();
  const limit = Math.min(Number(req.query.limit || 50), 200);
  const cursorRaw = String(req.query.cursor || "").trim();

  if (!Number.isFinite(chainId)) {
    return res.status(400).json({ error: "Invalid chainId" });
  }
  if (!/^0x[a-f0-9]{40}$/.test(address)) {
    return res.status(400).json({ error: "Invalid address" });
  }

  let cursorBlock: number | null = null;
  let cursorLog: number | null = null;
  if (cursorRaw) {
    const parts = cursorRaw.split(":");
    const b = Number(parts[0]);
    const l = Number(parts[1]);
    if (Number.isFinite(b) && Number.isFinite(l)) {
      cursorBlock = b;
      cursorLog = l;
    }
  }

  const params: any[] = [chainId, address];
  let whereCursor = "";
  if (cursorBlock != null && cursorLog != null) {
    params.push(cursorBlock, cursorLog);
    whereCursor = "and (v.block_number < $3 or (v.block_number = $3 and v.log_index < $4))";
  }

  params.push(limit);

  const r = await pool.query(
    `select
       v.tx_hash,
       v.log_index,
       v.block_number,
       v.block_timestamp,
       v.campaign_address,
       v.voter_address,
       v.asset_address,
       v.amount_raw,
       v.meta,
       c.name,
       c.symbol,
       c.logo_uri
     from public.votes v
     left join public.campaigns c
       on c.chain_id = v.chain_id
      and c.campaign_address = v.campaign_address
     where v.chain_id = $1
       and v.voter_address = $2
       and v.status = 'confirmed'
       ${whereCursor}
     order by v.block_number desc, v.log_index desc
     limit $${params.length}`,
    params
  );

  const items = (r.rows || []).map((row: any) => ({
    id: `${row.tx_hash}:${row.log_index}`,
    txHash: row.tx_hash,
    logIndex: Number(row.log_index),
    blockNumber: Number(row.block_number),
    blockTime: row.block_timestamp,
    campaignAddress: row.campaign_address,
    voterAddress: row.voter_address,
    assetAddress: row.asset_address,
    amountRaw: row.amount_raw,
    meta: row.meta,
    campaignName: row.name ?? null,
    campaignSymbol: row.symbol ?? null,
    logoUri: row.logo_uri ?? null,
    type: "upvote",
  }));

  const last = items[items.length - 1];
  const nextCursor = last ? `${last.blockNumber}:${last.logIndex}` : null;

  res.json({ items, nextCursor });
}));

/**
 * Snapshot endpoints for TokenDetails
 */
app.get("/api/token/:campaign/summary", wrap(async (req, res) => {
  const campaign = String(req.params.campaign || "").toLowerCase();
  const chainId = Number(req.query.chainId || 97);

  const r = await pool.query(
    `select * from public.token_stats where chain_id=$1 and campaign_address=$2`,
    [chainId, campaign]
  );
  res.json(r.rows[0] || null);
}));

app.get("/api/token/:campaign/trades", wrap(async (req, res) => {
  const campaign = String(req.params.campaign || "").toLowerCase();
  const chainId = Number(req.query.chainId || 97);
  const limit = Math.min(Number(req.query.limit || 50), 200);

  const r = await pool.query(
    `select
       tx_hash, log_index, block_number, block_time,
       side, wallet, token_amount, bnb_amount, price_bnb
     from public.curve_trades
     where chain_id=$1 and campaign_address=$2
     order by block_number desc, log_index desc
     limit $3`,
    [chainId, campaign, limit]
  );

  res.json(r.rows);
}));


// ---------------------------------------------
// UP Only League (objective leaderboards)
// ---------------------------------------------
// /api/league?chainId=97&category=straight_up|fastest_graduation|largest_buy&period=weekly|monthly|all_time&limit=50
app.get("/api/league", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const category = String(req.query.category || "fastest_graduation");
  const period = String(req.query.period || "weekly");
  const limit = Math.min(Number(req.query.limit || 50), 200);

  const periodFilterCampaign =
    period === "monthly"
      ? "c.graduated_at_chain >= date_trunc('month', now()) and c.graduated_at_chain < date_trunc('month', now()) + interval '1 month'"
      : period === "weekly"
      ? "c.graduated_at_chain >= date_trunc('week', now()) and c.graduated_at_chain < date_trunc('week', now()) + interval '1 week'"
      : "true";

  const periodFilterTrades =
    period === "monthly"
      ? "t.block_time >= date_trunc('month', now()) and t.block_time < date_trunc('month', now()) + interval '1 month'"
      : period === "weekly"
      ? "t.block_time >= date_trunc('week', now()) and t.block_time < date_trunc('week', now()) + interval '1 week'"
      : "true";

  if (category === "largest_buy") {
    // Largest single buy tx during bonding (measured in BNB, excludes creator/feeRecipient/campaign)
    const r = await pool.query(
      `select
         t.campaign_address,
         c.name,
         c.symbol,
         c.logo_uri,
         c.creator_address,
         c.fee_recipient_address,
         t.wallet as buyer_address,
         t.bnb_amount_raw as bnb_amount_raw,
         t.tx_hash,
         t.log_index,
         t.block_number,
         t.block_time
       from public.curve_trades t
       join public.campaigns c
         on c.chain_id=t.chain_id and c.campaign_address=t.campaign_address
       where t.chain_id=$1
         and t.side='buy'
         and ${periodFilterTrades}
         and lower(t.wallet) <> lower(c.creator_address)
         and (c.fee_recipient_address is null or lower(t.wallet) <> lower(c.fee_recipient_address))
         and lower(t.wallet) <> lower(c.campaign_address)
       order by (t.bnb_amount_raw::numeric) desc, t.block_number desc, t.log_index desc
       limit $2`,
      [chainId, limit]
    );

    return res.json({ chainId, category, period, items: r.rows });
  }

  const requireUniqueBuyers = category === "fastest_graduation";
  const extra: string[] = [];
  if (requireUniqueBuyers) extra.push("coalesce(s.unique_buyers,0) >= 25");
  if (category === "straight_up") extra.push("coalesce(s.sells_count,0) = 0");
  const extraWhere = extra.length ? `and ${extra.join(" and ")}` : "";

  const r = await pool.query(
    `with stats as (
       select
         t.chain_id,
         t.campaign_address,
         count(distinct case when t.side='buy' then t.wallet end) as unique_buyers,
         sum(case when t.side='sell' then 1 else 0 end) as sells_count,
         sum(case when t.side='buy' then (t.bnb_amount_raw::numeric) else 0 end) as buy_volume_raw
       from public.curve_trades t
       where t.chain_id=$1
       group by t.chain_id, t.campaign_address
     )
     select
       c.campaign_address,
       c.creator_address,
       c.fee_recipient_address,
       c.token_address,
       c.name,
       c.symbol,
       c.logo_uri,
       c.created_at_chain,
       c.graduated_at_chain,
       c.graduated_block,
       coalesce(s.unique_buyers,0)::int as unique_buyers,
       coalesce(s.sells_count,0)::int as sells_count,
       coalesce(s.buy_volume_raw,0)::text as buy_volume_raw,
       extract(epoch from (c.graduated_at_chain - c.created_at_chain))::bigint as duration_seconds
     from public.campaigns c
     left join stats s
       on s.chain_id=c.chain_id and s.campaign_address=c.campaign_address
     where c.chain_id=$1
       and c.created_at_chain is not null
       and c.graduated_at_chain is not null
       and ${periodFilterCampaign}
       ${extraWhere}
     order by duration_seconds asc nulls last, c.graduated_at_chain asc
     limit $2`,
    [chainId, limit]
  );

  return res.json({ chainId, category, period, items: r.rows });
}));

app.get("/api/token/:campaign/candles", wrap(async (req, res) => {
  const campaign = String(req.params.campaign || "").toLowerCase();
  const chainId = Number(req.query.chainId || 97);
  const tf = String(req.query.tf || "5s");
  const limit = Math.min(Number(req.query.limit || 200), 2000);

  const r = await pool.query(
    `select bucket_start, o,h,l,c,volume_bnb,trades_count
     from public.token_candles
     where chain_id=$1 and campaign_address=$2 and timeframe=$3
     order by bucket_start desc
     limit $4`,
    [chainId, campaign, tf, limit]
  );

  res.json(r.rows.reverse());
}));

// ---------------------------------------------
// Votes + Featured
// ---------------------------------------------

// /api/votes?chainId=97&campaignAddress=0x..&voter=0x..&limit=50
app.get("/api/votes", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const campaign = String(req.query.campaignAddress || "").toLowerCase();
  const voter = String(req.query.voter || "").toLowerCase();
  const limit = Math.min(Number(req.query.limit || 50), 200);

  const where: string[] = ["chain_id=$1", "status='confirmed'"];
  const params: any[] = [chainId];
  let p = 2;

  if (campaign) {
    where.push(`campaign_address=$${p++}`);
    params.push(campaign);
  }
  if (voter) {
    where.push(`voter_address=$${p++}`);
    params.push(voter);
  }

  const r = await pool.query(
    `select
       chain_id,campaign_address,voter_address,asset_address,amount_raw,
       tx_hash,log_index,block_number,block_timestamp,meta
     from public.votes
     where ${where.join(" and ")}
     order by block_number desc, log_index desc
     limit $${p}`,
    [...params, limit]
  );

  res.json(r.rows);
}));

// /api/featured?chainId=97&sort=trending|24h|7d|all&limit=50
app.get("/api/featured", wrap(async (req, res) => {
  const chainId = Number(req.query.chainId || 97);
  const sort = String(req.query.sort || "trending");
  const limit = Math.min(Number(req.query.limit || 50), 200);

  const orderBy =
    sort === "24h" ? "votes_24h desc" :
    sort === "7d" ? "votes_7d desc" :
    sort === "all" ? "votes_all_time desc" :
    "trending_score desc";

  const r = await pool.query(
    `select
       chain_id,campaign_address,
       votes_1h,votes_24h,votes_7d,votes_all_time,
       trending_score,last_vote_at,updated_at
     from public.vote_aggregates
     where chain_id=$1
     order by ${orderBy}, campaign_address asc
     limit $2`,
    [chainId, limit]
  );

  res.json(r.rows);
}));
app.use((err: any, _req: any, res: any, _next: any) => {
  console.error("API error:", err);
  res.status(500).json({ ok: false, error: err?.message || String(err) });
});
// Start server (Railway requires 0.0.0.0:PORT) :contentReference[oaicite:1]{index=1}
app.listen(ENV.PORT, "0.0.0.0", () => {
  console.log(`realtime-indexer listening on 0.0.0.0:${ENV.PORT}`);
});

// ---------------------------------------------------------------------------
// Telemetry snapshot (optional)
// ---------------------------------------------------------------------------
let lastIndexerRunAt = 0;
let lastIndexerErrorAt = 0;
let lastIndexerErrorMsg: string | null = null;

async function getLastIndexedBlock(chainId: number): Promise<number | null> {
  try {
    const r = await pool.query(
      `select cursor,last_indexed_block from public.indexer_state where chain_id=$1 and cursor in ('factory','votes')`,
      [chainId]
    );
    if (!r.rowCount) return null;
    // Conservative: take min of known cursors so lag isn't understated
    const vals = r.rows.map((x: any) => Number(x.last_indexed_block)).filter((n: any) => Number.isFinite(n));
    if (!vals.length) return null;
    return Math.min(...vals);
  } catch {
    return null;
  }
}

async function getRpcHeadBlock(): Promise<number | null> {
  const first = String(ENV.BSC_RPC_HTTP_97 || "")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean)[0];
  if (!first) return null;
  try {
    const body = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
    const resp = await fetch(first, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!resp.ok) return null;
    const j: any = await resp.json();
    const hex = j?.result;
    if (typeof hex !== "string" || !hex.startsWith("0x")) return null;
    return parseInt(hex, 16);
  } catch {
    return null;
  }
}

startTelemetryReporter(async () => {
  const ts = Math.floor(Date.now() / 1000);
  const head = await getRpcHeadBlock();
  const last = await getLastIndexedBlock(97);
  const lag = head != null && last != null ? Math.max(0, head - last) : null;

  const snap: TelemetrySnapshot = {
    service: "realtime-indexer",
    ts,
    ok: true,
    rps_1m: reqCount1m / 60,
    errors_1m: errCount1m,
    head_block: head ?? undefined,
    last_indexed_block: last ?? undefined,
    lag_blocks: lag ?? undefined,
    last_indexer_run_ms_ago: lastIndexerRunAt ? Date.now() - lastIndexerRunAt : undefined,
    last_indexer_error_ms_ago: lastIndexerErrorAt ? Date.now() - lastIndexerErrorAt : undefined,
  };

  // If we have a recent error, mark ok=false but keep reporting.
  if (lastIndexerErrorAt && Date.now() - lastIndexerErrorAt < 5 * 60_000) {
    snap.ok = false;
  }

  return snap;
});

// Indexer loop
// NOTE: Keep this conservative for public RPCs. We also avoid overlap.
let running = false;
const INTERVAL_MS = ENV.INDEXER_INTERVAL_MS;

setInterval(async () => {
  if (running) return;
  running = true;
  try {
    lastIndexerRunAt = Date.now();
    await runIndexerOnce();
  } catch (e) {
    console.error("indexer loop error", e);
    lastIndexerErrorAt = Date.now();
    lastIndexerErrorMsg = String((e as any)?.message || e);
  } finally {
    running = false;
  }
}, INTERVAL_MS);
</file>

<file path="frontend/api/campaigns.js">
import { pool } from "../server/db.js";
import { badMethod, getQuery, json } from "../server/http.js";

// LaunchFactory default graduation target is 50 BNB (see contracts/LaunchFactory.sol).
// Campaigns can override this, but until we persist per-campaign targets in DB,
// we treat this as the system default for progress/ETA on the homepage.
const DEFAULT_GRAD_TARGET_BNB = 50;

function toInt(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? Math.trunc(n) : fallback;
}

function toFloat(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}

function normalizeTab(v) {
  const t = String(v || "trending").toLowerCase();
  return t === "new" || t === "ending" || t === "dex" ? t : "trending";
}

function normalizeSort(v) {
  const s = String(v || "default").toLowerCase();
  return [
    "default",
    "created_desc",
    "created_asc",
    "mcap_desc",
    "mcap_asc",
    "votes_desc",
    "progress_desc",
  ].includes(s)
    ? s
    : "default";
}

function normalizeStatus(v) {
  const s = String(v || "all").toLowerCase();
  return s === "live" || s === "graduated" || s === "ended" ? s : "all";
}

export default async function handler(req, res) {
  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);

    const chainId = toInt(q.chainId, 97);
    const limit = clamp(toInt(q.limit, 24), 1, 50);
    const cursor = clamp(toInt(q.cursor, 0), 0, 1_000_000); // offset-based pagination

    const tab = normalizeTab(q.tab);
    const sort = normalizeSort(q.sort);
    const status = normalizeStatus(q.status);

    // Contract rule:
    // - /api/campaigns defaults to "all"
    // - "Ending Soon" is always Live-only
    // - "Trading on DEX" is always Graduated-only
    const effectiveStatus =
      tab === "ending" ? "live" : tab === "dex" ? "graduated" : status;
    const searchRaw = String(q.search || "").trim();
    const search = searchRaw ? `%${searchRaw}%` : null;

    // Optional filters
    const bnbUsd = Number.isFinite(Number(q.bnbUsd)) ? toFloat(q.bnbUsd, NaN) : null;
    const mcapMinUsd = Number.isFinite(Number(q.mcapMinUsd)) ? toFloat(q.mcapMinUsd, NaN) : null;
    const mcapMaxUsd = Number.isFinite(Number(q.mcapMaxUsd)) ? toFloat(q.mcapMaxUsd, NaN) : null;
    const progressMinPct = Number.isFinite(Number(q.progressMinPct)) ? toFloat(q.progressMinPct, NaN) : null;
    const progressMaxPct = Number.isFinite(Number(q.progressMaxPct)) ? toFloat(q.progressMaxPct, NaN) : null;

    const gradTargetBnb = clamp(toFloat(q.gradTargetBnb, DEFAULT_GRAD_TARGET_BNB), 0.0001, 10_000);

    // Deterministic ordering per tab/sort.
    // IMPORTANT: the outer query selects from the CTE `calc`.
    // So ORDER BY must only reference columns available on `calc`.
    const orderBy = (() => {
      if (sort === "created_desc") return "calc.created_block desc, calc.campaign_address asc";
      if (sort === "created_asc") return "calc.created_block asc, calc.campaign_address asc";
      if (sort === "mcap_desc") return "coalesce(calc.marketcap_bnb, 0) desc, calc.created_block desc, calc.campaign_address asc";
      if (sort === "mcap_asc") return "coalesce(calc.marketcap_bnb, 0) asc, calc.created_block desc, calc.campaign_address asc";
      if (sort === "votes_desc") return "coalesce(calc.votes_24h, 0) desc, calc.created_block desc, calc.campaign_address asc";
      if (sort === "progress_desc") return "coalesce(calc.progress_pct, -1) desc, calc.created_block desc, calc.campaign_address asc";

      // Tab defaults
      if (tab === "new") return "calc.created_block desc, calc.campaign_address asc";
      if (tab === "ending")
        return "calc.eta_sec asc nulls last, calc.progress_pct desc nulls last, calc.created_block desc, calc.campaign_address asc";
      if (tab === "dex") return "calc.graduated_block desc nulls last, calc.created_block desc, calc.campaign_address asc";

      // trending default
      return "calc.trending_score desc nulls last, calc.created_block desc, calc.campaign_address asc";
    })();

    const sql = `
      with base as (
        select
          c.chain_id,
          c.campaign_address,
          c.token_address,
          c.creator_address,
          c.name,
          c.symbol,
          c.logo_uri,
          c.created_block,
          c.created_at_chain,
          c.graduated_block,
          c.graduated_at_chain,
          c.is_active,
          ts.last_price_bnb,
          ts.sold_tokens,
          ts.marketcap_bnb,
          ts.vol_24h_bnb,
          va.votes_24h,
          va.votes_all_time
        from public.campaigns c
        left join public.token_stats ts
          on ts.chain_id = c.chain_id and ts.campaign_address = c.campaign_address
        left join public.vote_aggregates va
          on va.chain_id = c.chain_id and va.campaign_address = c.campaign_address
        where c.chain_id = $1
          and ($3::text is null or (
            c.name ilike $3
            or c.symbol ilike $3
            or c.campaign_address::text ilike $3
          ))
          and (
            $4::text = 'all'
            or ($4::text = 'live' and c.is_active = true)
            or ($4::text = 'graduated' and c.graduated_at_chain is not null)
            or ($4::text = 'ended' and c.is_active = false and c.graduated_at_chain is null)
          )
          and (
            $5::text <> 'dex'
            or c.graduated_at_chain is not null
          )
      ),
      rt as (
        select
          b.chain_id,
          b.campaign_address,
          coalesce(
            sum(case when t.side = 'buy' then t.bnb_amount else -t.bnb_amount end)
            ,0
          ) as raised_total_bnb,
          coalesce(
            sum(case when t.side = 'buy' then t.bnb_amount else -t.bnb_amount end)
              filter (where t.block_time >= now() - interval '10 minutes')
            ,0
          ) as raised_10m_bnb
        from base b
        left join public.curve_trades t
          on t.chain_id = b.chain_id and t.campaign_address = b.campaign_address
        group by b.chain_id, b.campaign_address
      ),
      calc as (
        select
          b.*,
          rt.raised_total_bnb,
          rt.raised_10m_bnb,
          case
            when $2::numeric <= 0 then null
            else least(100, greatest(0, (rt.raised_total_bnb / $2::numeric) * 100))
          end as progress_pct,
          case
            when rt.raised_total_bnb >= $2::numeric then 0
            when rt.raised_10m_bnb <= 0 then null
            else (
              ($2::numeric - rt.raised_total_bnb)
              / (rt.raised_10m_bnb / 600.0)
            )
          end as eta_sec,
          (
            coalesce(b.vol_24h_bnb, 0) * 1000
            + coalesce(b.votes_24h, 0) * 10
          ) as trending_score
        from base b
        join rt
          on rt.chain_id = b.chain_id and rt.campaign_address = b.campaign_address
      )
      select *
      from calc
      where 1=1
        and (
          $9::numeric is null
          or calc.progress_pct >= $9::numeric
        )
        and (
          $10::numeric is null
          or calc.progress_pct <= $10::numeric
        )
        and (
          $6::numeric is null
          or $7::numeric is null
          or (calc.marketcap_bnb is not null and (calc.marketcap_bnb * $6::numeric) >= $7::numeric)
        )
        and (
          $6::numeric is null
          or $8::numeric is null
          or (calc.marketcap_bnb is not null and (calc.marketcap_bnb * $6::numeric) <= $8::numeric)
        )
      order by ${orderBy}
      offset $11
      limit $12
    `;

    const r = await pool.query(sql, [
      chainId,
      gradTargetBnb,
      search,
      effectiveStatus,
      tab,
      bnbUsd,
      mcapMinUsd,
      mcapMaxUsd,
      progressMinPct,
      progressMaxPct,
      cursor,
      limit,
    ]);

    const items = (r.rows || []).map((row) => {
      const campaignAddress = String(row.campaign_address ?? "").toLowerCase();
      const graduatedAt = row.graduated_at_chain ? String(row.graduated_at_chain) : null;

      return {
        chainId: Number(row.chain_id),
        campaignAddress,
        tokenAddress: row.token_address ? String(row.token_address).toLowerCase() : null,
        creatorAddress: row.creator_address ? String(row.creator_address).toLowerCase() : null,
        name: row.name ?? null,
        symbol: row.symbol ?? null,
        logoUri: row.logo_uri ?? null,
        createdAtChain: row.created_at_chain ? String(row.created_at_chain) : null,
        graduatedAtChain: graduatedAt,
        isDexTrading: Boolean(graduatedAt),

        // canonical status (useful for UI)
        isActive: Boolean(row.is_active),
        status: graduatedAt ? "graduated" : row.is_active ? "live" : "ended",

        // stats
        lastPriceBnb: row.last_price_bnb != null ? String(row.last_price_bnb) : null,
        soldTokens: row.sold_tokens != null ? String(row.sold_tokens) : null,
        marketcapBnb: row.marketcap_bnb != null ? String(row.marketcap_bnb) : null,
        vol24hBnb: row.vol_24h_bnb != null ? String(row.vol_24h_bnb) : null,
        votes24h: row.votes_24h != null ? Number(row.votes_24h) : 0,
        votesAllTime: row.votes_all_time != null ? Number(row.votes_all_time) : 0,

        // derived
        raisedTotalBnb: row.raised_total_bnb != null ? String(row.raised_total_bnb) : "0",
        raised10mBnb: row.raised_10m_bnb != null ? String(row.raised_10m_bnb) : "0",
        progressPct: row.progress_pct != null ? Number(row.progress_pct) : null,
        etaSec: row.eta_sec != null ? Number(row.eta_sec) : null,
        gradTargetBnb,
      };
    });

    const nextCursor = items.length === limit ? cursor + limit : null;

    return json(res, 200, {
      items,
      nextCursor,
      pageSize: limit,
      updatedAt: new Date().toISOString(),
    });
  } catch (e) {
    console.error("[api/campaigns]", e);
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/src/components/LoadingScreen.tsx">
/**
 * Loading Screen Component
 * Displays an animated loading screen with space background and logo
 * Automatically transitions out after the specified minimum load time
 */

import { useEffect, useState } from "react";
import { SpaceBackground } from "@/components/ui/space-background";

// NOTE:
// Use the public logo so there's exactly one source of truth with the header logo.
// The query string helps bust aggressive caching.
const LOADING_LOGO_SRC = "/assets/logo.png?v=mb1";

interface LoadingScreenProps {
  onLoadComplete?: () => void;
  minLoadTime?: number;
}

export const LoadingScreen = ({ onLoadComplete, minLoadTime = 2000 }: LoadingScreenProps) => {
  const [isVisible, setIsVisible] = useState(true);
  const [isExiting, setIsExiting] = useState(false);

  useEffect(() => {
    const exitTimer = setTimeout(() => {
      setIsExiting(true);
    }, minLoadTime - 800); // Start exit animation 800ms before complete

    const completeTimer = setTimeout(() => {
      setIsVisible(false);
      if (onLoadComplete) {
        onLoadComplete();
      }
    }, minLoadTime);

    return () => {
      clearTimeout(exitTimer);
      clearTimeout(completeTimer);
    };
  }, [minLoadTime, onLoadComplete]);

  if (!isVisible) return null;

  return (
    <div 
      className={`fixed inset-0 z-[100] flex items-center justify-center bg-background transition-all duration-700 ${
        isExiting ? "opacity-0 scale-110" : "opacity-100 scale-100"
      }`}
    >
      <SpaceBackground 
        particleCount={450} 
        particleColor="rgba(175, 127, 35, 0.8)"
        backgroundColor="hsl(var(--background))"
      />
      
      <div 
        className={`relative z-10 text-center transition-all duration-700 ${
          isExiting ? "opacity-0 scale-150 blur-xl" : "opacity-100 scale-100 blur-0 animate-fade-in"
        }`}
      >
        <div className="animate-pulse">
          <img 
            src={LOADING_LOGO_SRC} 
            alt="Launchpad Logo" 
            className="h-48 w-48 mx-auto object-contain drop-shadow-[0_0_40px_rgba(175,254,0,0.6)]"
          />
        </div>
      </div>
    </div>
  );
};
</file>

<file path="frontend/src/hooks/useLeagueRealtime.ts">
import { useEffect, useMemo, useRef, useState } from "react";
import { useAblyLeagueChannel } from "./useAblyLeagueChannel";

export type LeaguePatch = {
  campaignAddress: string; // lowercase
  lastPriceBnb?: string | null;
  marketcapBnb?: string | null;
  vol24hBnb?: string | null;
  votes24h?: number;
  votesAllTime?: number;
  trendingScore?: string | null;
  raisedTotalBnb?: string | null;
  ts?: number;
};

export type LeagueCampaignCreated = {
  campaignAddress: string; // lowercase
  tokenAddress?: string | null;
  creatorAddress?: string | null;
  name?: string | null;
  symbol?: string | null;
  createdAtChain?: string | null;
  blockNumber?: number | null;
};

type PatchMsg = {
  type: "campaign_patch";
  chainId: number;
  ts: number;
  items: LeaguePatch[];
};

type CampaignCreatedMsg = {
  type: "campaign_created";
  chainId: number;
  ts: number;
  item: LeagueCampaignCreated;
};

type Opts = {
  enabled: boolean;
  chainId: number;

  /**
   * Called only when realtime is NOT connected.
   * Use it to trigger a single lightweight REST refresh of Home data.
   */
  onFallbackRefresh?: () => void;

  /**
   * Default 25s. Keep it >= 20s to avoid hammering.
   */
  fallbackMs?: number;
};

export function useLeagueRealtime(opts: Opts) {
  const { enabled, chainId, onFallbackRefresh, fallbackMs } = opts;

  const { channel, ready, isConnected } = useAblyLeagueChannel({ enabled, chainId });

  const [patchByCampaign, setPatchByCampaign] = useState<Record<string, LeaguePatch>>({});
  const [created, setCreated] = useState<LeagueCampaignCreated[]>([]);

  // Buffer updates to avoid render storms. Flush at 500ms (requested).
  const pendingPatchRef = useRef<Record<string, LeaguePatch>>({});
  const pendingCreatedRef = useRef<LeagueCampaignCreated[]>([]);

  // --- realtime subscription (campaign_patch) ---
  useEffect(() => {
    if (!ready || !channel) return;

    const onPatch = (msg: any) => {
      const data = (msg?.data ?? null) as PatchMsg | null;
      if (!data || data.type !== "campaign_patch" || !Array.isArray(data.items)) return;

      const buf = pendingPatchRef.current;
      for (const it of data.items) {
        const addr = String(it?.campaignAddress ?? "").toLowerCase();
        if (!addr) continue;
        const prev = buf[addr] ?? { campaignAddress: addr };
        buf[addr] = { ...prev, ...it, campaignAddress: addr, ts: data.ts };
      }
    };

    const onCreated = (msg: any) => {
      const data = (msg?.data ?? null) as CampaignCreatedMsg | null;
      if (!data || data.type !== "campaign_created" || !data.item) return;
      const addr = String((data.item as any).campaignAddress ?? "").toLowerCase();
      if (!addr) return;
      pendingCreatedRef.current.push({ ...data.item, campaignAddress: addr });
    };

    channel.subscribe("campaign_patch", onPatch);
    channel.subscribe("campaign_created", onCreated);

    const flushId = setInterval(() => {
      // Flush patches
      const buf = pendingPatchRef.current;
      const keys = Object.keys(buf);
      if (keys.length) {
        setPatchByCampaign((prev) => {
          const next = { ...prev };
          for (const k of keys) {
            const it = buf[k];
            next[k] = { ...(next[k] ?? { campaignAddress: k }), ...it, campaignAddress: k };
          }
          return next;
        });
        pendingPatchRef.current = {};
      }

      // Flush created campaigns
      const createdBatch = pendingCreatedRef.current;
      if (createdBatch.length) {
        setCreated((prev) => {
          // keep last 50 created announcements (UI consumption only)
          const next = [...createdBatch, ...prev];
          return next.slice(0, 50);
        });
        pendingCreatedRef.current = [];
      }
    }, 500);

    return () => {
      clearInterval(flushId);
      try {
        channel.unsubscribe("campaign_patch", onPatch);
      } catch {}
      try {
        channel.unsubscribe("campaign_created", onCreated);
      } catch {}
    };
  }, [ready, channel]);

  // --- self-heal: fallback refresh when disconnected ---
  const timerRef = useRef<any>(null);
  const lastRefreshRef = useRef<number>(0);

  useEffect(() => {
    const intervalMs = Math.max(20000, Number(fallbackMs ?? 25000));

    // stop timer if realtime connected or no callback
    if (!enabled || isConnected || !onFallbackRefresh) {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
      return;
    }

    // start (or keep) timer while disconnected
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        const now = Date.now();
        // safety: ensure no accidental tight loop
        if (now - lastRefreshRef.current < intervalMs - 250) return;
        lastRefreshRef.current = now;

        try {
          onFallbackRefresh();
        } catch {
          // ignore
        }
      }, intervalMs);
    }

    // trigger an immediate refresh once when we first notice disconnect
    const now = Date.now();
    if (now - lastRefreshRef.current > 1000) {
      lastRefreshRef.current = now;
      try {
        onFallbackRefresh();
      } catch {
        // ignore
      }
    }

    return () => {
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [enabled, isConnected, onFallbackRefresh, fallbackMs]);

  return useMemo(() => ({ patchByCampaign, created, isConnected }), [patchByCampaign, created, isConnected]);
}
</file>

<file path="frontend/src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom Fonts */
@font-face {
  font-family: 'Pixeboy';
  src: url('/fonts/Pixeboy.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Definition of the design system. All colors, gradients, fonts, etc should be defined here. 
All colors MUST be HSL.
*/

@layer base {
  :root {
    /* Pure black app canvas */
    --background: 0 0% 0%;
    --foreground: 0 0% 98%;

    --card: 0 0% 8%;
    --card-foreground: 0 0% 98%;

    --popover: 0 0% 5%;
    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 15%;
    --primary-foreground: 0 0% 98%;

    --secondary: 0 0% 10%;
    --secondary-foreground: 0 0% 98%;

    --muted: 0 0% 12%;
    --muted-foreground: 0 0% 65%;

    /* brand = #af7f23 */
    --accent: 39.43 66.67% 41.18%;
    --accent-foreground: 0 0% 3%;

    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 98%;

    --success: 142 76% 36%;
    --success-foreground: 0 0% 98%;

    --border: 0 0% 15%;
    --input: 0 0% 12%;
    --ring: 39.43 66.67% 41.18%;

    --radius: 0.75rem;

    --glow-primary: 0 0% 15%;
    --glow-accent: 39.43 66.67% 41.18%;
    --glow-success: 142 76% 36%;
    
    --sidebar-background: 0 0% 0%;
    --sidebar-foreground: 0 0% 70%;
    --sidebar-primary: 39.43 66.67% 41.18%;
    --sidebar-primary-foreground: 0 0% 3%;
    --sidebar-accent: 0 0% 8%;
    --sidebar-accent-foreground: 81 100% 50%;
    --sidebar-border: 0 0% 12%;
    --sidebar-ring: 39.43 66.67% 41.18%;

    --bg-primary: #080808;
    --text-primary: #E6EDF3;
    --cyan-glow: #00BFFF;
    --cyan-bright: #00FFFF;
    --cyan-border: rgba(0, 191, 255, 0.3);
    --card-bg: linear-gradient(135deg, rgba(8, 8, 8, 0.4), rgba(15, 15, 15, 0.3));
  }
}

@layer base {
  * {
    @apply border-border;
  }
a:hover {
    color: hsl(var(--accent));
  }
  body {
    @apply bg-background text-foreground;
    font-size: 1.125rem; /* 18px - increased by 2pt from default 16px */
  }
}

/* Holographic Card Effects */
.holo-card {
  position: relative;
  background: var(--card-bg);
  border: 1px solid var(--cyan-border);
  border-radius: 12px;
  padding: 1.5rem;
  transition: all 0.3s ease;
  overflow: hidden;
  backdrop-filter: blur(10px);
  cursor: pointer;
  min-width: 280px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

.holo-card::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  padding: 1px;
  background: linear-gradient(135deg, rgba(0, 255, 255, 0.5), rgba(0, 191, 255, 0.3));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.holo-card::after {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    to bottom right,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.03) 45%,
    rgba(255, 255, 255, 0.05) 50%,
    rgba(255, 255, 255, 0.03) 55%,
    rgba(255, 255, 255, 0) 100%
  );
  transform: translateX(-100%) translateY(-100%) rotate(45deg);
  transition: transform 0.6s ease;
}

.holo-card:hover {
  transform: scale(1.05) translateY(-8px);
  box-shadow: 
    0 0 30px rgba(0, 255, 255, 0.4),
    0 0 60px rgba(0, 191, 255, 0.3),
    0 12px 40px rgba(0, 0, 0, 0.6);
  border-color: rgba(0, 255, 255, 0.8);
}

.holo-card:hover::before {
  opacity: 1;
}

.holo-card:hover::after {
  transform: translateX(100%) translateY(100%) rotate(45deg);
}

.card-content {
  position: relative;
  z-index: 1;
}

.card-preview-content {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 120px;
  margin-bottom: 1rem;
}

.fake-link {
  display: block;
  color: var(--cyan-bright);
  text-decoration: none;
  font-size: 0.875rem;
  text-align: center;
  padding: 0.5rem;
  border: 1px solid var(--cyan-border);
  border-radius: 6px;
  transition: all 0.2s ease;
  background: rgba(0, 191, 255, 0.05);
}

.fake-link:hover {
  background: rgba(0, 191, 255, 0.15);
  border-color: var(--cyan-bright);
  transform: translateY(-2px);
}

.holo-button {
  padding: 0.75rem 2rem;
  background: linear-gradient(135deg, rgba(0, 191, 255, 0.2), rgba(0, 255, 255, 0.1));
  border: 1px solid var(--cyan-border);
  border-radius: 8px;
  color: var(--cyan-bright);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 1px;
  font-size: 0.875rem;
}

.holo-button:hover {
  background: linear-gradient(135deg, rgba(0, 191, 255, 0.3), rgba(0, 255, 255, 0.2));
  border-color: var(--cyan-bright);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
  transform: translateY(-2px);
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: rgba(13, 37, 63, 0.6);
  border-radius: 10px;
  overflow: hidden;
  border: 1px solid var(--cyan-border);
}

.progress-bar-inner {
  height: 100%;
  background: linear-gradient(90deg, var(--cyan-glow), var(--cyan-bright));
  border-radius: 10px;
  transition: width 0.3s ease;
  box-shadow: 0 0 10px var(--cyan-bright);
}

.data-viz-bar {
  flex: 1;
  background: linear-gradient(to top, var(--cyan-glow), var(--cyan-bright));
  border-radius: 4px 4px 0 0;
  animation: dance 2s ease-in-out infinite;
  box-shadow: 0 0 10px var(--cyan-bright);
}

.glowing-orb {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: radial-gradient(circle, var(--orb-color), transparent);
  animation: pulse 3s ease-in-out infinite;
}

.starfield {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    radial-gradient(2px 2px at 20px 30px, white, transparent),
    radial-gradient(2px 2px at 60px 70px, white, transparent),
    radial-gradient(1px 1px at 50px 50px, white, transparent),
    radial-gradient(1px 1px at 130px 80px, white, transparent),
    radial-gradient(2px 2px at 90px 10px, white, transparent);
  background-repeat: repeat;
  background-size: 200px 200px;
  animation: move-stars 200s linear infinite;
  opacity: 0.5;
  z-index: 0;
}

.app-container {
  position: relative;
  min-height: 100vh;
  background: var(--bg-primary);
  color: var(--text-primary);
}

@keyframes move-stars {
  from {
    background-position: 0 0;
  }
  to {
    background-position: -10000px 5000px;
  }
}

@keyframes scroll-left {
  0% {
    transform: translateX(0);
  }
  100% {
    transform: translateX(-50%);
  }
}

@keyframes scroll-right {
  0% {
    transform: translateX(-50%);
  }
  100% {
    transform: translateX(0);
  }
}

@keyframes dance {
  0%, 100% {
    height: 5px;
  }
  50% {
    height: 50px;
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(0.9);
    box-shadow: 0 0 15px var(--orb-color), 0 0 30px var(--orb-glow), 0 0 45px var(--orb-glow);
  }
  50% {
    transform: scale(1);
    box-shadow: 0 0 25px var(--orb-color), 0 0 50px var(--orb-glow), 0 0 75px var(--orb-glow);
  }
}

/* Scrolling Grid Styles */
.grid-container {
  overflow: hidden;
  width: 100%;
  margin-bottom: 1.5rem;
}

.scrolling-grid {
  display: flex;
  gap: 1.5rem;
  animation-duration: var(--scroll-duration);
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  will-change: transform;
}

/* Custom Scrollbar Styles */
.scrollbar-thin::-webkit-scrollbar {
  width: 8px;
}

.scrollbar-thin::-webkit-scrollbar-track {
  background: hsl(var(--muted));
  border-radius: 4px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
  background: hsl(var(--accent) / 0.5);
  border-radius: 4px;
  transition: background 0.2s;
}

/* Hide all scrollbars globally while keeping scroll functionality */
* {
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none;  /* IE and Edge */
}

*::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

/* Scrollbar hidden utility class */
.scrollbar-hidden {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.scrollbar-hidden::-webkit-scrollbar {
  display: none;
}

/* Glass Button Styles */
@layer components {
  .glass-button-wrap {
    @apply relative inline-block;
  }
  
  .glass-button {
    @apply relative z-10 rounded-full;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.15),
      rgba(255, 255, 255, 0.05)
    );
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.18);
    box-shadow: 
      0 8px 32px 0 rgba(31, 38, 135, 0.15),
      inset 0 1px 0 0 rgba(255, 255, 255, 0.2),
      inset 0 -1px 0 0 rgba(0, 0, 0, 0.1);
  }
  
  .glass-button:hover {
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.2),
      rgba(255, 255, 255, 0.1)
    );
    box-shadow: 
      0 8px 32px 0 rgba(31, 38, 135, 0.25),
      inset 0 1px 0 0 rgba(255, 255, 255, 0.3),
      inset 0 -1px 0 0 rgba(0, 0, 0, 0.1);
  }
  
  .glass-button:active {
    transform: translateY(1px);
    box-shadow: 
      0 4px 16px 0 rgba(31, 38, 135, 0.2),
      inset 0 1px 0 0 rgba(255, 255, 255, 0.15),
      inset 0 -1px 0 0 rgba(0, 0, 0, 0.15);
  }
  
  .glass-button-shadow {
    @apply absolute inset-0 -z-10;
    background: linear-gradient(
      135deg,
      rgba(255, 255, 255, 0.05),
      rgba(255, 255, 255, 0.02)
    );
    filter: blur(8px);
    transform: translateY(2px);
  }
  
  .glass-button-text {
    @apply text-foreground;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
}
</file>

<file path="realtime-indexer/src/indexer.ts">
import { ethers } from "ethers";
import { pool } from "./db.js";
import { ENV } from "./env.js";
import { LAUNCH_FACTORY_ABI, LAUNCH_CAMPAIGN_ABI, UP_VOTE_TREASURY_ABI } from "./abis.js";
import { TIMEFRAMES, bucketStart, TF } from "./timeframes.js";
import { publishTrade, publishCandle, publishStats, publishLeague } from "./ably.js";
import { createLeagueFeedPublisher } from "./leagueFeed.js";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const leagueFeed = createLeagueFeedPublisher({ pool, flushMs: 500 });
leagueFeed.start();

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function toDec18(x: bigint): number {
  return Number(ethers.formatUnits(x, 18));
}

function parseRpcList(v: string): string[] {
  return String(v || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
}

function isRateLimitError(e: any): boolean {
  const msg = String(e?.shortMessage || e?.message || "").toLowerCase();
  if (msg.includes("rate limit")) return true;

  // ethers v6 BAD_DATA wrapping JSON-RPC batch errors
  const v = e?.value;
  if (Array.isArray(v) && v[0]?.error?.code === -32005) return true;
  const infoV = e?.info?.value;
  if (Array.isArray(infoV) && infoV[0]?.error?.code === -32005) return true;
  const inner = e?.error;
  if (inner?.code === -32005) return true;
  return false;
}

function isPrunedHistoryError(e: any): boolean {
  // Seen on some providers (e.g., Allnodes) for old eth_getLogs ranges
  const code = e?.error?.code ?? e?.code;
  if (code === -32701) return true;
  const msg = String(e?.shortMessage || e?.message || e?.error?.message || "").toLowerCase();
  if (msg.includes("history has been pruned")) return true;
  if (msg.includes("pruned")) return true;
  return false;
}

function isRpcTransportError(e: any): boolean {
  const msg = String(e?.shortMessage || e?.message || "").toLowerCase();

  // Common transient gateway/network failures from public RPCs
  if (msg.includes("service unavailable") || msg.includes("503")) return true;
  if (msg.includes("bad gateway") || msg.includes("502")) return true;
  if (msg.includes("gateway timeout") || msg.includes("504")) return true;
  if (msg.includes("overflow")) return true;

  // TLS/connection problems (Railway/Node networking)
  if (msg.includes("handshake failure")) return true;
  if (msg.includes("eproto")) return true;
  if (msg.includes("econnreset") || msg.includes("connection reset")) return true;
  if (msg.includes("etimedout") || msg.includes("timeout")) return true;

  // Ethers sometimes nests these
  const code = String(e?.code || "");
  if (code === "SERVER_ERROR") return true;

  return false;
}

// ---------------------------------------------------------------------------
// Activity feed helpers
// ---------------------------------------------------------------------------

type CampaignInfo = {
  tokenAddress: string | null;
  name: string | null;
  symbol: string | null;
};

const CAMPAIGN_CACHE = new Map<string, CampaignInfo>();
let activityWritesDisabled = false;

function cacheCampaignInfo(chainId: number, campaign: string, info: CampaignInfo) {
  const key = `${chainId}:${campaign.toLowerCase()}`;
  CAMPAIGN_CACHE.set(key, info);
}

async function getCampaignInfo(chainId: number, campaign: string): Promise<CampaignInfo | null> {
  const key = `${chainId}:${campaign.toLowerCase()}`;
  const cached = CAMPAIGN_CACHE.get(key);
  if (cached) return cached;

  try {
    const r = await pool.query(
      `select token_address, name, symbol
       from public.campaigns
       where chain_id=$1 and campaign_address=$2`,
      [chainId, campaign.toLowerCase()]
    );
    const row = r.rows?.[0];
    const info: CampaignInfo = {
      tokenAddress: row?.token_address ?? null,
      name: row?.name ?? null,
      symbol: row?.symbol ?? null,
    };
    cacheCampaignInfo(chainId, campaign, info);
    return info;
  } catch {
    return null;
  }
}

async function insertActivityEvent(row: {
  chainId: number;
  eventType: string;
  txHash: string;
  logIndex: number;
  blockNumber: number;
  blockTime: Date;
  actor: string;
  campaign?: string | null;
  token?: string | null;
  amountInWei?: bigint | null;
  amountOutWei?: bigint | null;
  costWei?: bigint | null;
  payoutWei?: bigint | null;
  meta?: Record<string, any> | null;
}) {
  if (activityWritesDisabled) return;

  try {
    await pool.query(
      `insert into public.activity_events(
         chain_id,event_type,tx_hash,log_index,block_number,block_time,
         actor_address,campaign_address,token_address,
         amount_in_wei,amount_out_wei,cost_wei,payout_wei,meta
       ) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14)
       on conflict (chain_id,tx_hash,log_index) do nothing`,
      [
        row.chainId,
        row.eventType,
        row.txHash.toLowerCase(),
        row.logIndex,
        row.blockNumber,
        row.blockTime,
        row.actor.toLowerCase(),
        row.campaign ? row.campaign.toLowerCase() : null,
        row.token ? row.token.toLowerCase() : null,
        row.amountInWei ? row.amountInWei.toString() : null,
        row.amountOutWei ? row.amountOutWei.toString() : null,
        row.costWei ? row.costWei.toString() : null,
        row.payoutWei ? row.payoutWei.toString() : null,
        row.meta ? JSON.stringify(row.meta) : "{}",
      ]
    );
  } catch (e: any) {
    const msg = String(e?.message || e);
    if (msg.includes("activity_events") || msg.includes("relation")) {
      // Disable further writes to avoid spamming logs if migration is missing.
      activityWritesDisabled = true;
      console.warn("[activity_events] disabled (table missing or invalid).", msg);
      return;
    }
    console.warn("[activity_events] insert failed", msg);
  }
}

async function getLogsSafe(provider: ethers.JsonRpcProvider, filter: any, depth = 0): Promise<ethers.Log[]> {
  try {
    return await provider.getLogs(filter);
  } catch (e: any) {
    // Pruned history should not be retried on the SAME provider.
    if (isPrunedHistoryError(e)) throw e;

    if (!isRateLimitError(e)) throw e;

    const from = typeof filter?.fromBlock === "number" ? filter.fromBlock : null;
    const to = typeof filter?.toBlock === "number" ? filter.toBlock : null;

    // If the range is large, split it (dramatically reduces eth_getLogs load on public RPCs)
    if (from !== null && to !== null) {
      const span = to - from + 1;
      if (span > ENV.MIN_LOG_CHUNK_SIZE && depth < 12) {
        const mid = Math.floor((from + to) / 2);
        const left = await getLogsSafe(provider, { ...filter, fromBlock: from, toBlock: mid }, depth + 1);
        const right = await getLogsSafe(provider, { ...filter, fromBlock: mid + 1, toBlock: to }, depth + 1);
        return left.concat(right);
      }
    }

    // Otherwise, backoff + retry a few times
    let delay = 750;
    for (let attempt = 0; attempt < 6; attempt++) {
      await sleep(delay + Math.floor(Math.random() * 250));
      try {
        return await provider.getLogs(filter);
      } catch (e2: any) {
        if (isPrunedHistoryError(e2)) throw e2;
        if (!isRateLimitError(e2)) throw e2;
      }
      delay = Math.min(15_000, delay * 2);
    }

    throw e;
  }
}

// ---------------------------------------------------------------------------
// Chain config
// ---------------------------------------------------------------------------

type ChainCfg = {
  chainId: number;
  rpcHttp: string; // comma-separated list
  factoryAddress?: string;
  factoryStartBlock?: number;
  voteTreasuryAddress?: string;
  voteTreasuryStartBlock?: number;
};

const CHAINS: ChainCfg[] = [
  {
    chainId: 97,
    rpcHttp: ENV.BSC_RPC_HTTP_97,
    factoryAddress: ENV.FACTORY_ADDRESS_97 || undefined,
    factoryStartBlock: ENV.FACTORY_START_BLOCK_97 || undefined,
    voteTreasuryAddress: ENV.VOTE_TREASURY_ADDRESS_97 || undefined,
    voteTreasuryStartBlock: ENV.VOTE_TREASURY_START_BLOCK_97 || undefined
  }
  // enable later:
  // {
  //   chainId: 56,
  //   rpcHttp: ENV.BSC_RPC_HTTP_56,
  //   factoryAddress: ENV.FACTORY_ADDRESS_56 || undefined,
  //   factoryStartBlock: ENV.FACTORY_START_BLOCK_56 || undefined
  // }
];

// ---------------------------------------------------------------------------
// DB state
// ---------------------------------------------------------------------------

async function getState(chainId: number, cursor: string): Promise<number> {
  const r = await pool.query(
    `select last_indexed_block from public.indexer_state where chain_id=$1 and cursor=$2`,
    [chainId, cursor]
  );
  if (!r.rowCount) return 0;
  return Number(r.rows[0].last_indexed_block);
}

async function setStateMax(chainId: number, cursor: string, nextBlock: number) {
  // Do NOT allow the state to move backwards (repair jobs may scan earlier windows)
  await pool.query(
    `insert into public.indexer_state(chain_id,cursor,last_indexed_block)
     values($1,$2,$3)
     on conflict (chain_id,cursor) do update
       set last_indexed_block = greatest(public.indexer_state.last_indexed_block, excluded.last_indexed_block),
           updated_at=now()`,
    [chainId, cursor, nextBlock]
  );
}

async function upsertCampaign(
  chainId: number,
  factoryAddress: string | null,
  campaign: string,
  token: string,
  creator: string,
  name: string,
  symbol: string,
  createdBlock: number,
  createdAtChain: Date | null = null
) {
  // NOTE: campaigns lives in the *indexer* DB.
  // It is used for discovery + scanning and is separate from user-profile tables.
  // Current schema expects creator_address to be NOT NULL.
  await pool.query(
    `insert into public.campaigns(
        chain_id,factory_address,campaign_address,token_address,creator_address,name,symbol,created_block,created_at_chain,is_active
     )
     values($1,$2,$3,$4,$5,$6,$7,$8,$9,true)
     on conflict (chain_id,campaign_address) do update
       set token_address=coalesce(excluded.token_address, public.campaigns.token_address),
           factory_address=coalesce(public.campaigns.factory_address, excluded.factory_address),
           creator_address=coalesce(excluded.creator_address, public.campaigns.creator_address),
           name=coalesce(excluded.name, public.campaigns.name),
           symbol=coalesce(excluded.symbol, public.campaigns.symbol),
           created_block=(
             case
               -- Treat 0 as "unknown" (older migrations used DEFAULT 0).
               when public.campaigns.created_block is null or public.campaigns.created_block=0 then excluded.created_block
               when excluded.created_block is null or excluded.created_block=0 then public.campaigns.created_block
               else least(public.campaigns.created_block, excluded.created_block)
             end
           ),
           created_at_chain=(
             case
               when public.campaigns.created_at_chain is null then excluded.created_at_chain
               else public.campaigns.created_at_chain
             end
           ),
           is_active=true,
           updated_at=now()`,
    [
      chainId,
      (factoryAddress ? factoryAddress.toLowerCase() : null),
      campaign.toLowerCase(),
      token.toLowerCase(),
      creator.toLowerCase(),
      name,
      symbol,
      createdBlock,
      createdAtChain
    ]
  );

  cacheCampaignInfo(chainId, campaign, {
    tokenAddress: token ? token.toLowerCase() : null,
    name: name || null,
    symbol: symbol || null,
  });
}

async function setCampaignGraduated(
  chainId: number,
  campaign: string,
  graduatedBlock: number,
  graduatedAt: Date,
  txHash: string
) {
  await pool.query(
    `update public.campaigns
       set is_active=false,
           graduated_block=$3,
           graduated_at_chain=$4,
           meta = coalesce(meta,'{}'::jsonb) || jsonb_build_object('graduatedTx', $5),
           updated_at=now()
     where chain_id=$1 and campaign_address=$2`,
    [chainId, campaign.toLowerCase(), graduatedBlock, graduatedAt, txHash.toLowerCase()]
  );
}

async function setCampaignFeeRecipient(
  chainId: number,
  campaign: string,
  feeRecipient: string
) {
  await pool.query(
    `update public.campaigns
       set fee_recipient_address=coalesce(fee_recipient_address, $3),
           updated_at=now()
     where chain_id=$1 and campaign_address=$2`,
    [chainId, campaign.toLowerCase(), feeRecipient.toLowerCase()]
  );
}


async function listActiveCampaigns(chainId: number): Promise<Array<{ campaign: string; createdBlock: number }>> {
  const r = await pool.query(
    `select campaign_address, coalesce(created_block, 0) as created_block
     from public.campaigns
     where chain_id=$1 and is_active=true`,
    [chainId]
  );
  return r.rows.map((x) => ({
    campaign: String(x.campaign_address),
    createdBlock: Number(x.created_block || 0)
  }));
}

async function insertTrade(row: {
  chainId: number;
  campaign: string;
  txHash: string;
  logIndex: number;
  blockNumber: number;
  blockTime: Date;
  side: "buy" | "sell";
  wallet: string;
  tokenRaw: bigint;
  bnbRaw: bigint;
}) {
  const tokenAmount = toDec18(row.tokenRaw);
  const bnbAmount = toDec18(row.bnbRaw);
  const priceBnb = tokenAmount > 0 ? bnbAmount / tokenAmount : null;

  await pool.query(
    `insert into public.curve_trades(
        chain_id,campaign_address,tx_hash,log_index,block_number,block_time,
        side,wallet,token_amount_raw,bnb_amount_raw,token_amount,bnb_amount,price_bnb
     ) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)
     on conflict (chain_id,tx_hash,log_index) do nothing`,
    [
      row.chainId,
      row.campaign.toLowerCase(),
      row.txHash.toLowerCase(),
      row.logIndex,
      row.blockNumber,
      row.blockTime,
      row.side,
      row.wallet.toLowerCase(),
      row.tokenRaw.toString(),
      row.bnbRaw.toString(),
      tokenAmount,
      bnbAmount,
      priceBnb
    ]
  );

  return { tokenAmount, bnbAmount, priceBnb };
}

async function insertVote(row: {
  chainId: number;
  campaign: string;
  voter: string;
  asset: string; // address(0) for native BNB
  amountRaw: bigint;
  meta: string; // bytes32 hex
  txHash: string;
  logIndex: number;
  blockNumber: number;
  blockTime: Date;
}) {
  await pool.query(
    `insert into public.votes(
        chain_id,campaign_address,voter_address,asset_address,amount_raw,
        tx_hash,log_index,block_number,block_timestamp,meta,status
     ) values($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,'confirmed')
     on conflict (chain_id,tx_hash,log_index) do nothing`,
    [
      row.chainId,
      row.campaign.toLowerCase(),
      row.voter.toLowerCase(),
      row.asset.toLowerCase(),
      row.amountRaw.toString(),
      row.txHash.toLowerCase(),
      row.logIndex,
      row.blockNumber,
      row.blockTime,
      row.meta.toLowerCase()
    ]
  );
}

async function patchVoteAggregates(chainId: number, campaign: string) {
  // Recompute aggregates for a single campaign. This is intentionally simple for v1.
  // If vote volume grows, we can switch to bucketed incremental aggregates.
  const r = await pool.query(
    `with v as (
       select
         count(*) filter (where block_timestamp >= now() - interval '1 hour') as votes_1h,
         count(*) filter (where block_timestamp >= now() - interval '24 hours') as votes_24h,
         count(*) filter (where block_timestamp >= now() - interval '7 days') as votes_7d,
         count(*) as votes_all_time,
         count(*) filter (
           where block_timestamp >= now() - interval '24 hours'
         ) as b0,
         count(*) filter (
           where block_timestamp < now() - interval '24 hours'
             and block_timestamp >= now() - interval '48 hours'
         ) as b1,
         count(*) filter (
           where block_timestamp < now() - interval '48 hours'
             and block_timestamp >= now() - interval '72 hours'
         ) as b2,
         max(block_timestamp) as last_vote_at
       from public.votes
       where chain_id=$1 and campaign_address=$2 and status='confirmed'
     )
     select
       coalesce(votes_1h,0)::int as votes_1h,
       coalesce(votes_24h,0)::int as votes_24h,
       coalesce(votes_7d,0)::int as votes_7d,
       coalesce(votes_all_time,0)::int as votes_all_time,
       (coalesce(b0,0) * 1.0 + coalesce(b1,0) * 0.5 + coalesce(b2,0) * 0.25) as trending_score,
       last_vote_at
     from v`,
    [chainId, campaign.toLowerCase()]
  );

  const x = r.rows[0] || {
    votes_1h: 0,
    votes_24h: 0,
    votes_7d: 0,
    votes_all_time: 0,
    trending_score: 0,
    last_vote_at: null
  };

  await pool.query(
    `insert into public.vote_aggregates(
        chain_id,campaign_address,
        votes_1h,votes_24h,votes_7d,votes_all_time,trending_score,
        last_vote_at,updated_at
     ) values($1,$2,$3,$4,$5,$6,$7,$8,now())
     on conflict (chain_id,campaign_address) do update set
       votes_1h=excluded.votes_1h,
       votes_24h=excluded.votes_24h,
       votes_7d=excluded.votes_7d,
       votes_all_time=excluded.votes_all_time,
       trending_score=excluded.trending_score,
       last_vote_at=excluded.last_vote_at,
       updated_at=now()`,
    [
      chainId,
      campaign.toLowerCase(),
      Number(x.votes_1h || 0),
      Number(x.votes_24h || 0),
      Number(x.votes_7d || 0),
      Number(x.votes_all_time || 0),
      String(x.trending_score || 0),
      x.last_vote_at
    ]
  );
  leagueFeed.queueVotes(chainId, campaign, {
    votes24h: Number(x.votes_24h || 0),
    votesAllTime: Number(x.votes_all_time || 0),
    trendingScore: String(x.trending_score || 0)
  });
}

async function upsertCandle(
  chainId: number,
  campaign: string,
  tf: TF,
  bucketSec: number,
  price: number,
  volBnb: number
) {
  const bucketTs = new Date(bucketSec * 1000);

  await pool.query(
    `insert into public.token_candles(
        chain_id,campaign_address,timeframe,bucket_start,o,h,l,c,volume_bnb,trades_count
     ) values($1,$2,$3,$4,$5,$5,$5,$5,$6,1)
     on conflict (chain_id,campaign_address,timeframe,bucket_start) do update set
       h = greatest(public.token_candles.h, excluded.h),
       l = least(public.token_candles.l, excluded.l),
       c = excluded.c,
       volume_bnb = public.token_candles.volume_bnb + excluded.volume_bnb,
       trades_count = public.token_candles.trades_count + 1,
       updated_at = now()`,
    [chainId, campaign.toLowerCase(), tf, bucketTs, price, volBnb]
  );

  // Lightweight realtime patch (authoritative values come from REST)
  await publishCandle(chainId, campaign, {
    type: "candle_upsert",
    tf,
    bucket: bucketSec,
    c: String(price),
    v: String(volBnb)
  });
}

async function patchStats(chainId: number, campaign: string) {
  const r = await pool.query(
    `with t as (
       select price_bnb, block_time, bnb_amount
       from public.curve_trades
       where chain_id=$1 and campaign_address=$2
       order by block_number desc, log_index desc
       limit 1
     ),
     v as (
       select coalesce(sum(bnb_amount),0) as vol24h
       from public.curve_trades
       where chain_id=$1 and campaign_address=$2
         and block_time >= now() - interval '24 hours'
     )
     select
       (select price_bnb from t) as last_price_bnb,
       (select vol24h from v) as vol24h_bnb`,
    [chainId, campaign.toLowerCase()]
  );

  const lastPrice: number | null = r.rows[0]?.last_price_bnb ?? null;
  const vol24h: number = Number(r.rows[0]?.vol24h_bnb ?? 0);

  const soldRes = await pool.query(
    `select
       coalesce(sum(case when side='buy' then token_amount else 0 end),0) -
       coalesce(sum(case when side='sell' then token_amount else 0 end),0) as sold
     from public.curve_trades
     where chain_id=$1 and campaign_address=$2`,
    [chainId, campaign.toLowerCase()]
  );

  const sold: number = Number(soldRes.rows[0]?.sold ?? 0);
  const marketcap: number | null = lastPrice !== null ? lastPrice * sold : null;

  await pool.query(
    `insert into public.token_stats(
        chain_id,campaign_address,last_price_bnb,sold_tokens,marketcap_bnb,vol_24h_bnb,updated_at
     ) values($1,$2,$3,$4,$5,$6,now())
     on conflict (chain_id,campaign_address) do update set
       last_price_bnb=excluded.last_price_bnb,
       sold_tokens=excluded.sold_tokens,
       marketcap_bnb=excluded.marketcap_bnb,
       vol_24h_bnb=excluded.vol_24h_bnb,
       updated_at=now()`,
    [chainId, campaign.toLowerCase(), lastPrice, sold, marketcap, vol24h]
  );

  await publishStats(chainId, campaign, {
    type: "stats_patch",
    lastPriceBnb: lastPrice !== null ? String(lastPrice) : null,
    marketcapBnb: marketcap !== null ? String(marketcap) : null,
    vol24hBnb: String(vol24h)
  });

  leagueFeed.queueStats(chainId, campaign, {
    lastPriceBnb: lastPrice !== null ? String(lastPrice) : null,
    marketcapBnb: marketcap !== null ? String(marketcap) : null,
    vol24hBnb: String(vol24h)
  });

}

// ---------------------------------------------------------------------------
// On-chain scans
// ---------------------------------------------------------------------------

async function scanFactoryRange(
  provider: ethers.JsonRpcProvider,
  chain: ChainCfg,
  fromBlock: number,
  toBlock: number
) {
  if (!chain.factoryAddress) return;

  const iface = new ethers.Interface(LAUNCH_FACTORY_ABI);
  const eventFrag = iface.getEvent("CampaignCreated");
  if (!eventFrag) throw new Error("Event CampaignCreated not found in LAUNCH_FACTORY_ABI");
  const topic0 = eventFrag.topicHash;

  const cursor = "factory";
  const step = ENV.LOG_CHUNK_SIZE;

  for (let start = fromBlock; start <= toBlock; start += step) {
    const end = Math.min(toBlock, start + step - 1);

    const logs = await getLogsSafe(provider, {
      address: chain.factoryAddress,
      fromBlock: start,
      toBlock: end,
      topics: [topic0]
    });

    // Best-effort: store created_at_chain using block timestamp
    const blkNums = Array.from(new Set(logs.map((l) => l.blockNumber)));
    const blockTimes = new Map<number, Date>();
    for (const bn of blkNums) {
      const b = await provider.getBlock(bn);
      blockTimes.set(bn, new Date(Number(b?.timestamp || 0) * 1000));
    }

    for (const log of logs) {
      const parsed = iface.parseLog(log);
      if (!parsed) continue;
      const campaign = String((parsed.args as any).campaign);
      const token = String((parsed.args as any).token);
      const creator = String((parsed.args as any).creator);
      const name = String((parsed.args as any).name);
      const symbol = String((parsed.args as any).symbol);
      const blockTime = blockTimes.get(log.blockNumber) || null;
      await upsertCampaign(
        chain.chainId,
        chain.factoryAddress ?? null,
        campaign,
        token,
        creator,
        name,
        symbol,
        log.blockNumber,
        blockTime
      );

      // Realtime: announce newly created campaigns so Home "New" can insert instantly.
      // Keep payload minimal; UI can hydrate logoURI from chain later.
      try {
        await publishLeague(chain.chainId, "campaign_created", {
          type: "campaign_created",
          chainId: chain.chainId,
          ts: Math.floor(Date.now() / 1000),
          item: {
            campaignAddress: String(campaign).toLowerCase(),
            tokenAddress: String(token).toLowerCase(),
            creatorAddress: String(creator).toLowerCase(),
            name,
            symbol,
            createdAtChain: blockTime ? blockTime.toISOString() : null,
            blockNumber: log.blockNumber,
          },
        });
      } catch {
        // best-effort
      }

      if (log.transactionHash) {
        await insertActivityEvent({
          chainId: chain.chainId,
          eventType: "CREATE_CAMPAIGN",
          txHash: log.transactionHash,
          logIndex: log.index ?? 0,
          blockNumber: log.blockNumber,
          blockTime: blockTime || new Date(0),
          actor: creator,
          campaign,
          token,
          meta: {
            name,
            symbol,
            factory: chain.factoryAddress ? chain.factoryAddress.toLowerCase() : null,
          },
        });
      }
    }

    await setStateMax(chain.chainId, cursor, end + 1);
  }
}

async function scanVoteTreasuryRange(
  provider: ethers.JsonRpcProvider,
  chain: ChainCfg,
  fromBlock: number,
  toBlock: number
) {
  if (!chain.voteTreasuryAddress) return;

  const iface = new ethers.Interface(UP_VOTE_TREASURY_ABI);
  const eventFrag = iface.getEvent("VoteCast");
  if (!eventFrag) throw new Error("Event VoteCast not found in UP_VOTE_TREASURY_ABI");
  const topic0 = eventFrag.topicHash;

  const cursor = "votes";
  const step = ENV.LOG_CHUNK_SIZE;

  for (let start = fromBlock; start <= toBlock; start += step) {
    const end = Math.min(toBlock, start + step - 1);

    const logs = await getLogsSafe(provider, {
      address: chain.voteTreasuryAddress,
      fromBlock: start,
      toBlock: end,
      topics: [topic0]
    });

    if (logs.length) {
      const blkNums = Array.from(new Set(logs.map((l) => l.blockNumber)));
      const blockTimes = new Map<number, Date>();
      for (const bn of blkNums) {
        const b = await provider.getBlock(bn);
        blockTimes.set(bn, new Date(Number(b?.timestamp || 0) * 1000));
      }

      const touched = new Set<string>();
      for (const log of logs) {
        const parsed = iface.parseLog(log);
        if (!parsed) continue;

        const campaign = String((parsed.args as any).campaign);
        const voter = String((parsed.args as any).voter);
        const asset = String((parsed.args as any).asset);
        const amountPaid = (parsed.args as any).amountPaid as bigint;
        const meta = String((parsed.args as any).meta);

        await insertVote({
          chainId: chain.chainId,
          campaign,
          voter,
          asset,
          amountRaw: amountPaid,
          meta,
          txHash: log.transactionHash,
          logIndex: log.index,
          blockNumber: log.blockNumber,
          blockTime: blockTimes.get(log.blockNumber) || new Date(0)
        });

        await insertActivityEvent({
          chainId: chain.chainId,
          eventType: "UPVOTE",
          txHash: log.transactionHash,
          logIndex: log.index ?? 0,
          blockNumber: log.blockNumber,
          blockTime: blockTimes.get(log.blockNumber) || new Date(0),
          actor: voter,
          campaign,
          amountInWei: amountPaid,
          meta: {
            asset: asset?.toLowerCase?.() ?? asset,
            meta,
          },
        });

        touched.add(campaign.toLowerCase());
      }

      for (const c of touched) {
        await patchVoteAggregates(chain.chainId, c);
      }
    }

    await setStateMax(chain.chainId, cursor, end + 1);
  }
}



// ---------------------------------------------------------------------------
// Robust campaign discovery
// ---------------------------------------------------------------------------
//
// Some public RPCs can occasionally return incomplete eth_getLogs results.
// If that happens during the factory scan, we may miss a CampaignCreated event
// but still advance the factory cursor, causing the indexer to never learn about
// that campaign (and therefore never index its trades).
//
// To make discovery deterministic, we also periodically pull the factory's
// on-chain campaign registry (campaignsCount/getCampaign) and upsert any missing
// rows into public.campaigns.
//
async function syncFactoryCampaignsByCall(
  provider: ethers.JsonRpcProvider,
  chain: ChainCfg
) {
  if (!chain.factoryAddress) return;

  const factory = new ethers.Contract(chain.factoryAddress, LAUNCH_FACTORY_ABI, provider);

  let countBn: bigint;
  try {
    countBn = (await factory.campaignsCount()) as bigint;
  } catch (e) {
    console.warn("syncFactoryCampaignsByCall: campaignsCount failed", { chainId: chain.chainId }, e);
    return;
  }

  const count = Number(countBn);
  if (!Number.isFinite(count) || count <= 0) return;

  // Build a set of known campaigns (lowercased)
  const r = await pool.query(
    `select lower(campaign_address) as campaign
       from public.campaigns
      where chain_id=$1`,
    [chain.chainId]
  );
  const known = new Set<string>(r.rows.map((x) => String(x.campaign)));

  for (let i = 0; i < count; i++) {
    let info: any;
    try {
      info = await factory.getCampaign(i);
    } catch (e) {
      // Skip invalid ids rather than failing the whole sync
      continue;
    }

    const campaign = String(info?.campaign ?? info?.[0] ?? "").trim();
    if (!campaign || campaign === ethers.ZeroAddress) continue;

    const key = campaign.toLowerCase();
    if (known.has(key)) continue;

    const token = String(info?.token ?? info?.[1] ?? "").trim();
    const creator = String(info?.creator ?? info?.[2] ?? "").trim();
    const name = String(info?.name ?? info?.[3] ?? "").trim();
    const symbol = String(info?.symbol ?? info?.[4] ?? "").trim();

    const createdAtRaw = info?.createdAt ?? info?.[9];
    const createdAtSec = createdAtRaw !== undefined && createdAtRaw !== null ? Number(createdAtRaw) : 0;
    const createdAt = createdAtSec > 0 ? new Date(createdAtSec * 1000) : null;

    await upsertCampaign(chain.chainId, chain.factoryAddress ?? null, campaign, token, creator, name, symbol, 0, createdAt);
    known.add(key);

    console.log("Discovered missing campaign via factory registry", {
      chainId: chain.chainId,
      id: i,
      campaign: key
    });
  }
}

async function scanCampaignRange(
  provider: ethers.JsonRpcProvider,
  chainId: number,
  campaign: string,
  fromBlock: number,
  toBlock: number
) {
  const iface = new ethers.Interface(LAUNCH_CAMPAIGN_ABI);

  const buyFrag = iface.getEvent("TokensPurchased");
  const sellFrag = iface.getEvent("TokensSold");
  const finFrag = iface.getEvent("CampaignFinalized");
  if (!buyFrag || !sellFrag || !finFrag) throw new Error("Missing TokensPurchased/TokensSold/CampaignFinalized in LAUNCH_CAMPAIGN_ABI");

  const buyTopic = buyFrag.topicHash;
  const sellTopic = sellFrag.topicHash;
  const finTopic = finFrag.topicHash;

  const cursor = `campaign:${campaign.toLowerCase()}`;
  const step = ENV.LOG_CHUNK_SIZE;
  const blockTimeCache = new Map<number, number>();
  const campaignInfo = await getCampaignInfo(chainId, campaign);
  const tokenAddr = campaignInfo?.tokenAddress ?? null;

  // Best-effort: hydrate campaign feeRecipient for anti-abuse checks (Largest Buys).
  try {
    const rr = await pool.query(
      `select fee_recipient_address from public.campaigns where chain_id=$1 and campaign_address=$2`,
      [chainId, campaign.toLowerCase()]
    );
    const existing = rr.rows?.[0]?.fee_recipient_address ? String(rr.rows[0].fee_recipient_address) : "";
    if (!existing) {
      const c = new ethers.Contract(campaign, LAUNCH_CAMPAIGN_ABI, provider);
      const fr = String(await c.feeRecipient());
      if (/^0x[a-fA-F0-9]{40}$/.test(fr)) {
        await setCampaignFeeRecipient(chainId, campaign, fr);
      }
    }
  } catch {
    // ignore
  }

  for (let start = fromBlock; start <= toBlock; start += step) {
    const end = Math.min(toBlock, start + step - 1);

    const logs = await getLogsSafe(provider, {
      address: campaign,
      fromBlock: start,
      toBlock: end,
      topics: [[buyTopic, sellTopic, finTopic]]
    });

    logs.sort((a, b) => a.blockNumber - b.blockNumber || ((a.index ?? 0) - (b.index ?? 0)));

    for (const log of logs) {
      const txHash = log.transactionHash;
      if (!txHash) continue;

      let tsSec = blockTimeCache.get(log.blockNumber);
      if (!tsSec) {
        const blk = await provider.getBlock(log.blockNumber);
        tsSec = Number(blk?.timestamp ?? Math.floor(Date.now() / 1000));
        blockTimeCache.set(log.blockNumber, tsSec);
      }

      const parsed = iface.parseLog(log);
      if (!parsed) continue;
      const name = parsed.name;
      const logIndex = log.index ?? 0;

      if (name === "TokensPurchased") {
        const buyer = String((parsed.args as any).buyer);
        const amountOut = (parsed.args as any).amountOut as bigint;
        const cost = (parsed.args as any).cost as bigint;

        const { tokenAmount, bnbAmount, priceBnb } = await insertTrade({
          chainId,
          campaign,
          txHash,
          logIndex,
          blockNumber: log.blockNumber,
          blockTime: new Date(tsSec * 1000),
          side: "buy",
          wallet: buyer,
          tokenRaw: amountOut,
          bnbRaw: cost
        });

        await publishTrade(chainId, campaign, {
          type: "trade",
          chainId,
          token: campaign.toLowerCase(),
          txHash,
          logIndex,
          side: "buy",
          wallet: buyer.toLowerCase(),
          tokenAmount: String(tokenAmount),
          bnbAmount: String(bnbAmount),
          priceBnb: priceBnb !== null ? String(priceBnb) : null,
          ts: tsSec,
          blockNumber: log.blockNumber
        });

        await insertActivityEvent({
          chainId,
          eventType: "BUY",
          txHash,
          logIndex,
          blockNumber: log.blockNumber,
          blockTime: new Date(tsSec * 1000),
          actor: buyer,
          campaign,
          token: tokenAddr,
          amountInWei: cost,
          amountOutWei: amountOut,
          costWei: cost,
          meta: { priceBnb },
        });

        if (priceBnb !== null) {
          for (const tf of TIMEFRAMES) {
            const b = bucketStart(tsSec, tf);
            await upsertCandle(chainId, campaign, tf, b, priceBnb, bnbAmount);
          }
        }
      } else if (name === "TokensSold") {
        const seller = String((parsed.args as any).seller);
        const amountIn = (parsed.args as any).amountIn as bigint;
        const payout = (parsed.args as any).payout as bigint;

        const { tokenAmount, bnbAmount, priceBnb } = await insertTrade({
          chainId,
          campaign,
          txHash,
          logIndex,
          blockNumber: log.blockNumber,
          blockTime: new Date(tsSec * 1000),
          side: "sell",
          wallet: seller,
          tokenRaw: amountIn,
          bnbRaw: payout
        });

        // Home feed progress: sells subtract from raisedTotalBnb
        leagueFeed.queueRaisedDelta(chainId, campaign, -bnbAmount);

        await publishTrade(chainId, campaign, {
          type: "trade",
          chainId,
          token: campaign.toLowerCase(),
          txHash,
          logIndex,
          side: "sell",
          wallet: seller.toLowerCase(),
          tokenAmount: String(tokenAmount),
          bnbAmount: String(bnbAmount),
          priceBnb: priceBnb !== null ? String(priceBnb) : null,
          ts: tsSec,
          blockNumber: log.blockNumber
        });

        await insertActivityEvent({
          chainId,
          eventType: "SELL",
          txHash,
          logIndex,
          blockNumber: log.blockNumber,
          blockTime: new Date(tsSec * 1000),
          actor: seller,
          campaign,
          token: tokenAddr,
          amountInWei: amountIn,
          amountOutWei: payout,
          payoutWei: payout,
          meta: { priceBnb },
        });

        if (priceBnb !== null) {
          for (const tf of TIMEFRAMES) {
            const b = bucketStart(tsSec, tf);
            await upsertCandle(chainId, campaign, tf, b, priceBnb, bnbAmount);
          }
        }
      } else if (name === "CampaignFinalized") {
        const caller = String((parsed.args as any).caller ?? "");
        const liquidityTokens = (parsed.args as any).liquidityTokens as bigint;
        const liquidityBnb = (parsed.args as any).liquidityBnb as bigint;
        const protocolFee = (parsed.args as any).protocolFee as bigint;
        const creatorPayout = (parsed.args as any).creatorPayout as bigint;

        await insertActivityEvent({
          chainId,
          eventType: "FINALIZE",
          txHash,
          logIndex,
          blockNumber: log.blockNumber,
          blockTime: new Date(tsSec * 1000),
          actor: caller || campaign,
          campaign,
          token: tokenAddr,
          meta: {
            liquidityTokens: liquidityTokens?.toString?.() ?? null,
            liquidityBnb: liquidityBnb?.toString?.() ?? null,
            protocolFee: protocolFee?.toString?.() ?? null,
            creatorPayout: creatorPayout?.toString?.() ?? null,
          },
        });

        // Graduation marker for league categories
        await setCampaignGraduated(chainId, campaign, log.blockNumber, new Date(tsSec * 1000), txHash);
      }
    }

    await setStateMax(chainId, cursor, end + 1);
    if (logs.length > 0) await patchStats(chainId, campaign);
  }
}

function computeStartBlock(chain: ChainCfg, headTarget: number, existingState: number): number {
  // Priority:
  //  1) If state is already set, use it
  //  2) Else use configured factoryStartBlock (if set)
  //  3) Else fallback to headTarget - lookback
  if (existingState > 0) return existingState;
  if ((chain.factoryStartBlock ?? 0) > 0) return Number(chain.factoryStartBlock);
  return Math.max(0, headTarget - ENV.FACTORY_LOOKBACK_BLOCKS);
}

// ---------------------------------------------------------------------------
// Public entrypoints
// ---------------------------------------------------------------------------

export async function runIndexerOnce() {
  await runIndexerCore({
    mode: "normal",
    lookbackBlocks: ENV.FACTORY_LOOKBACK_BLOCKS,
    rewindBlocks: 0
  });
}

// Runs a bounded repair window: rewinds per-cursor state and replays recent logs.
export async function runRepairOnce() {
  await runIndexerCore({
    mode: "repair",
    lookbackBlocks: ENV.REPAIR_LOOKBACK_BLOCKS,
    rewindBlocks: ENV.REPAIR_REWIND_BLOCKS
  });
}

async function runIndexerCore(opts: { mode: "normal" | "repair"; lookbackBlocks: number; rewindBlocks: number }) {
  for (const chain of CHAINS) {
    const rpcList = parseRpcList(chain.rpcHttp);
    if (rpcList.length === 0) {
      console.error("No RPC URLs configured for chain", chain.chainId);
      continue;
    }

    let rpcIdx = 0;

    const makeProvider = () =>
      new ethers.JsonRpcProvider(rpcList[rpcIdx], undefined, {
        // reduce batch eth_getLogs pressure on public endpoints
        batchMaxCount: 1,
        batchStallTime: 0
      });

    const rotate = () => {
      rpcIdx = (rpcIdx + 1) % rpcList.length;
    };

    const withProviderRetry = async <T>(fn: (p: ethers.JsonRpcProvider) => Promise<T>): Promise<T> => {
      let lastErr: any;

      // try up to 2 full rotations
      for (let attempt = 0; attempt < rpcList.length * 2; attempt++) {
        const p = makeProvider();
        const url = rpcList[rpcIdx];

        try {
          return await fn(p);
        } catch (e: any) {
          lastErr = e;

          if (isRateLimitError(e) || isRpcTransportError(e) || isPrunedHistoryError(e)) {
            console.warn("RPC error; rotating endpoint", {
              chainId: chain.chainId,
              rpc: url,
              err: e?.shortMessage || e?.message || e
            });

            rotate();
            await sleep(500 + Math.floor(Math.random() * 500));
            continue;
          }

          // Non-transient error: bubble up
          throw e;
        }
      }

      throw lastErr;
    };

    // Compute scanning head for this pass
    const head = await withProviderRetry((p) => p.getBlockNumber());
    const target = Math.max(0, head - ENV.CONFIRMATIONS);

    // ---------------- Factory scan ----------------
    try {
      const cursor = "factory";
      const state = await getState(chain.chainId, cursor);
      const baselineStart = computeStartBlock(chain, target, state);
      const windowStart = Math.max(0, target - opts.lookbackBlocks);
      const from = opts.mode === "repair"
        ? Math.max(windowStart, Math.max(0, state - opts.rewindBlocks))
        : Math.max(baselineStart, windowStart);

      await withProviderRetry((p) => scanFactoryRange(p, chain, from, target));
      // Deterministic discovery: pull campaigns directly from the factory registry
      await withProviderRetry((p) => syncFactoryCampaignsByCall(p, chain));
    } catch (e) {
      console.error("scanFactory error (all RPCs failed)", { chainId: chain.chainId }, e);
    }

    // ---------------- VoteTreasury scan ----------------
    try {
      if (chain.voteTreasuryAddress) {
        const cursor = "votes";
        const state = await getState(chain.chainId, cursor);
        const windowStart = Math.max(0, target - opts.lookbackBlocks);

        // Prefer configured start block, otherwise fallback to rolling lookback.
        const startHint = chain.voteTreasuryStartBlock || 0;
        const from = opts.mode === "repair"
          ? Math.max(windowStart, Math.max(0, state - opts.rewindBlocks))
          : (state > 0 ? state : (startHint > 0 ? startHint : windowStart));

        await withProviderRetry((p) => scanVoteTreasuryRange(p, chain, from, target));
      }
    } catch (e) {
      console.error("scanVoteTreasury error (all RPCs failed)", { chainId: chain.chainId }, e);
    }

    // ---------------- Campaign scans ----------------
    let campaigns: Array<{ campaign: string; createdBlock: number }> = [];
    try {
      campaigns = await listActiveCampaigns(chain.chainId);
    } catch (e) {
      console.error("listActiveCampaigns error", { chainId: chain.chainId }, e);
      continue;
    }

    for (const c of campaigns) {
      const campaign = c.campaign;
      try {
        const cursor = `campaign:${campaign.toLowerCase()}`;
        const state = await getState(chain.chainId, cursor);
        const windowStart = Math.max(0, target - opts.lookbackBlocks);

        // Prefer a deterministic start block when we have no state yet.
        // This prevents "newly discovered" campaigns from missing older trades
        // that fall outside the rolling lookback window.
        const campaignStart = c.createdBlock && c.createdBlock > 0
          ? c.createdBlock
          : (chain.factoryStartBlock || 0);

        // In normal mode, campaign scans should start from their cursor state.
        // In repair mode, rewind the cursor slightly but never earlier than windowStart.
        const from = opts.mode === "repair"
          ? Math.max(windowStart, Math.max(0, state - opts.rewindBlocks))
          : (state > 0 ? state : (campaignStart > 0 ? campaignStart : windowStart));

        await withProviderRetry((p) => scanCampaignRange(p, chain.chainId, campaign, from, target));
      } catch (e) {
        console.error("scanCampaign error (all RPCs failed)", { chainId: chain.chainId, campaign }, e);
      }
    }
  }
}
</file>

<file path="frontend/api/league.js">
import { ethers } from "ethers";
import { pool } from "../server/db.js";
import { badMethod, getQuery, isAddress, json, readJson } from "../server/http.js";

// League categories (LOCKED):
// - perfect_run (monthly only)
// - fastest_finish
// - biggest_hit
// - top_earner (bonding curve trader PnL)
// - crowd_favorite
const CATEGORY_SET = new Set(["perfect_run", "fastest_finish", "biggest_hit", "top_earner", "crowd_favorite"]);

// Accept old period spellings for backward compatibility.
const PERIOD_SET = new Set(["weekly", "monthly", "all", "all_time", "alltime"]);

function clampInt(v, lo, hi, def) {
  const n = Number(v);
  if (!Number.isFinite(n)) return def;
  return Math.max(lo, Math.min(hi, Math.trunc(n)));
}

function normPeriod(periodRaw) {
  const p = String(periodRaw || "weekly").toLowerCase().trim();
  if (p === "weekly") return "weekly";
  if (p === "monthly") return "monthly";
  return "all_time";
}

// ---------------------------
// Fixed epochs (UTC, locked)
// ---------------------------
// Weekly: Monday 00:00 UTC  next Monday 00:00 UTC
// Monthly: 1st 00:00 UTC  next 1st 00:00 UTC
// For live epoch: rangeEnd = now
// For past epoch: rangeEnd = epochEnd

function startOfUtcDay(d) {
  return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0, 0, 0, 0));
}

function getWeeklyEpochUtc(epochOffset) {
  const now = new Date();
  const today0 = startOfUtcDay(now);
  // JS: 0=Sun..6=Sat. We want Monday-based.
  const dow = today0.getUTCDay();
  const daysSinceMonday = (dow + 6) % 7; // Mon=0, Tue=1, ... Sun=6
  const thisMonday0 = new Date(today0.getTime() - daysSinceMonday * 86400_000);
  const epochStart = new Date(thisMonday0.getTime() - epochOffset * 7 * 86400_000);
  const epochEnd = new Date(epochStart.getTime() + 7 * 86400_000);
  const isLive = epochOffset === 0;
  const rangeEnd = isLive ? now : epochEnd;
  return {
    period: "weekly",
    epochOffset,
    epochStart,
    epochEnd,
    rangeEnd,
    isLive
  };
}

function getMonthlyEpochUtc(epochOffset) {
  const now = new Date();
  const y = now.getUTCFullYear();
  const m = now.getUTCMonth();
  const thisMonthStart = new Date(Date.UTC(y, m, 1, 0, 0, 0, 0));
  const epochStart = new Date(Date.UTC(y, m - epochOffset, 1, 0, 0, 0, 0));
  const epochEnd = new Date(Date.UTC(epochStart.getUTCFullYear(), epochStart.getUTCMonth() + 1, 1, 0, 0, 0, 0));
  // If epochOffset is 0, use thisMonthStart for clarity, but the computed epochStart already matches.
  const isLive = epochOffset === 0;
  const rangeEnd = isLive ? now : epochEnd;
  return {
    period: "monthly",
    epochOffset,
    epochStart,
    epochEnd,
    rangeEnd,
    isLive
  };
}

function getEpoch(periodNorm, epochOffset) {
  if (periodNorm === "weekly") return getWeeklyEpochUtc(epochOffset);
  if (periodNorm === "monthly") return getMonthlyEpochUtc(epochOffset);
  return {
    period: "all_time",
    epochOffset: 0,
    epochStart: null,
    epochEnd: null,
    rangeEnd: null,
    isLive: false
  };
}

// ---------------------------
// Prize pool (league fee only)
// ---------------------------
const DEFAULT_PROTOCOL_FEE_BPS = 200; // 2%
const DEFAULT_LEAGUE_FEE_BPS = 25; // 0.25% slice of gross
const PRIZE_TTL_MS = 60 * 60 * 1000;
const PRIZE_SPLIT_BPS = [4000, 2500, 1500, 1200, 800]; // 40/25/15/12/8

function readBps(name, def) {
  const raw = process?.env?.[name];
  const n = Number(raw);
  if (!Number.isFinite(n) || n < 0 || n > 10_000) return def;
  return Math.trunc(n);
}

function prizeEligibleCategories(periodNorm) {
  if (periodNorm === "weekly") return ["fastest_finish", "biggest_hit", "top_earner", "crowd_favorite"]; // 4
  if (periodNorm === "monthly") return ["perfect_run", "fastest_finish", "biggest_hit", "top_earner", "crowd_favorite"]; // 5
  return null;
}

const prizeCache = new Map(); // key: `${chainId}:${period}` -> { computedAtMs, data }

// ---------------------------
// Claims (signature + nonce)
// ---------------------------

function buildClaimMessage({ chainId, recipient, period, epochStart, category, rank, nonce }) {
  return [
    "MemeBattles League",
    "Action: LEAGUE_CLAIM",
    `ChainId: ${chainId}`,
    `Recipient: ${String(recipient).toLowerCase()}`,
    `Period: ${period}`,
    `EpochStart: ${epochStart}`,
    `Category: ${category}`,
    `Rank: ${rank}`,
    `Nonce: ${nonce}`,
  ].join("\n");
}

async function consumeNonce(chainId, address, nonce) {
  const { rows } = await pool.query(
    `SELECT nonce, expires_at, used_at
     FROM auth_nonces
     WHERE chain_id = $1 AND address = $2
     LIMIT 1`,
    [chainId, address]
  );
  const row = rows[0];
  if (!row) throw new Error("Nonce not found");
  if (row.used_at) throw new Error("Nonce already used");
  const exp = row.expires_at ? new Date(row.expires_at).getTime() : 0;
  if (!exp || Date.now() > exp) throw new Error("Nonce expired");
  if (String(row.nonce) !== String(nonce)) throw new Error("Nonce mismatch");

  await pool.query(
    `UPDATE auth_nonces SET used_at = NOW() WHERE chain_id = $1 AND address = $2`,
    [chainId, address]
  );
}

function splitPotRaw(potRawBigInt) {
  const pot = BigInt(potRawBigInt);
  const payouts = PRIZE_SPLIT_BPS.map((bps) => (pot * BigInt(bps)) / 10000n);
  const sum = payouts.reduce((a, b) => a + b, 0n);
  // Push rounding dust to #1 so totals reconcile.
  payouts[0] = payouts[0] + (pot - sum);
  return payouts.map((x) => x.toString());
}

async function computeTotalLeagueFeeRawInRange(chainId, startIso, endIso, protocolFeeBps, leagueFeeBps) {
  // IMPORTANT:
  // curve_trades.bnb_amount_raw is:
  // - buy: total paid = gross + floor(gross * protocolFeeBps / 10000)
  // - sell: net payout = gross - floor(gross * protocolFeeBps / 10000)
  // We invert to gross using an integer-safe candidate +/- 2 wei check, then compute:
  // league_fee = floor(gross * leagueFeeBps / 10000)
  const { rows } = await pool.query(
    `
    WITH trades AS (
      SELECT
        t.side,
        t.bnb_amount_raw::numeric AS amt
      FROM public.curve_trades t
      WHERE t.chain_id = $1
        AND ($2::timestamptz IS NULL OR t.block_time >= $2::timestamptz)
        AND ($3::timestamptz IS NULL OR t.block_time < $3::timestamptz)
    ),
    base AS (
      SELECT
        side,
        amt,
        floor((amt * 10000) / (10000 + $4)) AS buy_g0,
        ceiling((amt * 10000) / (10000 - $4)) AS sell_g0
      FROM trades
    ),
    calc AS (
      SELECT
        side,
        CASE
          WHEN side = 'buy' THEN (
            CASE
              WHEN (buy_g0 + floor((buy_g0 * $4) / 10000)) = amt THEN buy_g0
              WHEN ((buy_g0 + 1) + floor(((buy_g0 + 1) * $4) / 10000)) = amt THEN buy_g0 + 1
              WHEN ((buy_g0 + 2) + floor(((buy_g0 + 2) * $4) / 10000)) = amt THEN buy_g0 + 2
              WHEN (greatest(buy_g0 - 1, 0) + floor((greatest(buy_g0 - 1, 0) * $4) / 10000)) = amt THEN greatest(buy_g0 - 1, 0)
              WHEN (greatest(buy_g0 - 2, 0) + floor((greatest(buy_g0 - 2, 0) * $4) / 10000)) = amt THEN greatest(buy_g0 - 2, 0)
              ELSE buy_g0
            END
          )
          ELSE (
            CASE
              WHEN (sell_g0 - floor((sell_g0 * $4) / 10000)) = amt THEN sell_g0
              WHEN (greatest(sell_g0 - 1, 0) - floor((greatest(sell_g0 - 1, 0) * $4) / 10000)) = amt THEN greatest(sell_g0 - 1, 0)
              WHEN (greatest(sell_g0 - 2, 0) - floor((greatest(sell_g0 - 2, 0) * $4) / 10000)) = amt THEN greatest(sell_g0 - 2, 0)
              WHEN ((sell_g0 + 1) - floor(((sell_g0 + 1) * $4) / 10000)) = amt THEN sell_g0 + 1
              WHEN ((sell_g0 + 2) - floor(((sell_g0 + 2) * $4) / 10000)) = amt THEN sell_g0 + 2
              ELSE sell_g0
            END
          )
        END AS gross
      FROM base
    ),
    fees AS (
      SELECT floor((gross * $5) / 10000) AS league_fee
      FROM calc
    )
    SELECT COALESCE(sum(league_fee), 0)::numeric(78, 0) AS total_league_fee_raw
    FROM fees;
    `,
    [chainId, startIso ?? null, endIso ?? null, protocolFeeBps, leagueFeeBps]
  );

  const v = rows?.[0]?.total_league_fee_raw;
  // Always return integer string.
  return String(v ?? "0");
}

async function getPrizeMeta(chainId, periodNorm, epochStartIso, rangeEndIso) {
  const eligible = prizeEligibleCategories(periodNorm);
  if (!eligible) return null;

  // Keyed by epoch start so we never bleed between epochs on warm instances.
  const key = `${chainId}:${periodNorm}:${epochStartIso ?? ""}`;
  const now = Date.now();
  const cached = prizeCache.get(key);
  if (cached && now - cached.computedAtMs < PRIZE_TTL_MS) return cached.data;

  const protocolFeeBps = readBps("PROTOCOL_FEE_BPS", DEFAULT_PROTOCOL_FEE_BPS);
  const leagueFeeBps = readBps("LEAGUE_FEE_BPS", DEFAULT_LEAGUE_FEE_BPS);

  const totalLeagueFeeRaw = await computeTotalLeagueFeeRawInRange(
    chainId,
    epochStartIso ?? null,
    rangeEndIso ?? null,
    protocolFeeBps,
    leagueFeeBps
  );
  const total = BigInt(totalLeagueFeeRaw);

  const leagueCount = eligible.length;
  const base = leagueCount > 0 ? total / BigInt(leagueCount) : 0n;
  const rem = leagueCount > 0 ? total % BigInt(leagueCount) : 0n;

  const byCategory = {};
  for (let i = 0; i < eligible.length; i++) {
    const cat = eligible[i];
    const pot = base + (BigInt(i) < rem ? 1n : 0n); // spread dust evenly (<= 1 wei difference)
    byCategory[cat] = {
      potRaw: pot.toString(),
      payoutsRaw: splitPotRaw(pot)
    };
  }

  const data = {
    basis: "league_fee_only",
    period: periodNorm,
    cutoff: epochStartIso,
    rangeEnd: rangeEndIso,
    computedAt: new Date(now).toISOString(),
    protocolFeeBps,
    leagueFeeBps,
    totalLeagueFeeRaw: total.toString(),
    leagueCount,
    winners: 5,
    splitBps: PRIZE_SPLIT_BPS,
    byCategory
  };

  prizeCache.set(key, { computedAtMs: now, data });
  return data;
}

export default async function handler(req, res) {
  // POST = claim a finalized prize (Profile -> Rewards)
  if (req.method === "POST") {
    try {
      const b = await readJson(req);
      const action = String(b.action ?? "").toLowerCase().trim();
      if (action !== "claim") return json(res, 400, { error: "Invalid action" });

      const chainId = Number(b.chainId);
      const period = String(b.period ?? "").toLowerCase().trim();
      const epochStart = String(b.epochStart ?? "").trim();
      const category = String(b.category ?? "").toLowerCase().trim();
      const rank = Number(b.rank);
      const recipient = String(b.recipient ?? b.address ?? "").toLowerCase().trim();
      const nonce = String(b.nonce ?? "");
      const signature = String(b.signature ?? "");

      if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });
      if (!isAddress(recipient)) return json(res, 400, { error: "Invalid recipient" });
      if (!(period === "weekly" || period === "monthly")) return json(res, 400, { error: "Invalid period" });
      if (!CATEGORY_SET.has(category)) return json(res, 400, { error: "Invalid category" });
      if (!Number.isFinite(rank) || rank < 1 || rank > 5) return json(res, 400, { error: "Invalid rank" });
      if (!epochStart) return json(res, 400, { error: "epochStart missing" });
      if (!nonce) return json(res, 400, { error: "Nonce missing" });
      if (!signature) return json(res, 400, { error: "Signature missing" });
      if (!pool) return json(res, 500, { error: "Server misconfigured: DATABASE_URL missing" });

      // Nonce must match the *recipient* (wallet) signing the claim.
      await consumeNonce(chainId, recipient, nonce);

      const msg = buildClaimMessage({ chainId, recipient, period, epochStart, category, rank, nonce });
      const recovered = ethers.verifyMessage(msg, signature).toLowerCase();
      if (recovered !== recipient) return json(res, 401, { error: "Invalid signature" });

      // Winner must exist, and must belong to recipient.
      const { rows: wrows } = await pool.query(
        `SELECT epoch_end AS "epochEnd", recipient_address AS "recipientAddress", amount_raw AS "amountRaw"
           FROM league_epoch_winners
          WHERE chain_id = $1
            AND period = $2
            AND epoch_start = $3::timestamptz
            AND category = $4
            AND rank = $5
          LIMIT 1`,
        [chainId, period, epochStart, category, rank]
      );
      const w = wrows[0];
      if (!w) return json(res, 404, { error: "Winner not found" });
      if (String(w.recipientAddress ?? "").toLowerCase() !== recipient) {
        return json(res, 403, { error: "Not the winner" });
      }

      // Optional safety: only allow claims after epoch end.
      const epochEndMs = w.epochEnd ? new Date(w.epochEnd).getTime() : 0;
      if (epochEndMs && Date.now() < epochEndMs) {
        return json(res, 400, { error: "Epoch not finalized" });
      }

      // Record the claim (prevents double-claim)
      await pool.query(
        `INSERT INTO league_epoch_claims (chain_id, period, epoch_start, category, rank, recipient_address, signature)
         VALUES ($1, $2, $3::timestamptz, $4, $5, $6, $7)
         ON CONFLICT (chain_id, period, epoch_start, category, rank)
         DO NOTHING`,
        [chainId, period, epochStart, category, rank, recipient, signature]
      );

      // If already claimed, the insert is ignored. Detect it.
      const { rows: crows } = await pool.query(
        `SELECT claimed_at AS "claimedAt"
           FROM league_epoch_claims
          WHERE chain_id = $1 AND period = $2 AND epoch_start = $3::timestamptz AND category = $4 AND rank = $5
          LIMIT 1`,
        [chainId, period, epochStart, category, rank]
      );
      const claimedAt = crows?.[0]?.claimedAt ? new Date(crows[0].claimedAt).toISOString() : null;

      return json(res, 200, { ok: true, claimedAt, amountRaw: w.amountRaw });
    } catch (e) {
      const msg = String(e?.message ?? "");
      const isAuth = /nonce|signature/i.test(msg);
      console.error("[api/league claim]", e);
      return json(res, isAuth ? 401 : 500, { error: isAuth ? msg : "Server error" });
    }
  }

  if (req.method !== "GET") return badMethod(res);

  try {
    const q = getQuery(req);
    const chainId = Number(q.chainId ?? 97);
    if (!Number.isFinite(chainId)) return json(res, 400, { error: "Invalid chainId" });

    const category = String(q.category ?? "").toLowerCase().trim();
    if (!CATEGORY_SET.has(category)) return json(res, 400, { error: "Invalid category" });

    const periodRaw = String(q.period ?? "weekly").toLowerCase().trim();
    if (!PERIOD_SET.has(periodRaw)) return json(res, 400, { error: "Invalid period" });

    const periodNorm = normPeriod(periodRaw);
    const epochOffset =
      periodNorm === "weekly"
        ? clampInt(q.epochOffset ?? 0, 0, 2, 0)
        : periodNorm === "monthly"
          ? clampInt(q.epochOffset ?? 0, 0, 1, 0)
          : 0;

    const epoch = getEpoch(periodNorm, epochOffset);
    const epochStartIso = epoch?.epochStart ? epoch.epochStart.toISOString() : null;
    const epochEndIso = epoch?.epochEnd ? epoch.epochEnd.toISOString() : null;
    const rangeEndIso = epoch?.rangeEnd ? epoch.rangeEnd.toISOString() : null;

    const limit = clampInt(q.limit ?? 10, 1, 50, 10);

    // Prize meta is computed once per chain/period per warm instance (and TTL = 1h).
    // This prevents recomputing fee totals on every category request.
    const prizeMeta = await getPrizeMeta(chainId, periodNorm, epochStartIso, rangeEndIso);
    const prizeForCategory = prizeMeta?.byCategory?.[category]
      ? {
          basis: prizeMeta.basis,
          period: prizeMeta.period,
          cutoff: prizeMeta.cutoff,
          rangeEnd: prizeMeta.rangeEnd,
          computedAt: prizeMeta.computedAt,
          totalLeagueFeeRaw: prizeMeta.totalLeagueFeeRaw,
          leagueCount: prizeMeta.leagueCount,
          winners: prizeMeta.winners,
          splitBps: prizeMeta.splitBps,
          potRaw: prizeMeta.byCategory[category].potRaw,
          payoutsRaw: prizeMeta.byCategory[category].payoutsRaw
        }
      : undefined;

    const epochMeta =
      periodNorm === "weekly" || periodNorm === "monthly"
        ? {
            period: periodNorm,
            epochOffset,
            epochStart: epochStartIso,
            epochEnd: epochEndIso,
            rangeEnd: rangeEndIso,
            status: epoch.isLive ? "live" : "finalized"
          }
        : undefined;

    // -------------------------------------------------
    // Fastest Finish
    // -------------------------------------------------
    if (category === "fastest_finish") {
      const params = [chainId, epochStartIso, rangeEndIso, limit];

      const { rows } = await pool.query(
        `
        WITH grads AS (
          SELECT
            c.chain_id,
            c.campaign_address,
            c.name,
            c.symbol,
            c.logo_uri,
            c.creator_address,
            c.created_at_chain,
            c.graduated_at_chain,
            c.created_block,
            c.graduated_block,
            EXTRACT(EPOCH FROM (c.graduated_at_chain - c.created_at_chain))::bigint AS duration_seconds,
            (
              SELECT COUNT(DISTINCT t.wallet)
              FROM curve_trades t
              WHERE t.chain_id = c.chain_id
                AND t.campaign_address = c.campaign_address
                AND t.side = 'buy'
                AND t.block_number >= c.created_block
                AND (c.graduated_block IS NULL OR c.graduated_block = 0 OR t.block_number <= c.graduated_block)
                -- Locked rule: creator buys do not count towards "fastest"
                AND (c.creator_address IS NULL OR t.wallet <> c.creator_address)
            ) AS unique_buyers
          FROM campaigns c
          WHERE c.chain_id = $1
            AND c.created_at_chain IS NOT NULL
            AND c.graduated_at_chain IS NOT NULL
            AND (c.graduated_block IS NOT NULL AND c.graduated_block > 0)
            AND ($2::timestamptz IS NULL OR c.graduated_at_chain >= $2::timestamptz)
            AND ($3::timestamptz IS NULL OR c.graduated_at_chain < $3::timestamptz)
        )
        SELECT *
        FROM grads
        WHERE unique_buyers >= 25
        ORDER BY duration_seconds ASC NULLS LAST
        LIMIT $4
        `,
        params
      );

      return json(res, 200, { items: rows, prize: prizeForCategory, epoch: epochMeta });
    }

    // -------------------------------------------------
    // Perfect Run (monthly only)
    // -------------------------------------------------
    if (category === "perfect_run") {
      // Locked rule: monthly only. If caller asks weekly/all-time, respond empty.
      if (periodNorm !== "monthly") {
        return json(res, 200, { items: [], warning: "perfect_run is monthly only", prize: prizeForCategory, epoch: epochMeta });
      }

      const params = [chainId, epochStartIso, rangeEndIso, limit];

      const { rows } = await pool.query(
        `
        WITH qualified AS (
          SELECT
            c.chain_id,
            c.campaign_address,
            c.name,
            c.symbol,
            c.logo_uri,
            c.creator_address,
            c.created_at_chain,
            c.graduated_at_chain,
            c.created_block,
            c.graduated_block,
            EXTRACT(EPOCH FROM (c.graduated_at_chain - c.created_at_chain))::bigint AS duration_seconds,
            (
              SELECT COUNT(DISTINCT t.wallet)
              FROM curve_trades t
              WHERE t.chain_id = c.chain_id
                AND t.campaign_address = c.campaign_address
                AND t.side = 'buy'
                AND t.block_number >= c.created_block
                AND t.block_number <= c.graduated_block
                AND (c.creator_address IS NULL OR t.wallet <> c.creator_address)
            ) AS unique_buyers,
            (
              SELECT COALESCE(SUM(t.bnb_amount_raw), 0)::numeric(78,0)
              FROM curve_trades t
              WHERE t.chain_id = c.chain_id
                AND t.campaign_address = c.campaign_address
                AND t.side = 'buy'
                AND t.block_number >= c.created_block
                AND t.block_number <= c.graduated_block
                AND (c.creator_address IS NULL OR t.wallet <> c.creator_address)
            ) AS buy_total_raw
          FROM campaigns c
          WHERE c.chain_id = $1
            AND c.created_at_chain IS NOT NULL
            AND c.graduated_at_chain IS NOT NULL
            AND (c.graduated_block IS NOT NULL AND c.graduated_block > 0)
            AND ($2::timestamptz IS NULL OR c.graduated_at_chain >= $2::timestamptz)
            AND ($3::timestamptz IS NULL OR c.graduated_at_chain < $3::timestamptz)
            AND NOT EXISTS (
              SELECT 1
              FROM curve_trades t
              WHERE t.chain_id = c.chain_id
                AND t.campaign_address = c.campaign_address
                AND t.side = 'sell'
                AND t.block_number >= c.created_block
                AND t.block_number <= c.graduated_block
            )
        )
        SELECT *
        FROM qualified
        -- Top 5 determination (deterministic):
        -- 1) strongest demand (buy volume)
        -- 2) most unique buyers
        -- 3) fastest graduation
        ORDER BY buy_total_raw DESC, unique_buyers DESC, duration_seconds ASC
        LIMIT $4
        `,
        params
      );

      return json(res, 200, {
        items: rows,
        warning: rows.length ? undefined : "No Perfect Run qualifiers found. Jackpot rolls over.",
        prize: prizeForCategory,
        epoch: epochMeta
      });
    }

    // -------------------------------------------------
    // Biggest Hit (largest single buy in bonding)
    // -------------------------------------------------
    if (category === "biggest_hit") {
      const params = [chainId, epochStartIso, rangeEndIso, limit];

      const { rows } = await pool.query(
        `
        SELECT
          t.chain_id,
          t.campaign_address,
          c.name,
          c.symbol,
          c.logo_uri,
          c.creator_address,
          c.fee_recipient_address,
          t.wallet AS buyer_address,
          t.bnb_amount_raw,
          t.tx_hash,
          t.log_index,
          t.block_number,
          t.block_time
        FROM curve_trades t
        JOIN campaigns c
          ON c.chain_id = t.chain_id
         AND c.campaign_address = t.campaign_address
        WHERE t.chain_id = $1
          AND t.side = 'buy'
          AND ($2::timestamptz IS NULL OR t.block_time >= $2::timestamptz)
          AND ($3::timestamptz IS NULL OR t.block_time < $3::timestamptz)
          -- anti-abuse exclusions
          AND t.wallet <> c.campaign_address
          AND (c.creator_address IS NULL OR t.wallet <> c.creator_address)
          AND (c.fee_recipient_address IS NULL OR t.wallet <> c.fee_recipient_address)
          -- ensure "during bonding" when we have a graduation block
          AND (c.graduated_block IS NULL OR c.graduated_block = 0 OR t.block_number <= c.graduated_block)
        ORDER BY t.bnb_amount_raw::numeric DESC NULLS LAST
        LIMIT $4
        `,
        params
      );

      return json(res, 200, { items: rows, prize: prizeForCategory, epoch: epochMeta });
    }

    // -------------------------------------------------
    // Crowd Favorite (most upvotes)
    // -------------------------------------------------
    if (category === "crowd_favorite") {
      const params = [chainId, epochStartIso, rangeEndIso, limit];

      // Rank by total confirmed vote count first, then unique voters.
      const { rows } = await pool.query(
        `
        WITH agg AS (
          SELECT
            v.chain_id,
            v.campaign_address,
            COUNT(*)::bigint AS votes_count,
            COUNT(DISTINCT v.voter_address)::bigint AS unique_voters,
            COALESCE(SUM(v.amount_raw), 0)::numeric AS amount_raw_sum
          FROM public.votes_confirmed v
          WHERE v.chain_id = $1
            AND ($2::timestamptz IS NULL OR v.block_timestamp >= $2::timestamptz)
            AND ($3::timestamptz IS NULL OR v.block_timestamp < $3::timestamptz)
          GROUP BY v.chain_id, v.campaign_address
        )
        SELECT
          a.chain_id,
          a.campaign_address,
          c.name,
          c.symbol,
          c.logo_uri,
          c.creator_address,
          a.votes_count,
          a.unique_voters,
          a.amount_raw_sum
        FROM agg a
        JOIN public.campaigns c
          ON c.chain_id = a.chain_id
         AND c.campaign_address = a.campaign_address
        ORDER BY a.votes_count DESC, a.unique_voters DESC
        LIMIT $4
        `,
        params
      );

      return json(res, 200, { items: rows, prize: prizeForCategory, epoch: epochMeta });
    }

    // -------------------------------------------------
    // Top Earner (bonding curve trader PnL)
    // -------------------------------------------------
    // Locked rule update:
    // - trader (NOT campaign owner)
    // - realized net BNB profit from curve trades in the period
    //   profit = sum(sell payouts) - sum(buy costs)
    if (category === "top_earner") {
      if (periodNorm === "all_time") {
        return json(res, 200, { items: [], warning: "top_earner is paid weekly/monthly only", prize: prizeForCategory });
      }

      const params = [chainId, epochStartIso, rangeEndIso, limit];

      const { rows } = await pool.query(
        `
        WITH filtered AS (
          SELECT
            t.wallet,
            t.side,
            t.bnb_amount_raw::numeric AS bnb_raw
          FROM public.curve_trades t
          JOIN public.campaigns c
            ON c.chain_id = t.chain_id
           AND c.campaign_address = t.campaign_address
          WHERE t.chain_id = $1
            AND ($2::timestamptz IS NULL OR t.block_time >= $2::timestamptz)
            AND ($3::timestamptz IS NULL OR t.block_time < $3::timestamptz)
            -- exclude campaign/creator/feeRecipient wallets for that campaign
            AND t.wallet <> c.campaign_address
            AND (c.creator_address IS NULL OR t.wallet <> c.creator_address)
            AND (c.fee_recipient_address IS NULL OR t.wallet <> c.fee_recipient_address)
        ),
        agg AS (
          SELECT
            wallet,
            SUM(CASE WHEN side = 'sell' THEN bnb_raw ELSE 0 END)::numeric(78,0) AS sells_raw,
            SUM(CASE WHEN side = 'buy' THEN bnb_raw ELSE 0 END)::numeric(78,0) AS buys_raw,
            COUNT(*)::bigint AS trades_count
          FROM filtered
          GROUP BY wallet
        ),
        calc AS (
          SELECT
            wallet,
            (sells_raw - buys_raw)::numeric(78,0) AS profit_raw,
            sells_raw,
            buys_raw,
            trades_count
          FROM agg
        )
        SELECT wallet, profit_raw, sells_raw, buys_raw, trades_count
        FROM calc
        WHERE profit_raw > 0
        ORDER BY profit_raw DESC
        LIMIT $4
        `,
        params
      );

      return json(res, 200, { items: rows, prize: prizeForCategory, epoch: epochMeta });
    }

    return json(res, 200, { items: [], prize: prizeForCategory, epoch: epochMeta });
  } catch (e) {
    // If the DB schema hasn't been migrated yet, avoid breaking the UI with 500s.
    const code = e?.code;
    console.error("[api/league]", e);
    if (code === "42P01" || code === "42703") {
      return json(res, 200, { items: [], warning: "DB schema missing league columns/tables" });
    }
    return json(res, 500, { error: "Server error" });
  }
}
</file>

<file path="frontend/src/components/home/DiscoveryControls.tsx">
import { useEffect, useMemo, useState } from "react";
import type { ReactNode } from "react";

import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";

import type { FeedTabKey, HomeQuery } from "./CampaignGrid";
import { Filter, Flame, Sparkles, Timer, TrendingUp } from "lucide-react";

type DiscoveryControlsProps = {
  className?: string;
  query: HomeQuery;
  onChange: (next: HomeQuery) => void;
};

const TAB_DEFS: Array<{ key: FeedTabKey; label: string; icon: ReactNode }> = [
  { key: "trending", label: "Trending", icon: <TrendingUp className="h-4 w-4" /> },
  { key: "new", label: "New", icon: <Sparkles className="h-4 w-4" /> },
  { key: "ending", label: "Ending Soon", icon: <Timer className="h-4 w-4" /> },
  { key: "dex", label: "Trading on DEX", icon: <Flame className="h-4 w-4" /> },
];

const SORT_DEFS: Array<{ value: NonNullable<HomeQuery["sort"]>; label: string }> = [
  { value: "default", label: "Default" },
  { value: "mcap_desc", label: "Market Cap: High  Low" },
  { value: "mcap_asc", label: "Market Cap: Low  High" },
  { value: "votes_desc", label: "Upvotes (24h): High  Low" },
  { value: "progress_desc", label: "Progress: High  Low" },
  { value: "created_desc", label: "Created: New  Old" },
  { value: "created_asc", label: "Created: Old  New" },
];

function numOrUndef(s: string): number | undefined {
  const raw = String(s ?? "").trim();
  if (!raw) return undefined;
  const n = Number(raw);
  return Number.isFinite(n) ? n : undefined;
}

export function DiscoveryControls({ className, query, onChange }: DiscoveryControlsProps) {
  const searchValue = String(query.search ?? "");
  const timeChips = useMemo(() => ["1h", "24h", "7d", "all"] as const, []);

  const [filtersOpen, setFiltersOpen] = useState(false);

  const forcedStatus = query.tab === "ending" ? "live" : query.tab === "dex" ? "graduated" : null;

  const statusValue = forcedStatus ?? (query.status ?? "all");
  const sortValue = query.sort ?? "default";

  // local controlled strings for numeric inputs (avoid NaN churn)
  const [mcapMin, setMcapMin] = useState<string>(query.mcapMinUsd != null ? String(query.mcapMinUsd) : "");
  const [mcapMax, setMcapMax] = useState<string>(query.mcapMaxUsd != null ? String(query.mcapMaxUsd) : "");
  const [pMin, setPMin] = useState<string>(query.progressMinPct != null ? String(query.progressMinPct) : "");
  const [pMax, setPMax] = useState<string>(query.progressMaxPct != null ? String(query.progressMaxPct) : "");

  // Keep local strings in sync when query is reset externally.
  useEffect(() => {
    setMcapMin(query.mcapMinUsd != null ? String(query.mcapMinUsd) : "");
    setMcapMax(query.mcapMaxUsd != null ? String(query.mcapMaxUsd) : "");
    setPMin(query.progressMinPct != null ? String(query.progressMinPct) : "");
    setPMax(query.progressMaxPct != null ? String(query.progressMaxPct) : "");
  }, [query.mcapMinUsd, query.mcapMaxUsd, query.progressMinPct, query.progressMaxPct]);

  const applyNumericFilters = () => {
    onChange({
      ...query,
      mcapMinUsd: numOrUndef(mcapMin),
      mcapMaxUsd: numOrUndef(mcapMax),
      progressMinPct: numOrUndef(pMin),
      progressMaxPct: numOrUndef(pMax),
    });
  };

  const resetFilters = () => {
    setMcapMin("");
    setMcapMax("");
    setPMin("");
    setPMax("");
    onChange({
      ...query,
      status: "all",
      mcapMinUsd: undefined,
      mcapMaxUsd: undefined,
      progressMinPct: undefined,
      progressMaxPct: undefined,
      sort: "default",
    });
  };

  return (
    <div className={cn("w-full", className)}>
      {/* One row on desktop: Tabs + controls side-by-side */}
<div className="flex flex-col md:flex-row md:items-center md:justify-between gap-2">
  {/* Left: Tabs + time chips */}
  <div className="flex flex-wrap items-center gap-2">
    <div className="inline-flex rounded-xl border border-border/50 bg-card/40 p-1">
      {TAB_DEFS.map((t) => {
        const active = query.tab === t.key;
        return (
          <Button
            key={t.key}
            variant={active ? "default" : "ghost"}
            size="sm"
            className={cn(
              "gap-2 rounded-lg font-retro",
              active
                ? "bg-accent text-accent-foreground hover:bg-accent/90"
                : "text-muted-foreground hover:text-foreground"
            )}
            onClick={() => {
              const nextTab = t.key;
              const nextStatus =
                nextTab === "ending" ? "live" : nextTab === "dex" ? "graduated" : "all";
              onChange({ ...query, tab: nextTab, status: nextStatus });
            }}
          >
            {t.icon}
            <span className="hidden sm:inline">{t.label}</span>
          </Button>
        );
      })}
    </div>

    {/* Time chips (optional) */}
    <div className="hidden md:flex items-center gap-2">
      {timeChips.map((k) => {
        const active = (query.timeFilter ?? "24h") === k;
        return (
          <Button
            key={k}
            size="sm"
            variant={active ? "default" : "outline"}
            className={cn(
              "h-8 px-3 rounded-lg",
              active ? "bg-accent text-accent-foreground" : "text-muted-foreground"
            )}
            onClick={() => onChange({ ...query, timeFilter: k })}
          >
            {k}
          </Button>
        );
      })}
    </div>
  </div>

  {/* Right: Filters / Sort / Search */}
  <div className="flex flex-col md:flex-row md:items-center gap-2 w-full md:w-auto">
    <div className="inline-flex items-center gap-2">
      <Sheet open={filtersOpen} onOpenChange={setFiltersOpen}>
        <SheetTrigger asChild>
          <Button variant="outline" size="sm" className="gap-2">
            <Filter className="h-4 w-4" />
            Filters
          </Button>
        </SheetTrigger>

        {/* keep your SheetContent exactly as-is */}
        <SheetContent side="bottom" className="border-border/60">
          <SheetHeader>
            <SheetTitle>Filters</SheetTitle>
          </SheetHeader>

          <div className="mt-6 grid gap-5">
            <div className="grid gap-2">
              <Label>Status</Label>
              <Select
                value={statusValue}
                disabled={Boolean(forcedStatus)}
                onValueChange={(v) => onChange({ ...query, status: v as any })}
              >
                <SelectTrigger className="rounded-xl">
                  <SelectValue placeholder="All" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All</SelectItem>
                  <SelectItem value="live">Live</SelectItem>
                  <SelectItem value="graduated">Graduated</SelectItem>
                </SelectContent>
              </Select>
              {forcedStatus ? (
                <div className="text-xs text-muted-foreground">
                  Status is locked to <span className="font-medium">{forcedStatus}</span> for this tab.
                </div>
              ) : null}
            </div>

            <div className="grid gap-2">
              <Label>Market Cap (USD) range</Label>
              <div className="grid grid-cols-2 gap-3">
                <input
                  value={mcapMin}
                  onChange={(e) => setMcapMin(e.target.value)}
                  onBlur={applyNumericFilters}
                  placeholder="Min"
                  inputMode="decimal"
                  className="h-10 rounded-xl border border-border/50 bg-card/40 px-3 text-sm outline-none focus:ring-2 focus:ring-accent/30"
                />
                <input
                  value={mcapMax}
                  onChange={(e) => setMcapMax(e.target.value)}
                  onBlur={applyNumericFilters}
                  placeholder="Max"
                  inputMode="decimal"
                  className="h-10 rounded-xl border border-border/50 bg-card/40 px-3 text-sm outline-none focus:ring-2 focus:ring-accent/30"
                />
              </div>
              <div className="text-xs text-muted-foreground">
                Uses best-effort BNB/USD conversion. If price is unavailable, Market Cap filtering may hide unknown values.
              </div>
            </div>

            <div className="grid gap-2">
              <Label>Progress (%) range</Label>
              <div className="grid grid-cols-2 gap-3">
                <input
                  value={pMin}
                  onChange={(e) => setPMin(e.target.value)}
                  onBlur={applyNumericFilters}
                  placeholder="Min"
                  inputMode="decimal"
                  className="h-10 rounded-xl border border-border/50 bg-card/40 px-3 text-sm outline-none focus:ring-2 focus:ring-accent/30"
                />
                <input
                  value={pMax}
                  onChange={(e) => setPMax(e.target.value)}
                  onBlur={applyNumericFilters}
                  placeholder="Max"
                  inputMode="decimal"
                  className="h-10 rounded-xl border border-border/50 bg-card/40 px-3 text-sm outline-none focus:ring-2 focus:ring-accent/30"
                />
              </div>
            </div>

            <div className="flex items-center justify-between gap-2 pt-2">
              <Button variant="outline" onClick={resetFilters}>
                Reset
              </Button>
              <Button
                className="bg-accent text-accent-foreground hover:bg-accent/90"
                onClick={() => {
                  applyNumericFilters();
                  setFiltersOpen(false);
                }}
              >
                Apply
              </Button>
            </div>
          </div>
        </SheetContent>
      </Sheet>

      <div className="hidden sm:block shrink-0 w-[220px]">
        <Select value={sortValue} onValueChange={(v) => onChange({ ...query, sort: v as any })}>
          <SelectTrigger className="h-9 rounded-xl border-border/50 bg-card/40">
            <SelectValue placeholder="Sort" />
          </SelectTrigger>
          <SelectContent>
            {SORT_DEFS.map((s) => (
              <SelectItem key={s.value} value={s.value}>
                {s.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </div>
  </div>
</div>

    </div>
  );
}
</file>

<file path="frontend/src/components/home/HeaderBand.tsx">
import { cn } from "@/lib/utils";

type HeaderBandProps = {
  className?: string;
};

export function HeaderBand({ className }: HeaderBandProps) {
  return (
    <div className={cn("relative w-full", className)}>
      {/* Glow strip / separator */}
      {/* Slightly shorter hero height to reduce dead space above Featured grid */}
      <div className="relative h-[240px] md:h-[260px] lg:h-[280px] overflow-hidden">

        {/* horizontal highlight band */}
        <div className="absolute left-0 right-0 top-1/2 -translate-y-1/2">
          <div
            className="h-[10px] md:h-[10px] opacity-90"
            style={{
              background:
                "linear-gradient(90deg, rgba(0,0,0,0) 0%, rgba(255,229,92,0.7) 25%, rgba(255,159,28,0.8) 50%, rgba(255,59,59,0.75) 75%, rgba(0,0,0,0) 100%)",
              filter: "blur(0.2px)",
            }}
          />
          <div
            className="h-px"
            style={{
              background:
                "linear-gradient(90deg, rgba(0,0,0,0) 0%, rgba(255,229,92,0.35) 25%, rgba(255,159,28,0.45) 50%, rgba(255,59,59,0.35) 75%, rgba(0,0,0,0) 100%)",
            }}
          />
        </div>

        {/* centered logo */}
        <div className="absolute inset-0 flex items-center justify-center">
          <img
            src="/assets/logo.png"
            alt="Meme Battles"
            className="h-[240px] md:h-[260px] lg:h-[280px] w-auto drop-shadow-[0_0_18px_rgba(255,160,0,0.35)]"
            draggable={false}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/TokenDetails.tsx">
/**
 * Token Details Page
 * Displays comprehensive information about a specific token including
 * chart, trading interface, transactions, and holder distribution
 */

import { useEffect, useMemo, useRef, useState } from "react";
import { Link, useParams } from "react-router-dom";
import { Copy, ExternalLink, Globe, ChevronDown } from "lucide-react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { useToast } from "@/hooks/use-toast";
import twitterIcon from "@/assets/social/twitter.png";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignInfo, CampaignMetrics, CampaignSummary, CampaignActivity } from "@/lib/launchpadClient";
import { getActiveChainId } from "@/lib/chainConfig";
import { useDexScreenerChart } from "@/hooks/useDexScreenerChart";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { useTokenStatsRealtime } from "@/hooks/useTokenStatsRealtime";
import { CurvePriceChart } from "@/components/token/CurvePriceChart";
import { TokenComments } from "@/components/token/TokenComments";
import { AthBar } from "@/components/token/AthBar";
import { UpvoteDialog } from "@/components/token/UpvoteDialog";
import { useWallet } from "@/hooks/useWallet";
import { useCurveTrades, type CurveTradePoint } from "@/hooks/useCurveTrades";
import { Contract, ethers } from "ethers";
import LaunchCampaignArtifact from "@/abi/LaunchCampaign.json";
import LaunchTokenArtifact from "@/abi/LaunchToken.json";
import { fetchUserProfile, type UserProfile } from "@/lib/profileApi";

const CAMPAIGN_ABI = LaunchCampaignArtifact.abi as ethers.InterfaceAbi;
const TOKEN_ABI = LaunchTokenArtifact.abi as ethers.InterfaceAbi;
const TOKEN_DECIMALS = 18;
const SLIPPAGE_PCT = 5;
const MAX_UINT256 = (1n << 256n) - 1n;

// This is the UI table row shape (NOT the on-chain CurveTrade shape)
type TxRow = {
  id: string;
  time: string;
  type: "buy" | "sell";
  amount: string;
  bnb: string;
  price: string;
  mcap: string;
  maker: string;
  makerAddress: string;
  txHash: string;
};

function getExplorerBase(chainId?: number): string {
  const id = Number(chainId ?? 0);
  if (id === 56) return "https://bscscan.com";
  if (id === 97) return "https://testnet.bscscan.com";
  // Sensible default
  return "https://bscscan.com";
}

function shortenAddress(addr?: string | null): string {
  const a = String(addr ?? "").trim();
  if (!a) return "";
  if (a.length <= 10) return a;
  return `${a.slice(0, 6)}${a.slice(-4)}`;
}

function formatTimeAgo(ts?: number | null): string {
  if (ts == null) return "";
  const raw = Number(ts);
  if (!Number.isFinite(raw) || raw <= 0) return "";

  // tolerate ms timestamps
  const seconds = raw > 1e11 ? Math.floor(raw / 1000) : Math.floor(raw);
  const nowSec = Math.floor(Date.now() / 1000);
  const diff = Math.max(0, nowSec - seconds);

  if (diff < 60) return "just now";
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
  if (diff < 604800) return `${Math.floor(diff / 86400)}d ago`;
  return `${Math.floor(diff / 604800)}w ago`;
}

const TokenDetails = () => {
  // URL param: /token/:campaignAddress  (address-based)
  const { campaignAddress } = useParams<{ campaignAddress: string }>();

  const { toast } = useToast();
  const [tradeAmount, setTradeAmount] = useState("0");

  const [tradeInputDenom, setTradeInputDenom] = useState<"TOKEN" | "BNB">("TOKEN");
  const toggleTradeInputDenom = () => {
    setTradeAmount("0");
    setQuoteWei(null);
    setQuoteError(null);
    setTradeInputDenom((d) => (d === "TOKEN" ? "BNB" : "TOKEN"));
  };
  const [effectiveTokenWei, setEffectiveTokenWei] = useState<bigint>(0n);
  const [effectiveBnbWei, setEffectiveBnbWei] = useState<bigint>(0n);
  const [tradeTab, setTradeTab] = useState<"buy" | "sell">("buy");
  const handleTradeTabChange = (value: string) => {
    setTradeTab(value as "buy" | "sell");
  };
  const [selectedTimeframe, setSelectedTimeframe] = useState<
    "5m" | "1h" | "4h" | "24h"
  >("24h");

  const [displayDenom, setDisplayDenom] = useState<"USD" | "BNB">(() => {
    try {
      const saved = localStorage.getItem("launchit:displayDenom");
      if (saved === "USD" || saved === "BNB") return saved;

      // Backward-compat: older builds stored this under a market-cap specific key.
      const legacy = localStorage.getItem("launchit:mcDenom");
      if (legacy === "USD" || legacy === "BNB") return legacy;

      return "USD";
    } catch {
      return "USD";
    }
  });
  const [metricsExpanded, setMetricsExpanded] = useState(false);
  const isMobile = window.innerWidth < 768;

  useEffect(() => {
    try {
      localStorage.setItem("launchit:displayDenom", displayDenom);
    } catch {
      // ignore
    }
  }, [displayDenom]);

  // Launchpad hooks + state for the on-chain data
  const { fetchCampaigns, fetchCampaignSummary, fetchCampaignMetrics, fetchCampaignActivity, buyTokens, sellTokens } = useLaunchpad();
  const wallet = useWallet();
  const chainIdForStorage = useMemo(() => getActiveChainId(wallet.chainId), [wallet.chainId]);
  const [campaign, setCampaign] = useState<CampaignInfo | null>(null);
  const [metrics, setMetrics] = useState<CampaignMetrics | null>(null);
  const [summary, setSummary] = useState<CampaignSummary | null>(null);
  const [activity, setActivity] = useState<CampaignActivity | null>(null);
  const [activityTab, setActivityTab] = useState<"comments" | "trades">("comments");
  const [curveReserveWei, setCurveReserveWei] = useState<bigint | null>(null);

  // UI rows for the transactions table
  const [txs, setTxs] = useState<TxRow[]>([]);

  // Maker profiles for the Trades tab (best-effort; cached per address)
  const [makerProfiles, setMakerProfiles] = useState<Record<string, UserProfile | null>>({});

  // Creator profile (best-effort; used in the header)
  const [creatorProfile, setCreatorProfile] = useState<UserProfile | null>(null);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Trading (quote + balances)
  const [quoteWei, setQuoteWei] = useState<bigint | null>(null);
  const [quoteLoading, setQuoteLoading] = useState(false);
  const [quoteError, setQuoteError] = useState<string | null>(null);
  const [tradePending, setTradePending] = useState(false);
  const [approvePending, setApprovePending] = useState(false);
  const [bnbBalanceWei, setBnbBalanceWei] = useState<bigint | null>(null);
  const [tokenBalanceWei, setTokenBalanceWei] = useState<bigint | null>(null);

  // Fetch maker profiles for displayed trades (best-effort; do not block UI)
  useEffect(() => {
    const chainIdNum = Number(wallet.chainId ?? 97);
    if (!txs.length) return;

    const uniq = Array.from(
      new Set(
        txs
          .map((t) => (t.makerAddress ? String(t.makerAddress).toLowerCase() : ""))
          .filter(Boolean)
      )
    );

    const missing = uniq.filter((a) => makerProfiles[a] === undefined).slice(0, 30);
    if (!missing.length) return;

    let cancelled = false;
    (async () => {
      for (const addr of missing) {
        try {
          const p = await fetchUserProfile(chainIdNum, addr);
          if (cancelled) return;
          setMakerProfiles((prev) => ({ ...prev, [addr]: p }));
        } catch {
          if (cancelled) return;
          setMakerProfiles((prev) => ({ ...prev, [addr]: null }));
        }
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [txs, wallet.chainId, makerProfiles]);

  // Fetch creator profile (best-effort; do not block UI)
  useEffect(() => {
    const creator = String(campaign?.creator ?? "").trim();
    if (!creator) {
      setCreatorProfile(null);
      return;
    }

    const chainIdNum = Number(wallet.chainId ?? 97);
    let cancelled = false;

    (async () => {
      try {
        const p = await fetchUserProfile(chainIdNum, creator);
        if (cancelled) return;
        setCreatorProfile(p);
      } catch {
        if (cancelled) return;
        setCreatorProfile(null);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [campaign?.creator, wallet.chainId]);

  // Load campaign + metrics based on :campaignAddress (preferred).
  // Backward-compatible fallback: if param is not a 0x address, treat it as symbol.
  useEffect(() => {
    const load = async () => {
      if (!campaignAddress) return;

      try {
        setLoading(true);
        setError(null);

        const campaigns = await fetchCampaigns();

        if (!campaigns || campaigns.length === 0) {
          setError("No token data");
          setCampaign(null);
          setMetrics(null);
          setSummary(null);
          return;
        }

        const param = campaignAddress.trim();
        const isAddress = /^0x[a-fA-F0-9]{40}$/.test(param);

        const match = isAddress
          ? campaigns.find((c) => (c.campaign ?? "").toLowerCase() === param.toLowerCase())
          : campaigns.find((c) => (c.symbol ?? "").toLowerCase() === param.toLowerCase());

        if (!match) {
          setError("Token not found");
          setCampaign(null);
          setMetrics(null);
          setSummary(null);
          return;
        }

        setCampaign(match);

        // Unified token stats + metrics (same source as carousel / UP Dashboard)
        const s = await fetchCampaignSummary(match);
        setSummary(s);
        setMetrics(s.metrics ?? null);
      } catch (err) {
        console.error(err);
        setError("Failed to load token data");
      } finally {
        setLoading(false);
      }
    };

    load();
  }, [campaignAddress, fetchCampaigns, fetchCampaignSummary]);

  const formatPriceFromWei = (wei?: bigint | null): string => {
    if (wei == null) return "";
    try {
      const raw = ethers.formatUnits(wei, 18);
      const n = Number(raw);
      if (!Number.isFinite(n)) return `${raw} BNB`;
      const pretty = n >= 1 ? n.toFixed(2) : n >= 0.01 ? n.toFixed(4) : n.toFixed(6);
      return `${pretty} BNB`;
    } catch {
      return "";
    }
  };

  const formatBnbFromWei = (wei?: bigint | null): string => {
    if (wei == null) return "";
    try {
      const raw = ethers.formatEther(wei);
      const n = Number(raw);
      if (!Number.isFinite(n)) return `${raw} BNB`;
      const pretty = n >= 1 ? n.toFixed(2) : n >= 0.01 ? n.toFixed(4) : n.toFixed(6);
      return `${pretty} BNB`;
    } catch {
      return "";
    }
  };

  const formatTokenFromWei = (wei?: bigint | null): string => {
    if (wei == null) return "";
    try {
      const raw = ethers.formatUnits(wei, TOKEN_DECIMALS);
      const n = Number(raw);
      if (!Number.isFinite(n)) return raw;
      const pretty = n >= 1 ? n.toFixed(4) : n >= 0.01 ? n.toFixed(6) : n.toFixed(8);
      return pretty;
    } catch {
      return "";
    }
  };
  const parseBnbLabel = (input?: string | null): number | null => {
    if (!input) return null;
    const s = String(input).trim();
    if (!s || s === "") return null;

    // Accept forms like:
    //  - "0.1234 BNB"
    //  - "1.23k BNB"
    //  - "1.23k"
    //  - "0.000123"
    
    // IMPORTANT: avoid treating the leading "B" in "BNB" as a suffix.

    const token = s.split(/\s+/)[0] ?? "";

    const m = token.match(/^(-?\d+(?:\.\d+)?)([kKmMbBtT])?$/);
    if (!m) return null;
    const num = Number(m[1]);
    if (!Number.isFinite(num)) return null;

    const suf = (m[2] ?? "").toLowerCase();
    const mult = suf === "k" ? 1e3 : suf === "m" ? 1e6 : suf === "b" ? 1e9 : suf === "t" ? 1e12 : 1;
    return num * mult;
  };

  const formatCompactUsd = (usd: number): string => {
    if (!Number.isFinite(usd)) return "";
    const abs = Math.abs(usd);

    const fmt = (v: number, suffix: string) => {
      const decimals = v >= 100 ? 0 : v >= 10 ? 1 : 2;
      return `$${v.toFixed(decimals)}${suffix}`;
    };

    if (abs >= 1e12) return fmt(usd / 1e12, "T");
    if (abs >= 1e9) return fmt(usd / 1e9, "B");
    if (abs >= 1e6) return fmt(usd / 1e6, "M");
    if (abs >= 1e3) return fmt(usd / 1e3, "K");

    // Small values: show up to 2 decimals
    const decimals = abs >= 1 ? 2 : abs >= 0.01 ? 4 : 6;
    return `$${usd.toFixed(decimals)}`;
  };



  const parseTokenAmountWei = (value: string): bigint => {
    const v = (value ?? "").trim();
    if (!v || v === "." || v === "-") return 0n;
    // Only allow digits + a single decimal separator
    const cleaned = v.replace(/,/g, ".").replace(/[^0-9.]/g, "");
    const parts = cleaned.split(".");
    const normalized = parts.length <= 2 ? cleaned : parts[0] + "." + parts.slice(1).join("");
    try {
      return ethers.parseUnits(normalized || "0", TOKEN_DECIMALS);
    } catch {
      return 0n;
    }
  };


  const parseBnbAmountWei = (value: string): bigint => {
    const v = (value ?? "").trim();
    if (!v || v === "." || v === "-") return 0n;
    const cleaned = v.replace(/,/g, ".").replace(/[^0-9.]/g, "");
    const parts = cleaned.split(".");
    const normalized = parts.length <= 2 ? cleaned : parts[0] + "." + parts.slice(1).join("");
    try {
      return ethers.parseEther(normalized || "0");
    } catch {
      return 0n;
    }
  };

  const formatPriceBnb = (p?: number | null): string => {
    if (p == null || !Number.isFinite(p)) return "";
    const pretty =
      p >= 1 ? p.toFixed(2) : p >= 0.01 ? p.toFixed(6) : p.toFixed(8);
    return `${pretty} BNB`;
  };

  // Format a BNB amount (number) consistently across the UI.
  const formatBnb = (n?: number | null): string => {
    if (n == null || !Number.isFinite(n)) return "";
    const pretty = n >= 1 ? n.toFixed(2) : n >= 0.01 ? n.toFixed(4) : n.toFixed(6);
    return `${pretty} BNB`;
  };

  const shorten = (addr?: string): string => {
    if (!addr) return "";
    return addr.length > 10 ? `${addr.slice(0, 4)}...${addr.slice(-4)}` : addr;
  };

  const formatCompact = (n: number): string => {
    if (!Number.isFinite(n)) return "";
    const abs = Math.abs(n);
    if (abs >= 1e12) return `${(n / 1e12).toFixed(2)}t`;
    if (abs >= 1e9) return `${(n / 1e9).toFixed(2)}b`;
    if (abs >= 1e6) return `${(n / 1e6).toFixed(2)}m`;
    if (abs >= 1e3) return `${(n / 1e3).toFixed(2)}k`;
    if (abs >= 1) return n.toFixed(2);
    if (abs >= 0.01) return n.toFixed(4);
    if (abs >= 0.0001) return n.toFixed(6);
    return n.toFixed(8);
  };

  const formatAgo = (timestampSecs?: number): string => {
    if (!timestampSecs) return "";
    const now = Math.floor(Date.now() / 1000);
    const diff = Math.max(0, now - timestampSecs);
    if (diff < 60) return "now";
    const mins = Math.floor(diff / 60);
    if (mins < 60) return `${mins}m`;
    const hours = Math.floor(mins / 60);
    if (hours < 24) return `${hours}h`;
    const days = Math.floor(hours / 24);
    if (days < 7) return `${days}d`;
    const weeks = Math.floor(days / 7);
    return `${weeks}w`;
  };

  // Read curve trades for transactions + analytics (live mode)
  // Hook returns CurveTrade[] (your "@/types/token" Transaction type)
  const { points: liveCurvePoints, loading: liveCurveLoading, error: liveCurveError } = useCurveTrades(campaign?.campaign);
  const liveCurvePointsSafe: CurveTradePoint[] = Array.isArray(liveCurvePoints) ? liveCurvePoints : [];

  // Prevent chart flicker: keep last non-empty curve points while the live hook briefly refreshes/resets.
  const lastCurvePointsRef = useRef<CurveTradePoint[]>([]);
  useEffect(() => {
    if (liveCurvePointsSafe.length) lastCurvePointsRef.current = liveCurvePointsSafe;
  }, [liveCurvePointsSafe]);

  const curvePointsForUi: CurveTradePoint[] = useMemo(() => {
    return liveCurvePointsSafe.length ? liveCurvePointsSafe : lastCurvePointsRef.current;
  }, [liveCurvePointsSafe]);

  // Realtime stats from Railway (price/marketcap/24h vol), patched via Ably.
  const { stats: rtStats } = useTokenStatsRealtime(
    campaign?.campaign ?? campaignAddress,
    wallet.chainId
  );
const toSeconds = (ts: number): number => {
  if (!Number.isFinite(ts) || ts <= 0) return 0;
  // If it looks like milliseconds, convert to seconds.
  return ts > 1e11 ? Math.floor(ts / 1000) : Math.floor(ts);
};
  type TimeframeKey = "5m" | "1h" | "4h" | "24h";
  const timeframeTiles = useMemo(() => {
    const now = Math.floor(Date.now() / 1000);
    const windows: Record<TimeframeKey, number> = {
      "5m": 5 * 60,
      "1h": 60 * 60,
      "4h": 4 * 60 * 60,
      "24h": 24 * 60 * 60,
    };

    // End price: prefer realtime last trade price, else on-chain price, else latest trade price
    const endPrice =
      (rtStats?.lastPriceBnb != null ? Number(rtStats.lastPriceBnb) : undefined) ??
      (metrics?.currentPrice ? Number(ethers.formatUnits(metrics.currentPrice, 18)) : undefined);

    const isGraduated = Boolean(
  metrics && metrics.graduationTarget > 0n && metrics.sold >= metrics.graduationTarget
);

    // IMPORTANT:
    // - In live mode, useCurveTrades already provides pricePerToken as a NUMBER (BNB per token)
    // - Do NOT ethers.formatEther(pricePerToken) here.
    const points: Array<{ timestamp: number; pricePerToken: number; nativeWei?: bigint }> =
  liveCurvePointsSafe.map((p: any) => ({
    timestamp: Number(p.timestamp ?? 0),
    pricePerToken: typeof p.pricePerToken === "number" ? p.pricePerToken : Number(p.pricePerToken ?? 0),
    nativeWei: p.nativeWei,
  }));

    if (!points.length && endPrice == null) {
      return {
        "5m": { change: null as number | null, volume: "" },
        "1h": { change: null as number | null, volume: "" },
        "4h": { change: null as number | null, volume: "" },
        "24h": { change: null as number | null, volume: "" },
      };
    }

    const tsOf = (t: number) => (t > 1e11 ? Math.floor(t / 1000) : t); // tolerate ms timestamps
    const sorted = [...points].sort((a, b) => tsOf(a.timestamp) - tsOf(b.timestamp));
    const latestTradePrice = sorted[sorted.length - 1]?.pricePerToken;
    const end = endPrice ?? latestTradePrice ?? 0;

    const out: Record<TimeframeKey, { change: number | null; volume: string }> = {
      "5m": { change: null, volume: "" },
      "1h": { change: null, volume: "" },
      "4h": { change: null, volume: "" },
      "24h": { change: null, volume: "" },
    };

    for (const k of Object.keys(windows) as TimeframeKey[]) {
      const startTs = now - windows[k];

      // Start price: last trade at/before the window start, else first trade in the window.
      const before = [...sorted].reverse().find((p) => tsOf(p.timestamp) <= startTs);
      const within = sorted.find((p) => tsOf(p.timestamp) >= startTs);
      const startPrice = (before ?? within)?.pricePerToken;

      const volumeWei = sorted
        .filter((p) => tsOf(p.timestamp) >= startTs)
        .reduce((acc, p) => acc + (p.nativeWei ?? 0n), 0n);

      const start = startPrice ?? end;
      if (start > 0 && end > 0) {
        const pct = ((end - start) / start) * 100;
        out[k].change = Number.isFinite(pct) ? Number(pct.toFixed(2)) : null;
      } else {
        out[k].change = null;
      }

      out[k].volume = points.length ? formatBnbFromWei(volumeWei) : "";
    }

    return out;
  }, [campaign?.symbol, liveCurvePointsSafe, metrics]);

  // Token view-model used throughout the page
  const tokenData = useMemo(() => {
    const ticker = campaign?.symbol ?? "";
    const name = campaign?.name ?? "Token";
    const stats = summary?.stats;

    const rtMarketCap = rtStats?.marketcapBnb;
    const rtPrice = rtStats?.lastPriceBnb;

    return {
      image: campaign?.logoURI || "/placeholder.svg",
      ticker,
      name,
      hasWebsite: Boolean(campaign?.website && campaign.website.length > 0),
      hasTwitter: Boolean(campaign?.xAccount && campaign.xAccount.length > 0),

      // Unified headline stats
      marketCap:
        rtMarketCap != null && Number.isFinite(rtMarketCap)
          ? `${formatCompact(rtMarketCap)} BNB`
          : stats?.marketCap ?? "",
      volume: stats?.volume ?? "",
      holders: stats?.holders ?? "",
      price:
        rtPrice != null && Number.isFinite(rtPrice)
          ? formatPriceBnb(rtPrice)
          : formatPriceFromWei(metrics?.currentPrice ?? null),
      liquidity: formatBnbFromWei(curveReserveWei),

      // Timeframe analytics (BNB volume + price change)
      metrics: timeframeTiles,
    };
  }, [campaign, curveReserveWei, metrics, summary, timeframeTiles, rtStats]);
  // Keep USD reference price available for UI conversions and ATH tracking.
  // (Cached + throttled inside the hook.)
  const { price: bnbUsdPrice, loading: bnbUsdLoading } = useBnbUsdPrice(true);

// Normalize in case the hook returns a scaled value (e.g., 1e18-based).
const bnbUsd = useMemo(() => {
  if (bnbUsdPrice == null) return null;
  const n = Number(bnbUsdPrice);
  if (!Number.isFinite(n) || n <= 0) return null;

  // BNB price in USD should never be anywhere near 100k+. If it is, it's almost certainly scaled.
  if (n > 100_000) return n / 1e18;

  return n;
}, [bnbUsdPrice]);

  const marketCapDisplay = useMemo(() => {
    const bnbLabel = tokenData.marketCap;

    if (displayDenom === "BNB") return bnbLabel;

    const raw = rtStats?.marketcapBnb;
    const mcBnb = raw != null && Number.isFinite(raw) ? Number(raw) : parseBnbLabel(bnbLabel);
    if (mcBnb == null) return "";

    if (!bnbUsd) return bnbUsdLoading ? "" : "";

    return formatCompactUsd(mcBnb * bnbUsd);
  }, [displayDenom, tokenData.marketCap, rtStats?.marketcapBnb, bnbUsd, bnbUsdLoading]);

  // Always-USD market cap label for ATH tracking (independent of the denomination toggle).
  // IMPORTANT: Use raw numeric marketcapBnb when available; never parse from a formatted label.
  const marketCapUsdLabel = useMemo(() => {
    const raw = rtStats?.marketcapBnb;
    const mcBnb = raw != null && Number.isFinite(raw) ? Number(raw) : parseBnbLabel(tokenData.marketCap);
    if (mcBnb == null) return null;
    if (!bnbUsd) return null;
    const usd = mcBnb * bnbUsd;
    return Number.isFinite(usd) && usd > 0 ? formatCompactUsd(usd) : null;
  }, [tokenData.marketCap, rtStats?.marketcapBnb, bnbUsd]);

  const priceDisplay = useMemo(() => {
    const bnbLabel = tokenData.price;

    if (displayDenom === "BNB") return bnbLabel;

    const priceBnb = parseBnbLabel(bnbLabel);
    if (priceBnb == null) return "";

    if (!bnbUsdPrice) return bnbUsdLoading ? "" : "";

    return formatCompactUsd(priceBnb * bnbUsdPrice);
  }, [displayDenom, tokenData.price, bnbUsdPrice, bnbUsdLoading]);

  const volumeDisplay = useMemo(() => {
    const bnbLabel = tokenData.metrics[selectedTimeframe]?.volume ?? "";

    if (displayDenom === "BNB") return bnbLabel;

    const volBnb = parseBnbLabel(bnbLabel);
    if (volBnb == null) return "";

    if (!bnbUsdPrice) return bnbUsdLoading ? "" : "";

    return formatCompactUsd(volBnb * bnbUsdPrice);
  }, [displayDenom, tokenData.metrics, selectedTimeframe, bnbUsdPrice, bnbUsdLoading]);

  const formatBnbOrUsd = useMemo(() => {
    return (bnb: number | null | undefined): string => {
      if (bnb == null || !Number.isFinite(bnb)) return "";
      if (displayDenom === "BNB") return `${formatCompact(bnb)} BNB`;
      if (!bnbUsdPrice) return bnbUsdLoading ? "" : "";
      return formatCompactUsd(bnb * bnbUsdPrice);
    };
  }, [displayDenom, bnbUsdPrice, bnbUsdLoading]);

  const flywheel = useMemo(() => {
    const buyVolBnb = activity ? Number(ethers.formatEther(activity.buyVolumeWei)) : null;
    const sellVolBnb = activity ? Number(ethers.formatEther(activity.sellVolumeWei)) : null;
    const netFlowBnb = buyVolBnb != null && sellVolBnb != null ? buyVolBnb - sellVolBnb : null;

    const feeBps = metrics ? Number(metrics.protocolFeeBps) : 0;
    const feesBnb = buyVolBnb != null && sellVolBnb != null ? (buyVolBnb + sellVolBnb) * (feeBps / 10000) : null;

    return {
      buyVolume: formatBnbOrUsd(buyVolBnb),
      sellVolume: formatBnbOrUsd(sellVolBnb),
      netFlow: formatBnbOrUsd(netFlowBnb),
      feesEstimated: formatBnbOrUsd(feesBnb),
      buyers: activity ? String(activity.buyers) : "",
      feeRate: metrics ? `${(Number(metrics.protocolFeeBps) / 100).toFixed(2)}%` : "",
      lpRate: metrics ? `${(Number(metrics.liquidityBps) / 100).toFixed(2)}%` : "",
    };
  }, [activity, metrics, formatBnbOrUsd]);

  const holderDistribution = useMemo(() => {
    const shortAddr = (a: string) =>
      a && a.length > 12 ? `${a.slice(0, 6)}${a.slice(-4)}` : a;

    // Estimated balances derived from bonding curve trades only (no transfers).
    // NOTE: This is a best-effort view and does not include transfers.
    const balances = new Map<string, bigint>();

    for (const p of liveCurvePointsSafe) {
      const addr = (p.from || "").toLowerCase();
      if (!addr) continue;

      const prev = balances.get(addr) ?? 0n;
      const delta = p.tokensWei ?? 0n; // tokensWei
      const isBuy = (p.type ?? "buy") === "buy"; // type
      balances.set(addr, isBuy ? prev + delta : prev - delta);
    }

    const holders = [...balances.entries()]
      .filter(([, bal]) => bal > 0n)
      .map(([address, bal]) => ({ address, bal }))
      .sort((a, b) => (a.bal === b.bal ? 0 : a.bal > b.bal ? -1 : 1));

    const holdersBal = holders.reduce((acc, x) => acc + x.bal, 0n);

    // Liquidity pool allocation (token wei) from on-chain metrics (if present).
    // This is the amount intended for the LP at graduation.
    const lpBal = metrics?.liquiditySupply ?? 0n;

    const totalBal = holdersBal + lpBal;

    const pct = (bal: bigint) => (totalBal > 0n ? Number((bal * 10000n) / totalBal) / 100 : 0);

    const topUsers = holders.slice(0, 6).map((h) => ({
      address: h.address,
      label: shortAddr(h.address),
      pct: pct(h.bal),
      isLp: false as const,
    }));

    const othersBal = holders.slice(6).reduce((acc, x) => acc + x.bal, 0n);

    const top = [
      ...(lpBal > 0n
        ? [
            {
              address: "liquidity-pool",
              label: "Liquidity pool",
              pct: pct(lpBal),
              isLp: true as const,
            },
          ]
        : []),
      ...topUsers,
    ];

    return {
      top,
      othersPct: pct(othersBal),
      totalHolders: holders.length,
      hasLp: lpBal > 0n,
    };
  }, [liveCurvePointsSafe, metrics?.liquiditySupply]);


  // Reserve / "liquidity" shown on the page: BNB held by the campaign contract (pre-graduation)
  useEffect(() => {
    let cancelled = false;

    const loadReserve = async () => {
      try {
          if (!wallet.provider || !campaign?.campaign) {
          setCurveReserveWei(null);
          return;
        }
        const bal = await wallet.provider.getBalance(campaign.campaign);
        if (!cancelled) setCurveReserveWei(bal);
      } catch (e) {
        console.warn("[TokenDetails] Failed to load campaign reserve", e);
        if (!cancelled) setCurveReserveWei(null);
      }
    };

    loadReserve();
    return () => {
      cancelled = true;
    };
  }, [wallet.provider, campaign?.campaign]);

  // Campaign activity counters (buy/sell volume, buyers). Used for Flywheel and related panels.
  useEffect(() => {
    let cancelled = false;

    const loadActivity = async () => {
      try {
        if (!campaign?.campaign) {
          setActivity(null);
          return;
        }
        const a = await fetchCampaignActivity(campaign.campaign);
        if (!cancelled) setActivity(a);
      } catch (e) {
        console.warn("[TokenDetails] Failed to load campaign activity", e);
        if (!cancelled) setActivity(null);
      }
    };

    loadActivity();
    const t = setInterval(loadActivity, 60_000);
    return () => {
      cancelled = true;
      clearInterval(t);
    };
  }, [campaign?.campaign, fetchCampaignActivity]);

  // Wallet balances (for the trading panel)
  useEffect(() => {
    let cancelled = false;

    const loadBalances = async () => {
      try {
        if (!wallet.provider || !wallet.account) {
          setBnbBalanceWei(null);
          setTokenBalanceWei(null);
          return;
        }

        const [bnbBal, tokenBal] = await Promise.all([
          wallet.provider.getBalance(wallet.account),
          (async () => {
            try {
              if (!campaign?.token) return 0n;
              const t = new Contract(campaign.token, TOKEN_ABI, wallet.provider) as any;
              return (await t.balanceOf(wallet.account)) as bigint;
            } catch {
              return 0n;
            }
          })(),
        ]);

        if (!cancelled) {
          setBnbBalanceWei(bnbBal);
          setTokenBalanceWei(tokenBal);
        }
      } catch (e) {
        console.warn("[TokenDetails] Failed to load balances", e);
        if (!cancelled) {
          setBnbBalanceWei(null);
          setTokenBalanceWei(null);
        }
      }
    };

    loadBalances();

    return () => {
      cancelled = true;
    };
  }, [wallet.provider, wallet.account, campaign?.token]);

  // Build transactions table rows.
  useEffect(() => {
    if (!campaign) {
      setTxs([]);
      return;
    }
    // LIVE MODE: useCurveTrades() points are CurveTrade objects (type/from/tokensWei/nativeWei/pricePerToken/timestamp/txHash)
    const mcap = tokenData.marketCap ?? "";

    const next: TxRow[] = [...liveCurvePointsSafe]
  .slice(-50)
  .reverse()
  .map((p: any, idx: number) => {
    const tokenAmount = Number(ethers.formatUnits(p.tokensWei ?? 0n, TOKEN_DECIMALS));
    const bnb = Number(ethers.formatEther(p.nativeWei ?? 0n));
    const bnbStr = Number.isFinite(bnb) ? `${bnb.toFixed(4)} BNB` : "";

    const priceNum = typeof p.pricePerToken === "number" ? p.pricePerToken : Number(p.pricePerToken ?? 0);
    const priceStr = formatPriceBnb(priceNum);

    const txHash = String(p.txHash ?? "");
    const ts = Number(p.timestamp ?? 0);
    const id = txHash || `${ts}-${idx}`;

    return {
      id,
      time: formatAgo(ts),
      type: (p.type ?? "buy") as "buy" | "sell",
      amount: formatCompact(tokenAmount),
      bnb: bnbStr,
      price: priceStr,
      mcap,
      maker: shorten(p.from),
      makerAddress: String(p.from ?? ""),
      txHash,
    };
  });

setTxs(next);
  }, [campaign, liveCurvePointsSafe, tokenData.marketCap, metrics]);

  // DexScreener gating: only show external DEX chart after graduation / finalize.
  // Prefer explicit flags when available; fall back to sold >= graduationTarget for older deployments.
  const hasLaunchFlag = (metrics as any)?.launched !== undefined || (metrics as any)?.finalizedAt !== undefined;
  const isGraduated = hasLaunchFlag
    ? Boolean((metrics as any)?.launched) || (typeof (metrics as any)?.finalizedAt === "bigint" ? (metrics as any).finalizedAt > 0n : Number((metrics as any)?.finalizedAt ?? 0) > 0)
    : Boolean(metrics && metrics.graduationTarget > 0n && metrics.sold >= metrics.graduationTarget);

  const dexTokenAddress = isGraduated ? (campaign?.token ?? "") : "";

  const { url: chartUrl, baseUrl: dexBaseUrl, liquidityBnb: dexLiquidityBnb } =
    useDexScreenerChart(dexTokenAddress);
  const isDexStage = isGraduated;

  const curveProgress = useMemo(() => {
    // IMPORTANT:
    // - metrics.sold is TOKEN wei sold on the bonding curve.
    // - metrics.curveSupply is TOKEN wei available to sell on the curve.
    // - metrics.graduationTarget is BNB wei required (reserve) to unlock DEX stage.
    // The contract graduates when either:
    //   sold >= curveSupply   OR   reserve >= graduationTarget

    const sold = metrics?.sold ?? 0n;
    const curveSupply = metrics?.curveSupply ?? 0n;
    const targetWei = metrics?.graduationTarget ?? 0n;
    const reserveWei = curveReserveWei ?? 0n;

    const soldPct =
      curveSupply > 0n ? Number(((sold * 10000n) / curveSupply)) / 100 : 0;

    const raisedPct =
      targetWei > 0n ? Number(((reserveWei * 10000n) / targetWei)) / 100 : 0;

    const reachedSold = curveSupply > 0n && sold >= curveSupply;
    const reachedRaised = targetWei > 0n && reserveWei >= targetWei;

    // When we are in DEX stage, always show 100%.
    if (isDexStage) {
      return {
        pct: 100,
        matured: true,
        soldWei: sold,
        curveSupplyWei: curveSupply,
        reserveWei,
        targetWei,
        soldPct: 100,
        raisedPct: 100,
      };
    }

    // Show whichever progress is more complete, because graduation triggers on either.
    const pct = Math.max(
      0,
      Math.min(100, Math.max(soldPct, raisedPct))
    );

    return {
      pct,
      matured: reachedSold || reachedRaised,
      soldWei: sold,
      curveSupplyWei: curveSupply,
      reserveWei,
      targetWei,
      soldPct: Math.max(0, Math.min(100, soldPct)),
      raisedPct: Math.max(0, Math.min(100, raisedPct)),
    };
  }, [isDexStage, metrics?.sold, metrics?.curveSupply, metrics?.graduationTarget, curveReserveWei]);

    const remainingCurveWei = useMemo(() => {
    // Remaining BNB needed to reach the graduation target (reserve-based trigger).
    // If already in DEX stage, remaining is 0.
    if (isDexStage) return 0n;

    const targetWei = curveProgress.targetWei ?? 0n;
    const reserveWei = curveProgress.reserveWei ?? 0n;
    return targetWei > reserveWei ? targetWei - reserveWei : 0n;
  }, [isDexStage, curveProgress.targetWei, curveProgress.reserveWei]);

  const remainingCurveLabel = useMemo(() => {
    const bnbLabel = formatBnbFromWei(remainingCurveWei);

    let remainingBnbNum: number | null = null;
    try {
      const n = Number(ethers.formatEther(remainingCurveWei));
      remainingBnbNum = Number.isFinite(n) ? n : null;
    } catch {
      remainingBnbNum = null;
    }

    const usdLabel =
      remainingBnbNum != null && bnbUsdPrice
        ? formatCompactUsd(remainingBnbNum * bnbUsdPrice)
        : bnbUsdLoading
        ? ""
        : "";

    // Primary follows the denomination toggle; secondary shows the other denomination.
    if (displayDenom === "USD") return { primary: usdLabel, secondary: bnbLabel };
    return { primary: bnbLabel, secondary: usdLabel };
  }, [remainingCurveWei, displayDenom, bnbUsdPrice, bnbUsdLoading]);

  const liquidityLabel = isDexStage ? "Liquidity" : "Reserve";
  const liquidityValue = (() => {
    if (!isDexStage) return tokenData.liquidity;

    // LIVE: best-effort liquidity (BNB-equivalent) from DexScreener.
    return formatBnb(dexLiquidityBnb ?? null);
  })()

  const liquidityDisplay = useMemo(() => {
    const bnbLabel = liquidityValue;

    if (displayDenom === "BNB") return bnbLabel;

    const liqBnb = parseBnbLabel(bnbLabel);
    if (liqBnb == null) return "";

    if (!bnbUsdPrice) return bnbUsdLoading ? "" : "";

    return formatCompactUsd(liqBnb * bnbUsdPrice);
  }, [displayDenom, liquidityValue, bnbUsdPrice, bnbUsdLoading]);
;

  const chartTitle = isDexStage ? "DEX chart" : "";
  const stagePill = isDexStage ? "Graduated" : "Bonding";

  // Quote (buy: BNB cost; sell: BNB payout) for the entered token amount
  useEffect(() => {
    let cancelled = false;

    const loadQuote = async () => {
      try {
        setQuoteError(null);

        if (isDexStage) {
          setQuoteWei(null);
          return;
        }
        if (!campaign?.campaign) {
          setQuoteWei(null);
          return;
        }

        let amountWei = 0n;
        let inputBnbWei = 0n;
        if (tradeInputDenom === "BNB") {
          inputBnbWei = parseBnbAmountWei(tradeAmount);
          setEffectiveBnbWei(inputBnbWei);
          if (inputBnbWei <= 0n) {
            setEffectiveTokenWei(0n);
            setQuoteWei(null);
            return;
          }
        } else {
          amountWei = parseTokenAmountWei(tradeAmount);
          setEffectiveTokenWei(amountWei);
          if (amountWei <= 0n) {
            setQuoteWei(null);
            return;
          }
        }

        setQuoteLoading(true);

        if (!wallet.provider) {
          if (!cancelled) {
            setQuoteWei(null);
            setQuoteError("Wallet provider not available");
          }
          return;
        }

        const c = new Contract(campaign.campaign, CAMPAIGN_ABI, wallet.provider) as any;
        if (tradeInputDenom === "BNB") {
          // Invert the quote function so the user can input BNB.
          const targetWei = inputBnbWei;
          const priceWei = metrics?.currentPrice ?? 0n;
          let hi: bigint;
          if (tradeTab === "sell" && tokenBalanceWei != null && tokenBalanceWei > 0n) {
            hi = tokenBalanceWei;
          } else if (priceWei > 0n) {
            const est = (targetWei * 10n ** 18n) / priceWei;
            hi = est > 0n ? est * 2n : 10n ** 18n;
          } else {
            hi = 10n ** 24n;
          }
          let lo = 0n;
          // 28 iterations ~= good precision without too many RPC calls.
          for (let i = 0; i < 28; i++) {
            const mid = (lo + hi) / 2n;
            if (mid <= 0n) {
              lo = 0n;
              continue;
            }
            const q: bigint = tradeTab === "buy"
              ? await c.quoteBuyExactTokens(mid)
              : await c.quoteSellExactTokens(mid);
            if (tradeTab === "buy") {
              // Max tokens such that cost <= target
              if (q <= targetWei) lo = mid; else hi = mid;
            } else {
              // Min tokens such that payout >= target
              if (q >= targetWei) hi = mid; else lo = mid;
            }
          }
          const solved = tradeTab === "buy" ? lo : hi;
          if (!cancelled) {
            setEffectiveTokenWei(solved);
            setQuoteWei(targetWei);
          }
        } else {
          const q: bigint = tradeTab === "buy"
            ? await c.quoteBuyExactTokens(amountWei)
            : await c.quoteSellExactTokens(amountWei);
          if (!cancelled) setQuoteWei(q);
        }
      } catch (e: any) {
        console.warn("[TokenDetails] Quote failed", e);
        if (!cancelled) {
          setQuoteWei(null);
          setQuoteError(e?.message ?? "Failed to fetch quote");
        }
      } finally {
        if (!cancelled) setQuoteLoading(false);
      }
    };

    const t = setTimeout(loadQuote, 250);
    return () => {
      cancelled = true;
      clearTimeout(t);
    };
  }, [wallet.provider, campaign?.campaign, metrics?.currentPrice, tradeTab, tradeAmount, tradeInputDenom, tokenBalanceWei, isDexStage]);

  const handlePlaceTrade = async () => {
    if (!campaign?.campaign) return;

    if (isDexStage) {
      toast({
        title: "Token is graduated",
        description: "This token is trading on DEX now. Use DexScreener / PancakeSwap.",
      });
      if (dexBaseUrl) window.open(dexBaseUrl, "_blank", "noopener,noreferrer");
      return;
    }

    const amountWei = tradeInputDenom === "BNB" ? effectiveTokenWei : parseTokenAmountWei(tradeAmount);
  const inputBnbWei = tradeInputDenom === "BNB" ? effectiveBnbWei : 0n;
    if (amountWei <= 0n) {
      toast({
        title: "Invalid amount",
        description: tradeInputDenom === "BNB" ? "Enter a BNB amount greater than 0." : `Enter a ${tokenData.ticker} amount greater than 0.`,
        variant: "destructive",
      });
      return;
    }

    try {
      // Balance sanity checks (best-effort)
      if (!isDexStage && tradeTab === "sell" && tokenBalanceWei != null && amountWei > tokenBalanceWei) {
        toast({
          title: "Insufficient token balance",
          description: `You do not have enough ${tokenData.ticker} to sell that amount.`,
          variant: "destructive",
        });
        return;
      }

      if (!isDexStage && tradeTab === "buy" && bnbBalanceWei != null) {
        const baseCostWei = tradeInputDenom === "BNB" ? inputBnbWei : (quoteWei ?? 0n);
        if (baseCostWei > 0n) {
          const maxCostWei = (baseCostWei * BigInt(100 + SLIPPAGE_PCT)) / 100n;
          if (maxCostWei > bnbBalanceWei) {
          toast({
            title: "Insufficient BNB",
            description: `You need ~${formatBnbFromWei(maxCostWei)} to place this buy.`,
            variant: "destructive",
          });
          return;
        }
          }
      }

      // Ensure wallet is connected for writes
if (!wallet.signer || !wallet.account) {
  toast({
    title: "Connect wallet",
    description: "Please connect your wallet to trade.",
  });
  await wallet.connect();
}
if (!wallet.signer || !wallet.account) throw new Error("Wallet not connected");

      setTradePending(true);

      if (tradeTab === "buy") {
  let costWei = tradeInputDenom === "BNB" ? inputBnbWei : quoteWei;

  if (amountWei > 0n && (costWei == null || costWei === 0n)) {
    const c = new Contract(
      campaign.campaign,
      CAMPAIGN_ABI,
      wallet.provider ?? wallet.signer
    ) as any;

    costWei = await c.quoteBuyExactTokens(amountWei);
  }
        const maxCostWei = (costWei * BigInt(100 + SLIPPAGE_PCT)) / 100n;

        toast({
          title: "Submitting buy",
          description: `Buying ${ethers.formatUnits(amountWei, TOKEN_DECIMALS)} ${tokenData.ticker} (max ${formatBnbFromWei(maxCostWei)}).`,
        });

        const receipt: any = await buyTokens(campaign.campaign, amountWei, maxCostWei);

        toast({
          title: "Buy confirmed",
          description: receipt?.transactionHash ? `Tx: ${receipt.transactionHash.slice(0, 10)}...` : "Transaction confirmed.",
        });
      } else {
        let payoutWei = tradeInputDenom === "BNB" ? inputBnbWei : quoteWei;
        if (amountWei > 0n && (payoutWei == null || payoutWei === 0n)) {
  const c = new Contract(
    campaign.campaign,
    CAMPAIGN_ABI,
    wallet.provider ?? wallet.signer
  ) as any;

  payoutWei = await c.quoteSellExactTokens(amountWei);
}

        const minPayoutWei = (payoutWei * BigInt(100 - SLIPPAGE_PCT)) / 100n;

        if (campaign?.token) {
  const token = new Contract(campaign.token, TOKEN_ABI, wallet.signer) as any;
  const allowance: bigint = await token.allowance(wallet.account, campaign.campaign);

  if (allowance < amountWei) {
    setApprovePending(true);
    toast({
      title: "Approval required",
      description: `Approving ${tokenData.ticker} for selling...`,
    });

    const tx = await token.approve(campaign.campaign, MAX_UINT256);
    await tx.wait();

    setApprovePending(false);
  }
}

        toast({
          title: "Submitting sell",
          description: `Selling ${ethers.formatUnits(amountWei, TOKEN_DECIMALS)} ${tokenData.ticker} (min ${formatBnbFromWei(minPayoutWei)}).`,
        });

        const receipt: any = await sellTokens(campaign.campaign, amountWei, minPayoutWei);

        toast({
          title: "Sell confirmed",
          description: receipt?.transactionHash ? `Tx: ${receipt.transactionHash.slice(0, 10)}...` : "Transaction confirmed.",
        });
      }

      // Refresh headline stats + balances
      try {
        const s = await fetchCampaignSummary(campaign);
        setSummary(s);
        setMetrics(s.metrics ?? null);
      } catch {
        // ignore
      }

      try {
        if (!wallet.provider && campaign?.campaign) {
          const bal = await wallet.provider.getBalance(campaign.campaign);
          setCurveReserveWei(bal);
        }
      } catch {
        // ignore
      }

      try {
        if (wallet.provider && wallet.account && campaign?.token) {
          const [bnbBal, tokenBal] = await Promise.all([
            wallet.provider.getBalance(wallet.account),
            (async () => {
              try {
                const t = new Contract(campaign.token, TOKEN_ABI, wallet.provider) as any;
                return (await t.balanceOf(wallet.account)) as bigint;
              } catch {
                return 0n;
              }
            })(),
          ]);
          setBnbBalanceWei(bnbBal);
          setTokenBalanceWei(tokenBal);
        }
      } catch {
        // ignore
      }

      setTradeAmount("0");
    } catch (e: any) {
      console.error("[TokenDetails] Trade failed", e);
      toast({
        title: "Trade failed",
        description: e?.reason || e?.message || "Transaction failed.",
        variant: "destructive",
      });
    } finally {
      setApprovePending(false);
      setTradePending(false);
    }
  };

  const copyAddress = () => {
    const address = campaign?.token ?? "";
    if (!address) return;

    navigator.clipboard.writeText(address);
    toast({
      title: "Copied!",
      description: "Contract address copied to clipboard",
    });
  };

  if (error) {
    return (
      <div className="h-full w-full flex items-center justify-center px-4">
        <Card className="p-4 md:p-6 bg-card/40 border border-border/40 max-w-md w-full text-center">
          <h2 className="text-sm md:text-base font-semibold mb-2">{error}</h2>
          <p className="text-xs md:text-sm text-muted-foreground">
            {error === "No token data"
              ? "There are no campaigns available yet."
              : "Please go back to the main page and select another token."}
          </p>
        </Card>
      </div>
    );
  }

  if (loading && !campaign) {
    return (
      <div className="h-full w-full flex items-center justify-center px-4">
        <Card className="p-4 md:p-6 bg-card/40 border border-border/40 max-w-md w-full text-center">
          <p className="text-xs md:text-sm text-muted-foreground">
            Loading token data...
          </p>
        </Card>
      </div>
    );
  }

  return (
    <div className="h-full w-full overflow-y-auto lg:overflow-hidden flex flex-col px-3 md:px-6 pt-3 md:pt-6 gap-3 md:gap-4">
      {/* Main Content - Single Row */}
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-3 md:gap-4 lg:flex-1 lg:min-h-0">
        {/* Left Column - Header, Chart & Transactions (3/4 width) */}
        <div className="lg:col-span-3 lg:min-h-0">
          <div className="flex flex-col gap-3 md:gap-4 lg:h-full lg:min-h-0 lg:overflow-y-auto pr-1">
          {/* Top Header Bar */}
          <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-3 md:p-6 flex-shrink-0">
            <div className="flex flex-col md:flex-row md:items-center gap-4 md:gap-6">
              {/* Token Image & Info */}
              <div className="flex items-center gap-3 md:gap-5 flex-1 min-w-0">
                <img
                  src={tokenData.image}
                  alt={tokenData.ticker}
                  className="w-12 h-12 md:w-16 md:h-16 rounded-full flex-shrink-0"
                />

                <div className="flex flex-col gap-1.5 md:gap-2.5 flex-1 min-w-0">
                  <div className="flex items-center gap-2 md:gap-3">
                    <h1 className="text-sm md:text-lg font-retro text-foreground truncate">
                      {tokenData.name}
                    </h1>
                    <span className="text-xs md:text-sm text-muted-foreground font-mono">
                      {tokenData.ticker}
                    </span>
                    <Copy
                      className="h-3 w-3 md:h-3.5 md:w-3.5 text-muted-foreground cursor-pointer hover:text-foreground transition-colors flex-shrink-0"
                      onClick={copyAddress}
                    />
                  </div>
                  <div className="flex items-center gap-1.5 md:gap-2.5">
                    {tokenData.hasWebsite && (
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 md:h-7 md:w-7 p-0 hover:bg-muted/50"
                        onClick={() => {
                          const url = campaign?.website;
                          if (url) window.open(url, "_blank", "noopener,noreferrer");
                        }}
                      >
                        <Globe className="h-3 w-3 md:h-3.5 md:w-3.5" />
                      </Button>
                    )}
                    {tokenData.hasTwitter && (
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 md:h-7 md:w-7 p-0 hover:bg-muted/50"
                        onClick={() => {
                          const handle = campaign?.xAccount;
                          if (!handle) return;
                          const url = handle.startsWith("http")
                            ? handle
                            : `https://x.com/${handle.replace(/^@/, "")}`;
                          window.open(url, "_blank", "noopener,noreferrer");
                        }}
                      >
                        <img
                          src={twitterIcon}
                          alt="Twitter"
                          className="h-3 w-3 md:h-3.5 md:w-3.5"
                        />
                      </Button>
                    )}
                    {(() => {
                      const creator = String(campaign?.creator ?? "").trim();
                      if (!creator) return null;

                      const display =
                        (creatorProfile?.displayName
                          ? String(creatorProfile.displayName).trim()
                          : "") || shortenAddress(creator);

                      const createdLabel = campaign?.createdAt
                        ? formatTimeAgo(campaign.createdAt)
                        : campaign?.timeAgo
                        ? `${campaign.timeAgo}${String(campaign.timeAgo).includes("ago") ? "" : " ago"}`
                        : "";

                      const initial = display ? display.slice(0, 1).toUpperCase() : "C";

                      return (
                        <div className="flex items-center gap-2 flex-wrap">
                          <Link
                            to={`/profile?address=${creator}`}
                            className="flex items-center gap-2 hover:opacity-90 transition-opacity max-w-[240px]"
                          >
                            <Avatar className="h-6 w-6 md:h-7 md:w-7">
                              <AvatarImage
                                src={creatorProfile?.avatarUrl || undefined}
                                alt={display}
                              />
                              <AvatarFallback className="text-[10px] md:text-xs">
                                {initial}
                              </AvatarFallback>
                            </Avatar>
                            <span className="text-[10px] md:text-xs text-foreground/90 truncate">
                              {display}
                            </span>
                          </Link>
                          <span className="text-[10px] md:text-xs text-muted-foreground">
                            
                          </span>
                          <span className="text-[10px] md:text-xs text-muted-foreground">
                            {createdLabel}
                          </span>

                          {/* Upvote CTA */}
                          {campaignAddress ? (
                            <UpvoteDialog
                              campaignAddress={campaignAddress}
                              buttonVariant="secondary"
                              buttonSize="sm"
                              className="h-6 md:h-7 px-2 md:px-3 text-[10px] md:text-xs"
                            />
                          ) : null}
                        </div>
                      );
                    })()}
                  </div>
                </div>
              </div>

              {/* Vertical Separator - Desktop only */}
              <div className="hidden md:block h-14 w-px bg-border/50 flex-shrink-0" />

              {/* Market Cap */}
              <div className="flex items-center justify-between md:flex-col md:gap-1.5 md:flex-1 md:min-w-0">
                <p className="text-xs text-muted-foreground">Market cap</p>
                <div className="flex items-center gap-2 md:gap-3">
                  <div className="flex items-center gap-1 rounded-md bg-muted/40 p-0.5">
                    <Button
                      size="sm"
                      variant={displayDenom === "USD" ? "secondary" : "ghost"}
                      className="h-4 px-2"
                      onClick={() => setDisplayDenom("USD")}
                    >
                      USD
                    </Button>
                    <Button
                      size="sm"
                      variant={displayDenom === "BNB" ? "secondary" : "ghost"}
                      className="h-4 px-2"
                      onClick={() => setDisplayDenom("BNB")}
                    >
                      BNB
                    </Button>
                  </div>

                                    <h3 className="text-base md:text-xl font-retro text-foreground">
                    {marketCapDisplay}
                  </h3>
                </div>
              </div>

              {/* Mobile: Expandable Metrics Section */}
              {isMobile && (
                <div className="w-full">
                  <button
                    onClick={() => setMetricsExpanded(!metricsExpanded)}
                    className="w-full flex items-center justify-between py-2 px-3 bg-muted/30 rounded-lg"
                  >
                    <span className="text-xs text-muted-foreground">More metrics</span>
                    <ChevronDown
                      className={`h-4 w-4 transition-transform ${
                        metricsExpanded ? "rotate-180" : ""
                      }`}
                    />
                  </button>

                  {metricsExpanded && (
                    <div className="mt-2 space-y-3 p-3 bg-muted/20 rounded-lg">
                      {/* Time-based percentage changes */}
                      <div className="grid grid-cols-2 gap-2">
                        {Object.entries(tokenData.metrics).map(([key, data]) => (
                          <div
                            key={key}
                            onClick={() =>
                              setSelectedTimeframe(key as "5m" | "1h" | "4h" | "24h")
                            }
                            className={`cursor-pointer transition-all text-xs p-2 rounded-md ${
                              selectedTimeframe === key
                                ? "bg-accent/20"
                                : "hover:bg-muted/50"
                            }`}
                          >
                            <span className="text-muted-foreground">{key}</span>
                            {(() => {
                              const ch = (data as any).change as number | null;
                              return (
                                <span
                                  className={`ml-2 font-mono ${
                                    ch == null
                                      ? "text-muted-foreground"
                                      : ch > 0
                                      ? "text-green-500"
                                      : ch < 0
                                      ? "text-red-500"
                                      : "text-muted-foreground"
                                  }`}
                                >
                                  {ch == null ? "" : `${ch > 0 ? "" : ch < 0 ? "" : ""} ${Math.abs(ch).toFixed(2)}%`}
                                </span>
                              );
                            })()}
                          </div>
                        ))}
                      </div>

                      {/* Additional metrics */}
                      <div className="grid grid-cols-2 gap-2 pt-2 border-t border-border/30">
                        <div className="text-xs">
                          <span className="text-muted-foreground block">Price</span>
                          <span className="font-mono text-foreground">{priceDisplay}</span>
                        </div>
                        <div className="text-xs">
                          <span className="text-muted-foreground block">{liquidityLabel}</span>
                          <span className="font-mono text-foreground">{liquidityDisplay}</span>
                        </div>
                        <div className="text-xs">
                          <span className="text-muted-foreground block">Volume</span>
                          <span className="font-mono text-foreground">
                            {volumeDisplay}
                          </span>
                        </div>
                        <div className="text-xs">
                          <span className="text-muted-foreground block">Holders</span>
                          <span className="font-mono text-foreground">{tokenData.holders}</span>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Desktop: Vertical Separator */}
              <div className="hidden lg:block h-14 w-px bg-border/50 flex-shrink-0" />

              {/* Desktop: Time-based Metrics & Additional Metrics */}
              <div className="hidden lg:flex flex-col gap-4 flex-[2] min-w-0">
                {/* Top Row - Time-based percentage changes (clickable) */}
                <div className="flex items-center justify-between gap-4">
                  {Object.entries(tokenData.metrics).map(([key, data]) => (
                    <div
                      key={key}
                      onClick={() => setSelectedTimeframe(key as "5m" | "1h" | "4h" | "24h")}
                      className={`cursor-pointer transition-all text-xs ${
                        selectedTimeframe === key
                          ? "opacity-100"
                          : "opacity-50 hover:opacity-75"
                      }`}
                    >
                      <span className="text-muted-foreground">{key}</span>
                      {(() => {
                        const ch = (data as any).change as number | null;
                        return (
                          <span
                            className={`ml-2 font-mono ${
                              ch == null
                                ? "text-muted-foreground"
                                : ch < 0
                                ? "text-red-500"
                                : "text-green-500"
                            }`}
                          >
                            {ch == null ? "" : `${ch > 0 ? "" : ch < 0 ? "" : ""} ${Math.abs(ch).toFixed(2)}%`}
                          </span>
                        );
                      })()}
                    </div>
                  ))}
                </div>

                {/* Bottom Row - Price, Liq, Volume, Holders */}
                <div className="flex items-center justify-between gap-4">
                  <div className="text-xs">
                    <span className="text-muted-foreground">Price</span>
                    <span className="ml-2 font-mono text-foreground">{priceDisplay}</span>
                  </div>
                  <div className="text-xs">
                    <span className="text-muted-foreground">{liquidityLabel}</span>
                    <span className="ml-2 font-mono text-foreground">{liquidityDisplay}</span>
                  </div>
                  <div className="text-xs">
                    <span className="text-muted-foreground">Volume</span>
                    <span className="ml-2 font-mono text-foreground">
                      {volumeDisplay}
                    </span>
                  </div>
                  <div className="text-xs">
                    <span className="text-muted-foreground">Holders</span>
                    <span className="ml-2 font-mono text-foreground">{tokenData.holders}</span>
                  </div>
                </div>
              </div>
            </div>
          </Card>

          {/* Chart */}
          <Card
            className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-0 overflow-hidden flex flex-col min-h-[360px] h-[360px] md:min-h-[420px] md:h-[420px] lg:min-h-[320px] lg:h-auto"
style={!isMobile ? { flex: "2" } : undefined}
          >
            <div className="flex flex-col gap-2 px-4 py-2 border-b border-border/40 bg-card/20 md:flex-row md:items-center md:justify-between">
              <div className="flex items-center gap-2 min-w-0">
                <span className="text-xs text-muted-foreground">{chartTitle}</span>
                <span
  className={`text-[10px] px-2 py-0.5 rounded-full border font-semibold ${
    isDexStage
      ? "bg-emerald-500/25 text-emerald-200 border-emerald-500/40"
      : "bg-emerald-500/15 text-emerald-200 border-emerald-500/30"
  }`}
>
                  {stagePill}
                </span>
              </div>

              <div className="flex items-center gap-2 w-full md:w-auto md:justify-end">
                {!isDexStage && (
                  <AthBar
                    currentLabel={marketCapUsdLabel ?? undefined}
                    storageKey={`ath:${String(chainIdForStorage)}:${String((campaignAddress ?? campaign?.campaign ?? "")).toLowerCase()}`}
                    className="w-full md:w-auto md:max-w-[320px]"
                  />
                )}

                {isDexStage && dexBaseUrl && (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-7 px-2 text-[10px] text-muted-foreground hover:text-foreground"
                    onClick={() => window.open(dexBaseUrl, "_blank", "noopener,noreferrer")}
                  >
                    <ExternalLink className="h-3 w-3 mr-1" />
                    DexScreener
                  </Button>
                )}
              </div>
            </div>

            <div className="flex-1 min-h-0">
              {isDexStage ? (
                chartUrl ? (
                  <iframe
                    src={chartUrl}
                    title={`${tokenData.ticker} chart`}
                    className="w-full h-full min-h-[260px] border-0"
                    allow="clipboard-write; clipboard-read; encrypted-media;"
                  />
                ) : (
                  <div className="flex items-center justify-center h-full min-h-[260px] text-xs text-muted-foreground p-4">
                    DexScreener data is not available yet.
                  </div>
                )
              ) : (
                <div className="w-full h-full min-h-[260px]">
                <CurvePriceChart
                  campaignAddress={campaign?.campaign}
                  curvePointsOverride={curvePointsForUi}
                  loadingOverride={(curvePointsForUi?.length ?? 0) > 0 ? false : liveCurveLoading}
                  errorOverride={(curvePointsForUi?.length ?? 0) > 0 ? null : liveCurveError}
                />
                </div>
              )}
            </div>
          </Card>

          {/* Activity: Comments / Trades */}
        <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-4">
          <Tabs
            value={activityTab}
            onValueChange={(v) => setActivityTab(v as any)}
            className="h-full flex flex-col min-h-0"
          >
            <TabsList className="grid w-full grid-cols-2 mb-3">
              <TabsTrigger value="comments">Comments</TabsTrigger>
              <TabsTrigger value="trades">Trades</TabsTrigger>
            </TabsList>

            <TabsContent value="comments" className="flex-1 min-h-0 overflow-y-auto">
              {campaign?.campaign ? (
                <TokenComments
                  chainId={Number(wallet.chainId ?? 97)}
                  campaignAddress={campaign.campaign}
                  tokenAddress={campaign.token}
                />
              ) : (
                <div className="text-sm text-muted-foreground">Loading comments</div>
              )}
            </TabsContent>

            <TabsContent value="trades" className="flex-1 min-h-0 overflow-y-auto">
              <div className="overflow-auto h-full">
                <table className="w-full text-sm">
                  <thead className="sticky top-0 bg-card/60 backdrop-blur border-b border-border">
                    <tr>
                      <th className="text-left py-3 px-3 font-medium text-muted-foreground">Account</th>
                      <th className="text-left py-3 px-3 font-medium text-muted-foreground">Type</th>
                      <th className="text-left py-3 px-3 font-medium text-muted-foreground">BNB</th>
                      <th className="text-left py-3 px-3 font-medium text-muted-foreground">Token</th>
                      <th className="text-left py-3 px-3 font-medium text-muted-foreground">Time</th>
                      <th className="text-right py-3 px-3 font-medium text-muted-foreground">Txn</th>
                    </tr>
                  </thead>
                  <tbody>
                    {txs.map((tx) => {
                      const addr = (tx.makerAddress || "").toLowerCase();
                      const prof = addr ? makerProfiles[addr] : null;
                      const avatar = prof?.avatarUrl || "/placeholder.svg";
                      const label = (prof?.displayName && prof.displayName.trim().length)
                        ? prof.displayName.trim()
                        : tx.maker;

                      const explorer = getExplorerBase(wallet.chainId);
                      const txLabel = tx.txHash ? `${tx.txHash.slice(0, 6)}${tx.txHash.slice(-4)}` : "";
                      const txUrl = tx.txHash ? `${explorer}/tx/${tx.txHash}` : "";

                      return (
                        <tr key={tx.id} className="border-b border-border/40 hover:bg-muted/20">
                          <td className="py-3 px-3">
                            {tx.makerAddress ? (
                              <Link
                                to={`/profile?address=${tx.makerAddress}`}
                                className="flex items-center gap-2 min-w-0"
                              >
                                <img
                                  src={avatar}
                                  alt={label}
                                  onError={(e) => {
                                    (e.currentTarget as HTMLImageElement).src = "/placeholder.svg";
                                  }}
                                  className="h-7 w-7 rounded-full ring-1 ring-border/30 flex-shrink-0"
                                />
                                <span className="font-mono text-foreground truncate max-w-[140px]">
                                  {label}
                                </span>
                              </Link>
                            ) : (
                              <span className="font-mono text-muted-foreground"></span>
                            )}
                          </td>

                          <td className="py-3 px-3">
                            <span
                              className={`font-medium ${tx.type === "buy" ? "text-emerald-400" : "text-red-400"}`}
                            >
                              {tx.type === "buy" ? "Buy" : "Sell"}
                            </span>
                          </td>

                          <td className="py-3 px-3 font-mono text-foreground">{tx.bnb}</td>

                          <td className="py-3 px-3 font-mono">
                            <span className={tx.type === "buy" ? "text-emerald-300" : "text-red-300"}>
                              {tx.amount}
                            </span>
                          </td>

                          <td className="py-3 px-3 text-muted-foreground whitespace-nowrap">{tx.time}</td>

                          <td className="py-3 px-3 text-right">
                            {txUrl ? (
                              <a
                                href={txUrl}
                                target="_blank"
                                rel="noreferrer"
                                className="font-mono text-muted-foreground hover:text-foreground hover:underline underline-offset-4"
                              >
                                {txLabel}
                              </a>
                            ) : (
                              <span className="text-muted-foreground"></span>
                            )}
                          </td>
                        </tr>
                      );
                    })}
                    {txs.length === 0 && (
                      <tr>
                        <td colSpan={6} className="py-6 text-center text-sm text-muted-foreground">
                          No trades yet.
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>
            </TabsContent>
          </Tabs>
        </Card>
        </div>
        </div>

        {/* Right Column - Trading Panel & Stats (1/3 width) */}
        <div className="lg:col-span-1 min-h-0">
          <div className="flex flex-col gap-4 lg:h-full min-h-0 lg:overflow-y-auto pr-1">
          {/* Trading Panel - 2/5 height */}
          <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-4">
            <Tabs value={tradeTab} onValueChange={handleTradeTabChange}>
              <TabsList className="grid w-full grid-cols-2 mb-3">
                <TabsTrigger value="buy" className="text-sm">Buy</TabsTrigger>
                <TabsTrigger value="sell" className="text-sm">Sell</TabsTrigger>
              </TabsList>

              <TabsContent value="buy" className="space-y-3">
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2"><Button variant="ghost" size="sm" className="h-6 px-2 text-[10px] text-muted-foreground hover:bg-emerald-500/15 text-emerald-200 border-emerald-500/30" onClick={toggleTradeInputDenom}>{tradeInputDenom === "BNB" ? `Switch to ${tokenData.ticker}` : "Switch to BNB"}</Button></div>
                    <span className="text-xs text-muted-foreground">Slippage: {SLIPPAGE_PCT}%</span>
                  </div>
                  <div className="relative">
                    <input
                      type="text"
                      value={tradeAmount}
                      onChange={(e) => setTradeAmount(e.target.value)}
                      className="w-full bg-background border border-border rounded-lg px-3 py-2 pr-20 font-mono text-base focus:outline-none focus:ring-1 focus:ring-primary"
                      placeholder="0"
                    />
                    <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
                      <span className="text-xs font-mono text-muted-foreground">{tradeInputDenom === "BNB" ? "BNB" : tokenData.ticker}</span>
                    </div>
                  </div>
                  <div className="flex items-center justify-between mt-2">
                    <span className="text-xs text-muted-foreground">
                      Balance:{" "}
                      {tradeInputDenom === "BNB"
                        ? formatBnbFromWei(bnbBalanceWei)
                        : `${formatTokenFromWei(tokenBalanceWei)} ${tokenData.ticker}`}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      Cost: {tradeInputDenom === "BNB" ? formatBnbFromWei(effectiveBnbWei) : (quoteLoading ? "" : quoteWei != null ? formatBnbFromWei(quoteWei) : "")}
                    </span>
                  </div>
                  {tradeInputDenom === "BNB" && effectiveTokenWei > 0n ? (
                    <p className="mt-1 text-[11px] text-muted-foreground">Est. receive: {formatTokenFromWei(effectiveTokenWei)} {tokenData.ticker}</p>
                  ) : null}
                  {quoteError ? (
                    <p className="mt-2 text-center text-xs text-destructive">{quoteError}</p>
                  ) : null}
                </div>

                <div className="text-center text-xs text-muted-foreground">
                  {isDexStage ? (
                    <p>Token is graduated. Trade on DEX.</p>
                  ) : quoteWei != null ? (
                    <p>
                      You will pay ~{formatBnbFromWei(quoteWei)} (max {formatBnbFromWei((quoteWei * BigInt(100 + SLIPPAGE_PCT)) / 100n)})
                    </p>
                  ) : (
                    <p>Enter an amount to see the buy quote.</p>
                  )}
                </div>

                <Button
                  onClick={handlePlaceTrade}
                  disabled={tradePending || approvePending || (!isDexStage && (tradeInputDenom === "BNB" ? effectiveBnbWei <= 0n : parseTokenAmountWei(tradeAmount) <= 0n))}
                  className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-retro py-5"
                >
                  {tradePending ? "Processing..." : isDexStage ? "Trade on DEX" : "Place Trade"}
                </Button>
              </TabsContent>

              <TabsContent value="sell" className="space-y-3">
                <div>
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2"><span className="text-xs text-muted-foreground">Amount ({tradeInputDenom === "BNB" ? "BNB" : tokenData.ticker})</span><Button variant="ghost" size="sm" className="h-6 px-2 text-[10px] text-muted-foreground hover:text-foreground" onClick={toggleTradeInputDenom}>{tradeInputDenom === "BNB" ? `Switch to ${tokenData.ticker}` : "Switch to BNB"}</Button></div>
                    <span className="text-xs text-muted-foreground">Slippage: {SLIPPAGE_PCT}%</span>
                  </div>
                  <div className="relative">
                    <input
                      type="text"
                      value={tradeAmount}
                      onChange={(e) => setTradeAmount(e.target.value)}
                      className="w-full bg-background border border-border rounded-lg px-3 py-2 pr-20 font-mono text-base focus:outline-none focus:ring-1 focus:ring-primary"
                      placeholder="0"
                    />
                    <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
                      <span className="text-xs font-mono text-muted-foreground">{tradeInputDenom === "BNB" ? "BNB" : tokenData.ticker}</span>
                    </div>
                  </div>

                  <div className="flex gap-1 mt-2">
                    <Button
                      variant="outline"
                      size="sm"
                      className="flex-1 text-xs h-7"
                      onClick={() => {
                        if (tokenBalanceWei == null) return;
                        const amt = (tokenBalanceWei * 25n) / 100n;
                        setTradeAmount(ethers.formatUnits(amt, TOKEN_DECIMALS));
                      }}
                    >
                      25%
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      className="flex-1 text-xs h-7"
                      onClick={() => {
                        if (tokenBalanceWei == null) return;
                        const amt = (tokenBalanceWei * 50n) / 100n;
                        setTradeAmount(ethers.formatUnits(amt, TOKEN_DECIMALS));
                      }}
                    >
                      50%
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      className="flex-1 text-xs h-7"
                      onClick={() => {
                        if (tokenBalanceWei == null) return;
                        setTradeAmount(ethers.formatUnits(tokenBalanceWei, TOKEN_DECIMALS));
                      }}
                    >
                      100%
                    </Button>
                  </div>

                  <div className="flex items-center justify-between mt-2">
                    <span className="text-xs text-muted-foreground">
                      Balance:{" "}
                      {tradeInputDenom === "BNB"
                        ? formatBnbFromWei(bnbBalanceWei)
                        : `${formatTokenFromWei(tokenBalanceWei)} ${tokenData.ticker}`}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      Payout: {tradeInputDenom === "BNB" ? formatBnbFromWei(effectiveBnbWei) : (quoteLoading ? "" : quoteWei != null ? formatBnbFromWei(quoteWei) : "")}
                    </span>
                  </div>
                  {tradeInputDenom === "BNB" && effectiveTokenWei > 0n ? (
                    <p className="mt-1 text-[11px] text-muted-foreground">Est. sell: {formatTokenFromWei(effectiveTokenWei)} {tokenData.ticker}</p>
                  ) : null}

                  {approvePending ? (
                    <p className="mt-2 text-center text-xs text-muted-foreground">Approval in progress...</p>
                  ) : null}
                  {quoteError ? (
                    <p className="mt-2 text-center text-xs text-destructive">{quoteError}</p>
                  ) : null}
                </div>

                <div className="text-center text-xs text-muted-foreground">
                  {isDexStage ? (
                    <p>Token is graduated. Trade on DEX.</p>
                  ) : quoteWei != null ? (
                    <p>
                      You will receive ~{formatBnbFromWei(quoteWei)} (min {formatBnbFromWei((quoteWei * BigInt(100 - SLIPPAGE_PCT)) / 100n)})
                    </p>
                  ) : (
                    <p>Enter an amount to see the sell quote.</p>
                  )}
                </div>

                <Button
                  onClick={handlePlaceTrade}
                  disabled={tradePending || approvePending || (!isDexStage && (tradeInputDenom === "BNB" ? effectiveBnbWei <= 0n : parseTokenAmountWei(tradeAmount) <= 0n))}
                  className="w-full bg-primary hover:bg-primary/90 text-primary-foreground font-retro py-5"
                >
                  {tradePending ? "Processing..." : isDexStage ? "Trade on DEX" : "Place Trade"}
                </Button>
              </TabsContent>
            </Tabs>
          </Card>

          <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-4">
  <div className="flex flex-col gap-3">
    <div className="flex items-center justify-between">
      <h3 className="text-sm font-semibold">Bonding Curve Progress</h3>
      <span className="text-xs text-muted-foreground">
        {curveProgress.matured ? "Matured" : `${curveProgress.pct.toFixed(2)}%`}
      </span>
    </div>

    <div className="h-2 w-full rounded-full bg-muted/30 border border-border/40 overflow-hidden">
      <div
        className="h-full rounded-full bg-[linear-gradient(90deg,rgba(255,255,255,0.65),rgba(255,255,255,0.25),rgba(255,255,255,0.65))] dark:bg-[linear-gradient(90deg,rgba(255,255,255,0.25),rgba(255,255,255,0.08),rgba(255,255,255,0.25))]"
        style={{ width: `${Math.max(0, Math.min(100, curveProgress.pct))}%`, minWidth: curveProgress.pct > 0 ? "1px" : undefined }}
      />
    </div>

    <div className="text-xs text-muted-foreground">
      <div className="flex items-center justify-between">
        <span>{formatBnbFromWei(curveProgress.reserveWei ?? undefined)} in bonding curve</span>
        <span className="text-right">
          <span className="text-muted-foreground">Remaining:</span>{" "}
          {remainingCurveLabel.primary}
        </span>
      </div>
    </div>
  </div>
</Card>

          {/* Flywheel Statistics - 2/5 height */}
          <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-4">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
              <h3 className="text-sm font-retro text-foreground">Flywheel</h3>
              <span className="text-xs text-muted-foreground">All-time</span>
            </div>

            <div className="grid grid-cols-2 gap-3">
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Buy volume</p>
                <p className="text-lg font-retro text-foreground">{flywheel.buyVolume}</p>
              </div>
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Sell volume</p>
                <p className="text-lg font-retro text-foreground">{flywheel.sellVolume}</p>
              </div>
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Net flow</p>
                <p className="text-lg font-retro text-foreground">{flywheel.netFlow}</p>
              </div>
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Protocol fees (est.)</p>
                <p className="text-lg font-retro text-foreground">{flywheel.feesEstimated}</p>
              </div>
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Buyers</p>
                <p className="text-lg font-retro text-foreground">{flywheel.buyers}</p>
              </div>
              <div className="rounded-2xl border border-border bg-muted/20 p-3">
                <p className="text-xs text-muted-foreground">Protocol fee rate</p>
                <p className="text-lg font-retro text-foreground">{flywheel.feeRate}</p>
              </div>
            </div>

            <p className="text-xs text-muted-foreground mt-3">
              Volumes and buyer count come from on-chain counters when available. Fees are estimated from protocol fee basis points.
            </p>
          </Card>

          {/* Holder Distribution - 1/5 height */}
          <Card className="bg-card/30 backdrop-blur-md rounded-2xl border border-border p-4">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
              <h3 className="text-sm font-retro text-foreground">Holder Distribution</h3>
              <span className="text-xs text-muted-foreground">
                {holderDistribution.totalHolders} holders
              </span>
            </div>

            {holderDistribution.top.length ? (
              <div className="space-y-3 overflow-auto flex-1 min-h-0 pr-1">
                {holderDistribution.top.map((h, idx) => {
                  const rank = h.isLp ? null : holderDistribution.hasLp ? idx : idx + 1;

                  return (
                    <div key={h.address} className="space-y-1">
                      <div className="flex items-center justify-between text-xs">
                        <span className="font-mono min-w-0">
                          {rank != null ? `${rank}. ` : ""}

                          {h.isLp ? (
                            <span className="text-foreground">{h.label}</span>
                          ) : (
                            <Link
                              to={`/profile?address=${h.address}`}
                              className="text-foreground hover:underline underline-offset-4"
                            >
                              {h.label}
                            </Link>
                          )}
                        </span>
                        <span className="font-mono text-muted-foreground">{h.pct.toFixed(2)}%</span>
                      </div>
                      <Progress value={h.pct} className="h-1.5" />
                    </div>
                  );
                })}
                {holderDistribution.othersPct > 0 ? (
                  <div className="space-y-1">
                    <div className="flex items-center justify-between text-xs">
                      <span className="font-mono">Others</span>
                      <span className="font-mono text-muted-foreground">{holderDistribution.othersPct.toFixed(2)}%</span>
                    </div>
                    <Progress value={holderDistribution.othersPct} className="h-1.5" />
                  </div>
                ) : null}
              </div>
            ) : (
              <div className="text-xs text-muted-foreground">No holder data yet.</div>
            )}

            <p className="text-[11px] text-muted-foreground mt-3 flex-shrink-0">
              Estimated from bonding-curve trades (excludes transfers).
            </p>
          </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TokenDetails;
</file>

<file path="frontend/src/pages/League.tsx">
import { useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import { ethers } from "ethers";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useWallet } from "@/hooks/useWallet";
import { getDefaultChainId, isAllowedChainId } from "@/lib/chainConfig";

const isAddress = (s?: string) => /^0x[a-fA-F0-9]{40}$/.test(String(s ?? "").trim());
const shortAddr = (a: string) => (a && a.length > 12 ? a.slice(0, 6) + "..." + a.slice(-4) : a);

type Period = "weekly" | "monthly";

type LeagueBase = {
  campaign_address: string;
  name?: string | null;
  symbol?: string | null;
  logo_uri?: string | null;
};

type GraduationRow = LeagueBase & {
  duration_seconds?: number | null;
  unique_buyers?: number | null;
  sells_count?: number | null;
  buy_total_raw?: string | null;
};

type BiggestHitRow = LeagueBase & {
  buyer_address: string;
  bnb_amount_raw: string;
  tx_hash: string;
  block_number: number;
  block_time: string;
  log_index?: number | null;
};

type CrowdFavoriteRow = LeagueBase & {
  votes_count: string | number;
  unique_voters: string | number;
  amount_raw_sum: string;
};

type TopEarnerRow = {
  wallet: string;
  profit_raw: string;
  sells_raw?: string;
  buys_raw?: string;
  trades_count?: number;
};

type PrizeMeta = {
  basis: "league_fee_only";
  period: "weekly" | "monthly";
  cutoff?: string | null;
  rangeEnd?: string | null;
  computedAt: string;
  totalLeagueFeeRaw: string;
  leagueCount: number;
  winners: number;
  splitBps: number[];
  potRaw: string;
  payoutsRaw: [string, string, string, string, string];
};

type EpochMeta = {
  period: "weekly" | "monthly";
  epochOffset: number;
  epochStart: string;
  epochEnd: string;
  rangeEnd: string;
  status: "live" | "finalized";
};

type LeagueResponse<T> = {
  items: T[];
  warning?: string;
  prize?: PrizeMeta;
  epoch?: EpochMeta;
};

function clampInt(n: number, lo: number, hi: number) {
  if (!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, Math.trunc(n)));
}

function formatDuration(seconds?: number | null) {
  const s = Math.max(0, Number(seconds ?? 0));
  const d = Math.floor(s / 86400);
  const h = Math.floor((s % 86400) / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = Math.floor(s % 60);
  if (d > 0) return `${d}d ${h}h`;
  if (h > 0) return `${h}h ${m}m`;
  if (m > 0) return `${m}m ${sec}s`;
  return `${sec}s`;
}

function formatBnbFromRaw(raw?: string | null) {
  try {
    const v = BigInt(String(raw ?? "0"));
    const n = Number(ethers.formatUnits(v, 18));
    if (!Number.isFinite(n)) return "0";
    if (n >= 100) return n.toFixed(2);
    if (n >= 1) return n.toFixed(4);
    return n.toFixed(6);
  } catch {
    return "0";
  }
}

function periodLabel(p: Period) {
  if (p === "weekly") return "Weekly";
  return "Monthly";
}

function RowToken({ logo, name, symbol, address }: { logo?: string | null; name?: string | null; symbol?: string | null; address: string }) {
  const title = (name ? String(name) : "") || "Unknown";
  const sym = (symbol ? String(symbol) : "") || "";
  const initial = sym ? sym.slice(0, 1).toUpperCase() : "T";

  return (
    <div className="flex items-center gap-3 min-w-0">
      <Avatar className="h-8 w-8">
        <AvatarImage src={logo || undefined} />
        <AvatarFallback>{initial}</AvatarFallback>
      </Avatar>
      <div className="min-w-0">
        <div className="text-sm font-semibold truncate">
          {title} {sym ? <span className="text-muted-foreground">({sym})</span> : null}
        </div>
        <div className="text-[11px] text-muted-foreground truncate">{address}</div>
      </div>
    </div>
  );
}

function RowWallet({ address }: { address: string }) {
  const initial = address?.slice(2, 3)?.toUpperCase?.() || "W";
  return (
    <div className="flex items-center gap-3 min-w-0">
      <Avatar className="h-8 w-8">
        <AvatarFallback>{initial}</AvatarFallback>
      </Avatar>
      <div className="min-w-0">
        <div className="text-sm font-semibold truncate">Trader</div>
        <div className="text-[11px] text-muted-foreground truncate">{isAddress(address) ? address : String(address ?? "")}</div>
      </div>
    </div>
  );
}

type LeagueDef = {
  key: "perfect_run" | "fastest_finish" | "biggest_hit" | "top_earner" | "crowd_favorite";
  title: string;
  subtitle: string;
  image: string;
  supports: Period[];
  weeklyLimit?: number;
  monthlyLimit?: number;
};

const LEAGUES: LeagueDef[] = [
  {
    key: "perfect_run",
    title: "Perfect Run",
    subtitle: "Monthly only  No sells in bonding  <br><br>Jackpot rolls over if not hit",
    image: "/assets/perfectrun.png",
    supports: ["monthly"],
    monthlyLimit: 5,
  },
  {
    key: "fastest_finish",
    title: "Fastest Finish",
    subtitle: "Fastest graduation (creator buys excluded)",
    image: "/assets/fastestfinish.png",
    supports: ["weekly", "monthly"],
    weeklyLimit: 5,
    monthlyLimit: 5,
  },
  {
    key: "biggest_hit",
    title: "Biggest Hit",
    subtitle: "Biggest single buy in bonding",
    image: "/assets/biggesthit.png",
    supports: ["weekly", "monthly"],
    weeklyLimit: 5,
    monthlyLimit: 5,
  },
  {
    key: "top_earner",
    title: "Top Earner",
    subtitle: "Highest trader earnings inside the bonding curve  Paid weekly/monthly",
    image: "/assets/topearner.png",
    supports: ["weekly", "monthly"],
    weeklyLimit: 5,
    monthlyLimit: 5,
  },
  {
    key: "crowd_favorite",
    title: "Crowd Favorite",
    subtitle: "Most UpVotes (communitydriven)",
    image: "/assets/crowdfavorite.png",
    supports: ["weekly", "monthly"],
    weeklyLimit: 5,
    monthlyLimit: 5,
  },
];

function getLimit(def: LeagueDef, period: Period) {
  return period === "weekly" ? def.weeklyLimit ?? 10 : def.monthlyLimit ?? 10;
}

function formatIsoTiny(iso?: string | null) {
  try {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    return d.toLocaleString(undefined, { year: "numeric", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit" });
  } catch {
    return "";
  }
}

function formatUtcTiny(iso?: string | null) {
  try {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "";
    // Force UTC display regardless of client locale.
    return d.toLocaleString("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
    });
  } catch {
    return "";
  }
}

function formatEpochRangeUtc(epoch?: EpochMeta) {
  if (!epoch) return "";
  const start = formatUtcTiny(epoch.epochStart);
  const end = formatUtcTiny(epoch.status === "live" ? epoch.rangeEnd : epoch.epochEnd);
  if (!start || !end) return "";
  return `${start} UTC  ${end} UTC`;
}

export default function League({ chainId = 97 }: { chainId?: number }) {
  const navigate = useNavigate();

  const wallet = useWallet();
  const defaultChain = getDefaultChainId();
  const activeChainId = wallet.isConnected && isAllowedChainId(wallet.chainId) ? Number(wallet.chainId) : Number(chainId ?? defaultChain);

  const [period, setPeriod] = useState<Period>("weekly");
  const [epochOffset, setEpochOffset] = useState<number>(0);
  const [loading, setLoading] = useState(true);

  // Automatic refresh: hourly.
  const [refreshTick, setRefreshTick] = useState(0);

  const [data, setData] = useState<Record<string, unknown[]>>({});
  const [warnings, setWarnings] = useState<Record<string, string | undefined>>({});
  const [prizes, setPrizes] = useState<Record<string, PrizeMeta | undefined>>({});
  const [fallbackMonthlyPrize, setFallbackMonthlyPrize] = useState<PrizeMeta | undefined>(undefined);
  const [epochInfo, setEpochInfo] = useState<EpochMeta | undefined>(undefined);


  const periodButtons = useMemo(() => ["weekly", "monthly"] as Period[], []);

  const epochButtons = useMemo(() => {
    if (period === "weekly") {
      return [
        { label: "This week", offset: 0 },
        { label: "Last week", offset: 1 },
        { label: "2 weeks ago", offset: 2 },
      ];
    }
    return [
      { label: "This month", offset: 0 },
      { label: "Last month", offset: 1 },
    ];
  }, [period]);

  // Reset history selection when the user flips between Weekly and Monthly.
  useEffect(() => {
    setEpochOffset(0);
  }, [period]);

  // Hourly refresh (dynamic leaderboards / prize boxes).
  useEffect(() => {
    const id = window.setInterval(() => setRefreshTick((t) => t + 1), 60 * 60 * 1000);
    return () => window.clearInterval(id);
  }, []);

  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setLoading(true);

        const results = await Promise.all(
          LEAGUES.map(async (l) => {
            const effectivePeriod = l.supports.includes(period) ? period : l.supports[0];
            const limit = getLimit(l, effectivePeriod);
            const qs = `chainId=${encodeURIComponent(String(activeChainId))}&period=${encodeURIComponent(effectivePeriod)}&epochOffset=${encodeURIComponent(
              String(effectivePeriod === "weekly" ? (period === "weekly" ? epochOffset : 0) : period === "monthly" ? epochOffset : 0)
            )}&limit=${encodeURIComponent(
              String(limit)
            )}&category=${encodeURIComponent(l.key)}`;

            const r = (await fetch(`/api/league?${qs}`).then((x) => x.json())) as LeagueResponse<unknown>;
            return [l.key, r] as const;
          })
        );

        if (cancelled) return;
        const nextData: Record<string, unknown[]> = {};
        const nextWarnings: Record<string, string | undefined> = {};
        const nextPrizes: Record<string, PrizeMeta | undefined> = {};

        let nextEpoch: EpochMeta | undefined = undefined;

        for (const [k, r] of results) {
          const items = Array.isArray(r?.items) ? r.items : [];
          nextData[k] = items;
          nextWarnings[k] = r?.warning;
          nextPrizes[k] = r?.prize;
          if (!nextEpoch && r?.epoch) nextEpoch = r.epoch;
        }

        setEpochInfo(nextEpoch);

        let nextFallbackMonthlyPrize: PrizeMeta | undefined = undefined;

        // Perfect Run is monthly-only, but we still want to show its monthly jackpot even when the user is viewing Weekly.
        // If the API doesn't return a prize for perfect_run, fall back to any monthly prize (monthly league pots are equal by config).
        if (!nextPrizes["perfect_run"]) {
          try {
            const qs2 = `chainId=${encodeURIComponent(String(activeChainId))}&period=${encodeURIComponent("monthly")}&epochOffset=${encodeURIComponent(
              "0"
            )}&limit=${encodeURIComponent("1")}&category=${encodeURIComponent("fastest_finish")}`;
            const rr = (await fetch(`/api/league?${qs2}`).then((x) => x.json())) as LeagueResponse<unknown>;
            nextFallbackMonthlyPrize = rr?.prize;
          } catch (e) {
            console.warn("[League] failed to load monthly prize fallback", e);
          }
        }

        setFallbackMonthlyPrize(nextFallbackMonthlyPrize);

        setData(nextData);
        setWarnings(nextWarnings);
        setPrizes(nextPrizes);
      } catch (e) {
        console.error("[League] failed to load /api/league", e);
        if (!cancelled) {
          setData({});
          setWarnings({});
          setPrizes({});
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [activeChainId, period, epochOffset, refreshTick]);

  return (
    <div className="h-full overflow-y-auto pr-2 pt-6 md:pt-8">
      <div className="flex items-start justify-between gap-4 mb-5">
        <div>
          <h1 className="text-lg md:text-2xl font-semibold">Battle Leagues</h1>
          <p className="text-xs md:text-sm text-muted-foreground">
            Objective onchain leaderboards. Prize pools are funded from the <span className="font-semibold">league fee</span> inside bondingcurve trades.
          </p>

          <div className="mt-3 inline-flex items-center gap-2 px-3 py-2 rounded-xl border border-border bg-card/30 text-xs md:text-sm">
            <span className="text-muted-foreground">Winners claim in</span>
            <button
              type="button"
              onClick={() => navigate("/profile?tab=rewards")}
              className="text-accent hover:text-accent/80 font-semibold"
            >
              Profile  Rewards
            </button>
          </div>
        </div>

        <div className="flex flex-col items-end gap-2">
          <div className="flex items-center gap-2">
            {periodButtons.map((p) => (
              <button
                key={p}
                type="button"
                onClick={() => setPeriod(p)}
                className={
                  "px-3 py-2 rounded-xl border text-xs md:text-sm transition-colors " +
                  (period === p
                    ? "bg-card border-border text-foreground"
                    : "bg-transparent border-border/50 text-muted-foreground hover:text-foreground")
                }
              >
                {periodLabel(p)}
              </button>
            ))}
          </div>

          <div className="flex items-center gap-2 flex-wrap justify-end">
            {epochButtons.map((b) => (
              <button
                key={b.offset}
                type="button"
                onClick={() => setEpochOffset(b.offset)}
                className={
                  "px-3 py-1.5 rounded-xl border text-[11px] md:text-xs transition-colors " +
                  (epochOffset === b.offset
                    ? "bg-card border-border text-foreground"
                    : "bg-transparent border-border/50 text-muted-foreground hover:text-foreground")
                }
              >
                {b.label}
              </button>
            ))}
          </div>

          <div className="text-[11px] text-muted-foreground text-right">
            <div>
              {epochInfo ? (
                <>
                  {epochInfo.status === "live" ? "Live" : "Finalized"}  {formatEpochRangeUtc(epochInfo)}
                </>
              ) : null}
            </div>
            <div>Chain {activeChainId}</div>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4">
        {LEAGUES.map((l) => {
          const effectivePeriod: Period = l.supports.includes(period) ? period : l.supports[0];
          const items = (data[l.key] ?? []) as unknown[];
          const warn = warnings[l.key];
          const prize = prizes[l.key];
          const cardPrize = l.key === "perfect_run" ? (prize ?? fallbackMonthlyPrize) : prize;

          const emptyText = !l.supports.includes(period)
            ? `This league runs ${l.supports.map(periodLabel).join(" / ")}.`
            : "No results yet for this period.";

          return (
            <div key={l.key} className="rounded-2xl border border-border/50 bg-card/40 overflow-hidden">
              <div className="relative">
                <div className="w-full aspect-square bg-black/10 flex items-center justify-center">
                  <img src={l.image} alt={l.title} className="max-w-full max-h-full object-contain" draggable={false} />
                </div>
                <div className="absolute inset-0 bg-gradient-to-t from-background/90 via-background/30 to-transparent" />
                <div className="absolute left-4 right-4 bottom-3">
                  <div className="flex items-end justify-between gap-3">
                    <div className="min-w-0">
                      <div className="text-base md:text-lg font-semibold truncate">{l.title}</div>
                      <div className="text-[11px] md:text-xs text-muted-foreground truncate">{l.subtitle}</div>
                    </div>
                    <div className="text-[11px] md:text-xs text-muted-foreground">{periodLabel(effectivePeriod)}</div>
                  </div>
                </div>
              </div>

              <div className="p-4">
                {/* Prize box (weekly/monthly only) */}
                {cardPrize && (effectivePeriod === "weekly" || effectivePeriod === "monthly") ? (
                  <div className="mb-3 rounded-xl border border-border/40 bg-card/50 p-3">
                    <div className="flex items-center justify-between gap-3">
                      <div className="text-[11px] text-muted-foreground">{l.key === "perfect_run" ? "Jackpot pool (monthly  league fee only)" : "Prize pool (league fee only)"}</div>
                      <div className="text-sm font-semibold">{formatBnbFromRaw(cardPrize.potRaw)} BNB</div>
                    </div>

                    <div className="mt-2 grid grid-cols-2 sm:grid-cols-5 gap-x-4 gap-y-1 text-[11px]">
                      <div>
                        <span className="text-muted-foreground">#1</span> <span className="font-semibold">{formatBnbFromRaw(cardPrize.payoutsRaw[0])}</span>
                      </div>
                      <div>
                        <span className="text-muted-foreground">#2</span> <span className="font-semibold">{formatBnbFromRaw(cardPrize.payoutsRaw[1])}</span>
                      </div>
                      <div>
                        <span className="text-muted-foreground">#3</span> <span className="font-semibold">{formatBnbFromRaw(cardPrize.payoutsRaw[2])}</span>
                      </div>
                      <div>
                        <span className="text-muted-foreground">#4</span> <span className="font-semibold">{formatBnbFromRaw(cardPrize.payoutsRaw[3])}</span>
                      </div>
                      <div>
                        <span className="text-muted-foreground">#5</span> <span className="font-semibold">{formatBnbFromRaw(cardPrize.payoutsRaw[4])}</span>
                      </div>
                    </div>

                    <div className="mt-2 text-[10px] text-muted-foreground">
                      Updated hourly  computed {formatIsoTiny(cardPrize.computedAt)}  total league fees {formatBnbFromRaw(cardPrize.totalLeagueFeeRaw)} BNB
                    </div>
                  </div>
                ) : null}

                {warn ? <div className="mb-3 text-[11px] text-muted-foreground">{warn}</div> : null}

                {loading ? (
                  <div className="text-sm text-muted-foreground">Loading...</div>
                ) : items.length ? (
                  <div className="space-y-2">
                    {items.map((rowAny, idx) => {
                      const rank = clampInt(idx + 1, 1, 999);
                      const rankEl = (
                        <div className="w-7 text-sm font-semibold" style={{ color: "#affe00" }}>
                          {rank}
                        </div>
                      );

                      // Per-league row content
                      let leftEl: JSX.Element;
                      let metricTop = "";
                      let metricSub = "";
                      let onClick: (() => void) | undefined;
                      let key = "";

                      if (l.key === "top_earner") {
                        const r = rowAny as TopEarnerRow;
                        const wallet = String(r.wallet ?? "");
                        leftEl = <RowWallet address={wallet} />;
                        metricTop = `${formatBnbFromRaw(String(r.profit_raw ?? "0"))} BNB`;
                        metricSub = `${Number(r.trades_count ?? 0)} trades`;
                        key = `${l.key}:${wallet}:${idx}`;
                        onClick = () => {
                          if (isAddress(wallet)) navigate(`/profile?address=${wallet}`);
                        };
                      } else {
                        const row = rowAny as any;
                        const address = String(row.campaign_address ?? "");
                        leftEl = <RowToken logo={row.logo_uri} name={row.name} symbol={row.symbol} address={address} />;
                        key =
                          l.key === "biggest_hit"
                            ? `${String(row.tx_hash ?? "")}:${String(row.log_index ?? idx)}`
                            : `${l.key}:${address}:${idx}`;
                        onClick = () => {
                          if (isAddress(address)) navigate(`/token/${address}`);
                        };

                        if (l.key === "fastest_finish" || l.key === "perfect_run") {
                          const rr = row as GraduationRow;
                          metricTop = formatDuration(rr.duration_seconds ?? null);
                          metricSub = `${Number(rr.unique_buyers ?? 0)} buyers`;
                        } else if (l.key === "biggest_hit") {
                          const rr = row as BiggestHitRow;
                          metricTop = `${formatBnbFromRaw(rr.bnb_amount_raw)} BNB`;
                          metricSub = `Buyer: ${isAddress(rr.buyer_address) ? shortAddr(rr.buyer_address) : "-"}`;
                        } else if (l.key === "crowd_favorite") {
                          const rr = row as CrowdFavoriteRow;
                          metricTop = `${String(rr.votes_count)} votes`;
                          metricSub = `${String(rr.unique_voters)} voters`;
                        }
                      }

                      return (
                        <button
                          key={key}
                          type="button"
                          onClick={onClick}
                          className="w-full rounded-xl px-3 py-2 border border-border/40 hover:bg-card transition-colors text-left flex items-center gap-3"
                        >
                          {rankEl}
                          <div className="min-w-0 flex-1">{leftEl}</div>
                          <div className="text-right">
                            <div className="text-sm font-semibold">{metricTop}</div>
                            <div className="text-[11px] text-muted-foreground">{metricSub}</div>
                          </div>
                        </button>
                      );
                    })}
                  </div>
                ) : (
                  <div className="text-sm text-muted-foreground">{emptyText}</div>
                )}
              </div>
            </div>
          );
        })}
      </div>

      <div className="mt-6 text-xs text-muted-foreground">
        <div className="font-semibold text-foreground mb-1">Locked rules (summary)</div>
        <ul className="list-disc ml-5 space-y-1">
          <li>
            <span className="font-semibold">Perfect Run</span>: monthly only; campaign must graduate with <span className="font-semibold">zero</span> bondingcurve sells.
          </li>
          <li>
            <span className="font-semibold">Fastest Finish</span>: time from creation  graduation; creator buys excluded.
          </li>
          <li>
            <span className="font-semibold">Biggest Hit</span>: single largest bondingcurve buy (BNB).
          </li>
          <li>
            <span className="font-semibold">Top Earner</span>: trader PnL inside bonding curve (net sells  buys in BNB).
          </li>
          <li>
            <span className="font-semibold">Crowd Favorite</span>: most UpVotes (confirmed votes).
          </li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/App.tsx">
/**
 * Main Application Component
 * Handles routing, layout structure, and loading screen display
 * Sets up global providers for query client, tooltips, and toasts
 */

import { Toaster } from "@/components/ui/toaster";
import { Toaster as Sonner } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { useState } from "react";
import { LoadingScreen } from "@/components/LoadingScreen";
import Showcase from "./pages/Showcase";
import Create from "./pages/Create";
import League from "./pages/League";
import Profile from "./pages/Profile";
import TokenDetails from "./pages/TokenDetails";
import Playbook from "@/pages/Playbook";
import Status from "./pages/Status";
import NotFound from "./pages/NotFound";
import { Sidebar } from "@/components/Sidebar";
import { TopBar } from "@/components/TopBar";

const queryClient = new QueryClient();

const App = () => {
  const [isLoading, setIsLoading] = useState(true);
  const [showContent, setShowContent] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const handleLoadComplete = () => {
    setIsLoading(false);
    // Delay showing content slightly for smooth transition
    setTimeout(() => setShowContent(true), 100);
  };

  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <Sonner />
        {isLoading && <LoadingScreen onLoadComplete={handleLoadComplete} />}
        <div 
          className={`transition-all duration-700 ${
            showContent ? "opacity-100 scale-100" : "opacity-0 scale-95"
          }`}
        >
          <BrowserRouter>
            <div className="h-screen overflow-hidden bg-black flex flex-col">
              <Sidebar mobileMenuOpen={mobileMenuOpen} setMobileMenuOpen={setMobileMenuOpen} />
              <TopBar mobileMenuOpen={mobileMenuOpen} setMobileMenuOpen={setMobileMenuOpen} />
              {/*
                TopBar is fixed-position, so main content needs top padding.
                pt-14 (~56px) matches the TopBar height more closely and removes the
                extra dead space above the hero/logo.
              */}
              <main className="flex-1 overflow-hidden pt-4 px-4 md:px-6 lg:px-8 pb-4 md:pb-6 lg:pb-8">
                <Routes>
                  <Route path="/" element={<Showcase />} />
                  <Route path="/create" element={<Create />} />
                  {/* New naming (keep old paths as aliases) */}
                  <Route path="/battle-leagues" element={<League />} />
                  <Route path="/league" element={<League />} />
                  <Route path="/profile" element={<Profile />} />
                  <Route path="/token/:campaignAddress" element={<TokenDetails />} />
                  <Route path="/docs" element={<Playbook />} />
            <Route path="/playbook" element={<Playbook />} />
            <Route path="/docs" element={<Playbook />} />
                  <Route path="/status" element={<Status />} />
                  {/* ADD ALL CUSTOM ROUTES ABOVE THE CATCH-ALL "*" ROUTE */}
                  <Route path="*" element={<NotFound />} />
                </Routes>
              </main>
            </div>
          </BrowserRouter>
        </div>
      </TooltipProvider>
    </QueryClientProvider>
  );
};

export default App;
</file>

<file path="frontend/src/components/home/CampaignCard.tsx">
import { AthBar } from "@/components/token/AthBar";
import { UpvoteDialog } from "@/components/token/UpvoteDialog";
import { cn } from "@/lib/utils";
import { useNavigate } from "react-router-dom";
import { resolveImageUri } from "@/lib/media";

export type CampaignCardVM = {
  campaignAddress: string;
  name: string;
  symbol: string;
  logoURI?: string;
  creator?: string;
  createdAt?: number; // unix seconds

  // Computed / hydrated fields
  marketCapUsdLabel?: string | null;
  athLabel?: string | null;
  progressPct?: number | null;
  isDexTrading?: boolean;
  votes24h?: number;
};

function shortAddr(addr?: string) {
  if (!addr) return "";
  const a = String(addr);
  return a.length > 10 ? `${a.slice(0, 6)}...${a.slice(-4)}` : a;
}

function timeAgoFromUnix(seconds?: number): string {
  if (!seconds || !Number.isFinite(seconds)) return "";
  const now = Math.floor(Date.now() / 1000);
  const diff = Math.max(0, now - seconds);
  if (diff < 60) return `${diff}s ago`;
  const m = Math.floor(diff / 60);
  if (m < 60) return `${m}m ago`;
  const h = Math.floor(m / 60);
  if (h < 24) return `${h}h ago`;
  const d = Math.floor(h / 24);
  return `${d}d ago`;
}

export function CampaignCard({
  vm,
  chainIdForStorage,
  className,
}: {
  vm: CampaignCardVM;
  chainIdForStorage: number;
  className?: string;
}) {
  const navigate = useNavigate();
  const addr = String(vm.campaignAddress ?? "").toLowerCase();
  const creatorAddr = String(vm.creator ?? "").trim();
  const canOpenProfile = creatorAddr.length > 0;
  const openProfile = () => {
    if (!canOpenProfile) return;
    navigate(`/profile?address=${encodeURIComponent(creatorAddr)}`);
  };

  return (
    <div
      className={cn(
        "group relative flex w-full max-w-[clamp(160px,20vw,210px)] flex-col rounded-2xl overflow-hidden border border-border/50 bg-card/60",
        "transition-all hover:border-accent/50 hover:shadow-[0_0_0_1px_rgba(255,159,28,0.18),0_18px_50px_-22px_rgba(255,120,0,0.38)]",
        className
      )}
    >
      {/* Image */}
      <button
        className="block w-full text-left"
        onClick={() => navigate(`/token/${addr}`)}
        aria-label={`Open ${vm.name}`}
      >
        <div className="relative aspect-square w-full">
          <img
            src={resolveImageUri(vm.logoURI) || "/placeholder.svg"}
            alt={vm.name}
            className="h-full w-full object-cover bg-muted"
            draggable={false}
            loading="lazy"
          />
          {/* subtle top fade */}
          <div className="absolute inset-0 bg-gradient-to-t from-background/70 via-transparent to-transparent" />
        </div>
      </button>

      {/* Content */}
      <div className="flex aspect-square flex-col p-4">
        {/* Title + upvotes */}
        <div className="flex items-start justify-between gap-3">
          <div className="min-w-0">
            <div className="text-base font-semibold truncate">{vm.name}</div>
            <div className="text-xs text-muted-foreground truncate">{vm.symbol ? `$${vm.symbol}` : ""}</div>
          </div>

          <div onClick={(e) => e.stopPropagation()} className="shrink-0">
            <UpvoteDialog campaignAddress={addr} />
          </div>
        </div>

        {/* Creator + time */}
        <div className="mt-3 flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 min-w-0">
            <img
              src="/assets/profile_placeholder.png"
              alt="Creator"
              className={cn(
                "w-7 h-7 rounded-full object-cover border border-border/60",
                canOpenProfile ? "cursor-pointer hover:border-accent/60" : ""
              )}
              draggable={false}
              role={canOpenProfile ? "button" : undefined}
              tabIndex={canOpenProfile ? 0 : undefined}
              onClick={(e) => {
                if (!canOpenProfile) return;
                e.stopPropagation();
                openProfile();
              }}
              onKeyDown={(e) => {
                if (!canOpenProfile) return;
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  e.stopPropagation();
                  openProfile();
                }
              }}
            />
            <div
              className={cn(
                "text-xs text-muted-foreground truncate",
                canOpenProfile ? "cursor-pointer hover:text-foreground" : ""
              )}
              role={canOpenProfile ? "button" : undefined}
              tabIndex={canOpenProfile ? 0 : undefined}
              onClick={(e) => {
                if (!canOpenProfile) return;
                e.stopPropagation();
                openProfile();
              }}
              onKeyDown={(e) => {
                if (!canOpenProfile) return;
                if (e.key === "Enter" || e.key === " ") {
                  e.preventDefault();
                  e.stopPropagation();
                  openProfile();
                }
              }}
            >
              {vm.creator ? shortAddr(vm.creator) : ""}
            </div>
          </div>
          <div className="text-xs text-muted-foreground shrink-0">{timeAgoFromUnix(vm.createdAt)}</div>
        </div>

        {/* Key stats */}
        <div className="mt-3 flex items-center justify-between gap-3">
          <div className="min-w-0">
            <div className="text-[10px] text-muted-foreground">MCap</div>
            <div className="text-xs font-semibold truncate">{vm.marketCapUsdLabel ?? ""}</div>
          </div>

          <div className="text-right">
            <div className="text-[10px] text-muted-foreground">UpVotes (24h)</div>
            <div className="text-xs font-semibold">{Number(vm.votes24h ?? 0)}</div>
          </div>
        </div>

        {/* ATH bar */}
        <div className="mt-3">
          <AthBar
            currentLabel={vm.athLabel ?? null}
            storageKey={`ath:${String(chainIdForStorage)}:${addr}`}
            className="text-[10px]"
            barWidthPx={220}
            barMaxWidth="100%"
          />
        </div>

      </div>
    </div>
  );
}
</file>

<file path="frontend/src/pages/Profile.tsx">
import { useEffect, useMemo, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Copy, ExternalLink } from "lucide-react";
import { toast } from "sonner";
import { useNavigate, useSearchParams } from "react-router-dom";
import { ProfileTab } from "@/types/profile";
import { useWallet } from "@/hooks/useWallet";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignSummary } from "@/lib/launchpadClient";
import { BrowserProvider, Contract, ethers } from "ethers";
import { EditProfileDialog } from "@/components/profile/EditProfileDialog";
import {
  buildProfileMessage,
  fetchUserProfile,
  requestNonce,
  saveUserProfile,
  type UserProfile,
} from "@/lib/profileApi";
import {
  buildLeagueClaimMessage,
  fetchClaimableRewards,
  formatWeiToBnb,
  submitLeagueClaim,
  type RewardItem,
} from "@/lib/rewardsApi";
import { 
  followUser, unfollowUser, isFollowingUser, getFollowersCount, getFollowingCount, 
  getFollowers, getFollowing, getFollowedCampaigns 
} from '@/lib/followApi';

type TokenBalanceRow = {
  campaignAddress: string;
  tokenAddress: string;
  image: string;
  name: string;
  ticker: string;
  balanceRaw: bigint;
  balanceFormatted: string;
};

type ActivityTradeRow = {
  id: string;
  txHash: string;
  logIndex: number;
  blockNumber: number;
  blockTime: string;
  side: "buy" | "sell";
  wallet: string;
  tokenAmount: number | null;
  bnbAmount: number | null;
  priceBnb: number | null;
  campaignAddress: string;
  campaignName: string | null;
  campaignSymbol: string | null;
  logoUri: string | null;
};

const REALTIME_API_BASE = String(import.meta.env.VITE_REALTIME_API_BASE || "").replace(/\/$/, "");

const ERC20_ABI_MIN = [
  {
    type: "function",
    name: "balanceOf",
    stateMutability: "view",
    inputs: [{ name: "account", type: "address" }],
    outputs: [{ name: "balance", type: "uint256" }],
  },
  {
    type: "function",
    name: "decimals",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "decimals", type: "uint8" }],
  },
  {
    type: "function",
    name: "symbol",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "symbol", type: "string" }],
  },
] as const;

function getExplorerBase(chainId?: number): string {
  // BSC
  if (chainId === 97) return "https://testnet.bscscan.com";
  if (chainId === 56) return "https://bscscan.com";

  // Fallback (keeps link valid-ish)
  return "https://bscscan.com";
}

function shorten(addr?: string | null) {
  if (!addr) return "";
  if (addr.length <= 10) return addr;
  return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
}

function pickTokenAddressFromSummary(s: CampaignSummary): string | null {
  const anyCampaign: any = s?.campaign as any;
  // Try common fields (adjust once you confirm your schema)
  return (
    anyCampaign?.token ||
    anyCampaign?.tokenAddress ||
    anyCampaign?.tokenContract ||
    anyCampaign?.tokenAddr ||
    null
  );
}

const Profile = () => {
  const navigate = useNavigate();
  const wallet = useWallet();
  const { fetchCampaigns, fetchCampaignSummary } = useLaunchpad();

  const anyWallet: any = wallet as any;

  // Prefer an explicit isConnected flag if your hook provides it.
  const isConnected: boolean = Boolean(
    anyWallet?.isConnected ?? anyWallet?.connected ?? wallet.account
  );

  const account: string | null = isConnected ? (wallet.account ?? null) : null;
  const [searchParams] = useSearchParams();
  const addressParam = searchParams.get("address");
  const tabParam = searchParams.get("tab");
  const viewedAddress: string | null = addressParam ? addressParam : account;
  const isOwnProfile = Boolean(account && viewedAddress && account.toLowerCase() === viewedAddress.toLowerCase());
  const chainId: number | undefined = anyWallet?.chainId ?? anyWallet?.network?.chainId;

  const [activeTab, setActiveTab] = useState<ProfileTab>("balances");
  const [activityTab, setActivityTab] = useState<"trades" | "comments" | "created" | "interactions">("trades");

  // Rewards (league winnings)
  const [rewards, setRewards] = useState<RewardItem[]>([]);
  const [loadingRewards, setLoadingRewards] = useState(false);
  const [rewardsError, setRewardsError] = useState<string | null>(null);
  const [claimingKey, setClaimingKey] = useState<string | null>(null);

  const [activityTrades, setActivityTrades] = useState<ActivityTradeRow[]>([]);
  const [activityLoading, setActivityLoading] = useState(false);
  const [activityError, setActivityError] = useState<string | null>(null);

  const [created, setCreated] = useState<
    Array<{
      id: number;
      image: string;
      name: string;
      ticker: string;
      campaignAddress: string;
      marketCap: string;
      timeAgo: string;
      buyersCount?: number;
    }>
  >([]);

  const [nativeBalance, setNativeBalance] = useState<string>("");
  const [tokenBalances, setTokenBalances] = useState<TokenBalanceRow[]>([]);
  const [loadingBalances, setLoadingBalances] = useState(false);

  // Profile (username / bio)
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [loadingProfile, setLoadingProfile] = useState(false);
  const [editOpen, setEditOpen] = useState(false);
  const [savingProfile, setSavingProfile] = useState(false);
  const [awaitingWallet, setAwaitingWallet] = useState(false);
  const [savingAvatar, setSavingAvatar] = useState(false);
  const avatarInputRef = useRef<HTMLInputElement | null>(null);

  // Optional: allow deep-linking to a tab (e.g. /profile?tab=rewards)
  useEffect(() => {
    const t = String(tabParam ?? "").toLowerCase().trim();
    if (!t) return;
    if (t === "rewards") setActiveTab("rewards");
    if (t === "balances") setActiveTab("balances");
    if (t === "coins") setActiveTab("coins");
    if (t === "activity" || t === "replies") setActiveTab("replies");
    if (t === "followers") setActiveTab("followers");
    if (t === "notifications") setActiveTab("notifications");
  }, [tabParam]);

  // Allow deep-linking: /profile?tab=rewards
  useEffect(() => {
    const t = String(tabParam ?? "").toLowerCase().trim();
    if (t === "rewards") setActiveTab("rewards");
  }, [tabParam]);


  const walletAddressShort = useMemo(() => shorten(viewedAddress), [viewedAddress]);

  const displayName = useMemo(() => {
    const u = (profile?.displayName ?? "").trim();
    return u ? `@${u}` : walletAddressShort || "Profile";
  }, [profile?.displayName, walletAddressShort]);

  const walletAddressFull = viewedAddress ?? "Not connected";

  const explorerUrl = useMemo(() => {
    if (!viewedAddress) return "#";
    const base = getExplorerBase(chainId);
    return `${base}/address/${viewedAddress}`;
  }, [viewedAddress, chainId]);

  // Optional deep-linking: /profile?tab=rewards
  useEffect(() => {
    const t = String(tabParam ?? "").toLowerCase().trim();
    if (!t) return;
    const allowed: ProfileTab[] = ["balances", "coins", "replies", "rewards", "notifications", "followers"];
    if (allowed.includes(t as ProfileTab)) setActiveTab(t as ProfileTab);
  }, [tabParam]);

  // Load profile from backend (username/bio/avatar) if configured
  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      if (!viewedAddress) {
        setProfile(null);
        return;
      }

      setLoadingProfile(true);
      try {
        if (!chainId) {
          setProfile(null);
          return;
        }
        const p = await fetchUserProfile(chainId, viewedAddress);
        if (!cancelled) setProfile(p);
      } catch (e: any) {
        // Fail gracefully if the backend is not configured or the endpoint is missing.
        console.warn("Failed to load profile", e);
        if (!cancelled) setProfile(null);
      } finally {
        if (!cancelled) setLoadingProfile(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [viewedAddress, chainId]);

  // Load claimable league rewards (suppresses already-claimed)
  useEffect(() => {
    let cancelled = false;
    const loadRewards = async () => {
      if (activeTab !== "rewards") return;
      if (!chainId || !account || !isOwnProfile) {
        setRewards([]);
        return;
      }
      setLoadingRewards(true);
      setRewardsError(null);
      try {
        const items = await fetchClaimableRewards(chainId, account);
        if (!cancelled) setRewards(items);
      } catch (e: any) {
        const msg = String(e?.message ?? "Failed to load rewards");
        console.warn("Failed to load rewards", e);
        if (!cancelled) setRewardsError(msg);
        if (!cancelled) setRewards([]);
      } finally {
        if (!cancelled) setLoadingRewards(false);
      }
    };
    loadRewards();
    return () => {
      cancelled = true;
    };
  }, [activeTab, chainId, account, isOwnProfile]);


  const formatTimeAgo = (createdAt?: number): string => {
    if (!createdAt) return "";
    const now = Math.floor(Date.now() / 1000);
    const diff = Math.max(0, now - createdAt);
    if (diff < 60) return "now";
    const mins = Math.floor(diff / 60);
    if (mins < 60) return `${mins}m`;
    const hours = Math.floor(mins / 60);
    if (hours < 24) return `${hours}h`;
    const days = Math.floor(hours / 24);
    if (days < 7) return `${days}d`;
    const weeks = Math.floor(days / 7);
    return `${weeks}w`;
  };

  const formatNumber = (value?: number | null, maxDecimals = 4): string => {
    if (value == null || !Number.isFinite(value)) return "";
    return Number(value).toLocaleString(undefined, { maximumFractionDigits: maxDecimals });
  };

  const handleCopyAddress = () => {
    if (!viewedAddress) return;
    navigator.clipboard.writeText(viewedAddress);
    toast.success("Address copied!");
  };

  const handleConnect = async () => {
    // Try common hook patterns
    if (typeof anyWallet?.connect === "function") return anyWallet.connect();
    if (typeof anyWallet?.openConnectModal === "function") return anyWallet.openConnectModal();

    toast.message("Use the Connect Wallet button in the header to connect.");
  };

  const handleEdit = () => {
    if (!account) {
      handleConnect();
      return;
    }
    setEditOpen(true);
  };

  const uploadAvatarFile = async (file: File): Promise<string> => {
    if (!chainId) throw new Error("ChainId is not available.");
    if (!account) throw new Error("Wallet not connected.");

    const maxBytes = 500 * 1024;
    if (file.size > maxBytes) throw new Error("Avatar must be <= 500 KB.");

    const typeOk = /^(image\/png|image\/jpeg|image\/jpg|image\/webp)$/.test(file.type);
    if (!typeOk) throw new Error("Unsupported image type. Use png/jpg/webp.");

    const fd = new FormData();
    fd.append("file", file);

    const url = `/api/upload?kind=avatar&chainId=${encodeURIComponent(
      String(chainId)
    )}&address=${encodeURIComponent(account.toLowerCase())}`;

    const res = await fetch(url, { method: "POST", body: fd });
    const j = await res.json().catch(() => null);
    if (!res.ok) throw new Error(j?.error || `Upload failed (${res.status})`);
    if (!j?.url) throw new Error("Upload did not return a URL.");
    return String(j.url);
  };

  const handlePickAvatar = () => {
    if (!account) {
      handleConnect();
      return;
    }
    avatarInputRef.current?.click();
  };

  const handleAvatarSelected = async (file: File) => {
    if (!account) {
      toast.error("Connect your wallet to change your avatar.");
      return;
    }
    if (!chainId) {
      toast.error("ChainId is not available. Reconnect your wallet and try again.");
      return;
    }
    if (!wallet.signer) {
      toast.error("Wallet signer is not available. Reconnect your wallet and try again.");
      return;
    }

    setSavingAvatar(true);
    const toastId = toast.loading("Uploading");
    try {
      const uploadedUrl = await uploadAvatarFile(file);

      // Sign and persist the new avatar url
      const addr = account.toLowerCase();
      const nonce = await requestNonce(chainId, addr);
      const displayName = (profile?.displayName ?? "").trim() || null;
      const bio = (profile?.bio ?? "").trim() || null;

      setAwaitingWallet(true);
      toast.dismiss(toastId);
      const toastId2 = toast.loading("Confirm the signature in your wallet");
      let signature = "";
      try {
        const msg = buildProfileMessage({
          chainId,
          address: addr,
          nonce,
          displayName,
          avatarUrl: uploadedUrl,
        });
        signature = await wallet.signer.signMessage(msg);
      } finally {
        setAwaitingWallet(false);
        toast.dismiss(toastId2);
      }

      const toastId3 = toast.loading("Saving profile");
      try {
        await saveUserProfile({
          chainId,
          address: addr,
          displayName,
          bio,
          avatarUrl: uploadedUrl,
          nonce,
          signature,
        });
      } finally {
        toast.dismiss(toastId3);
      }

      const refreshed = await fetchUserProfile(chainId, addr);
      setProfile(refreshed);
      toast.success("Avatar updated.");
    } catch (e: any) {
      toast.error(e?.message ?? "Failed to update avatar.");
    } finally {
      setSavingAvatar(false);
      toast.dismiss(toastId);
    }
  };

  const handleSaveProfile = async (values: { username: string; bio: string }) => {
    if (!account) {
      toast.error("Connect your wallet to edit your profile.");
      return;
    }
    if (!chainId) {
      toast.error("ChainId is not available. Reconnect your wallet and try again.");
      return;
    }
    if (!wallet.signer) {
      toast.error("Wallet signer is not available. Reconnect your wallet and try again.");
      return;
    }

    setSavingProfile(true);

    const toastId = toast.loading("Preparing signature");
    try {
      const addr = account.toLowerCase();
      const nonce = await requestNonce(chainId, addr);
      const displayName = values.username.trim();
      const avatarUrl = profile?.avatarUrl ?? null;

      setAwaitingWallet(true);
      toast.dismiss(toastId);
      const toastId2 = toast.loading("Confirm the signature in your wallet");
      let signature = "";
      try {
        const msg = buildProfileMessage({
          chainId,
          address: addr,
          nonce,
          displayName: displayName || null,
          avatarUrl: avatarUrl ?? null,
        });
        signature = await wallet.signer.signMessage(msg);
      } finally {
        setAwaitingWallet(false);
        toast.dismiss(toastId2);
      }

      const toastId3 = toast.loading("Saving profile");
      try {
        await saveUserProfile({
          chainId,
          address: addr,
          displayName: displayName || null,
          bio: values.bio.trim() || null,
          avatarUrl,
          nonce,
          signature,
        });
      } finally {
        toast.dismiss(toastId3);
      }

      const refreshed = await fetchUserProfile(chainId, addr);
      setProfile(refreshed);
      setEditOpen(false);
      toast.success("Profile updated.");
    } catch (e: any) {
      toast.error(e?.message ?? "Failed to update profile.");
    } finally {
      setSavingProfile(false);
      toast.dismiss(toastId);
    }
  };

  const handleClaimPrize = async (item: RewardItem) => {
    if (!account) {
      toast.error("Connect your wallet to claim.");
      handleConnect();
      return;
    }
    if (!chainId) {
      toast.error("ChainId is not available. Reconnect your wallet and try again.");
      return;
    }
    if (!wallet.signer) {
      toast.error("Wallet signer is not available. Reconnect your wallet and try again.");
      return;
    }
    if (!isOwnProfile) {
      toast.error("You can only claim from your own profile.");
      return;
    }

    const key = `${item.period}:${item.epochStart}:${item.category}:${item.rank}`;
    setClaimingKey(key);

    const toastId = toast.loading("Preparing claim");
    try {
      const recipient = account.toLowerCase();
      const nonce = await requestNonce(chainId, recipient);

      toast.dismiss(toastId);
      const toastId2 = toast.loading("Confirm the signature in your wallet");
      let signature = "";
      try {
        const msg = buildLeagueClaimMessage({
          chainId,
          recipient,
          period: item.period,
          epochStart: item.epochStart,
          category: item.category,
          rank: item.rank,
          nonce,
        });
        signature = await wallet.signer.signMessage(msg);
      } finally {
        toast.dismiss(toastId2);
      }

      const toastId3 = toast.loading("Submitting claim");
      try {
        await submitLeagueClaim({
          chainId,
          period: item.period,
          epochStart: item.epochStart,
          category: item.category,
          rank: item.rank,
          recipient,
          nonce,
          signature,
        });
      } finally {
        toast.dismiss(toastId3);
      }

      // Remove from list (claimed prizes are suppressed)
      setRewards((prev) => prev.filter((r) => `${r.period}:${r.epochStart}:${r.category}:${r.rank}` !== key));
      toast.success("Claim recorded.");
    } catch (e: any) {
      toast.error(e?.message ?? "Claim failed.");
    } finally {
      setClaimingKey(null);
      toast.dismiss(toastId);
    }
  };

  // Load created campaigns (creator view)
  useEffect(() => {
    let cancelled = false;

    const loadCreated = async () => {
      try {
        if (!viewedAddress) {
          setCreated([]);
          return;
        }

        const campaigns = (await fetchCampaigns()) ?? [];
        const mine = campaigns.filter(
          (c) => (c.creator ?? "").toLowerCase() === account.toLowerCase()
        );

        const results = await Promise.allSettled(mine.map((c) => fetchCampaignSummary(c)));

        if (cancelled) return;

        const next = results
          .filter(
            (r): r is PromiseFulfilledResult<CampaignSummary> => r.status === "fulfilled"
          )
          .map((r, idx) => {
            const s = r.value;
            return {
              id: typeof s.campaign.id === "number" ? s.campaign.id : idx + 1,
              image: s.campaign.logoURI || "/placeholder.svg",
              name: s.campaign.name,
              ticker: s.campaign.symbol,
              campaignAddress: s.campaign.campaign,
              marketCap: s.stats.marketCap,
              timeAgo: (s.campaign as any).timeAgo || formatTimeAgo(s.campaign.createdAt),
              buyersCount: (s.stats as any)?.buyersCount ?? undefined,
            };
          });

        setCreated(next);
      } catch (e) {
        console.error("[Profile] Failed to load created campaigns", e);
        if (!cancelled) setCreated([]);
      }
    };

    loadCreated();
    return () => {
      cancelled = true;
    };
  }, [account, fetchCampaigns, fetchCampaignSummary]);

  // Load balances (native + launchpad token balances)
  useEffect(() => {
    let cancelled = false;

    const resolveReadProvider = (): ethers.Provider | null => {
      // 1) If the wallet hook already gives us an ethers provider, use it directly.
      //    (Do NOT wrap it in BrowserProvider again.)
      const p = (wallet as any)?.provider;
      if (p && typeof p.getBalance === "function") return p as ethers.Provider;

      // 2) Fallback to injected provider if it's a real EIP-1193 provider
      const injected = (window as any)?.ethereum;
      if (injected && typeof injected.request === "function") {
        return new BrowserProvider(injected);
      }

      return null;
    };

    const loadBalances = async () => {
      try {
        if (!viewedAddress) {
          setNativeBalance("");
          setTokenBalances([]);
          return;
        }

        const readProvider = resolveReadProvider();
        if (!readProvider) {
          // No usable provider in the browser right now; skip quietly.
          setNativeBalance("");
          setTokenBalances([]);
          return;
        }

        setLoadingBalances(true);

        // Native (BNB) balance
        const bal = await readProvider.getBalance(account as any);
        const bnb = Number(ethers.formatUnits(bal, 18)).toFixed(4);
        if (!cancelled) setNativeBalance(`${bnb} BNB`);

        // Launchpad token balances:
        const campaigns = (await fetchCampaigns()) ?? [];
        const summaries = await Promise.allSettled(
          campaigns.map((c) => fetchCampaignSummary(c))
        );

        const fulfilled = summaries
          .filter(
            (r): r is PromiseFulfilledResult<CampaignSummary> => r.status === "fulfilled"
          )
          .map((r) => r.value);

        const rows: TokenBalanceRow[] = [];

        for (const s of fulfilled) {
          const tokenAddr = pickTokenAddressFromSummary(s);
          if (!tokenAddr) continue;

          try {
            const erc20 = new Contract(tokenAddr as any, ERC20_ABI_MIN as any, readProvider);

            const [rawBal, decimalsAny, symbolMaybe] = await Promise.all([
              erc20.balanceOf(account) as Promise<bigint>,
              (erc20.decimals() as Promise<any>).catch(() => 18),
              (erc20.symbol() as Promise<string>).catch(() => null) as Promise<string | null>,
            ]);

            if (typeof rawBal !== "bigint" || rawBal <= 0n) continue;

            const decimals = Number(decimalsAny);
            const formatted = ethers.formatUnits(
              rawBal,
              Number.isFinite(decimals) ? decimals : 18
            );

            rows.push({
              campaignAddress: s.campaign.campaign,
              tokenAddress: tokenAddr,
              image: s.campaign.logoURI || "/placeholder.svg",
              name: s.campaign.name,
              ticker: s.campaign.symbol || symbolMaybe || "",
              balanceRaw: rawBal,
              balanceFormatted: formatted,
            });
          } catch {
            continue;
          }
        }

        if (!cancelled) {
          setTokenBalances(rows.sort((a, b) => (a.balanceRaw > b.balanceRaw ? -1 : 1)));
        }
      } catch (e) {
        console.error("[Profile] Failed to load balances", e);
        if (!cancelled) {
          setNativeBalance("");
          setTokenBalances([]);
        }
      } finally {
        if (!cancelled) setLoadingBalances(false);
      }
    };

    loadBalances();
    return () => {
      cancelled = true;
    };
    // IMPORTANT: include wallet.provider as a dependency so it reruns once provider is ready.
  }, [account, fetchCampaigns, fetchCampaignSummary, wallet]);

  // Activity: Trades (profile feed)
  useEffect(() => {
    let cancelled = false;

    if (activeTab !== "replies" || activityTab !== "trades") return;

    if (!viewedAddress) {
      setActivityTrades([]);
      setActivityError(null);
      setActivityLoading(false);
      return;
    }

    if (!REALTIME_API_BASE) {
      setActivityTrades([]);
      setActivityError("Missing VITE_REALTIME_API_BASE");
      setActivityLoading(false);
      return;
    }

    const ac = new AbortController();
    const addr = viewedAddress.toLowerCase();
    const cid = Number(chainId ?? 97);

    setActivityLoading(true);
    setActivityError(null);

    (async () => {
      try {
        const qs = new URLSearchParams({
          chainId: String(cid),
          address: addr,
          limit: "50",
        });
        const url = `${REALTIME_API_BASE}/api/activity/trades?${qs.toString()}`;
        const r = await fetch(url, { method: "GET", signal: ac.signal });
        const j = await r.json().catch(() => null);
        if (!r.ok) throw new Error(j?.error || `HTTP ${r.status}`);
        const rows = Array.isArray(j?.items) ? j.items : [];
        const next: ActivityTradeRow[] = rows.map((it: any) => ({
          id: String(it?.id ?? `${it?.txHash ?? ""}:${it?.logIndex ?? 0}`),
          txHash: String(it?.txHash ?? ""),
          logIndex: Number(it?.logIndex ?? 0),
          blockNumber: Number(it?.blockNumber ?? 0),
          blockTime: String(it?.blockTime ?? ""),
          side: (String(it?.side ?? "buy") === "sell" ? "sell" : "buy"),
          wallet: String(it?.wallet ?? ""),
          tokenAmount: it?.tokenAmount == null ? null : Number(it.tokenAmount),
          bnbAmount: it?.bnbAmount == null ? null : Number(it.bnbAmount),
          priceBnb: it?.priceBnb == null ? null : Number(it.priceBnb),
          campaignAddress: String(it?.campaignAddress ?? ""),
          campaignName: it?.campaignName ?? null,
          campaignSymbol: it?.campaignSymbol ?? null,
          logoUri: it?.logoUri ?? null,
        }));
        if (cancelled) return;
        setActivityTrades(next);
      } catch (e: any) {
        if (cancelled || ac.signal.aborted) return;
        setActivityError(String(e?.message || "Failed to load trades"));
        setActivityTrades([]);
      } finally {
        if (cancelled) return;
        setActivityLoading(false);
      }
    })();

    return () => {
      cancelled = true;
      ac.abort();
    };
  }, [activeTab, activityTab, viewedAddress, chainId]);


  // Followers/Following numbers (MVP proxies)
  const followingCount = 0; // later: number of followed creators/coins (watchlist)
  const followersCount = useMemo(() => {
    // MVP proxy:
    // If you created coins, treat total buyersCount as "followers" (better label later: "Investors").
    const sum = created.reduce((acc, c) => acc + (c.buyersCount ?? 0), 0);
    return sum;
  }, [created]);

  return (
        <div className="w-full h-full overflow-y-auto pt-10 md:pt-8 lg:pt-8 pl-0 lg:pl-0">
      {/* Disconnect Overlay */}
      {!isConnected && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-background/60 backdrop-blur-sm">
          <div className="bg-card/40 border border-border rounded-2xl p-8 text-center max-w-md w-[92%]">
            <div className="font-retro text-foreground text-xl mb-2">Connect your wallet</div>
            <div className="font-retro text-muted-foreground text-sm mb-6">
              The Profile page is only available when youre connected.
            </div>
            <Button
              onClick={handleConnect}
              className="bg-accent hover:bg-accent/80 text-accent-foreground font-retro w-full"
            >
              Connect Wallet
            </Button>
          </div>
        </div>
      )}

      <div
        className={`px-3 md:px-5 pb-5 md:pb-6 pt-6 md:pt-6 ${
          !isConnected ? "blur-md pointer-events-none select-none" : ""
        }`}
      >
        {/* Profile Header */}
        <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border mb-4">
          <div className="flex flex-col md:flex-row items-start justify-between mb-6 gap-4">
            <div className="flex flex-col sm:flex-row gap-4 md:gap-6 w-full md:w-auto">
              {/* Avatar */}
              <div className="flex flex-col items-center sm:items-start gap-2">
                <div className="w-20 h-20 md:w-28 md:h-28 rounded-full bg-accent/20 border-4 border-accent/30 overflow-hidden mx-auto sm:mx-0">
                  <img
                    src={profile?.avatarUrl || "https://images.unsplash.com/photo-1621504450181-5d356f61d307?w=200&h=200&fit=crop"}
                    alt="Profile"
                    className="w-full h-full object-cover"
                  />
                </div>

                <input
                  ref={avatarInputRef}
                  type="file"
                  accept="image/png,image/jpeg,image/jpg,image/webp"
                  className="hidden"
                  onChange={(e) => {
                    const f = e.target.files?.[0];
                    if (f) handleAvatarSelected(f);
                    e.currentTarget.value = "";
                  }}
                />

                <Button
                  onClick={handlePickAvatar}
                  disabled={!isConnected || savingAvatar || savingProfile}
                  className="bg-accent hover:bg-accent/80 text-accent-foreground font-retro w-full sm:w-auto"
                >
                  {savingAvatar ? (awaitingWallet ? "confirm in wallet..." : "uploading...") : "change avatar"}
                </Button>
              </div>

              {/* Profile Info */}
              <div className="flex-1 text-center sm:text-left">
                <h1 className="text-2xl md:text-3xl font-retro text-foreground mb-3">
                  {displayName}
                </h1>

                <div className="flex flex-col sm:flex-row items-center justify-center sm:justify-start gap-2 sm:gap-3 mb-4">
                  <span className="text-xs md:text-sm font-retro text-muted-foreground">
                    {walletAddressFull}
                  </span>

                  <div className="flex items-center gap-2">
                    <button
                      onClick={handleCopyAddress}
                      className="p-1 hover:bg-muted rounded transition-colors"
                      disabled={!account}
                      title="Copy address"
                    >
                      <Copy className="h-4 w-4 text-muted-foreground" />
                    </button>

                    <a
                      href={explorerUrl}
                      target={account ? "_blank" : undefined}
                      rel="noreferrer"
                      className={`flex items-center gap-1 text-xs md:text-sm font-retro transition-colors ${
                        account
                          ? "text-accent hover:text-accent/80"
                          : "text-muted-foreground pointer-events-none"
                      }`}
                    >
                      View on explorer
                      <ExternalLink className="h-3 w-3" />
                    </a>
                  </div>
                </div>

                {profile?.bio && (
                  <div className="mb-4 max-w-xl">
                    <div className="font-retro text-xs md:text-sm text-muted-foreground whitespace-pre-wrap">
                      {profile.bio}
                    </div>
                  </div>
                )}

                {/* Stats */}
                <div className="flex justify-center sm:justify-start gap-6 md:gap-8">
                  <div className="text-center">
                    <div className="text-xl md:text-2xl font-retro text-foreground">
                      {followersCount}
                    </div>
                    <div className="text-xs font-retro text-muted-foreground">Followers</div>
                  </div>
                  <div className="text-center">
                    <div className="text-xl md:text-2xl font-retro text-foreground">
                      {followingCount}
                    </div>
                    <div className="text-xs font-retro text-muted-foreground">Following</div>
                  </div>
                  <div className="text-center">
                    <div className="text-xl md:text-2xl font-retro text-foreground">
                      {created.length}
                    </div>
                    <div className="text-xs font-retro text-muted-foreground">Created coins</div>
                  </div>
                </div>
              </div>
            </div>

            {/* Edit Button */}
            {isOwnProfile ? (
              <div className="flex items-start justify-end w-full md:w-auto">
                <Button
                  onClick={handleEdit}
                  className="bg-muted hover:bg-muted/80 text-foreground font-retro w-full md:w-auto"
                >
                  edit
                </Button>
                <EditProfileDialog
                  open={editOpen}
                  onOpenChange={setEditOpen}
                  initialUsername={profile?.displayName ?? ""}
                  initialBio={profile?.bio ?? ""}
                  saving={savingProfile}
                  onSave={handleSaveProfile}
                />
              </div>
            ) : null}
          </div>


          {/* Tabs */}
          <div className="flex gap-3 md:gap-6 border-t border-border pt-4 md:pt-6 overflow-x-auto scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
            {[
              { id: "balances" as ProfileTab, label: "Balances", badge: null },
              { id: "coins" as ProfileTab, label: "Coins", badge: null },
              { id: "replies" as ProfileTab, label: "Activity", badge: null },
              { id: "rewards" as ProfileTab, label: "Rewards", badge: rewards.length ? rewards.length : null },
              { id: "notifications" as ProfileTab, label: "Notifications", badge: 13 },
              { id: "followers" as ProfileTab, label: "Followers", badge: null },
            ].map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`relative font-retro text-xs md:text-sm transition-colors whitespace-nowrap ${
                  activeTab === tab.id
                    ? "text-accent border-b-2 border-accent pb-2"
                    : "text-muted-foreground hover:text-foreground"
                }`}
              >
                {tab.label}
                {tab.badge && (
                  <span className="absolute -top-2 -right-6 bg-destructive text-destructive-foreground text-[10px] font-retro px-1.5 py-0.5 rounded-full">
                    {tab.badge}
                  </span>
                )}
              </button>
            ))}
          </div>
        </div>

        {/* BALANCES TAB */}
        {activeTab === "balances" && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* Left: Balances */}
            <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border">
              <h3 className="text-xs md:text-sm font-retro text-muted-foreground mb-4 md:mb-6">
                Balances
              </h3>

              {/* Native balance */}
              <div className="flex items-center justify-between p-3 md:p-4 bg-background/50 rounded-xl border border-border mb-3">
                <div className="flex items-center gap-3 md:gap-4">
                  <div className="w-10 h-10 md:w-12 md:h-12 rounded-full bg-accent/20 flex items-center justify-center border border-border">
                    <span className="text-foreground text-xs font-bold">BNB</span>
                  </div>
                  <div>
                    <div className="font-retro text-foreground mb-1 text-sm md:text-base">
                      Native balance
                    </div>
                    <div className="text-xs md:text-sm font-retro text-muted-foreground">
                      {nativeBalance || (loadingBalances ? "Loading..." : "")}
                    </div>
                  </div>
                </div>
              </div>

              {/* Launchpad token balances */}
              <div className="space-y-3 max-h-96 overflow-y-auto scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
                {loadingBalances && tokenBalances.length === 0 && (
                  <div className="font-retro text-muted-foreground text-sm">Loading token balances</div>
                )}

                {!loadingBalances && tokenBalances.length === 0 && (
                  <div className="font-retro text-muted-foreground text-sm">
                    No launchpad token balances found for this wallet.
                  </div>
                )}

                {tokenBalances.map((t) => (
                  <div
                    key={`${t.tokenAddress}-${t.campaignAddress}`}
                    className="flex items-center justify-between p-3 md:p-4 bg-background/50 rounded-xl border border-border hover:border-accent/50 transition-colors cursor-pointer"
                    onClick={() => navigate(`/token/${t.campaignAddress.toLowerCase()}`)}
                    title="Open token page"
                  >
                    <div className="flex items-center gap-3 md:gap-4 min-w-0">
                      <img
                        src={t.image}
                        alt={t.name}
                        className="w-10 h-10 md:w-12 md:h-12 rounded-full border-2 border-border object-cover"
                      />
                      <div className="min-w-0">
                        <div className="font-retro text-foreground mb-1 text-sm md:text-base truncate">
                          {t.name}
                        </div>
                        <div className="text-xs md:text-sm font-retro text-muted-foreground">
                          {t.ticker}
                        </div>
                      </div>
                    </div>

                    <div className="text-right shrink-0 ml-4">
                      <div className="font-retro text-foreground text-sm md:text-base">
                        {Number(t.balanceFormatted).toLocaleString(undefined, {
                          maximumFractionDigits: 6,
                        })}
                      </div>
                      <div className="font-retro text-muted-foreground text-xs">Balance</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Right: Created Coins */}
            <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border">
              <div className="flex items-center justify-between mb-4 md:mb-6">
                <h3 className="text-xs md:text-sm font-retro text-foreground">
                  created coins <span className="text-muted-foreground">({created.length})</span>
                </h3>
                <button className="text-xs md:text-sm font-retro text-accent hover:text-accent/80 transition-colors">
                  see all
                </button>
              </div>

              <div className="space-y-3 max-h-96 overflow-y-auto scrollbar-thin scrollbar-thumb-accent/50 scrollbar-track-muted">
                {created.map((coin) => (
                  <div
                    key={coin.id}
                    className="flex items-center justify-between p-3 bg-background/50 rounded-xl border border-border hover:border-accent/50 transition-colors cursor-pointer"
                    onClick={() => navigate(`/token/${coin.campaignAddress.toLowerCase()}`)}
                  >
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <img
                        src={coin.image}
                        alt={coin.name}
                        className="w-8 h-8 md:w-10 md:h-10 rounded-full border-2 border-border object-cover"
                      />
                      <div className="min-w-0 flex-1">
                        <div className="font-retro text-foreground text-xs md:text-sm truncate">
                          {coin.name}
                        </div>
                        <div className="font-retro text-muted-foreground text-xs">{coin.ticker}</div>
                      </div>
                    </div>
                    <div className="text-right shrink-0 ml-4">
                      <div className="font-retro text-foreground text-xs md:text-sm">{coin.marketCap}</div>
                      <div className="font-retro text-muted-foreground text-xs">{coin.timeAgo}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        )}

        {/* REWARDS TAB */}
        {activeTab === "rewards" && (
          <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xs md:text-sm font-retro text-foreground">rewards</h3>
              {isOwnProfile ? (
                <Button
                  onClick={() => {
                    // force reload
                    setActiveTab("balances");
                    setTimeout(() => setActiveTab("rewards"), 0);
                  }}
                  variant="outline"
                  className="font-retro"
                >
                  refresh
                </Button>
              ) : null}
            </div>

            {!isOwnProfile && (
              <div className="font-retro text-muted-foreground text-sm">
                Rewards are only visible on your own profile.
              </div>
            )}

            {isOwnProfile && !account && (
              <div className="font-retro text-muted-foreground text-sm">
                Connect your wallet to view and claim rewards.
              </div>
            )}

            {isOwnProfile && account && (
              <>
                {loadingRewards && (
                  <div className="font-retro text-muted-foreground text-sm">Loading rewards</div>
                )}
                {rewardsError && !loadingRewards && (
                  <div className="font-retro text-destructive text-sm">{rewardsError}</div>
                )}
                {!loadingRewards && !rewardsError && rewards.length === 0 && (
                  <div className="font-retro text-muted-foreground text-sm">
                    No claimable rewards right now.
                  </div>
                )}

                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {rewards.map((r) => {
                    const key = `${r.period}:${r.epochStart}:${r.category}:${r.rank}`;
                    const amountBnb = formatWeiToBnb(r.amountRaw);
                    const p: any = r.payload || {};
                    const name = String(p.name ?? p.campaignName ?? "").trim();
                    const symbol = String(p.symbol ?? p.campaignSymbol ?? "").trim();
                    const logo = String(p.logo_uri ?? p.logoUri ?? p.logoURI ?? "").trim();

                    const titleParts = [
                      r.period === "weekly" ? "Weekly" : "Monthly",
                      r.category.replace(/_/g, " "),
                      `#${r.rank}`,
                    ];

                    return (
                      <div key={key} className="p-4 bg-background/50 rounded-xl border border-border">
                        <div className="flex items-start justify-between gap-3">
                          <div className="flex items-center gap-3 min-w-0">
                            {logo ? (
                              <img src={logo} alt={name || symbol || "token"} className="w-10 h-10 rounded-full border-2 border-border object-cover" />
                            ) : (
                              <div className="w-10 h-10 rounded-full bg-accent/20 border border-border" />
                            )}
                            <div className="min-w-0">
                              <div className="font-retro text-foreground text-sm truncate">
                                {titleParts.join("  ")}
                              </div>
                              <div className="font-retro text-muted-foreground text-xs truncate">
                                {name || symbol || ""}
                              </div>
                            </div>
                          </div>

                          <div className="text-right shrink-0">
                            <div className="font-retro text-foreground text-sm">
                              {Number(amountBnb).toLocaleString(undefined, { maximumFractionDigits: 6 })} BNB
                            </div>
                            <div className="font-retro text-muted-foreground text-xs">Prize</div>
                          </div>
                        </div>

                        <div className="mt-3 flex items-center justify-between gap-3">
                          <div className="font-retro text-muted-foreground text-[10px] truncate">
                            {new Date(r.epochStart).toUTCString()}  {new Date(r.epochEnd).toUTCString()}
                          </div>

                          <Button
                            onClick={() => handleClaimPrize(r)}
                            disabled={!isOwnProfile || claimingKey === key}
                            className="bg-accent hover:bg-accent/80 text-accent-foreground font-retro"
                          >
                            {claimingKey === key ? "claiming" : "claim"}
                          </Button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </>
            )}
          </div>
        )}

        {/* COINS TAB: Tokens you invested in */}
        {activeTab === "coins" && (
          <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border">
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xs md:text-sm font-retro text-foreground">
                tokens you invested in <span className="text-muted-foreground">({tokenBalances.length})</span>
              </h3>
            </div>

            {loadingBalances && (
              <div className="font-retro text-muted-foreground text-sm">Loading</div>
            )}

            {!loadingBalances && tokenBalances.length === 0 && (
              <div className="font-retro text-muted-foreground text-sm">
                No invested tokens detected yet. Once you buy on a curve (or hold after DEX listing), it will show here.
              </div>
            )}

            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {tokenBalances.map((t) => (
                <div
                  key={`${t.tokenAddress}-${t.campaignAddress}-coins`}
                  className="p-4 bg-background/50 rounded-xl border border-border hover:border-accent/50 transition-colors cursor-pointer"
                  onClick={() => navigate(`/token/${t.campaignAddress.toLowerCase()}`)}
                >
                  <div className="flex items-center gap-3">
                    <img
                      src={t.image}
                      alt={t.name}
                      className="w-10 h-10 rounded-full border-2 border-border object-cover"
                    />
                    <div className="min-w-0">
                      <div className="font-retro text-foreground text-sm truncate">{t.name}</div>
                      <div className="font-retro text-muted-foreground text-xs">{t.ticker}</div>
                    </div>
                  </div>

                  <div className="mt-3 flex items-center justify-between">
                    <div className="font-retro text-muted-foreground text-xs">Your balance</div>
                    <div className="font-retro text-foreground text-sm">
                      {Number(t.balanceFormatted).toLocaleString(undefined, { maximumFractionDigits: 6 })}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* REPLIES TAB: Activity feed */}
        {activeTab === "replies" && (
          <div className="bg-card/30 backdrop-blur-md rounded-2xl p-4 md:p-6 border border-border">
            <div className="flex flex-wrap items-center gap-2 mb-4">
              {[
                { id: "trades", label: "Trades" },
                { id: "comments", label: "Comments" },
                { id: "created", label: "Created" },
                { id: "interactions", label: "Interactions" },
              ].map((t) => (
                <button
                  key={t.id}
                  onClick={() => setActivityTab(t.id as typeof activityTab)}
                  className={`px-3 py-1.5 rounded-full border text-xs font-retro transition-colors ${
                    activityTab === t.id
                      ? "bg-accent/20 text-accent border-accent/40"
                      : "bg-transparent text-muted-foreground border-border hover:text-foreground"
                  }`}
                >
                  {t.label}
                </button>
              ))}
            </div>

            <div className="rounded-xl border border-border bg-background/40 p-4 md:p-6">
              <div className="text-[11px] font-retro text-muted-foreground mb-4">
                Powered by indexed events (no per-campaign polling).
              </div>

              {activityTab === "trades" ? (
                <div className="space-y-3">
                  {activityLoading && (
                    <div className="font-retro text-muted-foreground text-sm">Loading trades...</div>
                  )}

                  {!activityLoading && activityError && (
                    <div className="font-retro text-destructive text-sm">{activityError}</div>
                  )}

                  {!activityLoading && !activityError && activityTrades.length === 0 && (
                    <div className="font-retro text-muted-foreground text-sm">No trades yet.</div>
                  )}

                  {!activityLoading && !activityError && activityTrades.length > 0 && (
                    <div className="space-y-2">
                      {activityTrades.map((t) => {
                        const label = t.campaignName || (t.campaignSymbol ? `$${t.campaignSymbol}` : "Unknown");
                        const symbol = t.campaignSymbol ? `$${t.campaignSymbol}` : "";
                        const ts = t.blockTime ? Math.floor(new Date(t.blockTime).getTime() / 1000) : undefined;
                        const timeAgo = ts ? formatTimeAgo(ts) : "";
                        const explorer = getExplorerBase(chainId);
                        const txUrl = t.txHash ? `${explorer}/tx/${t.txHash}` : "";

                        return (
                          <div
                            key={t.id}
                            className="flex items-center justify-between gap-3 rounded-xl border border-border/60 bg-background/40 px-3 py-2"
                          >
                            <div className="flex items-center gap-3 min-w-0">
                              <img
                                src={t.logoUri || "/placeholder.svg"}
                                alt={label}
                                className="h-9 w-9 rounded-full border border-border/60 object-cover"
                              />
                              <div className="min-w-0">
                                <div className="font-retro text-foreground text-sm truncate">{label}</div>
                                <div className="text-xs text-muted-foreground truncate">
                                  {symbol} {timeAgo ? `- ${timeAgo} ago` : ""}
                                </div>
                              </div>
                            </div>

                            <div className="text-right shrink-0">
                              <div className={`font-retro text-xs ${t.side === "buy" ? "text-emerald-400" : "text-red-400"}`}>
                                {t.side === "buy" ? "Buy" : "Sell"}
                              </div>
                              <div className="font-retro text-xs text-muted-foreground">
                                {formatNumber(t.bnbAmount, 6)} BNB
                              </div>
                              {txUrl ? (
                                <a
                                  href={txUrl}
                                  target="_blank"
                                  rel="noreferrer"
                                  className="text-[10px] text-muted-foreground hover:text-foreground"
                                >
                                  View tx
                                </a>
                              ) : null}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center">
                  <p className="font-retro text-muted-foreground text-sm md:text-base">
                    Activity will be powered by <span className="text-foreground">indexed events</span> (recommended).
                  </p>
                  <p className="mt-2 font-retro text-muted-foreground text-xs md:text-sm">
                    Showing: <span className="text-foreground">{activityTab}</span>
                  </p>
                </div>
              )}
            </div>
          </div>
        )}

          {/* NOTIFICATIONS TAB */}
        {activeTab === "notifications" && (
          <div className="bg-card/30 backdrop-blur-md rounded-2xl p-8 md:p-12 border border-border text-center">
            <p className="font-retro text-muted-foreground text-sm md:text-base">
              Notifications MVP ideas:
              curve at 80/90/95%, graduation, large buy alerts, your created coin milestones,
              and watched coins updates. This needs either an indexer or a lightweight polling service.
            </p>
          </div>
        )}

        {/* FOLLOWERS TAB */}
        {activeTab === "followers" && (
          <div className="bg-card/30 backdrop-blur-md rounded-2xl p-8 md:p-12 border border-border text-center">
            <p className="font-retro text-muted-foreground text-sm md:text-base">
              Followers MVP direction:
              for creators, show investors/holders of your coins (requires event indexing);
              for regular users, this becomes Creators you follow and Coins you watch.
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Profile;
</file>

<file path="frontend/src/components/TopBar.tsx">
/**
 * Top Bar Component
 * Responsive header with search, actions, and ticker feed
 */

import { useEffect, useMemo, useState } from "react";
import { Menu } from "lucide-react";
import { SearchBar } from "./ui/search-bar";
import { Link, useLocation, useNavigate } from "react-router-dom";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { useWallet, WalletType } from "@/hooks/useWallet";
import { useLaunchpad } from "@/lib/launchpadClient";
import type { CampaignInfo, CampaignMetrics } from "@/lib/launchpadClient";
import { useTokenSearch } from "@/hooks/useTokenSearch";
import { ethers } from "ethers";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { LeagueOverlayCard } from "@/components/home/LeagueOverlayCard";

interface TopBarProps {
  mobileMenuOpen: boolean;
  setMobileMenuOpen: (open: boolean) => void;
}

type TickerItem = {
  key: string; // campaign address (or unique)
  symbol: string;
  logoURI?: string;
  subtitle: string; // e.g. "Price 0.0123 BNB" or "Live"
  hot: boolean;
  route: string; // where to navigate on click
};

// Public brand asset (no bundler import required)
const brandMark = "/assets/ticker.png";

export const TopBar = ({ mobileMenuOpen, setMobileMenuOpen }: TopBarProps) => {
  const navigate = useNavigate();
  const location = useLocation();
  const wallet = useWallet();
  const [walletModalOpen, setWalletModalOpen] = useState(false);
  const [disconnectOpen, setDisconnectOpen] = useState(false);

  const { price: bnbUsd } = useBnbUsdPrice(true);

  // Search state
  const [searchQuery, setSearchQuery] = useState("");
  const [allCampaigns, setAllCampaigns] = useState<CampaignInfo[]>([]);

  const { fetchCampaigns, fetchCampaignMetrics } = useLaunchpad();

  // Ticker feed state
  const [tickerCampaigns, setTickerCampaigns] = useState<CampaignInfo[]>([]);
  const [tickerMetricsByCampaign, setTickerMetricsByCampaign] = useState<
    Record<string, CampaignMetrics | null>
  >({});
  const [tickerLoading, setTickerLoading] = useState(true);

  const { results: searchResults, loading: searchLoading, error: searchError } = useTokenSearch(
    searchQuery,
    allCampaigns,
    { limit: 10, debounceMs: 250 }
  );

  const shortAddress =
    wallet.account && wallet.account.length > 8
      ? `${wallet.account.slice(0, 4)}...${wallet.account.slice(-4)}`
      : wallet.account;

  // Match the primary button styling used across the app
  const topbarButtonClass = "bg-accent hover:bg-accent/90 text-accent-foreground font-retro text-xs md:text-sm px-3 md:px-4 py-2 rounded-xl shadow-lg";

  const openWalletModal = () => {
    // You can decide: allow switching wallet even when connected or not
    setWalletModalOpen(true);
  };

  const navLinks = useMemo(
    () => [
      { label: "Launchpad", path: "/" },
      { label: "Create Coin", path: "/create" },
      { label: "Battle Leagues", path: "/battle-leagues" },
      { label: "Profile", path: "/profile" },
      { label: "Docs", path: "/docs" },
    ],
    []
  );

  const handleWalletSelect = async (type: WalletType) => {
    try {
      await wallet.connect(type);
      setWalletModalOpen(false);
    } catch (e) {
      console.error(e);
      // Optional: add toast here if you want feedback
    }
  };

  // Load campaigns for ticker (handled by your launchpadClient)
  useEffect(() => {
    let cancelled = false;

    const load = async () => {
      try {
        setTickerLoading(true);

        const campaigns = await fetchCampaigns();
        const all = campaigns ?? [];
        const top = all.slice(0, 12);

        if (cancelled) return;
        setAllCampaigns(all);
        setTickerCampaigns(top);

        // Best-effort metrics per campaign (dont block UI if some fail)
        const results = await Promise.allSettled(
          top.map((c) => fetchCampaignMetrics(c.campaign))
        );

        if (cancelled) return;

        const next: Record<string, CampaignMetrics | null> = {};
        top.forEach((c, idx) => {
          const r = results[idx];
          next[c.campaign.toLowerCase()] = r.status === "fulfilled" ? r.value : null;
        });

        setTickerMetricsByCampaign(next);
      } catch (err) {
        console.error("[TopBar ticker] Failed to load campaigns", err);
        if (!cancelled) {
          setTickerCampaigns([]);
          setTickerMetricsByCampaign({});
        }
      } finally {
        if (!cancelled) setTickerLoading(false);
      }
    };

    load();
    return () => {
      cancelled = true;
    };
  }, [fetchCampaigns, fetchCampaignMetrics]);

  // Build ticker items from campaigns + metrics
  const tickerItems: TickerItem[] = useMemo(() => {
    const formatCompactUsd = (n: number) => {
      if (!Number.isFinite(n)) return "";
      const abs = Math.abs(n);
      const sign = n < 0 ? "-" : "";
      const v = Math.abs(n);
      if (abs >= 1_000_000_000) return `${sign}$${(v / 1_000_000_000).toFixed(2)}B`;
      if (abs >= 1_000_000) return `${sign}$${(v / 1_000_000).toFixed(2)}M`;
      if (abs >= 1_000) return `${sign}$${(v / 1_000).toFixed(1)}K`;
      return `${sign}$${v.toFixed(2)}`;
    };

    const formatCompactBnb = (bnb: number) => {
      if (!Number.isFinite(bnb)) return "";
      const abs = Math.abs(bnb);
      const pretty = abs >= 1 ? bnb.toFixed(2) : abs >= 0.01 ? bnb.toFixed(4) : abs >= 0.0001 ? bnb.toFixed(6) : bnb.toFixed(8);
      return `${pretty} BNB`;
    };

    const formatMarketCap = (m: CampaignMetrics | null | undefined) => {
      if (!m) return "MC ";
      try {
        // Match the bonding-curve chart semantics: circulating = net sold tokens.
        const circulating: bigint = (m as any).sold ?? 0n;
        const priceWeiPerToken: bigint = (m as any).currentPrice ?? 0n;
        if (circulating <= 0n || priceWeiPerToken <= 0n) return "MC ";

        const mcWei = (priceWeiPerToken * circulating) / 10n ** 18n;
        const mcBnb = Number(ethers.formatEther(mcWei));
        if (!Number.isFinite(mcBnb) || mcBnb <= 0) return "MC ";

        if (Number.isFinite(bnbUsd ?? NaN) && (bnbUsd ?? 0) > 0) {
          const mcUsd = mcBnb * (bnbUsd as number);
          return `MC ${formatCompactUsd(mcUsd)}`;
        }

        return `MC ${formatCompactBnb(mcBnb)}`;
      } catch {
        return "MC ";
      }
    };

    return (tickerCampaigns ?? [])
      .filter((c) => c && typeof c.symbol === "string" && c.symbol.length > 0)
      .map((c) => {
        const metrics = tickerMetricsByCampaign[c.campaign.toLowerCase()] ?? null;

        const sold = (() => {
          try {
            const v = (metrics as any)?.sold;
            if (typeof v === "bigint") return v;
            if (typeof v === "number") return BigInt(v);
            if (typeof v === "string") return BigInt(v);
            return 0n;
          } catch {
            return 0n;
          }
        })();

        return {
          key: c.campaign,
          symbol: c.symbol,
          logoURI: (c as any).logoURI,
          subtitle: formatMarketCap(metrics),
          hot: sold > 0n,
          route: `/token/${c.campaign.toLowerCase()}`,
        };
      });
  }, [tickerCampaigns, tickerMetricsByCampaign, bnbUsd]);

  // Ensure the scrolling band is always long enough, even if we only have a few campaigns.
  const tickerBaseLoop: TickerItem[] = useMemo(() => {
    if (!tickerItems || tickerItems.length === 0) return [];

    const MIN_ITEMS = 18; // tweak if you want more density on desktop
    const target = Math.max(MIN_ITEMS, tickerItems.length);

    const out: TickerItem[] = [];
    while (out.length < target) out.push(...tickerItems);

    return out.slice(0, target);
  }, [tickerItems]);

  const isActive = (path: string) => {
    if (path === "/") return location.pathname === "/";
    return location.pathname.startsWith(path);
  };

  return (
    <div className="fixed top-0 left-0 right-0 z-40 bg-transparent">
      <div className="flex items-center justify-between px-4 md:px-6 py-3">
        {/* Mobile Menu Button */}
        <button
          onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
          className="lg:hidden p-2 hover:bg-muted rounded-lg transition-colors"
          aria-label="Toggle menu"
        >
          <Menu className="h-6 w-6" />
        </button>

        {/* Desktop nav */}
        <div className="hidden lg:flex items-center gap-4 flex-1">
          <Link to="/" className="flex items-center gap-2 mr-2">
            <img src={brandMark} alt="MemeBattles" className="h-10 w-10" draggable={false} />
            <span className="font-retro text-sm">MemeBattles</span>
          </Link>

          <div className="flex items-center gap-1">
            {navLinks.map((item) => (
              <Link
                key={item.path}
                to={item.path}
                className={cn(
                  "px-3 py-2 rounded-xl text-xs font-retro transition-colors border",
                  isActive(item.path)
                    ? "bg-card/60 border-amber-400/40 text-amber-200"
                    : "bg-transparent border-transparent text-muted-foreground hover:text-foreground hover:bg-card/30"
                )}
              >
                {item.label}
              </Link>
            ))}
          </div>
        </div>

        {/* Search */}
        <div className="flex-none w-32 sm:flex-1 sm:max-w-xs md:max-w-md mx-2 md:mx-0 lg:mx-6">
          <SearchBar
            placeholder="Search campaigns..."
            value={searchQuery}
            onValueChange={(q) => {
              setSearchQuery(q);
              // Also broadcast to the Home grid as an optional "filter-in-place" search.
              // Pages that don't care can ignore this event.
              try {
                window.dispatchEvent(new CustomEvent("upmeme:homeSearch", { detail: String(q ?? "") }));
              } catch {
                // ignore
              }
            }}
            results={searchResults}
            loading={searchLoading}
            error={searchError}
            onSelectResult={(r) => {
              setSearchQuery("");
              navigate(`/token/${r.campaignAddress.toLowerCase()}`);
            }}
          />
        </div>
       <div className="relative flex items-center gap-2">
        {/* Right side actions */}
        <div className="flex items-center gap-2 md:gap-3">
          {/* Primary CTA */}
          <Button onClick={() => navigate("/create")} className={topbarButtonClass}>
            <span className="hidden sm:inline">Create Coin</span>
            <span className="sm:hidden">Create</span>
          </Button>

          {/* Connect wallet button with SAME style, but now opens modal */}
          <div
            className="relative"
            onMouseEnter={() => wallet.isConnected && setDisconnectOpen(true)}
            onMouseLeave={() => setDisconnectOpen(false)}
          >
            <Button className={topbarButtonClass} onClick={() => { if (!wallet.isConnected) { openWalletModal(); } }}>
              <span className="hidden sm:inline">
                {wallet.isConnected ? shortAddress : "Connect wallet"}
              </span>
              <span className="sm:hidden">
                {wallet.isConnected ? "Wallet" : "Connect"}
              </span>
            </Button>

            {/* Disconnect dropdown */}
            {wallet.isConnected && disconnectOpen && (
              <div className="absolute right-0 mt-1 w-32 rounded-md border border-border bg-background shadow-lg z-50">
                <button
                  className="w-full text-left text-xs px-3 py-2 hover:bg-muted"
                  onClick={() => {
                    wallet.disconnect();
                    setDisconnectOpen(false);
                  }}
                >
                  Disconnect
                </button>
              </div>
            )}
          </div>
        </div>
         {/* League overlay: desktop only (mobile renders in main content) */}
         {location.pathname === "/" && (
           <div className="absolute right-6 top-full mt-2 z-20 pointer-events-none hidden md:block">
             <LeagueOverlayCard className="pointer-events-auto" />
           </div>
         )}
        </div>
      </div>

      {/* Wallet selection modal */}
      {walletModalOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
          <div className="bg-background border border-border rounded-2xl shadow-xl w-[90%] max-w-sm p-4 md:p-6 space-y-4">
            <div className="flex items-center justify-between mb-2">
              <h2 className="text-sm md:text-base font-retro">Connect a wallet</h2>
              <button
                onClick={() => setWalletModalOpen(false)}
                className="text-xs text-muted-foreground hover:text-foreground"
              >
                Close
              </button>
            </div>

            <p className="text-xs text-muted-foreground mb-2">
              Select a BSC-compatible EVM wallet. You can switch between testnet and
              mainnet from your wallet settings.
            </p>

            <div className="space-y-2">
              {/* MetaMask / Rabby / browser wallet */}
              <button
                onClick={() => handleWalletSelect("metamask")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">MetaMask</p>
                  <p className="text-[11px] text-muted-foreground">
                    Browser wallet (Rabby etc.) on BSC
                  </p>
                </div>
                <div className="flex items-center gap-2 text-[11px] text-muted-foreground">
                  <span>EVM</span>
                </div>
              </button>

              {/* Binance Wallet */}
              <button
                onClick={() => handleWalletSelect("binance")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">Binance Wallet</p>
                  <p className="text-[11px] text-muted-foreground">
                    Official Binance extension for BSC
                  </p>
                </div>
                <div className="flex items-center gap-2 text-[11px] text-muted-foreground">
                  <span>BSC</span>
                </div>
              </button>

              {/* Generic injected fallback */}
              <button
                onClick={() => handleWalletSelect("injected")}
                className="w-full flex items-center justify-between px-3 py-2 rounded-xl border border-border bg-card hover:bg-card/80 transition-colors text-left"
              >
                <div>
                  <p className="text-xs md:text-sm font-medium">Other EVM wallet</p>
                  <p className="text-[11px] text-muted-foreground">
                    Any injected BSC-compatible wallet
                  </p>
                </div>
              </button>
            </div>

            <p className="text-[10px] text-muted-foreground mt-2">
              Make sure your selected wallet is configured for Binance Smart Chain
              (BSC mainnet or testnet, depending on your setup).
            </p>
          </div>
        </div>
      )}

      <style>{`
        @keyframes scroll {
          0% { transform: translateX(0); }
          100% { transform: translateX(-50%); }
        }
      `}</style>
    </div>
  );
};
</file>

<file path="frontend/src/components/home/CampaignGrid.tsx">
import { useEffect, useMemo, useRef, useState } from "react";
import { cn } from "@/lib/utils";
import { useLaunchpad } from "@/lib/launchpadClient";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { useLeagueRealtime } from "@/hooks/useLeagueRealtime";
import { CampaignCard, type CampaignCardVM } from "./CampaignCard";
import { resolveImageUri } from "@/lib/media";

export type FeedTabKey = "trending" | "new" | "ending" | "dex";

export type HomeQuery = {
  tab: FeedTabKey;
  status?: "all" | "live" | "graduated";
  mcapMinUsd?: number;
  mcapMaxUsd?: number;
  progressMinPct?: number;
  progressMaxPct?: number;
  category?: string;
  sort?:
    | "default"
    | "mcap_desc"
    | "mcap_asc"
    | "votes_desc"
    | "progress_desc"
    | "created_desc"
    | "created_asc";
  timeFilter?: "1h" | "24h" | "7d" | "all";
  search?: string;
};

type CampaignFeedItemApi = {
  chainId: number;
  campaignAddress: string;
  tokenAddress?: string | null;
  creatorAddress?: string | null;
  name?: string | null;
  symbol?: string | null;
  logoUri?: string | null;
  createdAtChain?: string | null;
  graduatedAtChain?: string | null;
  isDexTrading?: boolean;
  marketcapBnb?: string | null;
  votes24h?: number;
  progressPct?: number | null;
  etaSec?: number | null;
};

type CampaignFeedResponse = {
  items: CampaignFeedItemApi[];
  nextCursor: number | null;
  pageSize: number;
  updatedAt?: string;
};

function safeUnixSeconds(ts: any): number | null {
  if (ts == null) return null;
  if (typeof ts === "number" && Number.isFinite(ts)) {
    return ts > 1e12 ? Math.floor(ts / 1000) : Math.floor(ts);
  }
  if (typeof ts === "string") {
    const asNum = Number(ts);
    if (Number.isFinite(asNum) && asNum > 0) return asNum > 1e12 ? Math.floor(asNum / 1000) : Math.floor(asNum);
    const ms = Date.parse(ts);
    if (Number.isFinite(ms)) return Math.floor(ms / 1000);
  }
  return null;
}

function formatCompactUsd(value: number): string {
  if (!Number.isFinite(value)) return "";
  const fmt = new Intl.NumberFormat(undefined, {
    style: "currency",
    currency: "USD",
    notation: "compact",
    maximumFractionDigits: 2,
  });
  return fmt.format(value);
}

function buildQueryString(params: Record<string, any>) {
  const qs = new URLSearchParams();
  for (const [k, v] of Object.entries(params)) {
    if (v == null) continue;
    if (typeof v === "string" && v.trim() === "") continue;
    qs.set(k, String(v));
  }
  return qs.toString();
}

async function fetchCampaignFeed(params: Record<string, any>): Promise<CampaignFeedResponse> {
  const qs = buildQueryString(params);
  // Avoid CDN/browser caching for dynamic leaderboards (votes, trending, etc.).
  // Vercel edge caching keys on the URL, so include a changing param when callers want a refresh.
  const r = await fetch(`/api/campaigns?${qs}`, { cache: "no-store" as any });
  const j = await r.json();
  if (!r.ok) throw new Error(j?.error ?? "Failed to load campaigns");
  return j as CampaignFeedResponse;
}

export function CampaignGrid({ className, query }: { className?: string; query: HomeQuery }) {
  const { activeChainId, fetchCampaignLogoURI } = useLaunchpad();
  const [refetchNonce, setRefetchNonce] = useState(0);

const { patchByCampaign, created } = useLeagueRealtime({
  enabled: true,
  chainId: activeChainId,
  fallbackMs: 25000,
  onFallbackRefresh: () => setRefetchNonce((n) => n + 1),
});
  const { price: bnbUsd } = useBnbUsdPrice(true);

  // Debug toggle (works in production):
  //   localStorage.setItem('debug_campaign_grid', '1'); location.reload();
  //   localStorage.removeItem('debug_campaign_grid'); location.reload();
  const DEBUG =
    typeof window !== "undefined" &&
    (window.localStorage?.getItem("debug_campaign_grid") === "1" ||
      // Allow an escape hatch if you prefer a global flag.
      (window as any).__DEBUG_CAMPAIGN_GRID__ === true);

  const [items, setItems] = useState<CampaignFeedItemApi[]>([]);
  // Lightweight on-chain hydration for missing logo_uri in the DB-backed feed.
  const [logoCache, setLogoCache] = useState<Record<string, string>>({});
  const [nextCursor, setNextCursor] = useState<number | null>(0);
  const [loading, setLoading] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [lastUpdatedAt, setLastUpdatedAt] = useState<string | null>(null);

  // Insert newly-created campaigns instantly (no REST refetch) for the "New" tab.
  // Trending/etc will naturally catch up via periodic snapshot refresh.
  useEffect(() => {
    if (query.tab !== "new") return;
    if (!created?.length) return;

    setItems((prev) => {
      const seen = new Set(prev.map((x) => String(x.campaignAddress ?? "").toLowerCase()).filter(Boolean));
      const additions: CampaignFeedItemApi[] = [];

      for (const it of created) {
        const addr = String(it?.campaignAddress ?? "").toLowerCase();
        if (!addr || seen.has(addr)) continue;
        seen.add(addr);

        additions.push({
          chainId: activeChainId,
          campaignAddress: addr,
          tokenAddress: it.tokenAddress ?? null,
          creatorAddress: it.creatorAddress ?? null,
          name: it.name ?? null,
          symbol: it.symbol ?? null,
          logoUri: null,
          createdAtChain: it.createdAtChain ?? new Date().toISOString(),
          graduatedAtChain: null,
          isDexTrading: false,
          marketcapBnb: null,
          votes24h: 0,
          progressPct: 0,
          etaSec: null,
        });
      }

      if (!additions.length) return prev;
      return [...additions, ...prev].slice(0, 200);
    });
  }, [created, query.tab, activeChainId]);

  // Immediately refresh the feed after a confirmed tx (upvote/buy/sell/finalize)
  // so the card order and vote counts update without requiring a hard reload.
  useEffect(() => {
    const onRefresh = (e: any) => {
      const d = e?.detail ?? {};
      const cid = Number(d.chainId ?? NaN);
      if (Number.isFinite(cid) && cid !== activeChainId) return;
      setRefetchNonce((n) => n + 1);
    };
    window.addEventListener("upmeme:upvoteConfirmed", onRefresh as any);
    window.addEventListener("upmeme:txConfirmed", onRefresh as any);
    return () => {
      window.removeEventListener("upmeme:upvoteConfirmed", onRefresh as any);
      window.removeEventListener("upmeme:txConfirmed", onRefresh as any);
    };
  }, [activeChainId]);

  const sentinelRef = useRef<HTMLDivElement | null>(null);

  const baseParams = useMemo(() => {
    return {
      chainId: activeChainId,
      limit: 24,
      tab: query.tab ?? "trending",
      sort: query.sort ?? "default",
      status: query.status ?? "all",
      search: query.search ?? "",

      // Filters that require USD conversion.
      // We pass bnbUsd so the API can filter on marketcap_usd deterministically.
      bnbUsd: bnbUsd ? bnbUsd : null,
      mcapMinUsd: query.mcapMinUsd ?? null,
      mcapMaxUsd: query.mcapMaxUsd ?? null,
      progressMinPct: query.progressMinPct ?? null,
      progressMaxPct: query.progressMaxPct ?? null,
    };
  }, [activeChainId, query, bnbUsd]);

  // Reset + fetch first page whenever the query changes.
  useEffect(() => {
    let mounted = true;
    (async () => {
      setLoading(true);
      setErr(null);
      try {
        if (DEBUG) {
          console.debug('[CampaignGrid] fetch first page params', { ...baseParams, cursor: 0 });
        }
        const resp = await fetchCampaignFeed({ ...baseParams, cursor: 0, _r: refetchNonce });
        if (!mounted) return;
        if (DEBUG) {
          console.debug('[CampaignGrid] first page response', {
            count: resp.items?.length ?? 0,
            sample: (resp.items ?? []).slice(0, 3).map((x) => ({
              campaignAddress: x.campaignAddress,
              logoUri: x.logoUri,
              name: x.name,
              symbol: x.symbol,
            })),
          });
        }
        setItems(resp.items ?? []);
        setNextCursor(resp.nextCursor ?? null);
        setLastUpdatedAt(resp.updatedAt ?? null);
      } catch (e: any) {
        if (!mounted) return;
        setErr(e?.message ?? "Failed to load campaigns");
        setItems([]);
        setNextCursor(null);
      } finally {
        if (!mounted) return;
        setLoading(false);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [baseParams, refetchNonce]);

  // Hydrate missing token images from on-chain logoURI.
  // This keeps the DB feed fast for stats/sorts while matching the behavior of
  // pages that render images via useLaunchpad().fetchCampaigns().
  useEffect(() => {
    let cancelled = false;

    const missing = (items || [])
      .map((it) => String(it.campaignAddress ?? "").toLowerCase())
      .filter((addr) => addr && !logoCache[addr])
      .filter((addr) => {
        // If the feed already has a logo, don't hydrate.
        const found = (items || []).find((x) => String(x.campaignAddress ?? "").toLowerCase() === addr);
        return !found?.logoUri;
      })
      .slice(0, 24);

    if (!missing.length) return;

    if (DEBUG) {
      console.debug('[CampaignGrid] hydrating missing logos', {
        missingCount: missing.length,
        missing: missing.slice(0, 10),
      });
    }

    (async () => {
      try {
        const pairs = await Promise.all(
          missing.map(async (addr) => {
            const uri = await fetchCampaignLogoURI(addr);
            return [addr, uri] as const;
          })
        );
        if (cancelled) return;
        if (DEBUG) {
          console.debug('[CampaignGrid] hydration results', {
            resolved: pairs
              .filter(([, uri]) => !!uri)
              .slice(0, 10)
              .map(([addr, uri]) => ({ addr, uri, resolvedUrl: resolveImageUri(uri) })),
            unresolved: pairs.filter(([, uri]) => !uri).slice(0, 10).map(([addr]) => addr),
          });
        }
        setLogoCache((prev) => {
          const next = { ...prev };
          for (const [addr, uri] of pairs) {
            if (uri) next[addr] = uri;
          }
          return next;
        });
      } catch {
        if (DEBUG) console.debug('[CampaignGrid] hydration failed');
        // silent: missing images are non-fatal
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [items, logoCache, fetchCampaignLogoURI, DEBUG]);

  const loadMore = async () => {
    if (loadingMore || loading || nextCursor == null) return;
    setLoadingMore(true);
    try {
      if (DEBUG) {
        console.debug('[CampaignGrid] loadMore params', { ...baseParams, cursor: nextCursor });
      }
      const resp = await fetchCampaignFeed({ ...baseParams, cursor: nextCursor, _r: refetchNonce });
      if (DEBUG) {
        console.debug('[CampaignGrid] loadMore response', {
          count: resp.items?.length ?? 0,
          nextCursor: resp.nextCursor,
        });
      }
      setItems((prev) => [...prev, ...(resp.items ?? [])]);
      setNextCursor(resp.nextCursor ?? null);
      setLastUpdatedAt(resp.updatedAt ?? null);
    } catch (e: any) {
      setErr(e?.message ?? "Failed to load more");
    } finally {
      setLoadingMore(false);
    }
  };

  // Infinite scroll: load next page when sentinel becomes visible.
  useEffect(() => {
    const el = sentinelRef.current;
    if (!el) return;
    const obs = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) loadMore();
        }
      },
      { root: null, rootMargin: "600px", threshold: 0 }
    );
    obs.observe(el);
    return () => obs.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [sentinelRef.current, nextCursor, loading, loadingMore, baseParams]);

  const vms: CampaignCardVM[] = useMemo(() => {
    const GRAD_TARGET_BNB = 50;

    return (items || []).map((it) => {
      const addr = String(it.campaignAddress ?? "").toLowerCase();
      const patch = patchByCampaign[addr];

      const mcapBnb = Number((patch?.marketcapBnb ?? it.marketcapBnb) ?? NaN);
      const mcapUsd = Number.isFinite(mcapBnb) && bnbUsd ? mcapBnb * bnbUsd : NaN;
      const marketCapUsdLabel = Number.isFinite(mcapUsd) ? formatCompactUsd(mcapUsd) : null;
      const rawLogo = it.logoUri || logoCache[addr] || null;

      let progressPct: number | null = it.progressPct ?? null;
      const raised = Number(patch?.raisedTotalBnb ?? NaN);
      if (Number.isFinite(raised)) {
        progressPct = Math.max(0, Math.min(100, (raised / GRAD_TARGET_BNB) * 100));
      }

      return {
        campaignAddress: addr,
        name: String(it.name ?? "Unknown"),
        symbol: String(it.symbol ?? ""),
        logoURI: resolveImageUri(rawLogo) ?? undefined,
        creator: it.creatorAddress ?? undefined,
        createdAt: safeUnixSeconds(it.createdAtChain ?? null) ?? undefined,
        marketCapUsdLabel,
        athLabel: marketCapUsdLabel,
        progressPct,
        isDexTrading: Boolean(it.isDexTrading),
        votes24h: Number(patch?.votes24h ?? it.votes24h ?? 0),
      } as CampaignCardVM;
    });
  }, [items, bnbUsd, logoCache, patchByCampaign]);

  const resultsMeta = useMemo(() => {
    const count = vms.length;
    const updated = lastUpdatedAt ? Math.floor((Date.now() - Date.parse(lastUpdatedAt)) / 1000) : null;
    const updatedLabel = updated != null && Number.isFinite(updated) ? `${Math.max(0, updated)}s ago` : "";
    return `Showing ${count} campaigns  Updated ${updatedLabel}`;
  }, [vms.length, lastUpdatedAt]);

  return (
    <div className={cn("w-full", className)}>
      <div className="mb-3 flex items-center justify-between gap-4">
        <div className="text-xs text-muted-foreground">{resultsMeta}</div>
      </div>

      {loading && !vms.length ? (
        <div className="grid grid-cols-[repeat(auto-fit,minmax(180px,1fr))] gap-4 justify-items-center">
          {Array.from({ length: 12 }).map((_, i) => (
            <div
              key={i}
              className="aspect-[1/2] w-full max-w-[clamp(160px,20vw,210px)] rounded-2xl border border-border/40 bg-card/40 animate-pulse"
            />
          ))}
        </div>
      ) : err ? (
        <div className="py-10 text-center text-sm text-muted-foreground">{err}</div>
      ) : vms.length === 0 ? (
        <div className="py-10 text-center text-sm text-muted-foreground">No campaigns yet.</div>
      ) : (
        <>
          <div className="grid grid-cols-[repeat(auto-fit,minmax(180px,1fr))] gap-4 justify-items-center">
            {vms.map((vm) => (
              <CampaignCard key={vm.campaignAddress} vm={vm} chainIdForStorage={activeChainId} />
            ))}
          </div>

          <div ref={sentinelRef} className="h-12" />

          {loadingMore ? (
            <div className="py-6 text-center text-xs text-muted-foreground">Loading more</div>
          ) : nextCursor == null ? (
            <div className="py-6 text-center text-xs text-muted-foreground">End of results</div>
          ) : null}
        </>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/pages/Showcase.tsx">
import { useEffect, useMemo, useState } from "react";
import { FeaturedCampaigns } from "@/components/home/FeaturedCampaigns";
import { CampaignGrid, HomeQuery } from "@/components/home/CampaignGrid";
import { DiscoveryControls } from "@/components/home/DiscoveryControls";
import { HeaderBand } from "@/components/home/HeaderBand";
import { LeagueOverlayCard } from "@/components/home/LeagueOverlayCard";


const Showcase = () => {
  const [query, setQuery] = useState<HomeQuery>({ tab: "trending", timeFilter: "24h", search: "" });

  // Optional: keep TopBar typeahead behavior, but also allow "filter in place" for the Home grid.
  useEffect(() => {
    const onSearch = (e: any) => {
      const q = String(e?.detail ?? "");
      setQuery((prev) => ({ ...prev, search: q }));
    };
    window.addEventListener("upmeme:homeSearch", onSearch);
    return () => window.removeEventListener("upmeme:homeSearch", onSearch);
  }, []);

  const effectiveQuery = useMemo(() => {
    return {
      ...query,
      // default tab should be trending
      tab: query.tab ?? "trending",
    } as HomeQuery;
  }, [query]);

  return (
    <div className="h-full overflow-y-auto">
      <div className="relative px-3 md:px-6 pb-10">
        {/*
          Header band (logo + glow strip)
          IMPORTANT: avoid negative margins here  the scroll container clips anything pushed above its top.
          We align the logo by tightening App.tsx main padding instead.
        */}
        <HeaderBand />

        {/* Mobile League card (moves out of TopBar on small screens) */}
        <div className="md:hidden mt-2 mb-5">
          <LeagueOverlayCard className="w-full max-w-[460px] mx-auto" />
        </div>

        {/* Featured grid (UpVote campaigns) */}
        <div className="md:pr-[320px] -translate-y-6 md:-translate-y-14">
          <FeaturedCampaigns />
        </div>

        {/* Tabs / filters / sort / search */}
        <div className="mt-5 md:pr-[320px] -translate-y-6 md:-translate-y-14">
          <DiscoveryControls query={effectiveQuery} onChange={setQuery} />
        </div>

        {/* Main campaign browsing surface (paged / infinite) */}
        <div className="mt-4 -translate-y-6 md:-translate-y-14">
          <CampaignGrid query={effectiveQuery} />
        </div>
      </div>
    </div>
  );
};

export default Showcase;
</file>

<file path="frontend/src/components/home/FeaturedCampaigns.tsx">
import { useEffect, useMemo, useRef, useState } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { UpvoteDialog } from "@/components/token/UpvoteDialog";
import { cn } from "@/lib/utils";
import { useLaunchpad } from "@/lib/launchpadClient";
import { ChevronLeft, ChevronRight, Flame, ThumbsUp } from "lucide-react";
import { AthBar } from "@/components/token/AthBar";
import { useBnbUsdPrice } from "@/hooks/useBnbUsdPrice";
import { useLeagueRealtime } from "@/hooks/useLeagueRealtime";
import { resolveImageUri } from "@/lib/media";
import { fetchUserProfile, type UserProfile } from "@/lib/profileApi";

type FeaturedItemApi = {
  chainId: number;
  campaignAddress: string;
  tokenAddress?: string | null;
  creatorAddress?: string | null;
  // Optional profile fields (may or may not be present depending on API version)
  creatorName?: string | null;
  creatorUsername?: string | null;
  username?: string | null;
  name?: string | null;
  symbol?: string | null;
  logoUri?: string | null;
  createdAtChain?: string | null;
  graduatedAtChain?: string | null;
  votes24h?: number | null;
  votesAllTime?: number | null;
  marketcapBnb?: string | null;
};

function formatCompactUsd(value: number): string {
  if (!Number.isFinite(value)) return "";
  const fmt = new Intl.NumberFormat(undefined, {
    style: "currency",
    currency: "USD",
    notation: "compact",
    maximumFractionDigits: 2,
  });
  return fmt.format(value);
}

function shortAddr(addr?: string) {
  if (!addr) return "";
  const a = String(addr);
  return a.length > 10 ? `${a.slice(0, 6)}...${a.slice(-4)}` : a;
}

function isEvmAddress(addr?: string | null) {
  return /^0x[a-fA-F0-9]{40}$/.test(String(addr ?? "").trim());
}

export function FeaturedCampaigns({ className }: { className?: string }) {
  const navigate = useNavigate();
  const { activeChainId, fetchCampaignLogoURI } = useLaunchpad();
const [refetchNonce, setRefetchNonce] = useState(0);

const { patchByCampaign } = useLeagueRealtime({
  enabled: true,
  chainId: activeChainId,
  fallbackMs: 25000,
  onFallbackRefresh: () => setRefetchNonce((n) => n + 1),
});
  const { price: bnbUsd } = useBnbUsdPrice(true);

  const goProfile = (creatorAddr?: string) => {
    const a = (creatorAddr ?? "").trim();
    if (!a) return;
    navigate(`/profile?address=${encodeURIComponent(a)}`);
  };

  const [items, setItems] = useState<FeaturedItemApi[]>([]);
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  // On-chain logo hydration cache (same idea as CampaignGrid)
  const [logoCache, setLogoCache] = useState<Record<string, string>>({});
  const [profilesByAddr, setProfilesByAddr] = useState<Record<string, UserProfile | null>>({});

  const scrollRef = useRef<HTMLDivElement | null>(null);

  // Immediately refresh featured sorting after a confirmed tx (upvote/buy/sell/finalize).
  useEffect(() => {
    const onRefresh = (e: any) => {
      const d = e?.detail ?? {};
      const cid = Number(d.chainId ?? NaN);
      if (Number.isFinite(cid) && cid !== activeChainId) return;
      setRefetchNonce((n) => n + 1);
    };
    window.addEventListener("upmeme:upvoteConfirmed", onRefresh as any);
    window.addEventListener("upmeme:txConfirmed", onRefresh as any);
    return () => {
      window.removeEventListener("upmeme:upvoteConfirmed", onRefresh as any);
      window.removeEventListener("upmeme:txConfirmed", onRefresh as any);
    };
  }, [activeChainId]);

  useEffect(() => {
    let mounted = true;
    (async () => {
      setLoading(true);
      setErr(null);
      try {
        // Avoid edge/browser caching so vote counts/order refresh immediately after tx confirmation.
        const r = await fetch(`/api/featured?chainId=${activeChainId}&sort=24h&limit=20&_r=${refetchNonce}`, {
          cache: "no-store" as any,
        });
        const j = await r.json();
        if (!mounted) return;
        setItems(Array.isArray(j.items) ? j.items : []);
      } catch (e: any) {
        if (!mounted) return;
        setErr(e?.message ?? "Failed to load featured");
      } finally {
        if (!mounted) return;
        setLoading(false);
      }
    })();
    return () => {
      mounted = false;
    };
  }, [activeChainId, refetchNonce]);

  // Hydrate missing logos from chain if DB didnt have logoUri (mirrors CampaignGrid)
  useEffect(() => {
    let cancelled = false;

    const missing = (items || [])
      .map((it) => String(it.campaignAddress ?? "").toLowerCase())
      .filter((addr) => addr && !logoCache[addr])
      .filter((addr) => {
        const found = (items || []).find((x) => String(x.campaignAddress ?? "").toLowerCase() === addr);
        return !found?.logoUri;
      })
      .slice(0, 20);

    if (!missing.length) return;

    (async () => {
      try {
        const pairs = await Promise.all(
          missing.map(async (addr) => {
            const uri = await fetchCampaignLogoURI(addr);
            return [addr, uri] as const;
          })
        );
        if (cancelled) return;

        setLogoCache((prev) => {
          const next = { ...prev };
          for (const [addr, uri] of pairs) {
            if (uri) next[addr] = uri;
          }
          return next;
        });
      } catch {
        // non-fatal
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [items, logoCache, fetchCampaignLogoURI]);


  // Hydrate creator profiles (username/displayName) so we can show username instead of short address
  useEffect(() => {
    let cancelled = false;

    const unique = Array.from(
      new Set(
        (items || [])
          .map((it) => String(it.creatorAddress ?? "").trim().toLowerCase())
          .filter((a) => isEvmAddress(a))
      )
    );

    const missing = unique.filter((a) => profilesByAddr[a] === undefined);
    if (!missing.length) return;

    (async () => {
      try {
        const results = await Promise.all(
          missing.map(async (addr) => {
            try {
              const p = await fetchUserProfile(activeChainId, addr);
              return [addr, p] as const;
            } catch {
              return [addr, null] as const;
            }
          })
        );
        if (cancelled) return;

        setProfilesByAddr((prev) => {
          const next = { ...prev };
          for (const [addr, p] of results) next[addr] = p;
          return next;
        });
      } catch {
        // non-fatal
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [items, activeChainId, profilesByAddr]);

  const cards = useMemo(() => {
    return items.map((it, idx) => {
      const addr = String(it.campaignAddress ?? "").toLowerCase();
      const patch = patchByCampaign[addr];

      const createdAt = it.createdAtChain
        ? Math.floor(new Date(it.createdAtChain).getTime() / 1000)
        : undefined;

      const votes24h = Number(patch?.votes24h ?? it.votes24h ?? 0);
      
      const mcapBnb = Number((patch?.marketcapBnb ?? it.marketcapBnb) ?? NaN);
      const mcapUsdLabel = Number.isFinite(mcapBnb) && bnbUsd ? formatCompactUsd(mcapBnb * bnbUsd) : null;

      const rawLogo = it.logoUri || logoCache[addr] || null;
      const resolved = resolveImageUri(rawLogo) || "/placeholder.svg";

      const creatorAddr = String(it.creatorAddress ?? "");
      const creatorKey = creatorAddr ? creatorAddr.trim().toLowerCase() : "";
      const profile = creatorKey ? profilesByAddr[creatorKey] ?? null : null;

      const profileDisplayName = (profile?.displayName ?? "").trim();

      const maybeUsernameRaw =
        (it as any).creatorUsername ??
        (it as any).username ??
        (it as any).creatorName ??
        (it as any).creator?.username ??
        (it as any).creatorProfile?.username ??
        (it as any).profile?.username ??
        (it as any).creatorProfile?.displayName ??
        (it as any).profile?.displayName ??
        null;

      const usernameRaw =
        profileDisplayName ||
        (typeof maybeUsernameRaw === "string" && maybeUsernameRaw.trim().length > 0
          ? maybeUsernameRaw.trim()
          : "");

      const creatorName = usernameRaw
        ? usernameRaw.startsWith("@")
          ? usernameRaw
          : `@${usernameRaw}`
        : null;

      const creatorLabel = creatorName ? creatorName : creatorAddr ? shortAddr(creatorAddr) : "";

      return {
        idx: idx + 1,
        addr,
        name: String(it.name ?? "Unknown"),
        symbol: String(it.symbol ?? ""),
        creator: creatorAddr,
        creatorName,
        creatorLabel,
        createdAt,
        votes24h,
        mcapUsdLabel,
        image: resolved,
      };
    });
  }, [items, bnbUsd, logoCache, profilesByAddr]);

  const scrollByCards = (dir: "left" | "right") => {
    const el = scrollRef.current;
    if (!el) return;
    const amount = Math.max(320, Math.floor(el.clientWidth * 0.9));
    el.scrollBy({ left: dir === "left" ? -amount : amount, behavior: "smooth" });
  };

  return (
    <div className={cn("w-full", className)}>
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-2">
          <div className="inline-flex items-center gap-2 text-sm font-semibold">
            <ThumbsUp className="h-4 w-4 text-accent" />
            Featured Campaigns
          </div>
          <div className="text-xs text-muted-foreground">Top 20 (last 24h)</div>
        </div>

        <div className="hidden md:flex items-center gap-2">
          <Button variant="outline" size="sm" onClick={() => scrollByCards("left")}>
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <Button variant="outline" size="sm" onClick={() => scrollByCards("right")}>
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>

      <div className="relative">
        <div
          ref={scrollRef}
          className="flex gap-4 overflow-x-auto pb-2 pr-2 snap-x snap-mandatory scroll-smooth"
          style={{ scrollbarWidth: "none" } as any}
        >
          {loading && !cards.length ? (
            Array.from({ length: 6 }).map((_, i) => (
              <div
                key={i}
                className={cn(
                  "snap-start shrink-0 rounded-2xl border border-border/40 bg-card/40 animate-pulse",
                  // responsive width so it never becomes tiny
                  "min-w-[320px] w-[92vw] max-w-[420px] sm:w-[360px] sm:max-w-[360px] md:w-[420px] md:max-w-[420px]"
                )}
              >
                <div className="aspect-[2/1]" />
                <div className="h-10 border-t border-border/40" />
              </div>
            ))
          ) : err ? (
            <div className="text-sm text-muted-foreground py-8">{err}</div>
          ) : cards.length === 0 ? (
            <div className="text-sm text-muted-foreground py-8">No featured campaigns yet.</div>
          ) : (
            cards.map((c) => (
              <div
                key={c.addr}
                className={cn(
                  "snap-start shrink-0 rounded-2xl border border-border/50 bg-card/60 backdrop-blur-sm overflow-hidden hover:border-accent/50 transition-colors",
                  //  this prevents tiny cards on small screens
                  "min-w-[320px] w-[92vw] max-w-[420px] sm:w-[360px] sm:max-w-[360px] md:w-[420px] md:max-w-[420px]"
                )}
                role="button"
                tabIndex={0}
                onClick={() => navigate(`/token/${c.addr}`)}
                onKeyDown={(e) => {
                  if (e.key === "Enter" || e.key === " ") navigate(`/token/${c.addr}`);
                }}
              >
                {/* ATH overlay across image + data */}
<div className="absolute inset-x-0 bottom-0 z-20 px-3 py-2 pointer-events-none">
  <AthBar
    currentLabel={c.mcapUsdLabel ?? null}
    storageKey={`ath:${activeChainId}:${c.addr}`}
    className="text-[10px]"
    barWidthPx={420}
    barMaxWidth="100%"
  />
</div>
                {/* Top: two equal squares (image + data) */}
                <div className="grid grid-cols-2 aspect-[2/1]">
                  {/* Left: token image */}
                  <div className="relative w-full h-full bg-black">
                    <img
                      src={c.image}
                      alt={c.name}
                      className="w-full h-full object-cover"
                      draggable={false}
                      onError={(e) => {
                        const img = e.currentTarget;
                        if (!img.dataset.fallback) {
                          img.dataset.fallback = "1";
                          img.src = "/placeholder.svg";
                        }
                      }}
                    />

                    <div className="absolute inset-x-0 bottom-0 h-16 bg-gradient-to-t from-black/70 to-transparent" />

                    <div className="absolute top-2 left-2 h-7 min-w-7 px-2 flex items-center justify-center rounded-full bg-black/60 border-2 border-emerald-400 text-xs font-bold text-emerald-400">
                      {c.idx}
                    </div>
                  </div>

                  {/* Right: data panel (same size as image) */}
                  <div className="w-full h-full p-3 md:p-4 pb-20 flex flex-col min-w-0">
                    {/* Name + votes (24h) */}
                    <div className="flex items-start justify-between gap-2">
                      <div className="min-w-0">
                        <div className="text-base font-semibold truncate">{c.name}</div>
                        <div className="text-xs text-muted-foreground truncate">
                          {c.symbol ? `$${c.symbol}` : ""}
                        </div>
                      </div>

                      {/* Votes (24h) top-right */}
                      <div className="flex items-center gap-1 text-xs text-accent shrink-0">
                        <Flame className="h-4 w-4" />
                        <span className="font-semibold">{c.votes24h}</span>
                        <span className="text-muted-foreground">/ 24h</span>
                      </div>
                    </div>

                    {/* Creator row under ticker */}
                    <div className="mt-2 flex items-center gap-2 min-w-0">
                      <img
                        src="/assets/profile_placeholder.png"
                        alt="Creator"
                        className="w-7 h-7 rounded-full object-cover border border-border/60"
                        draggable={false}
                        role="button"
                        tabIndex={0}
                        onClick={(e) => {
                          e.stopPropagation();
                          goProfile(c.creator);
                        }}
                        onKeyDown={(e) => {
                          if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            e.stopPropagation();
                            goProfile(c.creator);
                          }
                        }}
                      />
                      <div
                        className="text-xs text-muted-foreground truncate"
                        role="button"
                        tabIndex={0}
                        onClick={(e) => {
                          e.stopPropagation();
                          goProfile(c.creator);
                        }}
                        onKeyDown={(e) => {
                          if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            e.stopPropagation();
                            goProfile(c.creator);
                          }
                        }}
                      >
                        {c.creatorLabel}
                      </div>
                    </div>

                    

                    {/* Upvote + MCap row */}
<div className="mt-3 flex items-center justify-between gap-3 w-full">
  {/* MCap (left) */}
  <div className="min-w-0">
    <div className="text-[10px] text-muted-foreground">MCap</div>
    <div className="text-sm font-semibold truncate">{c.mcapUsdLabel ?? ""}</div>
  </div>

  {/* Upvote (right) */}
  <div className="shrink-0" onClick={(e) => e.stopPropagation()}>
    <UpvoteDialog campaignAddress={c.addr} />
  </div>
</div>

                    {/* Spacer so content doesn't hug AthBar overlay */}
                    <div className="flex-1" />
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}
</file>

</files>
